import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-DP4XHQAG.js";

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code2.length; i2 < len; ++i2) {
      lookup[i2] = code2[i2];
      revLookup[code2.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens3 = getLens(b64);
      var validLen = lens3[0];
      var placeHoldersLen = lens3[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens3 = getLens(b64);
      var validLen = lens3[0];
      var placeHoldersLen = lens3[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s2 = buffer[offset + i2];
      i2 += d2;
      e2 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt2 / c2;
        } else {
          value += rt2 * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m2 = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m2 = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d2] |= s2 * 128;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.3.1";
        var REACT_ELEMENT_TYPE2 = Symbol.for("react.element");
        var REACT_PORTAL_TYPE2 = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE2 = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE2 = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE2 = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE2 = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE2 = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE2 = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE2 = Symbol.for("react.memo");
        var REACT_LAZY_TYPE2 = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE2 = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          // Used to reproduce behavior of `batchedUpdates` in legacy mode.
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign2 = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component2(props3, context2, updater) {
          this.props = props3;
          this.context = context2;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component2.prototype.isReactComponent = {};
        Component2.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component2.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component2.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component2.prototype;
        function PureComponent2(props3, context2, updater) {
          this.props = props3;
          this.context = context2;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent2.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent2;
        assign2(pureComponentPrototype, Component2.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray4(a2) {
          return isArrayImpl(a2);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type5 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type5;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e2) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type5) {
          return type5.displayName || "Context";
        }
        function getComponentNameFromType(type5) {
          if (type5 == null) {
            return null;
          }
          {
            if (typeof type5.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type5 === "function") {
            return type5.displayName || type5.name || null;
          }
          if (typeof type5 === "string") {
            return type5;
          }
          switch (type5) {
            case REACT_FRAGMENT_TYPE2:
              return "Fragment";
            case REACT_PORTAL_TYPE2:
              return "Portal";
            case REACT_PROFILER_TYPE2:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE2:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE2:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE2:
              return "SuspenseList";
          }
          if (typeof type5 === "object") {
            switch (type5.$$typeof) {
              case REACT_CONTEXT_TYPE2:
                var context2 = type5;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE2:
                var provider = type5;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE2:
                return getWrappedName(type5, type5.render, "ForwardRef");
              case REACT_MEMO_TYPE2:
                var outerName = type5.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type5.type) || "Memo";
              case REACT_LAZY_TYPE2: {
                var lazyComponent = type5;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init2(payload));
                } catch (x2) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config2) {
          {
            if (hasOwnProperty3.call(config2, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.ref !== void 0;
        }
        function hasValidKey(config2) {
          {
            if (hasOwnProperty3.call(config2, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config2.key !== void 0;
        }
        function defineKeyPropWarningGetter(props3, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props3, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props3, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props3, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config2) {
          {
            if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type5, key57, ref, self3, source, owner, props3) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE2,
            // Built-in properties that belong on the element
            type: type5,
            key: key57,
            ref,
            props: props3,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self3
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement3(type5, config2, children) {
          var propName;
          var props3 = {};
          var key57 = null;
          var ref = null;
          var self3 = null;
          var source = null;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config2);
              }
            }
            if (hasValidKey(config2)) {
              {
                checkKeyStringCoercion(config2.key);
              }
              key57 = "" + config2.key;
            }
            self3 = config2.__self === void 0 ? null : config2.__self;
            source = config2.__source === void 0 ? null : config2.__source;
            for (propName in config2) {
              if (hasOwnProperty3.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props3[propName] = config2[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props3.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i2 = 0; i2 < childrenLength; i2++) {
              childArray[i2] = arguments[i2 + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props3.children = childArray;
          }
          if (type5 && type5.defaultProps) {
            var defaultProps = type5.defaultProps;
            for (propName in defaultProps) {
              if (props3[propName] === void 0) {
                props3[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key57 || ref) {
              var displayName = typeof type5 === "function" ? type5.displayName || type5.name || "Unknown" : type5;
              if (key57) {
                defineKeyPropWarningGetter(props3, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props3, displayName);
              }
            }
          }
          return ReactElement(type5, key57, ref, self3, source, ReactCurrentOwner.current, props3);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config2, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props3 = assign2({}, element.props);
          var key57 = element.key;
          var ref = element.ref;
          var self3 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config2 != null) {
            if (hasValidRef(config2)) {
              ref = config2.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config2)) {
              {
                checkKeyStringCoercion(config2.key);
              }
              key57 = "" + config2.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config2) {
              if (hasOwnProperty3.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config2[propName] === void 0 && defaultProps !== void 0) {
                  props3[propName] = defaultProps[propName];
                } else {
                  props3[propName] = config2[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props3.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i2 = 0; i2 < childrenLength; i2++) {
              childArray[i2] = arguments[i2 + 2];
            }
            props3.children = childArray;
          }
          return ReactElement(element.type, key57, ref, self3, source, owner, props3);
        }
        function isValidElement(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE2;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape3(key57) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key57.replace(escapeRegex, function(match3) {
            return escaperLookup[match3];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text3) {
          return text3.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape3("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
          var type5 = typeof children;
          if (type5 === "undefined" || type5 === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type5) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE2:
                  case REACT_PORTAL_TYPE2:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray4(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c2) {
                return c2;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  // Keep both the (mapped) and old keys if they differ, just as
                  // traverseAllChildren used to do for objects as children
                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                    // eslint-disable-next-line react-internal/safe-string-coercion
                    escapeUserProvidedKey("" + mappedChild.key) + "/"
                  ) : "") + childKey
                );
              }
              array2.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray4(children)) {
            for (var i2 = 0; i2 < children.length; i2++) {
              child = children[i2];
              nextName = nextNamePrefix + getElementKey(child, i2);
              subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn2 = getIteratorFn(children);
            if (typeof iteratorFn2 === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn2 === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn2.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
              }
            } else if (type5 === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context2) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count2 = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context2, child, count2++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray3(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext2(defaultValue) {
          var context2 = {
            $$typeof: REACT_CONTEXT_TYPE2,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null,
            // Add these to use same hidden class in VM as ServerContext
            _defaultValue: null,
            _globalName: null
          };
          context2.Provider = {
            $$typeof: REACT_PROVIDER_TYPE2,
            _context: context2
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE2,
              _context: context2
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context2.Provider;
                },
                set: function(_Provider) {
                  context2.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context2._currentValue;
                },
                set: function(_currentValue) {
                  context2._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context2._currentValue2;
                },
                set: function(_currentValue2) {
                  context2._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context2._threadCount;
                },
                set: function(_threadCount) {
                  context2._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context2.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context2.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context2.Consumer = Consumer;
          }
          {
            context2._currentRenderer = null;
            context2._currentRenderer2 = null;
          }
          return context2;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            // We use these fields to store the result.
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE2,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef2(render2) {
          {
            if (render2 != null && render2.$$typeof === REACT_MEMO_TYPE2) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render2 !== "function") {
              error("forwardRef requires a render function but was given %s.", render2 === null ? "null" : typeof render2);
            } else {
              if (render2.length !== 0 && render2.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render2.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render2 != null) {
              if (render2.defaultProps != null || render2.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE2,
            render: render2
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!render2.name && !render2.displayName) {
                  render2.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType2(type5) {
          if (typeof type5 === "string" || typeof type5 === "function") {
            return true;
          }
          if (type5 === REACT_FRAGMENT_TYPE2 || type5 === REACT_PROFILER_TYPE2 || enableDebugTracing || type5 === REACT_STRICT_MODE_TYPE2 || type5 === REACT_SUSPENSE_TYPE2 || type5 === REACT_SUSPENSE_LIST_TYPE2 || enableLegacyHidden || type5 === REACT_OFFSCREEN_TYPE2 || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type5 === "object" && type5 !== null) {
            if (type5.$$typeof === REACT_LAZY_TYPE2 || type5.$$typeof === REACT_MEMO_TYPE2 || type5.$$typeof === REACT_PROVIDER_TYPE2 || type5.$$typeof === REACT_CONTEXT_TYPE2 || type5.$$typeof === REACT_FORWARD_REF_TYPE2 || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type5.$$typeof === REACT_MODULE_REFERENCE || type5.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type5, compare2) {
          {
            if (!isValidElementType2(type5)) {
              error("memo: The first argument must be a component. Instead received: %s", type5 === null ? "null" : typeof type5);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE2,
            type: type5,
            compare: compare2 === void 0 ? null : compare2
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name2) {
                ownName = name2;
                if (!type5.name && !type5.displayName) {
                  type5.displayName = name2;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext2(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState2(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init2);
        }
        function useRef2(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect2(create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create2, deps);
        }
        function useInsertionEffect(create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create2, deps);
        }
        function useLayoutEffect(create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create2, deps);
        }
        function useCallback2(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo2(create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create2, deps);
        }
        function useImperativeHandle(ref, create2, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create2, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore3(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props3 = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props3,
                log: props3,
                warn: props3,
                error: props3,
                group: props3,
                groupCollapsed: props3,
                groupEnd: props3
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props3 = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign2({}, props3, {
                  value: prevLog
                }),
                info: assign2({}, props3, {
                  value: prevInfo
                }),
                warn: assign2({}, props3, {
                  value: prevWarn
                }),
                error: assign2({}, props3, {
                  value: prevError
                }),
                group: assign2({}, props3, {
                  value: prevGroup
                }),
                groupCollapsed: assign2({}, props3, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign2({}, props3, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x2) {
                var match3 = x2.stack.trim().match(/\n( *(at )?)/);
                prefix = match3 && match3[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct4) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct4) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x2) {
                  control = x2;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x2) {
                  control = x2;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x2) {
                control = x2;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                c2--;
              }
              for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                if (sampleLines[s2] !== controlLines[c2]) {
                  if (s2 !== 1 || c2 !== 1) {
                    do {
                      s2--;
                      c2--;
                      if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component3) {
          var prototype = Component3.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type5, source, ownerFn) {
          if (type5 == null) {
            return "";
          }
          if (typeof type5 === "function") {
            {
              return describeNativeComponentFrame(type5, shouldConstruct(type5));
            }
          }
          if (typeof type5 === "string") {
            return describeBuiltInComponentFrame(type5);
          }
          switch (type5) {
            case REACT_SUSPENSE_TYPE2:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE2:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type5 === "object") {
            switch (type5.$$typeof) {
              case REACT_FORWARD_REF_TYPE2:
                return describeFunctionComponentFrame(type5.render);
              case REACT_MEMO_TYPE2:
                return describeUnknownElementTypeFrameInDEV(type5.type, source, ownerFn);
              case REACT_LAZY_TYPE2: {
                var lazyComponent = type5;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x2) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values3, location, componentName, element) {
          {
            var has4 = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has4(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err2 = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err2.name = "Invariant Violation";
                    throw err2;
                  }
                  error$1 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name2 = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name2) {
              return "\n\nCheck the render method of `" + name2 + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray4(node)) {
            for (var i2 = 0; i2 < node.length; i2++) {
              var child = node[i2];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn2 = getIteratorFn(node);
            if (typeof iteratorFn2 === "function") {
              if (iteratorFn2 !== node.entries) {
                var iterator = iteratorFn2.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type5 = element.type;
            if (type5 === null || type5 === void 0 || typeof type5 === "string") {
              return;
            }
            var propTypes;
            if (typeof type5 === "function") {
              propTypes = type5.propTypes;
            } else if (typeof type5 === "object" && (type5.$$typeof === REACT_FORWARD_REF_TYPE2 || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type5.$$typeof === REACT_MEMO_TYPE2)) {
              propTypes = type5.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name2 = getComponentNameFromType(type5);
              checkPropTypes(propTypes, element.props, "prop", name2, element);
            } else if (type5.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type5);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type5.getDefaultProps === "function" && !type5.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment2) {
          {
            var keys4 = Object.keys(fragment2.props);
            for (var i2 = 0; i2 < keys4.length; i2++) {
              var key57 = keys4[i2];
              if (key57 !== "children" && key57 !== "key") {
                setCurrentlyValidatingElement$1(fragment2);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key57);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment2.ref !== null) {
              setCurrentlyValidatingElement$1(fragment2);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type5, props3, children) {
          var validType = isValidElementType2(type5);
          if (!validType) {
            var info = "";
            if (type5 === void 0 || typeof type5 === "object" && type5 !== null && Object.keys(type5).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props3);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type5 === null) {
              typeString = "null";
            } else if (isArray4(type5)) {
              typeString = "array";
            } else if (type5 !== void 0 && type5.$$typeof === REACT_ELEMENT_TYPE2) {
              typeString = "<" + (getComponentNameFromType(type5.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type5;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement3.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i2 = 2; i2 < arguments.length; i2++) {
              validateChildKeys(arguments[i2], type5);
            }
          }
          if (type5 === REACT_FRAGMENT_TYPE2) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type5) {
          var validatedFactory = createElementWithValidation.bind(null, type5);
          validatedFactory.type = type5;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type5
                });
                return type5;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props3, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i2 = 2; i2 < arguments.length; i2++) {
            validateChildKeys(arguments[i2], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module && module[requireString];
              enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve4, reject3) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve4, reject3);
                    } else {
                      resolve4(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject3(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve4, reject3) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve4, reject3);
                    } else {
                      resolve4(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve4, reject3) {
                    resolve4(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve4, reject3) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve4(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve4, reject3);
                  }
                });
              } catch (error2) {
                reject3(error2);
              }
            } else {
              resolve4(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i2 = 0;
              try {
                for (; i2 < queue.length; i2++) {
                  var callback = queue[i2];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error2) {
                queue = queue.slice(i2 + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray: toArray3,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component2;
        exports.Fragment = REACT_FRAGMENT_TYPE2;
        exports.Profiler = REACT_PROFILER_TYPE2;
        exports.PureComponent = PureComponent2;
        exports.StrictMode = REACT_STRICT_MODE_TYPE2;
        exports.Suspense = REACT_SUSPENSE_TYPE2;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.act = act;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext2;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef2;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback2;
        exports.useContext = useContext2;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect2;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo2;
        exports.useReducer = useReducer;
        exports.useRef = useRef2;
        exports.useState = useState2;
        exports.useSyncExternalStore = useSyncExternalStore3;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/immutable/dist/immutable.js
var require_immutable = __commonJS({
  "node_modules/immutable/dist/immutable.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.Immutable = factory();
    })(exports, function() {
      "use strict";
      var SLICE$0 = Array.prototype.slice;
      function createClass(ctor, superClass) {
        if (superClass) {
          ctor.prototype = Object.create(superClass.prototype);
        }
        ctor.prototype.constructor = ctor;
      }
      function Iterable(value) {
        return isIterable2(value) ? value : Seq2(value);
      }
      createClass(KeyedIterable, Iterable);
      function KeyedIterable(value) {
        return isKeyed(value) ? value : KeyedSeq(value);
      }
      createClass(IndexedIterable, Iterable);
      function IndexedIterable(value) {
        return isIndexed2(value) ? value : IndexedSeq(value);
      }
      createClass(SetIterable, Iterable);
      function SetIterable(value) {
        return isIterable2(value) && !isAssociative(value) ? value : SetSeq(value);
      }
      function isIterable2(maybeIterable) {
        return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
      }
      function isKeyed(maybeKeyed) {
        return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
      }
      function isIndexed2(maybeIndexed) {
        return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
      }
      function isAssociative(maybeAssociative) {
        return isKeyed(maybeAssociative) || isIndexed2(maybeAssociative);
      }
      function isOrdered(maybeOrdered) {
        return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
      }
      Iterable.isIterable = isIterable2;
      Iterable.isKeyed = isKeyed;
      Iterable.isIndexed = isIndexed2;
      Iterable.isAssociative = isAssociative;
      Iterable.isOrdered = isOrdered;
      Iterable.Keyed = KeyedIterable;
      Iterable.Indexed = IndexedIterable;
      Iterable.Set = SetIterable;
      var IS_ITERABLE_SENTINEL = "@@__IMMUTABLE_ITERABLE__@@";
      var IS_KEYED_SENTINEL = "@@__IMMUTABLE_KEYED__@@";
      var IS_INDEXED_SENTINEL = "@@__IMMUTABLE_INDEXED__@@";
      var IS_ORDERED_SENTINEL = "@@__IMMUTABLE_ORDERED__@@";
      var DELETE = "delete";
      var SHIFT = 5;
      var SIZE = 1 << SHIFT;
      var MASK = SIZE - 1;
      var NOT_SET2 = {};
      var CHANGE_LENGTH = { value: false };
      var DID_ALTER = { value: false };
      function MakeRef(ref) {
        ref.value = false;
        return ref;
      }
      function SetRef(ref) {
        ref && (ref.value = true);
      }
      function OwnerID() {
      }
      function arrCopy(arr, offset) {
        offset = offset || 0;
        var len = Math.max(0, arr.length - offset);
        var newArr = new Array(len);
        for (var ii = 0; ii < len; ii++) {
          newArr[ii] = arr[ii + offset];
        }
        return newArr;
      }
      function ensureSize(iter) {
        if (iter.size === void 0) {
          iter.size = iter.__iterate(returnTrue);
        }
        return iter.size;
      }
      function wrapIndex(iter, index) {
        if (typeof index !== "number") {
          var uint32Index = index >>> 0;
          if ("" + uint32Index !== index || uint32Index === 4294967295) {
            return NaN;
          }
          index = uint32Index;
        }
        return index < 0 ? ensureSize(iter) + index : index;
      }
      function returnTrue() {
        return true;
      }
      function wholeSlice(begin, end, size) {
        return (begin === 0 || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
      }
      function resolveBegin(begin, size) {
        return resolveIndex(begin, size, 0);
      }
      function resolveEnd(end, size) {
        return resolveIndex(end, size, size);
      }
      function resolveIndex(index, size, defaultIndex) {
        return index === void 0 ? defaultIndex : index < 0 ? Math.max(0, size + index) : size === void 0 ? index : Math.min(size, index);
      }
      var ITERATE_KEYS = 0;
      var ITERATE_VALUES = 1;
      var ITERATE_ENTRIES = 2;
      var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
      function Iterator(next) {
        this.next = next;
      }
      Iterator.prototype.toString = function() {
        return "[Iterator]";
      };
      Iterator.KEYS = ITERATE_KEYS;
      Iterator.VALUES = ITERATE_VALUES;
      Iterator.ENTRIES = ITERATE_ENTRIES;
      Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
        return this.toString();
      };
      Iterator.prototype[ITERATOR_SYMBOL] = function() {
        return this;
      };
      function iteratorValue(type5, k, v2, iteratorResult) {
        var value = type5 === 0 ? k : type5 === 1 ? v2 : [k, v2];
        iteratorResult ? iteratorResult.value = value : iteratorResult = {
          value,
          done: false
        };
        return iteratorResult;
      }
      function iteratorDone() {
        return { value: void 0, done: true };
      }
      function hasIterator(maybeIterable) {
        return !!getIteratorFn(maybeIterable);
      }
      function isIterator(maybeIterator) {
        return maybeIterator && typeof maybeIterator.next === "function";
      }
      function getIterator(iterable) {
        var iteratorFn2 = getIteratorFn(iterable);
        return iteratorFn2 && iteratorFn2.call(iterable);
      }
      function getIteratorFn(iterable) {
        var iteratorFn2 = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn2 === "function") {
          return iteratorFn2;
        }
      }
      function isArrayLike3(value) {
        return value && typeof value.length === "number";
      }
      createClass(Seq2, Iterable);
      function Seq2(value) {
        return value === null || value === void 0 ? emptySequence() : isIterable2(value) ? value.toSeq() : seqFromValue(value);
      }
      Seq2.of = function() {
        return Seq2(arguments);
      };
      Seq2.prototype.toSeq = function() {
        return this;
      };
      Seq2.prototype.toString = function() {
        return this.__toString("Seq {", "}");
      };
      Seq2.prototype.cacheResult = function() {
        if (!this._cache && this.__iterateUncached) {
          this._cache = this.entrySeq().toArray();
          this.size = this._cache.length;
        }
        return this;
      };
      Seq2.prototype.__iterate = function(fn2, reverse3) {
        return seqIterate(this, fn2, reverse3, true);
      };
      Seq2.prototype.__iterator = function(type5, reverse3) {
        return seqIterator(this, type5, reverse3, true);
      };
      createClass(KeyedSeq, Seq2);
      function KeyedSeq(value) {
        return value === null || value === void 0 ? emptySequence().toKeyedSeq() : isIterable2(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : keyedSeqFromValue(value);
      }
      KeyedSeq.prototype.toKeyedSeq = function() {
        return this;
      };
      createClass(IndexedSeq, Seq2);
      function IndexedSeq(value) {
        return value === null || value === void 0 ? emptySequence() : !isIterable2(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
      }
      IndexedSeq.of = function() {
        return IndexedSeq(arguments);
      };
      IndexedSeq.prototype.toIndexedSeq = function() {
        return this;
      };
      IndexedSeq.prototype.toString = function() {
        return this.__toString("Seq [", "]");
      };
      IndexedSeq.prototype.__iterate = function(fn2, reverse3) {
        return seqIterate(this, fn2, reverse3, false);
      };
      IndexedSeq.prototype.__iterator = function(type5, reverse3) {
        return seqIterator(this, type5, reverse3, false);
      };
      createClass(SetSeq, Seq2);
      function SetSeq(value) {
        return (value === null || value === void 0 ? emptySequence() : !isIterable2(value) ? indexedSeqFromValue(value) : isKeyed(value) ? value.entrySeq() : value).toSetSeq();
      }
      SetSeq.of = function() {
        return SetSeq(arguments);
      };
      SetSeq.prototype.toSetSeq = function() {
        return this;
      };
      Seq2.isSeq = isSeq;
      Seq2.Keyed = KeyedSeq;
      Seq2.Set = SetSeq;
      Seq2.Indexed = IndexedSeq;
      var IS_SEQ_SENTINEL = "@@__IMMUTABLE_SEQ__@@";
      Seq2.prototype[IS_SEQ_SENTINEL] = true;
      createClass(ArraySeq, IndexedSeq);
      function ArraySeq(array2) {
        this._array = array2;
        this.size = array2.length;
      }
      ArraySeq.prototype.get = function(index, notSetValue) {
        return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
      };
      ArraySeq.prototype.__iterate = function(fn2, reverse3) {
        var array2 = this._array;
        var maxIndex = array2.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          if (fn2(array2[reverse3 ? maxIndex - ii : ii], ii, this) === false) {
            return ii + 1;
          }
        }
        return ii;
      };
      ArraySeq.prototype.__iterator = function(type5, reverse3) {
        var array2 = this._array;
        var maxIndex = array2.length - 1;
        var ii = 0;
        return new Iterator(
          function() {
            return ii > maxIndex ? iteratorDone() : iteratorValue(type5, ii, array2[reverse3 ? maxIndex - ii++ : ii++]);
          }
        );
      };
      createClass(ObjectSeq, KeyedSeq);
      function ObjectSeq(object2) {
        var keys4 = Object.keys(object2);
        this._object = object2;
        this._keys = keys4;
        this.size = keys4.length;
      }
      ObjectSeq.prototype.get = function(key57, notSetValue) {
        if (notSetValue !== void 0 && !this.has(key57)) {
          return notSetValue;
        }
        return this._object[key57];
      };
      ObjectSeq.prototype.has = function(key57) {
        return this._object.hasOwnProperty(key57);
      };
      ObjectSeq.prototype.__iterate = function(fn2, reverse3) {
        var object2 = this._object;
        var keys4 = this._keys;
        var maxIndex = keys4.length - 1;
        for (var ii = 0; ii <= maxIndex; ii++) {
          var key57 = keys4[reverse3 ? maxIndex - ii : ii];
          if (fn2(object2[key57], key57, this) === false) {
            return ii + 1;
          }
        }
        return ii;
      };
      ObjectSeq.prototype.__iterator = function(type5, reverse3) {
        var object2 = this._object;
        var keys4 = this._keys;
        var maxIndex = keys4.length - 1;
        var ii = 0;
        return new Iterator(function() {
          var key57 = keys4[reverse3 ? maxIndex - ii : ii];
          return ii++ > maxIndex ? iteratorDone() : iteratorValue(type5, key57, object2[key57]);
        });
      };
      ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
      createClass(IterableSeq, IndexedSeq);
      function IterableSeq(iterable) {
        this._iterable = iterable;
        this.size = iterable.length || iterable.size;
      }
      IterableSeq.prototype.__iterateUncached = function(fn2, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterate(fn2, reverse3);
        }
        var iterable = this._iterable;
        var iterator = getIterator(iterable);
        var iterations = 0;
        if (isIterator(iterator)) {
          var step;
          while (!(step = iterator.next()).done) {
            if (fn2(step.value, iterations++, this) === false) {
              break;
            }
          }
        }
        return iterations;
      };
      IterableSeq.prototype.__iteratorUncached = function(type5, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterator(type5, reverse3);
        }
        var iterable = this._iterable;
        var iterator = getIterator(iterable);
        if (!isIterator(iterator)) {
          return new Iterator(iteratorDone);
        }
        var iterations = 0;
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type5, iterations++, step.value);
        });
      };
      createClass(IteratorSeq, IndexedSeq);
      function IteratorSeq(iterator) {
        this._iterator = iterator;
        this._iteratorCache = [];
      }
      IteratorSeq.prototype.__iterateUncached = function(fn2, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterate(fn2, reverse3);
        }
        var iterator = this._iterator;
        var cache = this._iteratorCache;
        var iterations = 0;
        while (iterations < cache.length) {
          if (fn2(cache[iterations], iterations++, this) === false) {
            return iterations;
          }
        }
        var step;
        while (!(step = iterator.next()).done) {
          var val = step.value;
          cache[iterations] = val;
          if (fn2(val, iterations++, this) === false) {
            break;
          }
        }
        return iterations;
      };
      IteratorSeq.prototype.__iteratorUncached = function(type5, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterator(type5, reverse3);
        }
        var iterator = this._iterator;
        var cache = this._iteratorCache;
        var iterations = 0;
        return new Iterator(function() {
          if (iterations >= cache.length) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            cache[iterations] = step.value;
          }
          return iteratorValue(type5, iterations, cache[iterations++]);
        });
      };
      function isSeq(maybeSeq) {
        return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
      }
      var EMPTY_SEQ;
      function emptySequence() {
        return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
      }
      function keyedSeqFromValue(value) {
        var seq3 = Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() : isIterator(value) ? new IteratorSeq(value).fromEntrySeq() : hasIterator(value) ? new IterableSeq(value).fromEntrySeq() : typeof value === "object" ? new ObjectSeq(value) : void 0;
        if (!seq3) {
          throw new TypeError(
            "Expected Array or iterable object of [k, v] entries, or keyed object: " + value
          );
        }
        return seq3;
      }
      function indexedSeqFromValue(value) {
        var seq3 = maybeIndexedSeqFromValue(value);
        if (!seq3) {
          throw new TypeError(
            "Expected Array or iterable object of values: " + value
          );
        }
        return seq3;
      }
      function seqFromValue(value) {
        var seq3 = maybeIndexedSeqFromValue(value) || typeof value === "object" && new ObjectSeq(value);
        if (!seq3) {
          throw new TypeError(
            "Expected Array or iterable object of values, or keyed object: " + value
          );
        }
        return seq3;
      }
      function maybeIndexedSeqFromValue(value) {
        return isArrayLike3(value) ? new ArraySeq(value) : isIterator(value) ? new IteratorSeq(value) : hasIterator(value) ? new IterableSeq(value) : void 0;
      }
      function seqIterate(seq3, fn2, reverse3, useKeys) {
        var cache = seq3._cache;
        if (cache) {
          var maxIndex = cache.length - 1;
          for (var ii = 0; ii <= maxIndex; ii++) {
            var entry = cache[reverse3 ? maxIndex - ii : ii];
            if (fn2(entry[1], useKeys ? entry[0] : ii, seq3) === false) {
              return ii + 1;
            }
          }
          return ii;
        }
        return seq3.__iterateUncached(fn2, reverse3);
      }
      function seqIterator(seq3, type5, reverse3, useKeys) {
        var cache = seq3._cache;
        if (cache) {
          var maxIndex = cache.length - 1;
          var ii = 0;
          return new Iterator(function() {
            var entry = cache[reverse3 ? maxIndex - ii : ii];
            return ii++ > maxIndex ? iteratorDone() : iteratorValue(type5, useKeys ? entry[0] : ii - 1, entry[1]);
          });
        }
        return seq3.__iteratorUncached(type5, reverse3);
      }
      function fromJS2(json3, converter) {
        return converter ? fromJSWith(converter, json3, "", { "": json3 }) : fromJSDefault(json3);
      }
      function fromJSWith(converter, json3, key57, parentJSON) {
        if (Array.isArray(json3)) {
          return converter.call(parentJSON, key57, IndexedSeq(json3).map(function(v2, k) {
            return fromJSWith(converter, v2, k, json3);
          }));
        }
        if (isPlainObj2(json3)) {
          return converter.call(parentJSON, key57, KeyedSeq(json3).map(function(v2, k) {
            return fromJSWith(converter, v2, k, json3);
          }));
        }
        return json3;
      }
      function fromJSDefault(json3) {
        if (Array.isArray(json3)) {
          return IndexedSeq(json3).map(fromJSDefault).toList();
        }
        if (isPlainObj2(json3)) {
          return KeyedSeq(json3).map(fromJSDefault).toMap();
        }
        return json3;
      }
      function isPlainObj2(value) {
        return value && (value.constructor === Object || value.constructor === void 0);
      }
      function is6(valueA, valueB) {
        if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
          return true;
        }
        if (!valueA || !valueB) {
          return false;
        }
        if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
          valueA = valueA.valueOf();
          valueB = valueB.valueOf();
          if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
            return true;
          }
          if (!valueA || !valueB) {
            return false;
          }
        }
        if (typeof valueA.equals === "function" && typeof valueB.equals === "function" && valueA.equals(valueB)) {
          return true;
        }
        return false;
      }
      function deepEqual(a2, b) {
        if (a2 === b) {
          return true;
        }
        if (!isIterable2(b) || a2.size !== void 0 && b.size !== void 0 && a2.size !== b.size || a2.__hash !== void 0 && b.__hash !== void 0 && a2.__hash !== b.__hash || isKeyed(a2) !== isKeyed(b) || isIndexed2(a2) !== isIndexed2(b) || isOrdered(a2) !== isOrdered(b)) {
          return false;
        }
        if (a2.size === 0 && b.size === 0) {
          return true;
        }
        var notAssociative = !isAssociative(a2);
        if (isOrdered(a2)) {
          var entries2 = a2.entries();
          return b.every(function(v2, k) {
            var entry = entries2.next().value;
            return entry && is6(entry[1], v2) && (notAssociative || is6(entry[0], k));
          }) && entries2.next().done;
        }
        var flipped = false;
        if (a2.size === void 0) {
          if (b.size === void 0) {
            if (typeof a2.cacheResult === "function") {
              a2.cacheResult();
            }
          } else {
            flipped = true;
            var _2 = a2;
            a2 = b;
            b = _2;
          }
        }
        var allEqual2 = true;
        var bSize = b.__iterate(function(v2, k) {
          if (notAssociative ? !a2.has(v2) : flipped ? !is6(v2, a2.get(k, NOT_SET2)) : !is6(a2.get(k, NOT_SET2), v2)) {
            allEqual2 = false;
            return false;
          }
        });
        return allEqual2 && a2.size === bSize;
      }
      createClass(Repeat, IndexedSeq);
      function Repeat(value, times3) {
        if (!(this instanceof Repeat)) {
          return new Repeat(value, times3);
        }
        this._value = value;
        this.size = times3 === void 0 ? Infinity : Math.max(0, times3);
        if (this.size === 0) {
          if (EMPTY_REPEAT) {
            return EMPTY_REPEAT;
          }
          EMPTY_REPEAT = this;
        }
      }
      Repeat.prototype.toString = function() {
        if (this.size === 0) {
          return "Repeat []";
        }
        return "Repeat [ " + this._value + " " + this.size + " times ]";
      };
      Repeat.prototype.get = function(index, notSetValue) {
        return this.has(index) ? this._value : notSetValue;
      };
      Repeat.prototype.includes = function(searchValue) {
        return is6(this._value, searchValue);
      };
      Repeat.prototype.slice = function(begin, end) {
        var size = this.size;
        return wholeSlice(begin, end, size) ? this : new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
      };
      Repeat.prototype.reverse = function() {
        return this;
      };
      Repeat.prototype.indexOf = function(searchValue) {
        if (is6(this._value, searchValue)) {
          return 0;
        }
        return -1;
      };
      Repeat.prototype.lastIndexOf = function(searchValue) {
        if (is6(this._value, searchValue)) {
          return this.size;
        }
        return -1;
      };
      Repeat.prototype.__iterate = function(fn2, reverse3) {
        for (var ii = 0; ii < this.size; ii++) {
          if (fn2(this._value, ii, this) === false) {
            return ii + 1;
          }
        }
        return ii;
      };
      Repeat.prototype.__iterator = function(type5, reverse3) {
        var this$0 = this;
        var ii = 0;
        return new Iterator(
          function() {
            return ii < this$0.size ? iteratorValue(type5, ii++, this$0._value) : iteratorDone();
          }
        );
      };
      Repeat.prototype.equals = function(other) {
        return other instanceof Repeat ? is6(this._value, other._value) : deepEqual(other);
      };
      var EMPTY_REPEAT;
      function invariant2(condition, error) {
        if (!condition) throw new Error(error);
      }
      createClass(Range, IndexedSeq);
      function Range(start, end, step) {
        if (!(this instanceof Range)) {
          return new Range(start, end, step);
        }
        invariant2(step !== 0, "Cannot step a Range by 0");
        start = start || 0;
        if (end === void 0) {
          end = Infinity;
        }
        step = step === void 0 ? 1 : Math.abs(step);
        if (end < start) {
          step = -step;
        }
        this._start = start;
        this._end = end;
        this._step = step;
        this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
        if (this.size === 0) {
          if (EMPTY_RANGE) {
            return EMPTY_RANGE;
          }
          EMPTY_RANGE = this;
        }
      }
      Range.prototype.toString = function() {
        if (this.size === 0) {
          return "Range []";
        }
        return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
      };
      Range.prototype.get = function(index, notSetValue) {
        return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
      };
      Range.prototype.includes = function(searchValue) {
        var possibleIndex = (searchValue - this._start) / this._step;
        return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
      };
      Range.prototype.slice = function(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        begin = resolveBegin(begin, this.size);
        end = resolveEnd(end, this.size);
        if (end <= begin) {
          return new Range(0, 0);
        }
        return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
      };
      Range.prototype.indexOf = function(searchValue) {
        var offsetValue = searchValue - this._start;
        if (offsetValue % this._step === 0) {
          var index = offsetValue / this._step;
          if (index >= 0 && index < this.size) {
            return index;
          }
        }
        return -1;
      };
      Range.prototype.lastIndexOf = function(searchValue) {
        return this.indexOf(searchValue);
      };
      Range.prototype.__iterate = function(fn2, reverse3) {
        var maxIndex = this.size - 1;
        var step = this._step;
        var value = reverse3 ? this._start + maxIndex * step : this._start;
        for (var ii = 0; ii <= maxIndex; ii++) {
          if (fn2(value, ii, this) === false) {
            return ii + 1;
          }
          value += reverse3 ? -step : step;
        }
        return ii;
      };
      Range.prototype.__iterator = function(type5, reverse3) {
        var maxIndex = this.size - 1;
        var step = this._step;
        var value = reverse3 ? this._start + maxIndex * step : this._start;
        var ii = 0;
        return new Iterator(function() {
          var v2 = value;
          value += reverse3 ? -step : step;
          return ii > maxIndex ? iteratorDone() : iteratorValue(type5, ii++, v2);
        });
      };
      Range.prototype.equals = function(other) {
        return other instanceof Range ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
      };
      var EMPTY_RANGE;
      createClass(Collection, Iterable);
      function Collection() {
        throw TypeError("Abstract");
      }
      createClass(KeyedCollection, Collection);
      function KeyedCollection() {
      }
      createClass(IndexedCollection, Collection);
      function IndexedCollection() {
      }
      createClass(SetCollection, Collection);
      function SetCollection() {
      }
      Collection.Keyed = KeyedCollection;
      Collection.Indexed = IndexedCollection;
      Collection.Set = SetCollection;
      var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a2, b) {
        a2 = a2 | 0;
        b = b | 0;
        var c2 = a2 & 65535;
        var d2 = b & 65535;
        return c2 * d2 + ((a2 >>> 16) * d2 + c2 * (b >>> 16) << 16 >>> 0) | 0;
      };
      function smi(i32) {
        return i32 >>> 1 & 1073741824 | i32 & 3221225471;
      }
      function hash(o4) {
        if (o4 === false || o4 === null || o4 === void 0) {
          return 0;
        }
        if (typeof o4.valueOf === "function") {
          o4 = o4.valueOf();
          if (o4 === false || o4 === null || o4 === void 0) {
            return 0;
          }
        }
        if (o4 === true) {
          return 1;
        }
        var type5 = typeof o4;
        if (type5 === "number") {
          if (o4 !== o4 || o4 === Infinity) {
            return 0;
          }
          var h2 = o4 | 0;
          if (h2 !== o4) {
            h2 ^= o4 * 4294967295;
          }
          while (o4 > 4294967295) {
            o4 /= 4294967295;
            h2 ^= o4;
          }
          return smi(h2);
        }
        if (type5 === "string") {
          return o4.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o4) : hashString(o4);
        }
        if (typeof o4.hashCode === "function") {
          return o4.hashCode();
        }
        if (type5 === "object") {
          return hashJSObj(o4);
        }
        if (typeof o4.toString === "function") {
          return hashString(o4.toString());
        }
        throw new Error("Value type " + type5 + " cannot be hashed.");
      }
      function cachedHashString(string) {
        var hash2 = stringHashCache[string];
        if (hash2 === void 0) {
          hash2 = hashString(string);
          if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
            STRING_HASH_CACHE_SIZE = 0;
            stringHashCache = {};
          }
          STRING_HASH_CACHE_SIZE++;
          stringHashCache[string] = hash2;
        }
        return hash2;
      }
      function hashString(string) {
        var hash2 = 0;
        for (var ii = 0; ii < string.length; ii++) {
          hash2 = 31 * hash2 + string.charCodeAt(ii) | 0;
        }
        return smi(hash2);
      }
      function hashJSObj(obj) {
        var hash2;
        if (usingWeakMap) {
          hash2 = weakMap.get(obj);
          if (hash2 !== void 0) {
            return hash2;
          }
        }
        hash2 = obj[UID_HASH_KEY];
        if (hash2 !== void 0) {
          return hash2;
        }
        if (!canDefineProperty) {
          hash2 = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
          if (hash2 !== void 0) {
            return hash2;
          }
          hash2 = getIENodeHash(obj);
          if (hash2 !== void 0) {
            return hash2;
          }
        }
        hash2 = ++objHashUID;
        if (objHashUID & 1073741824) {
          objHashUID = 0;
        }
        if (usingWeakMap) {
          weakMap.set(obj, hash2);
        } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
          throw new Error("Non-extensible objects are not allowed as keys.");
        } else if (canDefineProperty) {
          Object.defineProperty(obj, UID_HASH_KEY, {
            "enumerable": false,
            "configurable": false,
            "writable": false,
            "value": hash2
          });
        } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
          obj.propertyIsEnumerable = function() {
            return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
          };
          obj.propertyIsEnumerable[UID_HASH_KEY] = hash2;
        } else if (obj.nodeType !== void 0) {
          obj[UID_HASH_KEY] = hash2;
        } else {
          throw new Error("Unable to set a non-enumerable property on object.");
        }
        return hash2;
      }
      var isExtensible = Object.isExtensible;
      var canDefineProperty = function() {
        try {
          Object.defineProperty({}, "@", {});
          return true;
        } catch (e2) {
          return false;
        }
      }();
      function getIENodeHash(node) {
        if (node && node.nodeType > 0) {
          switch (node.nodeType) {
            case 1:
              return node.uniqueID;
            case 9:
              return node.documentElement && node.documentElement.uniqueID;
          }
        }
      }
      var usingWeakMap = typeof WeakMap === "function";
      var weakMap;
      if (usingWeakMap) {
        weakMap = /* @__PURE__ */ new WeakMap();
      }
      var objHashUID = 0;
      var UID_HASH_KEY = "__immutablehash__";
      if (typeof Symbol === "function") {
        UID_HASH_KEY = Symbol(UID_HASH_KEY);
      }
      var STRING_HASH_CACHE_MIN_STRLEN = 16;
      var STRING_HASH_CACHE_MAX_SIZE = 255;
      var STRING_HASH_CACHE_SIZE = 0;
      var stringHashCache = {};
      function assertNotInfinite(size) {
        invariant2(
          size !== Infinity,
          "Cannot perform this action with an infinite size."
        );
      }
      createClass(Map3, KeyedCollection);
      function Map3(value) {
        return value === null || value === void 0 ? emptyMap() : isMap2(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map5) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v2, k) {
            return map5.set(k, v2);
          });
        });
      }
      Map3.of = function() {
        var keyValues = SLICE$0.call(arguments, 0);
        return emptyMap().withMutations(function(map5) {
          for (var i2 = 0; i2 < keyValues.length; i2 += 2) {
            if (i2 + 1 >= keyValues.length) {
              throw new Error("Missing value for key: " + keyValues[i2]);
            }
            map5.set(keyValues[i2], keyValues[i2 + 1]);
          }
        });
      };
      Map3.prototype.toString = function() {
        return this.__toString("Map {", "}");
      };
      Map3.prototype.get = function(k, notSetValue) {
        return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
      };
      Map3.prototype.set = function(k, v2) {
        return updateMap(this, k, v2);
      };
      Map3.prototype.setIn = function(keyPath, v2) {
        return this.updateIn(keyPath, NOT_SET2, function() {
          return v2;
        });
      };
      Map3.prototype.remove = function(k) {
        return updateMap(this, k, NOT_SET2);
      };
      Map3.prototype.deleteIn = function(keyPath) {
        return this.updateIn(keyPath, function() {
          return NOT_SET2;
        });
      };
      Map3.prototype.update = function(k, notSetValue, updater) {
        return arguments.length === 1 ? k(this) : this.updateIn([k], notSetValue, updater);
      };
      Map3.prototype.updateIn = function(keyPath, notSetValue, updater) {
        if (!updater) {
          updater = notSetValue;
          notSetValue = void 0;
        }
        var updatedValue = updateInDeepMap(
          this,
          forceIterator(keyPath),
          notSetValue,
          updater
        );
        return updatedValue === NOT_SET2 ? void 0 : updatedValue;
      };
      Map3.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._root = null;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyMap();
      };
      Map3.prototype.merge = function() {
        return mergeIntoMapWith(this, void 0, arguments);
      };
      Map3.prototype.mergeWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return mergeIntoMapWith(this, merger, iters);
      };
      Map3.prototype.mergeIn = function(keyPath) {
        var iters = SLICE$0.call(arguments, 1);
        return this.updateIn(
          keyPath,
          emptyMap(),
          function(m2) {
            return typeof m2.merge === "function" ? m2.merge.apply(m2, iters) : iters[iters.length - 1];
          }
        );
      };
      Map3.prototype.mergeDeep = function() {
        return mergeIntoMapWith(this, deepMerger, arguments);
      };
      Map3.prototype.mergeDeepWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return mergeIntoMapWith(this, deepMergerWith(merger), iters);
      };
      Map3.prototype.mergeDeepIn = function(keyPath) {
        var iters = SLICE$0.call(arguments, 1);
        return this.updateIn(
          keyPath,
          emptyMap(),
          function(m2) {
            return typeof m2.mergeDeep === "function" ? m2.mergeDeep.apply(m2, iters) : iters[iters.length - 1];
          }
        );
      };
      Map3.prototype.sort = function(comparator3) {
        return OrderedMap2(sortFactory(this, comparator3));
      };
      Map3.prototype.sortBy = function(mapper, comparator3) {
        return OrderedMap2(sortFactory(this, comparator3, mapper));
      };
      Map3.prototype.withMutations = function(fn2) {
        var mutable = this.asMutable();
        fn2(mutable);
        return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
      };
      Map3.prototype.asMutable = function() {
        return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
      };
      Map3.prototype.asImmutable = function() {
        return this.__ensureOwner();
      };
      Map3.prototype.wasAltered = function() {
        return this.__altered;
      };
      Map3.prototype.__iterator = function(type5, reverse3) {
        return new MapIterator(this, type5, reverse3);
      };
      Map3.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        var iterations = 0;
        this._root && this._root.iterate(function(entry) {
          iterations++;
          return fn2(entry[1], entry[0], this$0);
        }, reverse3);
        return iterations;
      };
      Map3.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeMap(this.size, this._root, ownerID, this.__hash);
      };
      function isMap2(maybeMap) {
        return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
      }
      Map3.isMap = isMap2;
      var IS_MAP_SENTINEL = "@@__IMMUTABLE_MAP__@@";
      var MapPrototype = Map3.prototype;
      MapPrototype[IS_MAP_SENTINEL] = true;
      MapPrototype[DELETE] = MapPrototype.remove;
      MapPrototype.removeIn = MapPrototype.deleteIn;
      function ArrayMapNode(ownerID, entries2) {
        this.ownerID = ownerID;
        this.entries = entries2;
      }
      ArrayMapNode.prototype.get = function(shift, keyHash, key57, notSetValue) {
        var entries2 = this.entries;
        for (var ii = 0, len = entries2.length; ii < len; ii++) {
          if (is6(key57, entries2[ii][0])) {
            return entries2[ii][1];
          }
        }
        return notSetValue;
      };
      ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key57, value, didChangeSize, didAlter) {
        var removed = value === NOT_SET2;
        var entries2 = this.entries;
        var idx = 0;
        for (var len = entries2.length; idx < len; idx++) {
          if (is6(key57, entries2[idx][0])) {
            break;
          }
        }
        var exists = idx < len;
        if (exists ? entries2[idx][1] === value : removed) {
          return this;
        }
        SetRef(didAlter);
        (removed || !exists) && SetRef(didChangeSize);
        if (removed && entries2.length === 1) {
          return;
        }
        if (!exists && !removed && entries2.length >= MAX_ARRAY_MAP_SIZE) {
          return createNodes(ownerID, entries2, key57, value);
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newEntries = isEditable ? entries2 : arrCopy(entries2);
        if (exists) {
          if (removed) {
            idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
          } else {
            newEntries[idx] = [key57, value];
          }
        } else {
          newEntries.push([key57, value]);
        }
        if (isEditable) {
          this.entries = newEntries;
          return this;
        }
        return new ArrayMapNode(ownerID, newEntries);
      };
      function BitmapIndexedNode(ownerID, bitmap, nodes) {
        this.ownerID = ownerID;
        this.bitmap = bitmap;
        this.nodes = nodes;
      }
      BitmapIndexedNode.prototype.get = function(shift, keyHash, key57, notSetValue) {
        if (keyHash === void 0) {
          keyHash = hash(key57);
        }
        var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
        var bitmap = this.bitmap;
        return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(shift + SHIFT, keyHash, key57, notSetValue);
      };
      BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key57, value, didChangeSize, didAlter) {
        if (keyHash === void 0) {
          keyHash = hash(key57);
        }
        var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var bit = 1 << keyHashFrag;
        var bitmap = this.bitmap;
        var exists = (bitmap & bit) !== 0;
        if (!exists && value === NOT_SET2) {
          return this;
        }
        var idx = popCount(bitmap & bit - 1);
        var nodes = this.nodes;
        var node = exists ? nodes[idx] : void 0;
        var newNode = updateNode2(node, ownerID, shift + SHIFT, keyHash, key57, value, didChangeSize, didAlter);
        if (newNode === node) {
          return this;
        }
        if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
          return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
        }
        if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
          return nodes[idx ^ 1];
        }
        if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
          return newNode;
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
        var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
        if (isEditable) {
          this.bitmap = newBitmap;
          this.nodes = newNodes;
          return this;
        }
        return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
      };
      function HashArrayMapNode(ownerID, count2, nodes) {
        this.ownerID = ownerID;
        this.count = count2;
        this.nodes = nodes;
      }
      HashArrayMapNode.prototype.get = function(shift, keyHash, key57, notSetValue) {
        if (keyHash === void 0) {
          keyHash = hash(key57);
        }
        var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var node = this.nodes[idx];
        return node ? node.get(shift + SHIFT, keyHash, key57, notSetValue) : notSetValue;
      };
      HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key57, value, didChangeSize, didAlter) {
        if (keyHash === void 0) {
          keyHash = hash(key57);
        }
        var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var removed = value === NOT_SET2;
        var nodes = this.nodes;
        var node = nodes[idx];
        if (removed && !node) {
          return this;
        }
        var newNode = updateNode2(node, ownerID, shift + SHIFT, keyHash, key57, value, didChangeSize, didAlter);
        if (newNode === node) {
          return this;
        }
        var newCount = this.count;
        if (!node) {
          newCount++;
        } else if (!newNode) {
          newCount--;
          if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
            return packNodes(ownerID, nodes, newCount, idx);
          }
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newNodes = setIn(nodes, idx, newNode, isEditable);
        if (isEditable) {
          this.count = newCount;
          this.nodes = newNodes;
          return this;
        }
        return new HashArrayMapNode(ownerID, newCount, newNodes);
      };
      function HashCollisionNode(ownerID, keyHash, entries2) {
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entries = entries2;
      }
      HashCollisionNode.prototype.get = function(shift, keyHash, key57, notSetValue) {
        var entries2 = this.entries;
        for (var ii = 0, len = entries2.length; ii < len; ii++) {
          if (is6(key57, entries2[ii][0])) {
            return entries2[ii][1];
          }
        }
        return notSetValue;
      };
      HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key57, value, didChangeSize, didAlter) {
        if (keyHash === void 0) {
          keyHash = hash(key57);
        }
        var removed = value === NOT_SET2;
        if (keyHash !== this.keyHash) {
          if (removed) {
            return this;
          }
          SetRef(didAlter);
          SetRef(didChangeSize);
          return mergeIntoNode(this, ownerID, shift, keyHash, [key57, value]);
        }
        var entries2 = this.entries;
        var idx = 0;
        for (var len = entries2.length; idx < len; idx++) {
          if (is6(key57, entries2[idx][0])) {
            break;
          }
        }
        var exists = idx < len;
        if (exists ? entries2[idx][1] === value : removed) {
          return this;
        }
        SetRef(didAlter);
        (removed || !exists) && SetRef(didChangeSize);
        if (removed && len === 2) {
          return new ValueNode(ownerID, this.keyHash, entries2[idx ^ 1]);
        }
        var isEditable = ownerID && ownerID === this.ownerID;
        var newEntries = isEditable ? entries2 : arrCopy(entries2);
        if (exists) {
          if (removed) {
            idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
          } else {
            newEntries[idx] = [key57, value];
          }
        } else {
          newEntries.push([key57, value]);
        }
        if (isEditable) {
          this.entries = newEntries;
          return this;
        }
        return new HashCollisionNode(ownerID, this.keyHash, newEntries);
      };
      function ValueNode(ownerID, keyHash, entry) {
        this.ownerID = ownerID;
        this.keyHash = keyHash;
        this.entry = entry;
      }
      ValueNode.prototype.get = function(shift, keyHash, key57, notSetValue) {
        return is6(key57, this.entry[0]) ? this.entry[1] : notSetValue;
      };
      ValueNode.prototype.update = function(ownerID, shift, keyHash, key57, value, didChangeSize, didAlter) {
        var removed = value === NOT_SET2;
        var keyMatch = is6(key57, this.entry[0]);
        if (keyMatch ? value === this.entry[1] : removed) {
          return this;
        }
        SetRef(didAlter);
        if (removed) {
          SetRef(didChangeSize);
          return;
        }
        if (keyMatch) {
          if (ownerID && ownerID === this.ownerID) {
            this.entry[1] = value;
            return this;
          }
          return new ValueNode(ownerID, this.keyHash, [key57, value]);
        }
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, hash(key57), [key57, value]);
      };
      ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn2, reverse3) {
        var entries2 = this.entries;
        for (var ii = 0, maxIndex = entries2.length - 1; ii <= maxIndex; ii++) {
          if (fn2(entries2[reverse3 ? maxIndex - ii : ii]) === false) {
            return false;
          }
        }
      };
      BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn2, reverse3) {
        var nodes = this.nodes;
        for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
          var node = nodes[reverse3 ? maxIndex - ii : ii];
          if (node && node.iterate(fn2, reverse3) === false) {
            return false;
          }
        }
      };
      ValueNode.prototype.iterate = function(fn2, reverse3) {
        return fn2(this.entry);
      };
      createClass(MapIterator, Iterator);
      function MapIterator(map5, type5, reverse3) {
        this._type = type5;
        this._reverse = reverse3;
        this._stack = map5._root && mapIteratorFrame(map5._root);
      }
      MapIterator.prototype.next = function() {
        var type5 = this._type;
        var stack = this._stack;
        while (stack) {
          var node = stack.node;
          var index = stack.index++;
          var maxIndex;
          if (node.entry) {
            if (index === 0) {
              return mapIteratorValue(type5, node.entry);
            }
          } else if (node.entries) {
            maxIndex = node.entries.length - 1;
            if (index <= maxIndex) {
              return mapIteratorValue(type5, node.entries[this._reverse ? maxIndex - index : index]);
            }
          } else {
            maxIndex = node.nodes.length - 1;
            if (index <= maxIndex) {
              var subNode = node.nodes[this._reverse ? maxIndex - index : index];
              if (subNode) {
                if (subNode.entry) {
                  return mapIteratorValue(type5, subNode.entry);
                }
                stack = this._stack = mapIteratorFrame(subNode, stack);
              }
              continue;
            }
          }
          stack = this._stack = this._stack.__prev;
        }
        return iteratorDone();
      };
      function mapIteratorValue(type5, entry) {
        return iteratorValue(type5, entry[0], entry[1]);
      }
      function mapIteratorFrame(node, prev) {
        return {
          node,
          index: 0,
          __prev: prev
        };
      }
      function makeMap(size, root, ownerID, hash2) {
        var map5 = Object.create(MapPrototype);
        map5.size = size;
        map5._root = root;
        map5.__ownerID = ownerID;
        map5.__hash = hash2;
        map5.__altered = false;
        return map5;
      }
      var EMPTY_MAP;
      function emptyMap() {
        return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
      }
      function updateMap(map5, k, v2) {
        var newRoot;
        var newSize;
        if (!map5._root) {
          if (v2 === NOT_SET2) {
            return map5;
          }
          newSize = 1;
          newRoot = new ArrayMapNode(map5.__ownerID, [[k, v2]]);
        } else {
          var didChangeSize = MakeRef(CHANGE_LENGTH);
          var didAlter = MakeRef(DID_ALTER);
          newRoot = updateNode2(map5._root, map5.__ownerID, 0, void 0, k, v2, didChangeSize, didAlter);
          if (!didAlter.value) {
            return map5;
          }
          newSize = map5.size + (didChangeSize.value ? v2 === NOT_SET2 ? -1 : 1 : 0);
        }
        if (map5.__ownerID) {
          map5.size = newSize;
          map5._root = newRoot;
          map5.__hash = void 0;
          map5.__altered = true;
          return map5;
        }
        return newRoot ? makeMap(newSize, newRoot) : emptyMap();
      }
      function updateNode2(node, ownerID, shift, keyHash, key57, value, didChangeSize, didAlter) {
        if (!node) {
          if (value === NOT_SET2) {
            return node;
          }
          SetRef(didAlter);
          SetRef(didChangeSize);
          return new ValueNode(ownerID, keyHash, [key57, value]);
        }
        return node.update(ownerID, shift, keyHash, key57, value, didChangeSize, didAlter);
      }
      function isLeafNode(node) {
        return node.constructor === ValueNode || node.constructor === HashCollisionNode;
      }
      function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
        if (node.keyHash === keyHash) {
          return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
        }
        var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
        var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
        var newNode;
        var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
        return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
      }
      function createNodes(ownerID, entries2, key57, value) {
        if (!ownerID) {
          ownerID = new OwnerID();
        }
        var node = new ValueNode(ownerID, hash(key57), [key57, value]);
        for (var ii = 0; ii < entries2.length; ii++) {
          var entry = entries2[ii];
          node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
        }
        return node;
      }
      function packNodes(ownerID, nodes, count2, excluding) {
        var bitmap = 0;
        var packedII = 0;
        var packedNodes = new Array(count2);
        for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
          var node = nodes[ii];
          if (node !== void 0 && ii !== excluding) {
            bitmap |= bit;
            packedNodes[packedII++] = node;
          }
        }
        return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
      }
      function expandNodes(ownerID, nodes, bitmap, including, node) {
        var count2 = 0;
        var expandedNodes = new Array(SIZE);
        for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
          expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
        }
        expandedNodes[including] = node;
        return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
      }
      function mergeIntoMapWith(map5, merger, iterables) {
        var iters = [];
        for (var ii = 0; ii < iterables.length; ii++) {
          var value = iterables[ii];
          var iter = KeyedIterable(value);
          if (!isIterable2(value)) {
            iter = iter.map(function(v2) {
              return fromJS2(v2);
            });
          }
          iters.push(iter);
        }
        return mergeIntoCollectionWith(map5, merger, iters);
      }
      function deepMerger(existing, value, key57) {
        return existing && existing.mergeDeep && isIterable2(value) ? existing.mergeDeep(value) : is6(existing, value) ? existing : value;
      }
      function deepMergerWith(merger) {
        return function(existing, value, key57) {
          if (existing && existing.mergeDeepWith && isIterable2(value)) {
            return existing.mergeDeepWith(merger, value);
          }
          var nextValue = merger(existing, value, key57);
          return is6(existing, nextValue) ? existing : nextValue;
        };
      }
      function mergeIntoCollectionWith(collection, merger, iters) {
        iters = iters.filter(function(x2) {
          return x2.size !== 0;
        });
        if (iters.length === 0) {
          return collection;
        }
        if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
          return collection.constructor(iters[0]);
        }
        return collection.withMutations(function(collection2) {
          var mergeIntoMap = merger ? function(value, key57) {
            collection2.update(
              key57,
              NOT_SET2,
              function(existing) {
                return existing === NOT_SET2 ? value : merger(existing, value, key57);
              }
            );
          } : function(value, key57) {
            collection2.set(key57, value);
          };
          for (var ii = 0; ii < iters.length; ii++) {
            iters[ii].forEach(mergeIntoMap);
          }
        });
      }
      function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
        var isNotSet2 = existing === NOT_SET2;
        var step = keyPathIter.next();
        if (step.done) {
          var existingValue = isNotSet2 ? notSetValue : existing;
          var newValue = updater(existingValue);
          return newValue === existingValue ? existing : newValue;
        }
        invariant2(
          isNotSet2 || existing && existing.set,
          "invalid keyPath"
        );
        var key57 = step.value;
        var nextExisting = isNotSet2 ? NOT_SET2 : existing.get(key57, NOT_SET2);
        var nextUpdated = updateInDeepMap(
          nextExisting,
          keyPathIter,
          notSetValue,
          updater
        );
        return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET2 ? existing.remove(key57) : (isNotSet2 ? emptyMap() : existing).set(key57, nextUpdated);
      }
      function popCount(x2) {
        x2 = x2 - (x2 >> 1 & 1431655765);
        x2 = (x2 & 858993459) + (x2 >> 2 & 858993459);
        x2 = x2 + (x2 >> 4) & 252645135;
        x2 = x2 + (x2 >> 8);
        x2 = x2 + (x2 >> 16);
        return x2 & 127;
      }
      function setIn(array2, idx, val, canEdit) {
        var newArray = canEdit ? array2 : arrCopy(array2);
        newArray[idx] = val;
        return newArray;
      }
      function spliceIn(array2, idx, val, canEdit) {
        var newLen = array2.length + 1;
        if (canEdit && idx + 1 === newLen) {
          array2[idx] = val;
          return array2;
        }
        var newArray = new Array(newLen);
        var after = 0;
        for (var ii = 0; ii < newLen; ii++) {
          if (ii === idx) {
            newArray[ii] = val;
            after = -1;
          } else {
            newArray[ii] = array2[ii + after];
          }
        }
        return newArray;
      }
      function spliceOut(array2, idx, canEdit) {
        var newLen = array2.length - 1;
        if (canEdit && idx === newLen) {
          array2.pop();
          return array2;
        }
        var newArray = new Array(newLen);
        var after = 0;
        for (var ii = 0; ii < newLen; ii++) {
          if (ii === idx) {
            after = 1;
          }
          newArray[ii] = array2[ii + after];
        }
        return newArray;
      }
      var MAX_ARRAY_MAP_SIZE = SIZE / 4;
      var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
      var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
      createClass(List2, IndexedCollection);
      function List2(value) {
        var empty4 = emptyList();
        if (value === null || value === void 0) {
          return empty4;
        }
        if (isList(value)) {
          return value;
        }
        var iter = IndexedIterable(value);
        var size = iter.size;
        if (size === 0) {
          return empty4;
        }
        assertNotInfinite(size);
        if (size > 0 && size < SIZE) {
          return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
        }
        return empty4.withMutations(function(list4) {
          list4.setSize(size);
          iter.forEach(function(v2, i2) {
            return list4.set(i2, v2);
          });
        });
      }
      List2.of = function() {
        return this(arguments);
      };
      List2.prototype.toString = function() {
        return this.__toString("List [", "]");
      };
      List2.prototype.get = function(index, notSetValue) {
        index = wrapIndex(this, index);
        if (index >= 0 && index < this.size) {
          index += this._origin;
          var node = listNodeFor(this, index);
          return node && node.array[index & MASK];
        }
        return notSetValue;
      };
      List2.prototype.set = function(index, value) {
        return updateList(this, index, value);
      };
      List2.prototype.remove = function(index) {
        return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
      };
      List2.prototype.insert = function(index, value) {
        return this.splice(index, 0, value);
      };
      List2.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = this._origin = this._capacity = 0;
          this._level = SHIFT;
          this._root = this._tail = null;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyList();
      };
      List2.prototype.push = function() {
        var values3 = arguments;
        var oldSize = this.size;
        return this.withMutations(function(list4) {
          setListBounds(list4, 0, oldSize + values3.length);
          for (var ii = 0; ii < values3.length; ii++) {
            list4.set(oldSize + ii, values3[ii]);
          }
        });
      };
      List2.prototype.pop = function() {
        return setListBounds(this, 0, -1);
      };
      List2.prototype.unshift = function() {
        var values3 = arguments;
        return this.withMutations(function(list4) {
          setListBounds(list4, -values3.length);
          for (var ii = 0; ii < values3.length; ii++) {
            list4.set(ii, values3[ii]);
          }
        });
      };
      List2.prototype.shift = function() {
        return setListBounds(this, 1);
      };
      List2.prototype.merge = function() {
        return mergeIntoListWith(this, void 0, arguments);
      };
      List2.prototype.mergeWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return mergeIntoListWith(this, merger, iters);
      };
      List2.prototype.mergeDeep = function() {
        return mergeIntoListWith(this, deepMerger, arguments);
      };
      List2.prototype.mergeDeepWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return mergeIntoListWith(this, deepMergerWith(merger), iters);
      };
      List2.prototype.setSize = function(size) {
        return setListBounds(this, 0, size);
      };
      List2.prototype.slice = function(begin, end) {
        var size = this.size;
        if (wholeSlice(begin, end, size)) {
          return this;
        }
        return setListBounds(
          this,
          resolveBegin(begin, size),
          resolveEnd(end, size)
        );
      };
      List2.prototype.__iterator = function(type5, reverse3) {
        var index = 0;
        var values3 = iterateList(this, reverse3);
        return new Iterator(function() {
          var value = values3();
          return value === DONE ? iteratorDone() : iteratorValue(type5, index++, value);
        });
      };
      List2.prototype.__iterate = function(fn2, reverse3) {
        var index = 0;
        var values3 = iterateList(this, reverse3);
        var value;
        while ((value = values3()) !== DONE) {
          if (fn2(value, index++, this) === false) {
            break;
          }
        }
        return index;
      };
      List2.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          this.__ownerID = ownerID;
          return this;
        }
        return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
      };
      function isList(maybeList) {
        return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
      }
      List2.isList = isList;
      var IS_LIST_SENTINEL = "@@__IMMUTABLE_LIST__@@";
      var ListPrototype = List2.prototype;
      ListPrototype[IS_LIST_SENTINEL] = true;
      ListPrototype[DELETE] = ListPrototype.remove;
      ListPrototype.setIn = MapPrototype.setIn;
      ListPrototype.deleteIn = ListPrototype.removeIn = MapPrototype.removeIn;
      ListPrototype.update = MapPrototype.update;
      ListPrototype.updateIn = MapPrototype.updateIn;
      ListPrototype.mergeIn = MapPrototype.mergeIn;
      ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
      ListPrototype.withMutations = MapPrototype.withMutations;
      ListPrototype.asMutable = MapPrototype.asMutable;
      ListPrototype.asImmutable = MapPrototype.asImmutable;
      ListPrototype.wasAltered = MapPrototype.wasAltered;
      function VNode(array2, ownerID) {
        this.array = array2;
        this.ownerID = ownerID;
      }
      VNode.prototype.removeBefore = function(ownerID, level, index) {
        if (index === level ? 1 << level : this.array.length === 0) {
          return this;
        }
        var originIndex = index >>> level & MASK;
        if (originIndex >= this.array.length) {
          return new VNode([], ownerID);
        }
        var removingFirst = originIndex === 0;
        var newChild;
        if (level > 0) {
          var oldChild = this.array[originIndex];
          newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
          if (newChild === oldChild && removingFirst) {
            return this;
          }
        }
        if (removingFirst && !newChild) {
          return this;
        }
        var editable = editableVNode(this, ownerID);
        if (!removingFirst) {
          for (var ii = 0; ii < originIndex; ii++) {
            editable.array[ii] = void 0;
          }
        }
        if (newChild) {
          editable.array[originIndex] = newChild;
        }
        return editable;
      };
      VNode.prototype.removeAfter = function(ownerID, level, index) {
        if (index === (level ? 1 << level : 0) || this.array.length === 0) {
          return this;
        }
        var sizeIndex = index - 1 >>> level & MASK;
        if (sizeIndex >= this.array.length) {
          return this;
        }
        var newChild;
        if (level > 0) {
          var oldChild = this.array[sizeIndex];
          newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
          if (newChild === oldChild && sizeIndex === this.array.length - 1) {
            return this;
          }
        }
        var editable = editableVNode(this, ownerID);
        editable.array.splice(sizeIndex + 1);
        if (newChild) {
          editable.array[sizeIndex] = newChild;
        }
        return editable;
      };
      var DONE = {};
      function iterateList(list4, reverse3) {
        var left = list4._origin;
        var right = list4._capacity;
        var tailPos = getTailOffset(right);
        var tail2 = list4._tail;
        return iterateNodeOrLeaf(list4._root, list4._level, 0);
        function iterateNodeOrLeaf(node, level, offset) {
          return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
        }
        function iterateLeaf(node, offset) {
          var array2 = offset === tailPos ? tail2 && tail2.array : node && node.array;
          var from2 = offset > left ? 0 : left - offset;
          var to2 = right - offset;
          if (to2 > SIZE) {
            to2 = SIZE;
          }
          return function() {
            if (from2 === to2) {
              return DONE;
            }
            var idx = reverse3 ? --to2 : from2++;
            return array2 && array2[idx];
          };
        }
        function iterateNode(node, level, offset) {
          var values3;
          var array2 = node && node.array;
          var from2 = offset > left ? 0 : left - offset >> level;
          var to2 = (right - offset >> level) + 1;
          if (to2 > SIZE) {
            to2 = SIZE;
          }
          return function() {
            do {
              if (values3) {
                var value = values3();
                if (value !== DONE) {
                  return value;
                }
                values3 = null;
              }
              if (from2 === to2) {
                return DONE;
              }
              var idx = reverse3 ? --to2 : from2++;
              values3 = iterateNodeOrLeaf(
                array2 && array2[idx],
                level - SHIFT,
                offset + (idx << level)
              );
            } while (true);
          };
        }
      }
      function makeList(origin, capacity, level, root, tail2, ownerID, hash2) {
        var list4 = Object.create(ListPrototype);
        list4.size = capacity - origin;
        list4._origin = origin;
        list4._capacity = capacity;
        list4._level = level;
        list4._root = root;
        list4._tail = tail2;
        list4.__ownerID = ownerID;
        list4.__hash = hash2;
        list4.__altered = false;
        return list4;
      }
      var EMPTY_LIST;
      function emptyList() {
        return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
      }
      function updateList(list4, index, value) {
        index = wrapIndex(list4, index);
        if (index !== index) {
          return list4;
        }
        if (index >= list4.size || index < 0) {
          return list4.withMutations(function(list5) {
            index < 0 ? setListBounds(list5, index).set(0, value) : setListBounds(list5, 0, index + 1).set(index, value);
          });
        }
        index += list4._origin;
        var newTail = list4._tail;
        var newRoot = list4._root;
        var didAlter = MakeRef(DID_ALTER);
        if (index >= getTailOffset(list4._capacity)) {
          newTail = updateVNode(newTail, list4.__ownerID, 0, index, value, didAlter);
        } else {
          newRoot = updateVNode(newRoot, list4.__ownerID, list4._level, index, value, didAlter);
        }
        if (!didAlter.value) {
          return list4;
        }
        if (list4.__ownerID) {
          list4._root = newRoot;
          list4._tail = newTail;
          list4.__hash = void 0;
          list4.__altered = true;
          return list4;
        }
        return makeList(list4._origin, list4._capacity, list4._level, newRoot, newTail);
      }
      function updateVNode(node, ownerID, level, index, value, didAlter) {
        var idx = index >>> level & MASK;
        var nodeHas = node && idx < node.array.length;
        if (!nodeHas && value === void 0) {
          return node;
        }
        var newNode;
        if (level > 0) {
          var lowerNode = node && node.array[idx];
          var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
          if (newLowerNode === lowerNode) {
            return node;
          }
          newNode = editableVNode(node, ownerID);
          newNode.array[idx] = newLowerNode;
          return newNode;
        }
        if (nodeHas && node.array[idx] === value) {
          return node;
        }
        SetRef(didAlter);
        newNode = editableVNode(node, ownerID);
        if (value === void 0 && idx === newNode.array.length - 1) {
          newNode.array.pop();
        } else {
          newNode.array[idx] = value;
        }
        return newNode;
      }
      function editableVNode(node, ownerID) {
        if (ownerID && node && ownerID === node.ownerID) {
          return node;
        }
        return new VNode(node ? node.array.slice() : [], ownerID);
      }
      function listNodeFor(list4, rawIndex) {
        if (rawIndex >= getTailOffset(list4._capacity)) {
          return list4._tail;
        }
        if (rawIndex < 1 << list4._level + SHIFT) {
          var node = list4._root;
          var level = list4._level;
          while (node && level > 0) {
            node = node.array[rawIndex >>> level & MASK];
            level -= SHIFT;
          }
          return node;
        }
      }
      function setListBounds(list4, begin, end) {
        if (begin !== void 0) {
          begin = begin | 0;
        }
        if (end !== void 0) {
          end = end | 0;
        }
        var owner = list4.__ownerID || new OwnerID();
        var oldOrigin = list4._origin;
        var oldCapacity = list4._capacity;
        var newOrigin = oldOrigin + begin;
        var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
        if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
          return list4;
        }
        if (newOrigin >= newCapacity) {
          return list4.clear();
        }
        var newLevel = list4._level;
        var newRoot = list4._root;
        var offsetShift = 0;
        while (newOrigin + offsetShift < 0) {
          newRoot = new VNode(newRoot && newRoot.array.length ? [void 0, newRoot] : [], owner);
          newLevel += SHIFT;
          offsetShift += 1 << newLevel;
        }
        if (offsetShift) {
          newOrigin += offsetShift;
          oldOrigin += offsetShift;
          newCapacity += offsetShift;
          oldCapacity += offsetShift;
        }
        var oldTailOffset = getTailOffset(oldCapacity);
        var newTailOffset = getTailOffset(newCapacity);
        while (newTailOffset >= 1 << newLevel + SHIFT) {
          newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
          newLevel += SHIFT;
        }
        var oldTail = list4._tail;
        var newTail = newTailOffset < oldTailOffset ? listNodeFor(list4, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
        if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
          newRoot = editableVNode(newRoot, owner);
          var node = newRoot;
          for (var level = newLevel; level > SHIFT; level -= SHIFT) {
            var idx = oldTailOffset >>> level & MASK;
            node = node.array[idx] = editableVNode(node.array[idx], owner);
          }
          node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
        }
        if (newCapacity < oldCapacity) {
          newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
        }
        if (newOrigin >= newTailOffset) {
          newOrigin -= newTailOffset;
          newCapacity -= newTailOffset;
          newLevel = SHIFT;
          newRoot = null;
          newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
        } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
          offsetShift = 0;
          while (newRoot) {
            var beginIndex = newOrigin >>> newLevel & MASK;
            if (beginIndex !== newTailOffset >>> newLevel & MASK) {
              break;
            }
            if (beginIndex) {
              offsetShift += (1 << newLevel) * beginIndex;
            }
            newLevel -= SHIFT;
            newRoot = newRoot.array[beginIndex];
          }
          if (newRoot && newOrigin > oldOrigin) {
            newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
          }
          if (newRoot && newTailOffset < oldTailOffset) {
            newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
          }
          if (offsetShift) {
            newOrigin -= offsetShift;
            newCapacity -= offsetShift;
          }
        }
        if (list4.__ownerID) {
          list4.size = newCapacity - newOrigin;
          list4._origin = newOrigin;
          list4._capacity = newCapacity;
          list4._level = newLevel;
          list4._root = newRoot;
          list4._tail = newTail;
          list4.__hash = void 0;
          list4.__altered = true;
          return list4;
        }
        return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
      }
      function mergeIntoListWith(list4, merger, iterables) {
        var iters = [];
        var maxSize = 0;
        for (var ii = 0; ii < iterables.length; ii++) {
          var value = iterables[ii];
          var iter = IndexedIterable(value);
          if (iter.size > maxSize) {
            maxSize = iter.size;
          }
          if (!isIterable2(value)) {
            iter = iter.map(function(v2) {
              return fromJS2(v2);
            });
          }
          iters.push(iter);
        }
        if (maxSize > list4.size) {
          list4 = list4.setSize(maxSize);
        }
        return mergeIntoCollectionWith(list4, merger, iters);
      }
      function getTailOffset(size) {
        return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
      }
      createClass(OrderedMap2, Map3);
      function OrderedMap2(value) {
        return value === null || value === void 0 ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map5) {
          var iter = KeyedIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v2, k) {
            return map5.set(k, v2);
          });
        });
      }
      OrderedMap2.of = function() {
        return this(arguments);
      };
      OrderedMap2.prototype.toString = function() {
        return this.__toString("OrderedMap {", "}");
      };
      OrderedMap2.prototype.get = function(k, notSetValue) {
        var index = this._map.get(k);
        return index !== void 0 ? this._list.get(index)[1] : notSetValue;
      };
      OrderedMap2.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._map.clear();
          this._list.clear();
          return this;
        }
        return emptyOrderedMap();
      };
      OrderedMap2.prototype.set = function(k, v2) {
        return updateOrderedMap(this, k, v2);
      };
      OrderedMap2.prototype.remove = function(k) {
        return updateOrderedMap(this, k, NOT_SET2);
      };
      OrderedMap2.prototype.wasAltered = function() {
        return this._map.wasAltered() || this._list.wasAltered();
      };
      OrderedMap2.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return this._list.__iterate(
          function(entry) {
            return entry && fn2(entry[1], entry[0], this$0);
          },
          reverse3
        );
      };
      OrderedMap2.prototype.__iterator = function(type5, reverse3) {
        return this._list.fromEntrySeq().__iterator(type5, reverse3);
      };
      OrderedMap2.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        var newList = this._list.__ensureOwner(ownerID);
        if (!ownerID) {
          this.__ownerID = ownerID;
          this._map = newMap;
          this._list = newList;
          return this;
        }
        return makeOrderedMap(newMap, newList, ownerID, this.__hash);
      };
      function isOrderedMap(maybeOrderedMap) {
        return isMap2(maybeOrderedMap) && isOrdered(maybeOrderedMap);
      }
      OrderedMap2.isOrderedMap = isOrderedMap;
      OrderedMap2.prototype[IS_ORDERED_SENTINEL] = true;
      OrderedMap2.prototype[DELETE] = OrderedMap2.prototype.remove;
      function makeOrderedMap(map5, list4, ownerID, hash2) {
        var omap2 = Object.create(OrderedMap2.prototype);
        omap2.size = map5 ? map5.size : 0;
        omap2._map = map5;
        omap2._list = list4;
        omap2.__ownerID = ownerID;
        omap2.__hash = hash2;
        return omap2;
      }
      var EMPTY_ORDERED_MAP;
      function emptyOrderedMap() {
        return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
      }
      function updateOrderedMap(omap2, k, v2) {
        var map5 = omap2._map;
        var list4 = omap2._list;
        var i2 = map5.get(k);
        var has4 = i2 !== void 0;
        var newMap;
        var newList;
        if (v2 === NOT_SET2) {
          if (!has4) {
            return omap2;
          }
          if (list4.size >= SIZE && list4.size >= map5.size * 2) {
            newList = list4.filter(function(entry, idx) {
              return entry !== void 0 && i2 !== idx;
            });
            newMap = newList.toKeyedSeq().map(function(entry) {
              return entry[0];
            }).flip().toMap();
            if (omap2.__ownerID) {
              newMap.__ownerID = newList.__ownerID = omap2.__ownerID;
            }
          } else {
            newMap = map5.remove(k);
            newList = i2 === list4.size - 1 ? list4.pop() : list4.set(i2, void 0);
          }
        } else {
          if (has4) {
            if (v2 === list4.get(i2)[1]) {
              return omap2;
            }
            newMap = map5;
            newList = list4.set(i2, [k, v2]);
          } else {
            newMap = map5.set(k, list4.size);
            newList = list4.set(list4.size, [k, v2]);
          }
        }
        if (omap2.__ownerID) {
          omap2.size = newMap.size;
          omap2._map = newMap;
          omap2._list = newList;
          omap2.__hash = void 0;
          return omap2;
        }
        return makeOrderedMap(newMap, newList);
      }
      createClass(ToKeyedSequence, KeyedSeq);
      function ToKeyedSequence(indexed, useKeys) {
        this._iter = indexed;
        this._useKeys = useKeys;
        this.size = indexed.size;
      }
      ToKeyedSequence.prototype.get = function(key57, notSetValue) {
        return this._iter.get(key57, notSetValue);
      };
      ToKeyedSequence.prototype.has = function(key57) {
        return this._iter.has(key57);
      };
      ToKeyedSequence.prototype.valueSeq = function() {
        return this._iter.valueSeq();
      };
      ToKeyedSequence.prototype.reverse = function() {
        var this$0 = this;
        var reversedSequence = reverseFactory(this, true);
        if (!this._useKeys) {
          reversedSequence.valueSeq = function() {
            return this$0._iter.toSeq().reverse();
          };
        }
        return reversedSequence;
      };
      ToKeyedSequence.prototype.map = function(mapper, context2) {
        var this$0 = this;
        var mappedSequence = mapFactory(this, mapper, context2);
        if (!this._useKeys) {
          mappedSequence.valueSeq = function() {
            return this$0._iter.toSeq().map(mapper, context2);
          };
        }
        return mappedSequence;
      };
      ToKeyedSequence.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        var ii;
        return this._iter.__iterate(
          this._useKeys ? function(v2, k) {
            return fn2(v2, k, this$0);
          } : (ii = reverse3 ? resolveSize(this) : 0, function(v2) {
            return fn2(v2, reverse3 ? --ii : ii++, this$0);
          }),
          reverse3
        );
      };
      ToKeyedSequence.prototype.__iterator = function(type5, reverse3) {
        if (this._useKeys) {
          return this._iter.__iterator(type5, reverse3);
        }
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        var ii = reverse3 ? resolveSize(this) : 0;
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type5, reverse3 ? --ii : ii++, step.value, step);
        });
      };
      ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
      createClass(ToIndexedSequence, IndexedSeq);
      function ToIndexedSequence(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      ToIndexedSequence.prototype.includes = function(value) {
        return this._iter.includes(value);
      };
      ToIndexedSequence.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        var iterations = 0;
        return this._iter.__iterate(function(v2) {
          return fn2(v2, iterations++, this$0);
        }, reverse3);
      };
      ToIndexedSequence.prototype.__iterator = function(type5, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        var iterations = 0;
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type5, iterations++, step.value, step);
        });
      };
      createClass(ToSetSequence, SetSeq);
      function ToSetSequence(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      ToSetSequence.prototype.has = function(key57) {
        return this._iter.includes(key57);
      };
      ToSetSequence.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return this._iter.__iterate(function(v2) {
          return fn2(v2, v2, this$0);
        }, reverse3);
      };
      ToSetSequence.prototype.__iterator = function(type5, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type5, step.value, step.value, step);
        });
      };
      createClass(FromEntriesSequence, KeyedSeq);
      function FromEntriesSequence(entries2) {
        this._iter = entries2;
        this.size = entries2.size;
      }
      FromEntriesSequence.prototype.entrySeq = function() {
        return this._iter.toSeq();
      };
      FromEntriesSequence.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return this._iter.__iterate(function(entry) {
          if (entry) {
            validateEntry(entry);
            var indexedIterable = isIterable2(entry);
            return fn2(
              indexedIterable ? entry.get(1) : entry[1],
              indexedIterable ? entry.get(0) : entry[0],
              this$0
            );
          }
        }, reverse3);
      };
      FromEntriesSequence.prototype.__iterator = function(type5, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        return new Iterator(function() {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            if (entry) {
              validateEntry(entry);
              var indexedIterable = isIterable2(entry);
              return iteratorValue(
                type5,
                indexedIterable ? entry.get(0) : entry[0],
                indexedIterable ? entry.get(1) : entry[1],
                step
              );
            }
          }
        });
      };
      ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
      function flipFactory(iterable) {
        var flipSequence = makeSequence(iterable);
        flipSequence._iter = iterable;
        flipSequence.size = iterable.size;
        flipSequence.flip = function() {
          return iterable;
        };
        flipSequence.reverse = function() {
          var reversedSequence = iterable.reverse.apply(this);
          reversedSequence.flip = function() {
            return iterable.reverse();
          };
          return reversedSequence;
        };
        flipSequence.has = function(key57) {
          return iterable.includes(key57);
        };
        flipSequence.includes = function(key57) {
          return iterable.has(key57);
        };
        flipSequence.cacheResult = cacheResultThrough;
        flipSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          return iterable.__iterate(function(v2, k) {
            return fn2(k, v2, this$0) !== false;
          }, reverse3);
        };
        flipSequence.__iteratorUncached = function(type5, reverse3) {
          if (type5 === ITERATE_ENTRIES) {
            var iterator = iterable.__iterator(type5, reverse3);
            return new Iterator(function() {
              var step = iterator.next();
              if (!step.done) {
                var k = step.value[0];
                step.value[0] = step.value[1];
                step.value[1] = k;
              }
              return step;
            });
          }
          return iterable.__iterator(
            type5 === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
            reverse3
          );
        };
        return flipSequence;
      }
      function mapFactory(iterable, mapper, context2) {
        var mappedSequence = makeSequence(iterable);
        mappedSequence.size = iterable.size;
        mappedSequence.has = function(key57) {
          return iterable.has(key57);
        };
        mappedSequence.get = function(key57, notSetValue) {
          var v2 = iterable.get(key57, NOT_SET2);
          return v2 === NOT_SET2 ? notSetValue : mapper.call(context2, v2, key57, iterable);
        };
        mappedSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          return iterable.__iterate(
            function(v2, k, c2) {
              return fn2(mapper.call(context2, v2, k, c2), k, this$0) !== false;
            },
            reverse3
          );
        };
        mappedSequence.__iteratorUncached = function(type5, reverse3) {
          var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse3);
          return new Iterator(function() {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var key57 = entry[0];
            return iteratorValue(
              type5,
              key57,
              mapper.call(context2, entry[1], key57, iterable),
              step
            );
          });
        };
        return mappedSequence;
      }
      function reverseFactory(iterable, useKeys) {
        var reversedSequence = makeSequence(iterable);
        reversedSequence._iter = iterable;
        reversedSequence.size = iterable.size;
        reversedSequence.reverse = function() {
          return iterable;
        };
        if (iterable.flip) {
          reversedSequence.flip = function() {
            var flipSequence = flipFactory(iterable);
            flipSequence.reverse = function() {
              return iterable.flip();
            };
            return flipSequence;
          };
        }
        reversedSequence.get = function(key57, notSetValue) {
          return iterable.get(useKeys ? key57 : -1 - key57, notSetValue);
        };
        reversedSequence.has = function(key57) {
          return iterable.has(useKeys ? key57 : -1 - key57);
        };
        reversedSequence.includes = function(value) {
          return iterable.includes(value);
        };
        reversedSequence.cacheResult = cacheResultThrough;
        reversedSequence.__iterate = function(fn2, reverse3) {
          var this$0 = this;
          return iterable.__iterate(function(v2, k) {
            return fn2(v2, k, this$0);
          }, !reverse3);
        };
        reversedSequence.__iterator = function(type5, reverse3) {
          return iterable.__iterator(type5, !reverse3);
        };
        return reversedSequence;
      }
      function filterFactory(iterable, predicate, context2, useKeys) {
        var filterSequence = makeSequence(iterable);
        if (useKeys) {
          filterSequence.has = function(key57) {
            var v2 = iterable.get(key57, NOT_SET2);
            return v2 !== NOT_SET2 && !!predicate.call(context2, v2, key57, iterable);
          };
          filterSequence.get = function(key57, notSetValue) {
            var v2 = iterable.get(key57, NOT_SET2);
            return v2 !== NOT_SET2 && predicate.call(context2, v2, key57, iterable) ? v2 : notSetValue;
          };
        }
        filterSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          var iterations = 0;
          iterable.__iterate(function(v2, k, c2) {
            if (predicate.call(context2, v2, k, c2)) {
              iterations++;
              return fn2(v2, useKeys ? k : iterations - 1, this$0);
            }
          }, reverse3);
          return iterations;
        };
        filterSequence.__iteratorUncached = function(type5, reverse3) {
          var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse3);
          var iterations = 0;
          return new Iterator(function() {
            while (true) {
              var step = iterator.next();
              if (step.done) {
                return step;
              }
              var entry = step.value;
              var key57 = entry[0];
              var value = entry[1];
              if (predicate.call(context2, value, key57, iterable)) {
                return iteratorValue(type5, useKeys ? key57 : iterations++, value, step);
              }
            }
          });
        };
        return filterSequence;
      }
      function countByFactory(iterable, grouper, context2) {
        var groups = Map3().asMutable();
        iterable.__iterate(function(v2, k) {
          groups.update(
            grouper.call(context2, v2, k, iterable),
            0,
            function(a2) {
              return a2 + 1;
            }
          );
        });
        return groups.asImmutable();
      }
      function groupByFactory(iterable, grouper, context2) {
        var isKeyedIter = isKeyed(iterable);
        var groups = (isOrdered(iterable) ? OrderedMap2() : Map3()).asMutable();
        iterable.__iterate(function(v2, k) {
          groups.update(
            grouper.call(context2, v2, k, iterable),
            function(a2) {
              return a2 = a2 || [], a2.push(isKeyedIter ? [k, v2] : v2), a2;
            }
          );
        });
        var coerce = iterableClass(iterable);
        return groups.map(function(arr) {
          return reify(iterable, coerce(arr));
        });
      }
      function sliceFactory(iterable, begin, end, useKeys) {
        var originalSize = iterable.size;
        if (begin !== void 0) {
          begin = begin | 0;
        }
        if (end !== void 0) {
          if (end === Infinity) {
            end = originalSize;
          } else {
            end = end | 0;
          }
        }
        if (wholeSlice(begin, end, originalSize)) {
          return iterable;
        }
        var resolvedBegin = resolveBegin(begin, originalSize);
        var resolvedEnd = resolveEnd(end, originalSize);
        if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
          return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
        }
        var resolvedSize = resolvedEnd - resolvedBegin;
        var sliceSize;
        if (resolvedSize === resolvedSize) {
          sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
        }
        var sliceSeq = makeSequence(iterable);
        sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || void 0;
        if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
          sliceSeq.get = function(index, notSetValue) {
            index = wrapIndex(this, index);
            return index >= 0 && index < sliceSize ? iterable.get(index + resolvedBegin, notSetValue) : notSetValue;
          };
        }
        sliceSeq.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          if (sliceSize === 0) {
            return 0;
          }
          if (reverse3) {
            return this.cacheResult().__iterate(fn2, reverse3);
          }
          var skipped = 0;
          var isSkipping = true;
          var iterations = 0;
          iterable.__iterate(function(v2, k) {
            if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
              iterations++;
              return fn2(v2, useKeys ? k : iterations - 1, this$0) !== false && iterations !== sliceSize;
            }
          });
          return iterations;
        };
        sliceSeq.__iteratorUncached = function(type5, reverse3) {
          if (sliceSize !== 0 && reverse3) {
            return this.cacheResult().__iterator(type5, reverse3);
          }
          var iterator = sliceSize !== 0 && iterable.__iterator(type5, reverse3);
          var skipped = 0;
          var iterations = 0;
          return new Iterator(function() {
            while (skipped++ < resolvedBegin) {
              iterator.next();
            }
            if (++iterations > sliceSize) {
              return iteratorDone();
            }
            var step = iterator.next();
            if (useKeys || type5 === ITERATE_VALUES) {
              return step;
            } else if (type5 === ITERATE_KEYS) {
              return iteratorValue(type5, iterations - 1, void 0, step);
            } else {
              return iteratorValue(type5, iterations - 1, step.value[1], step);
            }
          });
        };
        return sliceSeq;
      }
      function takeWhileFactory(iterable, predicate, context2) {
        var takeSequence = makeSequence(iterable);
        takeSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          if (reverse3) {
            return this.cacheResult().__iterate(fn2, reverse3);
          }
          var iterations = 0;
          iterable.__iterate(
            function(v2, k, c2) {
              return predicate.call(context2, v2, k, c2) && ++iterations && fn2(v2, k, this$0);
            }
          );
          return iterations;
        };
        takeSequence.__iteratorUncached = function(type5, reverse3) {
          var this$0 = this;
          if (reverse3) {
            return this.cacheResult().__iterator(type5, reverse3);
          }
          var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse3);
          var iterating = true;
          return new Iterator(function() {
            if (!iterating) {
              return iteratorDone();
            }
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            var k = entry[0];
            var v2 = entry[1];
            if (!predicate.call(context2, v2, k, this$0)) {
              iterating = false;
              return iteratorDone();
            }
            return type5 === ITERATE_ENTRIES ? step : iteratorValue(type5, k, v2, step);
          });
        };
        return takeSequence;
      }
      function skipWhileFactory(iterable, predicate, context2, useKeys) {
        var skipSequence = makeSequence(iterable);
        skipSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          if (reverse3) {
            return this.cacheResult().__iterate(fn2, reverse3);
          }
          var isSkipping = true;
          var iterations = 0;
          iterable.__iterate(function(v2, k, c2) {
            if (!(isSkipping && (isSkipping = predicate.call(context2, v2, k, c2)))) {
              iterations++;
              return fn2(v2, useKeys ? k : iterations - 1, this$0);
            }
          });
          return iterations;
        };
        skipSequence.__iteratorUncached = function(type5, reverse3) {
          var this$0 = this;
          if (reverse3) {
            return this.cacheResult().__iterator(type5, reverse3);
          }
          var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse3);
          var skipping = true;
          var iterations = 0;
          return new Iterator(function() {
            var step, k, v2;
            do {
              step = iterator.next();
              if (step.done) {
                if (useKeys || type5 === ITERATE_VALUES) {
                  return step;
                } else if (type5 === ITERATE_KEYS) {
                  return iteratorValue(type5, iterations++, void 0, step);
                } else {
                  return iteratorValue(type5, iterations++, step.value[1], step);
                }
              }
              var entry = step.value;
              k = entry[0];
              v2 = entry[1];
              skipping && (skipping = predicate.call(context2, v2, k, this$0));
            } while (skipping);
            return type5 === ITERATE_ENTRIES ? step : iteratorValue(type5, k, v2, step);
          });
        };
        return skipSequence;
      }
      function concatFactory(iterable, values3) {
        var isKeyedIterable = isKeyed(iterable);
        var iters = [iterable].concat(values3).map(function(v2) {
          if (!isIterable2(v2)) {
            v2 = isKeyedIterable ? keyedSeqFromValue(v2) : indexedSeqFromValue(Array.isArray(v2) ? v2 : [v2]);
          } else if (isKeyedIterable) {
            v2 = KeyedIterable(v2);
          }
          return v2;
        }).filter(function(v2) {
          return v2.size !== 0;
        });
        if (iters.length === 0) {
          return iterable;
        }
        if (iters.length === 1) {
          var singleton = iters[0];
          if (singleton === iterable || isKeyedIterable && isKeyed(singleton) || isIndexed2(iterable) && isIndexed2(singleton)) {
            return singleton;
          }
        }
        var concatSeq = new ArraySeq(iters);
        if (isKeyedIterable) {
          concatSeq = concatSeq.toKeyedSeq();
        } else if (!isIndexed2(iterable)) {
          concatSeq = concatSeq.toSetSeq();
        }
        concatSeq = concatSeq.flatten(true);
        concatSeq.size = iters.reduce(
          function(sum2, seq3) {
            if (sum2 !== void 0) {
              var size = seq3.size;
              if (size !== void 0) {
                return sum2 + size;
              }
            }
          },
          0
        );
        return concatSeq;
      }
      function flattenFactory(iterable, depth, useKeys) {
        var flatSequence = makeSequence(iterable);
        flatSequence.__iterateUncached = function(fn2, reverse3) {
          var iterations = 0;
          var stopped = false;
          function flatDeep(iter, currentDepth) {
            var this$0 = this;
            iter.__iterate(function(v2, k) {
              if ((!depth || currentDepth < depth) && isIterable2(v2)) {
                flatDeep(v2, currentDepth + 1);
              } else if (fn2(v2, useKeys ? k : iterations++, this$0) === false) {
                stopped = true;
              }
              return !stopped;
            }, reverse3);
          }
          flatDeep(iterable, 0);
          return iterations;
        };
        flatSequence.__iteratorUncached = function(type5, reverse3) {
          var iterator = iterable.__iterator(type5, reverse3);
          var stack = [];
          var iterations = 0;
          return new Iterator(function() {
            while (iterator) {
              var step = iterator.next();
              if (step.done !== false) {
                iterator = stack.pop();
                continue;
              }
              var v2 = step.value;
              if (type5 === ITERATE_ENTRIES) {
                v2 = v2[1];
              }
              if ((!depth || stack.length < depth) && isIterable2(v2)) {
                stack.push(iterator);
                iterator = v2.__iterator(type5, reverse3);
              } else {
                return useKeys ? step : iteratorValue(type5, iterations++, v2, step);
              }
            }
            return iteratorDone();
          });
        };
        return flatSequence;
      }
      function flatMapFactory(iterable, mapper, context2) {
        var coerce = iterableClass(iterable);
        return iterable.toSeq().map(
          function(v2, k) {
            return coerce(mapper.call(context2, v2, k, iterable));
          }
        ).flatten(true);
      }
      function interposeFactory(iterable, separator) {
        var interposedSequence = makeSequence(iterable);
        interposedSequence.size = iterable.size && iterable.size * 2 - 1;
        interposedSequence.__iterateUncached = function(fn2, reverse3) {
          var this$0 = this;
          var iterations = 0;
          iterable.__iterate(
            function(v2, k) {
              return (!iterations || fn2(separator, iterations++, this$0) !== false) && fn2(v2, iterations++, this$0) !== false;
            },
            reverse3
          );
          return iterations;
        };
        interposedSequence.__iteratorUncached = function(type5, reverse3) {
          var iterator = iterable.__iterator(ITERATE_VALUES, reverse3);
          var iterations = 0;
          var step;
          return new Iterator(function() {
            if (!step || iterations % 2) {
              step = iterator.next();
              if (step.done) {
                return step;
              }
            }
            return iterations % 2 ? iteratorValue(type5, iterations++, separator) : iteratorValue(type5, iterations++, step.value, step);
          });
        };
        return interposedSequence;
      }
      function sortFactory(iterable, comparator3, mapper) {
        if (!comparator3) {
          comparator3 = defaultComparator;
        }
        var isKeyedIterable = isKeyed(iterable);
        var index = 0;
        var entries2 = iterable.toSeq().map(
          function(v2, k) {
            return [k, v2, index++, mapper ? mapper(v2, k, iterable) : v2];
          }
        ).toArray();
        entries2.sort(function(a2, b) {
          return comparator3(a2[3], b[3]) || a2[2] - b[2];
        }).forEach(
          isKeyedIterable ? function(v2, i2) {
            entries2[i2].length = 2;
          } : function(v2, i2) {
            entries2[i2] = v2[1];
          }
        );
        return isKeyedIterable ? KeyedSeq(entries2) : isIndexed2(iterable) ? IndexedSeq(entries2) : SetSeq(entries2);
      }
      function maxFactory(iterable, comparator3, mapper) {
        if (!comparator3) {
          comparator3 = defaultComparator;
        }
        if (mapper) {
          var entry = iterable.toSeq().map(function(v2, k) {
            return [v2, mapper(v2, k, iterable)];
          }).reduce(function(a2, b) {
            return maxCompare(comparator3, a2[1], b[1]) ? b : a2;
          });
          return entry && entry[0];
        } else {
          return iterable.reduce(function(a2, b) {
            return maxCompare(comparator3, a2, b) ? b : a2;
          });
        }
      }
      function maxCompare(comparator3, a2, b) {
        var comp = comparator3(b, a2);
        return comp === 0 && b !== a2 && (b === void 0 || b === null || b !== b) || comp > 0;
      }
      function zipWithFactory(keyIter, zipper, iters) {
        var zipSequence = makeSequence(keyIter);
        zipSequence.size = new ArraySeq(iters).map(function(i2) {
          return i2.size;
        }).min();
        zipSequence.__iterate = function(fn2, reverse3) {
          var iterator = this.__iterator(ITERATE_VALUES, reverse3);
          var step;
          var iterations = 0;
          while (!(step = iterator.next()).done) {
            if (fn2(step.value, iterations++, this) === false) {
              break;
            }
          }
          return iterations;
        };
        zipSequence.__iteratorUncached = function(type5, reverse3) {
          var iterators = iters.map(
            function(i2) {
              return i2 = Iterable(i2), getIterator(reverse3 ? i2.reverse() : i2);
            }
          );
          var iterations = 0;
          var isDone = false;
          return new Iterator(function() {
            var steps;
            if (!isDone) {
              steps = iterators.map(function(i2) {
                return i2.next();
              });
              isDone = steps.some(function(s2) {
                return s2.done;
              });
            }
            if (isDone) {
              return iteratorDone();
            }
            return iteratorValue(
              type5,
              iterations++,
              zipper.apply(null, steps.map(function(s2) {
                return s2.value;
              }))
            );
          });
        };
        return zipSequence;
      }
      function reify(iter, seq3) {
        return isSeq(iter) ? seq3 : iter.constructor(seq3);
      }
      function validateEntry(entry) {
        if (entry !== Object(entry)) {
          throw new TypeError("Expected [K, V] tuple: " + entry);
        }
      }
      function resolveSize(iter) {
        assertNotInfinite(iter.size);
        return ensureSize(iter);
      }
      function iterableClass(iterable) {
        return isKeyed(iterable) ? KeyedIterable : isIndexed2(iterable) ? IndexedIterable : SetIterable;
      }
      function makeSequence(iterable) {
        return Object.create(
          (isKeyed(iterable) ? KeyedSeq : isIndexed2(iterable) ? IndexedSeq : SetSeq).prototype
        );
      }
      function cacheResultThrough() {
        if (this._iter.cacheResult) {
          this._iter.cacheResult();
          this.size = this._iter.size;
          return this;
        } else {
          return Seq2.prototype.cacheResult.call(this);
        }
      }
      function defaultComparator(a2, b) {
        return a2 > b ? 1 : a2 < b ? -1 : 0;
      }
      function forceIterator(keyPath) {
        var iter = getIterator(keyPath);
        if (!iter) {
          if (!isArrayLike3(keyPath)) {
            throw new TypeError("Expected iterable or array-like: " + keyPath);
          }
          iter = getIterator(Iterable(keyPath));
        }
        return iter;
      }
      createClass(Record, KeyedCollection);
      function Record(defaultValues, name2) {
        var hasInitialized;
        var RecordType = function Record2(values3) {
          if (values3 instanceof RecordType) {
            return values3;
          }
          if (!(this instanceof RecordType)) {
            return new RecordType(values3);
          }
          if (!hasInitialized) {
            hasInitialized = true;
            var keys4 = Object.keys(defaultValues);
            setProps(RecordTypePrototype, keys4);
            RecordTypePrototype.size = keys4.length;
            RecordTypePrototype._name = name2;
            RecordTypePrototype._keys = keys4;
            RecordTypePrototype._defaultValues = defaultValues;
          }
          this._map = Map3(values3);
        };
        var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
        RecordTypePrototype.constructor = RecordType;
        return RecordType;
      }
      Record.prototype.toString = function() {
        return this.__toString(recordName(this) + " {", "}");
      };
      Record.prototype.has = function(k) {
        return this._defaultValues.hasOwnProperty(k);
      };
      Record.prototype.get = function(k, notSetValue) {
        if (!this.has(k)) {
          return notSetValue;
        }
        var defaultVal = this._defaultValues[k];
        return this._map ? this._map.get(k, defaultVal) : defaultVal;
      };
      Record.prototype.clear = function() {
        if (this.__ownerID) {
          this._map && this._map.clear();
          return this;
        }
        var RecordType = this.constructor;
        return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
      };
      Record.prototype.set = function(k, v2) {
        if (!this.has(k)) {
          throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
        }
        if (this._map && !this._map.has(k)) {
          var defaultVal = this._defaultValues[k];
          if (v2 === defaultVal) {
            return this;
          }
        }
        var newMap = this._map && this._map.set(k, v2);
        if (this.__ownerID || newMap === this._map) {
          return this;
        }
        return makeRecord(this, newMap);
      };
      Record.prototype.remove = function(k) {
        if (!this.has(k)) {
          return this;
        }
        var newMap = this._map && this._map.remove(k);
        if (this.__ownerID || newMap === this._map) {
          return this;
        }
        return makeRecord(this, newMap);
      };
      Record.prototype.wasAltered = function() {
        return this._map.wasAltered();
      };
      Record.prototype.__iterator = function(type5, reverse3) {
        var this$0 = this;
        return KeyedIterable(this._defaultValues).map(function(_2, k) {
          return this$0.get(k);
        }).__iterator(type5, reverse3);
      };
      Record.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return KeyedIterable(this._defaultValues).map(function(_2, k) {
          return this$0.get(k);
        }).__iterate(fn2, reverse3);
      };
      Record.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map && this._map.__ensureOwner(ownerID);
        if (!ownerID) {
          this.__ownerID = ownerID;
          this._map = newMap;
          return this;
        }
        return makeRecord(this, newMap, ownerID);
      };
      var RecordPrototype = Record.prototype;
      RecordPrototype[DELETE] = RecordPrototype.remove;
      RecordPrototype.deleteIn = RecordPrototype.removeIn = MapPrototype.removeIn;
      RecordPrototype.merge = MapPrototype.merge;
      RecordPrototype.mergeWith = MapPrototype.mergeWith;
      RecordPrototype.mergeIn = MapPrototype.mergeIn;
      RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
      RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
      RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
      RecordPrototype.setIn = MapPrototype.setIn;
      RecordPrototype.update = MapPrototype.update;
      RecordPrototype.updateIn = MapPrototype.updateIn;
      RecordPrototype.withMutations = MapPrototype.withMutations;
      RecordPrototype.asMutable = MapPrototype.asMutable;
      RecordPrototype.asImmutable = MapPrototype.asImmutable;
      function makeRecord(likeRecord, map5, ownerID) {
        var record = Object.create(Object.getPrototypeOf(likeRecord));
        record._map = map5;
        record.__ownerID = ownerID;
        return record;
      }
      function recordName(record) {
        return record._name || record.constructor.name || "Record";
      }
      function setProps(prototype, names) {
        try {
          names.forEach(setProp.bind(void 0, prototype));
        } catch (error) {
        }
      }
      function setProp(prototype, name2) {
        Object.defineProperty(prototype, name2, {
          get: function() {
            return this.get(name2);
          },
          set: function(value) {
            invariant2(this.__ownerID, "Cannot set on an immutable record.");
            this.set(name2, value);
          }
        });
      }
      createClass(Set3, SetCollection);
      function Set3(value) {
        return value === null || value === void 0 ? emptySet() : isSet2(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set4) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v2) {
            return set4.add(v2);
          });
        });
      }
      Set3.of = function() {
        return this(arguments);
      };
      Set3.fromKeys = function(value) {
        return this(KeyedIterable(value).keySeq());
      };
      Set3.prototype.toString = function() {
        return this.__toString("Set {", "}");
      };
      Set3.prototype.has = function(value) {
        return this._map.has(value);
      };
      Set3.prototype.add = function(value) {
        return updateSet(this, this._map.set(value, true));
      };
      Set3.prototype.remove = function(value) {
        return updateSet(this, this._map.remove(value));
      };
      Set3.prototype.clear = function() {
        return updateSet(this, this._map.clear());
      };
      Set3.prototype.union = function() {
        var iters = SLICE$0.call(arguments, 0);
        iters = iters.filter(function(x2) {
          return x2.size !== 0;
        });
        if (iters.length === 0) {
          return this;
        }
        if (this.size === 0 && !this.__ownerID && iters.length === 1) {
          return this.constructor(iters[0]);
        }
        return this.withMutations(function(set4) {
          for (var ii = 0; ii < iters.length; ii++) {
            SetIterable(iters[ii]).forEach(function(value) {
              return set4.add(value);
            });
          }
        });
      };
      Set3.prototype.intersect = function() {
        var iters = SLICE$0.call(arguments, 0);
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetIterable(iter);
        });
        var originalSet = this;
        return this.withMutations(function(set4) {
          originalSet.forEach(function(value) {
            if (!iters.every(function(iter) {
              return iter.includes(value);
            })) {
              set4.remove(value);
            }
          });
        });
      };
      Set3.prototype.subtract = function() {
        var iters = SLICE$0.call(arguments, 0);
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetIterable(iter);
        });
        var originalSet = this;
        return this.withMutations(function(set4) {
          originalSet.forEach(function(value) {
            if (iters.some(function(iter) {
              return iter.includes(value);
            })) {
              set4.remove(value);
            }
          });
        });
      };
      Set3.prototype.merge = function() {
        return this.union.apply(this, arguments);
      };
      Set3.prototype.mergeWith = function(merger) {
        var iters = SLICE$0.call(arguments, 1);
        return this.union.apply(this, iters);
      };
      Set3.prototype.sort = function(comparator3) {
        return OrderedSet(sortFactory(this, comparator3));
      };
      Set3.prototype.sortBy = function(mapper, comparator3) {
        return OrderedSet(sortFactory(this, comparator3, mapper));
      };
      Set3.prototype.wasAltered = function() {
        return this._map.wasAltered();
      };
      Set3.prototype.__iterate = function(fn2, reverse3) {
        var this$0 = this;
        return this._map.__iterate(function(_2, k) {
          return fn2(k, k, this$0);
        }, reverse3);
      };
      Set3.prototype.__iterator = function(type5, reverse3) {
        return this._map.map(function(_2, k) {
          return k;
        }).__iterator(type5, reverse3);
      };
      Set3.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        if (!ownerID) {
          this.__ownerID = ownerID;
          this._map = newMap;
          return this;
        }
        return this.__make(newMap, ownerID);
      };
      function isSet2(maybeSet) {
        return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
      }
      Set3.isSet = isSet2;
      var IS_SET_SENTINEL = "@@__IMMUTABLE_SET__@@";
      var SetPrototype = Set3.prototype;
      SetPrototype[IS_SET_SENTINEL] = true;
      SetPrototype[DELETE] = SetPrototype.remove;
      SetPrototype.mergeDeep = SetPrototype.merge;
      SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
      SetPrototype.withMutations = MapPrototype.withMutations;
      SetPrototype.asMutable = MapPrototype.asMutable;
      SetPrototype.asImmutable = MapPrototype.asImmutable;
      SetPrototype.__empty = emptySet;
      SetPrototype.__make = makeSet;
      function updateSet(set4, newMap) {
        if (set4.__ownerID) {
          set4.size = newMap.size;
          set4._map = newMap;
          return set4;
        }
        return newMap === set4._map ? set4 : newMap.size === 0 ? set4.__empty() : set4.__make(newMap);
      }
      function makeSet(map5, ownerID) {
        var set4 = Object.create(SetPrototype);
        set4.size = map5 ? map5.size : 0;
        set4._map = map5;
        set4.__ownerID = ownerID;
        return set4;
      }
      var EMPTY_SET;
      function emptySet() {
        return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
      }
      createClass(OrderedSet, Set3);
      function OrderedSet(value) {
        return value === null || value === void 0 ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set4) {
          var iter = SetIterable(value);
          assertNotInfinite(iter.size);
          iter.forEach(function(v2) {
            return set4.add(v2);
          });
        });
      }
      OrderedSet.of = function() {
        return this(arguments);
      };
      OrderedSet.fromKeys = function(value) {
        return this(KeyedIterable(value).keySeq());
      };
      OrderedSet.prototype.toString = function() {
        return this.__toString("OrderedSet {", "}");
      };
      function isOrderedSet(maybeOrderedSet) {
        return isSet2(maybeOrderedSet) && isOrdered(maybeOrderedSet);
      }
      OrderedSet.isOrderedSet = isOrderedSet;
      var OrderedSetPrototype = OrderedSet.prototype;
      OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
      OrderedSetPrototype.__empty = emptyOrderedSet;
      OrderedSetPrototype.__make = makeOrderedSet;
      function makeOrderedSet(map5, ownerID) {
        var set4 = Object.create(OrderedSetPrototype);
        set4.size = map5 ? map5.size : 0;
        set4._map = map5;
        set4.__ownerID = ownerID;
        return set4;
      }
      var EMPTY_ORDERED_SET;
      function emptyOrderedSet() {
        return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
      }
      createClass(Stack, IndexedCollection);
      function Stack(value) {
        return value === null || value === void 0 ? emptyStack() : isStack(value) ? value : emptyStack().unshiftAll(value);
      }
      Stack.of = function() {
        return this(arguments);
      };
      Stack.prototype.toString = function() {
        return this.__toString("Stack [", "]");
      };
      Stack.prototype.get = function(index, notSetValue) {
        var head2 = this._head;
        index = wrapIndex(this, index);
        while (head2 && index--) {
          head2 = head2.next;
        }
        return head2 ? head2.value : notSetValue;
      };
      Stack.prototype.peek = function() {
        return this._head && this._head.value;
      };
      Stack.prototype.push = function() {
        if (arguments.length === 0) {
          return this;
        }
        var newSize = this.size + arguments.length;
        var head2 = this._head;
        for (var ii = arguments.length - 1; ii >= 0; ii--) {
          head2 = {
            value: arguments[ii],
            next: head2
          };
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head2;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head2);
      };
      Stack.prototype.pushAll = function(iter) {
        iter = IndexedIterable(iter);
        if (iter.size === 0) {
          return this;
        }
        assertNotInfinite(iter.size);
        var newSize = this.size;
        var head2 = this._head;
        iter.reverse().forEach(function(value) {
          newSize++;
          head2 = {
            value,
            next: head2
          };
        });
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head2;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head2);
      };
      Stack.prototype.pop = function() {
        return this.slice(1);
      };
      Stack.prototype.unshift = function() {
        return this.push.apply(this, arguments);
      };
      Stack.prototype.unshiftAll = function(iter) {
        return this.pushAll(iter);
      };
      Stack.prototype.shift = function() {
        return this.pop.apply(this, arguments);
      };
      Stack.prototype.clear = function() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._head = void 0;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyStack();
      };
      Stack.prototype.slice = function(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        var resolvedBegin = resolveBegin(begin, this.size);
        var resolvedEnd = resolveEnd(end, this.size);
        if (resolvedEnd !== this.size) {
          return IndexedCollection.prototype.slice.call(this, begin, end);
        }
        var newSize = this.size - resolvedBegin;
        var head2 = this._head;
        while (resolvedBegin--) {
          head2 = head2.next;
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head2;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head2);
      };
      Stack.prototype.__ensureOwner = function(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeStack(this.size, this._head, ownerID, this.__hash);
      };
      Stack.prototype.__iterate = function(fn2, reverse3) {
        if (reverse3) {
          return this.reverse().__iterate(fn2);
        }
        var iterations = 0;
        var node = this._head;
        while (node) {
          if (fn2(node.value, iterations++, this) === false) {
            break;
          }
          node = node.next;
        }
        return iterations;
      };
      Stack.prototype.__iterator = function(type5, reverse3) {
        if (reverse3) {
          return this.reverse().__iterator(type5);
        }
        var iterations = 0;
        var node = this._head;
        return new Iterator(function() {
          if (node) {
            var value = node.value;
            node = node.next;
            return iteratorValue(type5, iterations++, value);
          }
          return iteratorDone();
        });
      };
      function isStack(maybeStack) {
        return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
      }
      Stack.isStack = isStack;
      var IS_STACK_SENTINEL = "@@__IMMUTABLE_STACK__@@";
      var StackPrototype = Stack.prototype;
      StackPrototype[IS_STACK_SENTINEL] = true;
      StackPrototype.withMutations = MapPrototype.withMutations;
      StackPrototype.asMutable = MapPrototype.asMutable;
      StackPrototype.asImmutable = MapPrototype.asImmutable;
      StackPrototype.wasAltered = MapPrototype.wasAltered;
      function makeStack(size, head2, ownerID, hash2) {
        var map5 = Object.create(StackPrototype);
        map5.size = size;
        map5._head = head2;
        map5.__ownerID = ownerID;
        map5.__hash = hash2;
        map5.__altered = false;
        return map5;
      }
      var EMPTY_STACK;
      function emptyStack() {
        return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
      }
      function mixin(ctor, methods) {
        var keyCopier = function(key57) {
          ctor.prototype[key57] = methods[key57];
        };
        Object.keys(methods).forEach(keyCopier);
        Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
        return ctor;
      }
      Iterable.Iterator = Iterator;
      mixin(Iterable, {
        // ### Conversion to other types
        toArray: function() {
          assertNotInfinite(this.size);
          var array2 = new Array(this.size || 0);
          this.valueSeq().__iterate(function(v2, i2) {
            array2[i2] = v2;
          });
          return array2;
        },
        toIndexedSeq: function() {
          return new ToIndexedSequence(this);
        },
        toJS: function() {
          return this.toSeq().map(
            function(value) {
              return value && typeof value.toJS === "function" ? value.toJS() : value;
            }
          ).__toJS();
        },
        toJSON: function() {
          return this.toSeq().map(
            function(value) {
              return value && typeof value.toJSON === "function" ? value.toJSON() : value;
            }
          ).__toJS();
        },
        toKeyedSeq: function() {
          return new ToKeyedSequence(this, true);
        },
        toMap: function() {
          return Map3(this.toKeyedSeq());
        },
        toObject: function() {
          assertNotInfinite(this.size);
          var object2 = {};
          this.__iterate(function(v2, k) {
            object2[k] = v2;
          });
          return object2;
        },
        toOrderedMap: function() {
          return OrderedMap2(this.toKeyedSeq());
        },
        toOrderedSet: function() {
          return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
        },
        toSet: function() {
          return Set3(isKeyed(this) ? this.valueSeq() : this);
        },
        toSetSeq: function() {
          return new ToSetSequence(this);
        },
        toSeq: function() {
          return isIndexed2(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
        },
        toStack: function() {
          return Stack(isKeyed(this) ? this.valueSeq() : this);
        },
        toList: function() {
          return List2(isKeyed(this) ? this.valueSeq() : this);
        },
        // ### Common JavaScript methods and properties
        toString: function() {
          return "[Iterable]";
        },
        __toString: function(head2, tail2) {
          if (this.size === 0) {
            return head2 + tail2;
          }
          return head2 + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail2;
        },
        // ### ES6 Collection methods (ES6 Array and Map)
        concat: function() {
          var values3 = SLICE$0.call(arguments, 0);
          return reify(this, concatFactory(this, values3));
        },
        includes: function(searchValue) {
          return this.some(function(value) {
            return is6(value, searchValue);
          });
        },
        entries: function() {
          return this.__iterator(ITERATE_ENTRIES);
        },
        every: function(predicate, context2) {
          assertNotInfinite(this.size);
          var returnValue = true;
          this.__iterate(function(v2, k, c2) {
            if (!predicate.call(context2, v2, k, c2)) {
              returnValue = false;
              return false;
            }
          });
          return returnValue;
        },
        filter: function(predicate, context2) {
          return reify(this, filterFactory(this, predicate, context2, true));
        },
        find: function(predicate, context2, notSetValue) {
          var entry = this.findEntry(predicate, context2);
          return entry ? entry[1] : notSetValue;
        },
        forEach: function(sideEffect, context2) {
          assertNotInfinite(this.size);
          return this.__iterate(context2 ? sideEffect.bind(context2) : sideEffect);
        },
        join: function(separator) {
          assertNotInfinite(this.size);
          separator = separator !== void 0 ? "" + separator : ",";
          var joined = "";
          var isFirst = true;
          this.__iterate(function(v2) {
            isFirst ? isFirst = false : joined += separator;
            joined += v2 !== null && v2 !== void 0 ? v2.toString() : "";
          });
          return joined;
        },
        keys: function() {
          return this.__iterator(ITERATE_KEYS);
        },
        map: function(mapper, context2) {
          return reify(this, mapFactory(this, mapper, context2));
        },
        reduce: function(reducer, initialReduction, context2) {
          assertNotInfinite(this.size);
          var reduction;
          var useFirst;
          if (arguments.length < 2) {
            useFirst = true;
          } else {
            reduction = initialReduction;
          }
          this.__iterate(function(v2, k, c2) {
            if (useFirst) {
              useFirst = false;
              reduction = v2;
            } else {
              reduction = reducer.call(context2, reduction, v2, k, c2);
            }
          });
          return reduction;
        },
        reduceRight: function(reducer, initialReduction, context2) {
          var reversed = this.toKeyedSeq().reverse();
          return reversed.reduce.apply(reversed, arguments);
        },
        reverse: function() {
          return reify(this, reverseFactory(this, true));
        },
        slice: function(begin, end) {
          return reify(this, sliceFactory(this, begin, end, true));
        },
        some: function(predicate, context2) {
          return !this.every(not3(predicate), context2);
        },
        sort: function(comparator3) {
          return reify(this, sortFactory(this, comparator3));
        },
        values: function() {
          return this.__iterator(ITERATE_VALUES);
        },
        // ### More sequential methods
        butLast: function() {
          return this.slice(0, -1);
        },
        isEmpty: function() {
          return this.size !== void 0 ? this.size === 0 : !this.some(function() {
            return true;
          });
        },
        count: function(predicate, context2) {
          return ensureSize(
            predicate ? this.toSeq().filter(predicate, context2) : this
          );
        },
        countBy: function(grouper, context2) {
          return countByFactory(this, grouper, context2);
        },
        equals: function(other) {
          return deepEqual(this, other);
        },
        entrySeq: function() {
          var iterable = this;
          if (iterable._cache) {
            return new ArraySeq(iterable._cache);
          }
          var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
          entriesSequence.fromEntrySeq = function() {
            return iterable.toSeq();
          };
          return entriesSequence;
        },
        filterNot: function(predicate, context2) {
          return this.filter(not3(predicate), context2);
        },
        findEntry: function(predicate, context2, notSetValue) {
          var found = notSetValue;
          this.__iterate(function(v2, k, c2) {
            if (predicate.call(context2, v2, k, c2)) {
              found = [k, v2];
              return false;
            }
          });
          return found;
        },
        findKey: function(predicate, context2) {
          var entry = this.findEntry(predicate, context2);
          return entry && entry[0];
        },
        findLast: function(predicate, context2, notSetValue) {
          return this.toKeyedSeq().reverse().find(predicate, context2, notSetValue);
        },
        findLastEntry: function(predicate, context2, notSetValue) {
          return this.toKeyedSeq().reverse().findEntry(predicate, context2, notSetValue);
        },
        findLastKey: function(predicate, context2) {
          return this.toKeyedSeq().reverse().findKey(predicate, context2);
        },
        first: function() {
          return this.find(returnTrue);
        },
        flatMap: function(mapper, context2) {
          return reify(this, flatMapFactory(this, mapper, context2));
        },
        flatten: function(depth) {
          return reify(this, flattenFactory(this, depth, true));
        },
        fromEntrySeq: function() {
          return new FromEntriesSequence(this);
        },
        get: function(searchKey, notSetValue) {
          return this.find(function(_2, key57) {
            return is6(key57, searchKey);
          }, void 0, notSetValue);
        },
        getIn: function(searchKeyPath, notSetValue) {
          var nested = this;
          var iter = forceIterator(searchKeyPath);
          var step;
          while (!(step = iter.next()).done) {
            var key57 = step.value;
            nested = nested && nested.get ? nested.get(key57, NOT_SET2) : NOT_SET2;
            if (nested === NOT_SET2) {
              return notSetValue;
            }
          }
          return nested;
        },
        groupBy: function(grouper, context2) {
          return groupByFactory(this, grouper, context2);
        },
        has: function(searchKey) {
          return this.get(searchKey, NOT_SET2) !== NOT_SET2;
        },
        hasIn: function(searchKeyPath) {
          return this.getIn(searchKeyPath, NOT_SET2) !== NOT_SET2;
        },
        isSubset: function(iter) {
          iter = typeof iter.includes === "function" ? iter : Iterable(iter);
          return this.every(function(value) {
            return iter.includes(value);
          });
        },
        isSuperset: function(iter) {
          iter = typeof iter.isSubset === "function" ? iter : Iterable(iter);
          return iter.isSubset(this);
        },
        keyOf: function(searchValue) {
          return this.findKey(function(value) {
            return is6(value, searchValue);
          });
        },
        keySeq: function() {
          return this.toSeq().map(keyMapper).toIndexedSeq();
        },
        last: function() {
          return this.toSeq().reverse().first();
        },
        lastKeyOf: function(searchValue) {
          return this.toKeyedSeq().reverse().keyOf(searchValue);
        },
        max: function(comparator3) {
          return maxFactory(this, comparator3);
        },
        maxBy: function(mapper, comparator3) {
          return maxFactory(this, comparator3, mapper);
        },
        min: function(comparator3) {
          return maxFactory(this, comparator3 ? neg(comparator3) : defaultNegComparator);
        },
        minBy: function(mapper, comparator3) {
          return maxFactory(this, comparator3 ? neg(comparator3) : defaultNegComparator, mapper);
        },
        rest: function() {
          return this.slice(1);
        },
        skip: function(amount) {
          return this.slice(Math.max(0, amount));
        },
        skipLast: function(amount) {
          return reify(this, this.toSeq().reverse().skip(amount).reverse());
        },
        skipWhile: function(predicate, context2) {
          return reify(this, skipWhileFactory(this, predicate, context2, true));
        },
        skipUntil: function(predicate, context2) {
          return this.skipWhile(not3(predicate), context2);
        },
        sortBy: function(mapper, comparator3) {
          return reify(this, sortFactory(this, comparator3, mapper));
        },
        take: function(amount) {
          return this.slice(0, Math.max(0, amount));
        },
        takeLast: function(amount) {
          return reify(this, this.toSeq().reverse().take(amount).reverse());
        },
        takeWhile: function(predicate, context2) {
          return reify(this, takeWhileFactory(this, predicate, context2));
        },
        takeUntil: function(predicate, context2) {
          return this.takeWhile(not3(predicate), context2);
        },
        valueSeq: function() {
          return this.toIndexedSeq();
        },
        // ### Hashable Object
        hashCode: function() {
          return this.__hash || (this.__hash = hashIterable(this));
        }
        // ### Internal
        // abstract __iterate(fn, reverse)
        // abstract __iterator(type, reverse)
      });
      var IterablePrototype = Iterable.prototype;
      IterablePrototype[IS_ITERABLE_SENTINEL] = true;
      IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
      IterablePrototype.__toJS = IterablePrototype.toArray;
      IterablePrototype.__toStringMapper = quoteString;
      IterablePrototype.inspect = IterablePrototype.toSource = function() {
        return this.toString();
      };
      IterablePrototype.chain = IterablePrototype.flatMap;
      IterablePrototype.contains = IterablePrototype.includes;
      mixin(KeyedIterable, {
        // ### More sequential methods
        flip: function() {
          return reify(this, flipFactory(this));
        },
        mapEntries: function(mapper, context2) {
          var this$0 = this;
          var iterations = 0;
          return reify(
            this,
            this.toSeq().map(
              function(v2, k) {
                return mapper.call(context2, [k, v2], iterations++, this$0);
              }
            ).fromEntrySeq()
          );
        },
        mapKeys: function(mapper, context2) {
          var this$0 = this;
          return reify(
            this,
            this.toSeq().flip().map(
              function(k, v2) {
                return mapper.call(context2, k, v2, this$0);
              }
            ).flip()
          );
        }
      });
      var KeyedIterablePrototype = KeyedIterable.prototype;
      KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
      KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
      KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
      KeyedIterablePrototype.__toStringMapper = function(v2, k) {
        return JSON.stringify(k) + ": " + quoteString(v2);
      };
      mixin(IndexedIterable, {
        // ### Conversion to other types
        toKeyedSeq: function() {
          return new ToKeyedSequence(this, false);
        },
        // ### ES6 Collection methods (ES6 Array and Map)
        filter: function(predicate, context2) {
          return reify(this, filterFactory(this, predicate, context2, false));
        },
        findIndex: function(predicate, context2) {
          var entry = this.findEntry(predicate, context2);
          return entry ? entry[0] : -1;
        },
        indexOf: function(searchValue) {
          var key57 = this.keyOf(searchValue);
          return key57 === void 0 ? -1 : key57;
        },
        lastIndexOf: function(searchValue) {
          var key57 = this.lastKeyOf(searchValue);
          return key57 === void 0 ? -1 : key57;
        },
        reverse: function() {
          return reify(this, reverseFactory(this, false));
        },
        slice: function(begin, end) {
          return reify(this, sliceFactory(this, begin, end, false));
        },
        splice: function(index, removeNum) {
          var numArgs = arguments.length;
          removeNum = Math.max(removeNum | 0, 0);
          if (numArgs === 0 || numArgs === 2 && !removeNum) {
            return this;
          }
          index = resolveBegin(index, index < 0 ? this.count() : this.size);
          var spliced = this.slice(0, index);
          return reify(
            this,
            numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
          );
        },
        // ### More collection methods
        findLastIndex: function(predicate, context2) {
          var entry = this.findLastEntry(predicate, context2);
          return entry ? entry[0] : -1;
        },
        first: function() {
          return this.get(0);
        },
        flatten: function(depth) {
          return reify(this, flattenFactory(this, depth, false));
        },
        get: function(index, notSetValue) {
          index = wrapIndex(this, index);
          return index < 0 || (this.size === Infinity || this.size !== void 0 && index > this.size) ? notSetValue : this.find(function(_2, key57) {
            return key57 === index;
          }, void 0, notSetValue);
        },
        has: function(index) {
          index = wrapIndex(this, index);
          return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
        },
        interpose: function(separator) {
          return reify(this, interposeFactory(this, separator));
        },
        interleave: function() {
          var iterables = [this].concat(arrCopy(arguments));
          var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
          var interleaved = zipped.flatten(true);
          if (zipped.size) {
            interleaved.size = zipped.size * iterables.length;
          }
          return reify(this, interleaved);
        },
        keySeq: function() {
          return Range(0, this.size);
        },
        last: function() {
          return this.get(-1);
        },
        skipWhile: function(predicate, context2) {
          return reify(this, skipWhileFactory(this, predicate, context2, false));
        },
        zip: function() {
          var iterables = [this].concat(arrCopy(arguments));
          return reify(this, zipWithFactory(this, defaultZipper, iterables));
        },
        zipWith: function(zipper) {
          var iterables = arrCopy(arguments);
          iterables[0] = this;
          return reify(this, zipWithFactory(this, zipper, iterables));
        }
      });
      IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
      IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
      mixin(SetIterable, {
        // ### ES6 Collection methods (ES6 Array and Map)
        get: function(value, notSetValue) {
          return this.has(value) ? value : notSetValue;
        },
        includes: function(value) {
          return this.has(value);
        },
        // ### More sequential methods
        keySeq: function() {
          return this.valueSeq();
        }
      });
      SetIterable.prototype.has = IterablePrototype.includes;
      SetIterable.prototype.contains = SetIterable.prototype.includes;
      mixin(KeyedSeq, KeyedIterable.prototype);
      mixin(IndexedSeq, IndexedIterable.prototype);
      mixin(SetSeq, SetIterable.prototype);
      mixin(KeyedCollection, KeyedIterable.prototype);
      mixin(IndexedCollection, IndexedIterable.prototype);
      mixin(SetCollection, SetIterable.prototype);
      function keyMapper(v2, k) {
        return k;
      }
      function entryMapper(v2, k) {
        return [k, v2];
      }
      function not3(predicate) {
        return function() {
          return !predicate.apply(this, arguments);
        };
      }
      function neg(predicate) {
        return function() {
          return -predicate.apply(this, arguments);
        };
      }
      function quoteString(value) {
        return typeof value === "string" ? JSON.stringify(value) : String(value);
      }
      function defaultZipper() {
        return arrCopy(arguments);
      }
      function defaultNegComparator(a2, b) {
        return a2 < b ? 1 : a2 > b ? -1 : 0;
      }
      function hashIterable(iterable) {
        if (iterable.size === Infinity) {
          return 0;
        }
        var ordered = isOrdered(iterable);
        var keyed = isKeyed(iterable);
        var h2 = ordered ? 1 : 0;
        var size = iterable.__iterate(
          keyed ? ordered ? function(v2, k) {
            h2 = 31 * h2 + hashMerge(hash(v2), hash(k)) | 0;
          } : function(v2, k) {
            h2 = h2 + hashMerge(hash(v2), hash(k)) | 0;
          } : ordered ? function(v2) {
            h2 = 31 * h2 + hash(v2) | 0;
          } : function(v2) {
            h2 = h2 + hash(v2) | 0;
          }
        );
        return murmurHashOfSize(size, h2);
      }
      function murmurHashOfSize(size, h2) {
        h2 = imul(h2, 3432918353);
        h2 = imul(h2 << 15 | h2 >>> -15, 461845907);
        h2 = imul(h2 << 13 | h2 >>> -13, 5);
        h2 = (h2 + 3864292196 | 0) ^ size;
        h2 = imul(h2 ^ h2 >>> 16, 2246822507);
        h2 = imul(h2 ^ h2 >>> 13, 3266489909);
        h2 = smi(h2 ^ h2 >>> 16);
        return h2;
      }
      function hashMerge(a2, b) {
        return a2 ^ b + 2654435769 + (a2 << 6) + (a2 >> 2) | 0;
      }
      var Immutable = {
        Iterable,
        Seq: Seq2,
        Collection,
        Map: Map3,
        OrderedMap: OrderedMap2,
        List: List2,
        Stack,
        Set: Set3,
        OrderedSet,
        Record,
        Range,
        Repeat,
        is: is6,
        fromJS: fromJS2
      };
      return Immutable;
    });
  }
});

// node_modules/redux-immutable/dist/utilities/getStateName.js
var require_getStateName = __commonJS({
  "node_modules/redux-immutable/dist/utilities/getStateName.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(action) {
      return action && action.type === "@@redux/INIT" ? "initialState argument passed to createStore" : "previous state received by the reducer";
    };
    module.exports = exports["default"];
  }
});

// node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js
var require_getUnexpectedInvocationParameterMessage = __commonJS({
  "node_modules/redux-immutable/dist/utilities/getUnexpectedInvocationParameterMessage.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _immutable = require_immutable();
    var _immutable2 = _interopRequireDefault(_immutable);
    var _getStateName = require_getStateName();
    var _getStateName2 = _interopRequireDefault(_getStateName);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = function(state2, reducers, action) {
      var reducerNames = Object.keys(reducers);
      if (!reducerNames.length) {
        return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
      }
      var stateName = (0, _getStateName2.default)(action);
      if (_immutable2.default.isImmutable ? !_immutable2.default.isImmutable(state2) : !_immutable2.default.Iterable.isIterable(state2)) {
        return "The " + stateName + ' is of unexpected type. Expected argument to be an instance of Immutable.Collection or Immutable.Record with the following properties: "' + reducerNames.join('", "') + '".';
      }
      var unexpectedStatePropertyNames = state2.toSeq().keySeq().toArray().filter(function(name2) {
        return !reducers.hasOwnProperty(name2);
      });
      if (unexpectedStatePropertyNames.length > 0) {
        return "Unexpected " + (unexpectedStatePropertyNames.length === 1 ? "property" : "properties") + ' "' + unexpectedStatePropertyNames.join('", "') + '" found in ' + stateName + '. Expected to find one of the known reducer property names instead: "' + reducerNames.join('", "') + '". Unexpected properties will be ignored.';
      }
      return null;
    };
    module.exports = exports["default"];
  }
});

// node_modules/redux-immutable/dist/utilities/validateNextState.js
var require_validateNextState = __commonJS({
  "node_modules/redux-immutable/dist/utilities/validateNextState.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(nextState, reducerName, action) {
      if (nextState === void 0) {
        throw new Error('Reducer "' + reducerName + '" returned undefined when handling "' + action.type + '" action. To ignore an action, you must explicitly return the previous state.');
      }
    };
    module.exports = exports["default"];
  }
});

// node_modules/redux-immutable/dist/utilities/index.js
var require_utilities = __commonJS({
  "node_modules/redux-immutable/dist/utilities/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.validateNextState = exports.getUnexpectedInvocationParameterMessage = exports.getStateName = void 0;
    var _getStateName2 = require_getStateName();
    var _getStateName3 = _interopRequireDefault(_getStateName2);
    var _getUnexpectedInvocationParameterMessage2 = require_getUnexpectedInvocationParameterMessage();
    var _getUnexpectedInvocationParameterMessage3 = _interopRequireDefault(_getUnexpectedInvocationParameterMessage2);
    var _validateNextState2 = require_validateNextState();
    var _validateNextState3 = _interopRequireDefault(_validateNextState2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.getStateName = _getStateName3.default;
    exports.getUnexpectedInvocationParameterMessage = _getUnexpectedInvocationParameterMessage3.default;
    exports.validateNextState = _validateNextState3.default;
  }
});

// node_modules/redux-immutable/dist/combineReducers.js
var require_combineReducers = __commonJS({
  "node_modules/redux-immutable/dist/combineReducers.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _immutable = require_immutable();
    var _immutable2 = _interopRequireDefault(_immutable);
    var _utilities = require_utilities();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = function(reducers) {
      var getDefaultState = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _immutable2.default.Map;
      var reducerKeys = Object.keys(reducers);
      return function() {
        var inputState = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getDefaultState();
        var action = arguments[1];
        if (true) {
          var warningMessage = (0, _utilities.getUnexpectedInvocationParameterMessage)(inputState, reducers, action);
          if (warningMessage) {
            console.error(warningMessage);
          }
        }
        return inputState.withMutations(function(temporaryState) {
          reducerKeys.forEach(function(reducerName) {
            var reducer = reducers[reducerName];
            var currentDomainState = temporaryState.get(reducerName);
            var nextDomainState = reducer(currentDomainState, action);
            (0, _utilities.validateNextState)(nextDomainState, reducerName, action);
            temporaryState.set(reducerName, nextDomainState);
          });
        });
      };
    };
    module.exports = exports["default"];
  }
});

// node_modules/redux-immutable/dist/index.js
var require_dist = __commonJS({
  "node_modules/redux-immutable/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.combineReducers = void 0;
    var _combineReducers2 = require_combineReducers();
    var _combineReducers3 = _interopRequireDefault(_combineReducers2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.combineReducers = _combineReducers3.default;
  }
});

// node_modules/serialize-error/index.js
var require_serialize_error = __commonJS({
  "node_modules/serialize-error/index.js"(exports, module) {
    "use strict";
    var NonError = class _NonError extends Error {
      constructor(message) {
        super(_NonError._prepareSuperMessage(message));
        Object.defineProperty(this, "name", {
          value: "NonError",
          configurable: true,
          writable: true
        });
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _NonError);
        }
      }
      static _prepareSuperMessage(message) {
        try {
          return JSON.stringify(message);
        } catch {
          return String(message);
        }
      }
    };
    var commonProperties = [
      { property: "name", enumerable: false },
      { property: "message", enumerable: false },
      { property: "stack", enumerable: false },
      { property: "code", enumerable: true }
    ];
    var isCalled = Symbol(".toJSON called");
    var toJSON = (from2) => {
      from2[isCalled] = true;
      const json3 = from2.toJSON();
      delete from2[isCalled];
      return json3;
    };
    var destroyCircular = ({
      from: from2,
      seen,
      to_,
      forceEnumerable,
      maxDepth,
      depth
    }) => {
      const to2 = to_ || (Array.isArray(from2) ? [] : {});
      seen.push(from2);
      if (depth >= maxDepth) {
        return to2;
      }
      if (typeof from2.toJSON === "function" && from2[isCalled] !== true) {
        return toJSON(from2);
      }
      for (const [key57, value] of Object.entries(from2)) {
        if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
          to2[key57] = "[object Buffer]";
          continue;
        }
        if (typeof value === "function") {
          continue;
        }
        if (!value || typeof value !== "object") {
          to2[key57] = value;
          continue;
        }
        if (!seen.includes(from2[key57])) {
          depth++;
          to2[key57] = destroyCircular({
            from: from2[key57],
            seen: seen.slice(),
            forceEnumerable,
            maxDepth,
            depth
          });
          continue;
        }
        to2[key57] = "[Circular]";
      }
      for (const { property: property2, enumerable } of commonProperties) {
        if (typeof from2[property2] === "string") {
          Object.defineProperty(to2, property2, {
            value: from2[property2],
            enumerable: forceEnumerable ? true : enumerable,
            configurable: true,
            writable: true
          });
        }
      }
      return to2;
    };
    var serializeError2 = (value, options = {}) => {
      const { maxDepth = Number.POSITIVE_INFINITY } = options;
      if (typeof value === "object" && value !== null) {
        return destroyCircular({
          from: value,
          seen: [],
          forceEnumerable: true,
          maxDepth,
          depth: 0
        });
      }
      if (typeof value === "function") {
        return `[Function: ${value.name || "anonymous"}]`;
      }
      return value;
    };
    var deserializeError = (value, options = {}) => {
      const { maxDepth = Number.POSITIVE_INFINITY } = options;
      if (value instanceof Error) {
        return value;
      }
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        const newError = new Error();
        destroyCircular({
          from: value,
          seen: [],
          to_: newError,
          maxDepth,
          depth: 0
        });
        return newError;
      }
      return new NonError(value);
    };
    module.exports = {
      serializeError: serializeError2,
      deserializeError
    };
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array2, key57) {
      var length3 = array2.length;
      while (length3--) {
        if (eq(array2[length3][0], key57)) {
          return length3;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key57) {
      var data = this.__data__, index = assocIndexOf(data, key57);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key57) {
      var data = this.__data__, index = assocIndexOf(data, key57);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key57) {
      return assocIndexOf(this.__data__, key57) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key57, value) {
      var data = this.__data__, index = assocIndexOf(data, key57);
      if (index < 0) {
        ++this.size;
        data.push([key57, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries2) {
      var index = -1, length3 = entries2 == null ? 0 : entries2.length;
      this.clear();
      while (++index < length3) {
        var entry = entries2[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key57) {
      var data = this.__data__, result = data["delete"](key57);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key57) {
      return this.__data__.get(key57);
    }
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key57) {
      return this.__data__.has(key57);
    }
    module.exports = stackHas;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject6(value) {
      var type5 = typeof value;
      return value != null && (type5 == "object" || type5 == "function");
    }
    module.exports = isObject6;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject6 = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction3(value) {
      if (!isObject6(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction3;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction3 = require_isFunction();
    var isMasked = require_isMasked();
    var isObject6 = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject6(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object2, key57) {
      return object2 == null ? void 0 : object2[key57];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object2, key57) {
      var value = getValue(object2, key57);
      return baseIsNative(value) ? value : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map3 = getNative(root, "Map");
    module.exports = Map3;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key57) {
      var result = this.has(key57) && delete this.__data__[key57];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function hashGet(key57) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key57];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty3.call(data, key57) ? data[key57] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function hashHas(key57) {
      var data = this.__data__;
      return nativeCreate ? data[key57] !== void 0 : hasOwnProperty3.call(data, key57);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key57, value) {
      var data = this.__data__;
      this.size += this.has(key57) ? 0 : 1;
      data[key57] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries2) {
      var index = -1, length3 = entries2 == null ? 0 : entries2.length;
      this.clear();
      while (++index < length3) {
        var entry = entries2[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map3 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map3 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value) {
      var type5 = typeof value;
      return type5 == "string" || type5 == "number" || type5 == "symbol" || type5 == "boolean" ? value !== "__proto__" : value === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map5, key57) {
      var data = map5.__data__;
      return isKeyable(key57) ? data[typeof key57 == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key57) {
      var result = getMapData(this, key57)["delete"](key57);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key57) {
      return getMapData(this, key57).get(key57);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key57) {
      return getMapData(this, key57).has(key57);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key57, value) {
      var data = getMapData(this, key57), size = data.size;
      data.set(key57, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries2) {
      var index = -1, length3 = entries2 == null ? 0 : entries2.length;
      this.clear();
      while (++index < length3) {
        var entry = entries2[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map3 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key57, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs2 = data.__data__;
        if (!Map3 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key57, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs2);
      }
      data.set(key57, value);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries2) {
      var data = this.__data__ = new ListCache(entries2);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty2 = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    module.exports = defineProperty2;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty2 = require_defineProperty();
    function baseAssignValue(object2, key57, value) {
      if (key57 == "__proto__" && defineProperty2) {
        defineProperty2(object2, key57, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key57] = value;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object2, key57, value) {
      if (value !== void 0 && !eq(object2[key57], value) || value === void 0 && !(key57 in object2)) {
        baseAssignValue(object2, key57, value);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports, module) {
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index = -1, iterable = Object(object2), props3 = keysFunc(object2), length3 = props3.length;
        while (length3--) {
          var key57 = props3[fromRight ? length3 : ++index];
          if (iteratee(iterable[key57], key57, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    module.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports, module) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports, module) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length3 = buffer.length, result = allocUnsafe ? allocUnsafe(length3) : new buffer.constructor(length3);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array2 = root.Uint8Array;
    module.exports = Uint8Array2;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module) {
    function copyArray3(source, array2) {
      var index = -1, length3 = source.length;
      array2 || (array2 = Array(length3));
      while (++index < length3) {
        array2[index] = source[index];
      }
      return array2;
    }
    module.exports = copyArray3;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports, module) {
    var isObject6 = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object2() {
      }
      return function(proto2) {
        if (!isObject6(proto2)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto2);
        }
        object2.prototype = proto2;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto2;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
    }
    module.exports = initCloneObject;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray4 = Array.isArray;
    module.exports = isArray4;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction3 = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike3(value) {
      return value != null && isLength(value.length) && !isFunction3(value);
    }
    module.exports = isArrayLike3;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike3 = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike3(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject3(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto2 = getPrototype(value);
      if (proto2 === null) {
        return true;
      }
      var Ctor = hasOwnProperty3.call(proto2, "constructor") && proto2.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject3;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object2, key57) {
      if (key57 === "constructor" && typeof object2[key57] === "function") {
        return;
      }
      if (key57 == "__proto__") {
        return;
      }
      return object2[key57];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function assignValue(object2, key57, value) {
      var objValue = object2[key57];
      if (!(hasOwnProperty3.call(object2, key57) && eq(objValue, value)) || value === void 0 && !(key57 in object2)) {
        baseAssignValue(object2, key57, value);
      }
    }
    module.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props3, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index = -1, length3 = props3.length;
      while (++index < length3) {
        var key57 = props3[index];
        var newValue = customizer ? customizer(object2[key57], source[key57], key57, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key57];
        }
        if (isNew) {
          baseAssignValue(object2, key57, newValue);
        } else {
          assignValue(object2, key57, newValue);
        }
      }
      return object2;
    }
    module.exports = copyObject;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length3) {
      var type5 = typeof value;
      length3 = length3 == null ? MAX_SAFE_INTEGER2 : length3;
      return !!length3 && (type5 == "number" || type5 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length3);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray4 = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray4(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length3 = result.length;
      for (var key57 in value) {
        if ((inherited || hasOwnProperty3.call(value, key57)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key57 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key57 == "offset" || key57 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key57 == "buffer" || key57 == "byteLength" || key57 == "byteOffset") || // Skip index properties.
        isIndex(key57, length3)))) {
          result.push(key57);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key57 in Object(object2)) {
          result.push(key57);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module) {
    var isObject6 = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject6(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key57 in object2) {
        if (!(key57 == "constructor" && (isProto || !hasOwnProperty3.call(object2, key57)))) {
          result.push(key57);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike3 = require_isArrayLike();
    function keysIn3(object2) {
      return isArrayLike3(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    module.exports = keysIn3;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn3 = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn3(value));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray3 = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray4 = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction3 = require_isFunction();
    var isObject6 = require_isObject();
    var isPlainObject3 = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object2, source, key57, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object2, key57), srcValue = safeGet(source, key57), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object2, key57, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key57 + "", object2, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray4(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray4(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray3(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject3(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject6(objValue) || isFunction3(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object2, key57, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject6 = require_isObject();
    var keysIn3 = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object2, source, srcIndex, customizer, stack) {
      if (object2 === source) {
        return;
      }
      baseFor(source, function(srcValue, key57) {
        stack || (stack = new Stack());
        if (isObject6(srcValue)) {
          baseMergeDeep(object2, source, key57, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object2, key57), srcValue, key57 + "", object2, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object2, key57, newValue);
        }
      }, keysIn3);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module) {
    function identity2(value) {
      return value;
    }
    module.exports = identity2;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports, module) {
    function apply4(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply4;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports, module) {
    var apply4 = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start, transform2) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length3 = nativeMax(args.length - start, 0), array2 = Array(length3);
        while (++index < length3) {
          array2[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform2(array2);
        return apply4(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports, module) {
    function constant(value) {
      return function() {
        return value;
      };
    }
    module.exports = constant;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports, module) {
    var constant = require_constant();
    var defineProperty2 = require_defineProperty();
    var identity2 = require_identity();
    var baseSetToString = !defineProperty2 ? identity2 : function(func, string) {
      return defineProperty2(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports, module) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count2 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count2 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count2 = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports, module) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports, module) {
    var identity2 = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity2), func + "");
    }
    module.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports, module) {
    var eq = require_eq();
    var isArrayLike3 = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject6 = require_isObject();
    function isIterateeCall(value, index, object2) {
      if (!isObject6(object2)) {
        return false;
      }
      var type5 = typeof index;
      if (type5 == "number" ? isArrayLike3(object2) && isIndex(index, object2.length) : type5 == "string" && index in object2) {
        return eq(object2[index], value);
      }
      return false;
    }
    module.exports = isIterateeCall;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object2, sources) {
        var index = -1, length3 = sources.length, customizer = length3 > 1 ? sources[length3 - 1] : void 0, guard = length3 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length3--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length3 < 3 ? void 0 : customizer;
          length3 = 1;
        }
        object2 = Object(object2);
        while (++index < length3) {
          var source = sources[index];
          if (source) {
            assigner(object2, source, index, customizer);
          }
        }
        return object2;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/merge.js
var require_merge = __commonJS({
  "node_modules/lodash/merge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge5 = createAssigner(function(object2, source, srcIndex) {
      baseMerge(object2, source, srcIndex);
    });
    module.exports = merge5;
  }
});

// node_modules/@braintree/sanitize-url/dist/constants.js
var require_constants = __commonJS({
  "node_modules/@braintree/sanitize-url/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BLANK_URL = exports.relativeFirstCharacters = exports.whitespaceEscapeCharsRegex = exports.urlSchemeRegex = exports.ctrlCharactersRegex = exports.htmlCtrlEntityRegex = exports.htmlEntitiesRegex = exports.invalidProtocolRegex = void 0;
    exports.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
    exports.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
    exports.htmlCtrlEntityRegex = /&(newline|tab);/gi;
    exports.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
    exports.urlSchemeRegex = /^.+(:|&colon;)/gim;
    exports.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g;
    exports.relativeFirstCharacters = [".", "/"];
    exports.BLANK_URL = "about:blank";
  }
});

// node_modules/@braintree/sanitize-url/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@braintree/sanitize-url/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sanitizeUrl = void 0;
    var constants_1 = require_constants();
    function isRelativeUrlWithoutProtocol(url) {
      return constants_1.relativeFirstCharacters.indexOf(url[0]) > -1;
    }
    function decodeHtmlCharacters(str2) {
      var removedNullByte = str2.replace(constants_1.ctrlCharactersRegex, "");
      return removedNullByte.replace(constants_1.htmlEntitiesRegex, function(match3, dec2) {
        return String.fromCharCode(dec2);
      });
    }
    function decodeURI2(uri2) {
      try {
        return decodeURIComponent(uri2);
      } catch (e2) {
        return uri2;
      }
    }
    function sanitizeUrl3(url) {
      if (!url) {
        return constants_1.BLANK_URL;
      }
      var charsToDecode;
      var decodedUrl = decodeURI2(url);
      do {
        decodedUrl = decodeHtmlCharacters(decodedUrl).replace(constants_1.htmlCtrlEntityRegex, "").replace(constants_1.ctrlCharactersRegex, "").replace(constants_1.whitespaceEscapeCharsRegex, "").trim();
        decodedUrl = decodeURI2(decodedUrl);
        charsToDecode = decodedUrl.match(constants_1.ctrlCharactersRegex) || decodedUrl.match(constants_1.htmlEntitiesRegex) || decodedUrl.match(constants_1.htmlCtrlEntityRegex) || decodedUrl.match(constants_1.whitespaceEscapeCharsRegex);
      } while (charsToDecode && charsToDecode.length > 0);
      var sanitizedUrl = decodedUrl;
      if (!sanitizedUrl) {
        return constants_1.BLANK_URL;
      }
      if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
        return sanitizedUrl;
      }
      var urlSchemeParseResults = sanitizedUrl.match(constants_1.urlSchemeRegex);
      if (!urlSchemeParseResults) {
        return sanitizedUrl;
      }
      var urlScheme = urlSchemeParseResults[0];
      if (constants_1.invalidProtocolRegex.test(urlScheme)) {
        return constants_1.BLANK_URL;
      }
      return sanitizedUrl;
    }
    exports.sanitizeUrl = sanitizeUrl3;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array2, iteratee) {
      var index = -1, length3 = array2 == null ? 0 : array2.length, result = Array(length3);
      while (++index < length3) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol2;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray4 = require_isArray();
    var isSymbol2 = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray4(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol2(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString5(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString5;
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports, module) {
    function baseSlice(array2, start, end) {
      var index = -1, length3 = array2.length;
      if (start < 0) {
        start = -start > length3 ? 0 : length3 + start;
      }
      end = end > length3 ? length3 : end;
      if (end < 0) {
        end += length3;
      }
      length3 = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length3);
      while (++index < length3) {
        result[index] = array2[index + start];
      }
      return result;
    }
    module.exports = baseSlice;
  }
});

// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/lodash/_castSlice.js"(exports, module) {
    var baseSlice = require_baseSlice();
    function castSlice(array2, start, end) {
      var length3 = array2.length;
      end = end === void 0 ? length3 : end;
      return !start && end >= length3 ? array2 : baseSlice(array2, start, end);
    }
    module.exports = castSlice;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module.exports = hasUnicode;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports, module) {
    function asciiToArray(string) {
      return string.split("");
    }
    module.exports = asciiToArray;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports, module) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module.exports = stringToArray;
  }
});

// node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "node_modules/lodash/_createCaseFirst.js"(exports, module) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString5 = require_toString();
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString5(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module.exports = createCaseFirst;
  }
});

// node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "node_modules/lodash/upperFirst.js"(exports, module) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module.exports = upperFirst;
  }
});

// node_modules/lodash/capitalize.js
var require_capitalize = __commonJS({
  "node_modules/lodash/capitalize.js"(exports, module) {
    var toString5 = require_toString();
    var upperFirst = require_upperFirst();
    function capitalize(string) {
      return upperFirst(toString5(string).toLowerCase());
    }
    module.exports = capitalize;
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports, module) {
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index = -1, length3 = array2 == null ? 0 : array2.length;
      if (initAccum && length3) {
        accumulator = array2[++index];
      }
      while (++index < length3) {
        accumulator = iteratee(accumulator, array2[index], index, array2);
      }
      return accumulator;
    }
    module.exports = arrayReduce;
  }
});

// node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "node_modules/lodash/_basePropertyOf.js"(exports, module) {
    function basePropertyOf(object2) {
      return function(key57) {
        return object2 == null ? void 0 : object2[key57];
      };
    }
    module.exports = basePropertyOf;
  }
});

// node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
  "node_modules/lodash/_deburrLetter.js"(exports, module) {
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module.exports = deburrLetter;
  }
});

// node_modules/lodash/deburr.js
var require_deburr = __commonJS({
  "node_modules/lodash/deburr.js"(exports, module) {
    var deburrLetter = require_deburrLetter();
    var toString5 = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string) {
      string = toString5(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  }
});

// node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
  "node_modules/lodash/_asciiWords.js"(exports, module) {
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    module.exports = asciiWords;
  }
});

// node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
  "node_modules/lodash/_hasUnicodeWord.js"(exports, module) {
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    module.exports = hasUnicodeWord;
  }
});

// node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
  "node_modules/lodash/_unicodeWords.js"(exports, module) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    module.exports = unicodeWords;
  }
});

// node_modules/lodash/words.js
var require_words = __commonJS({
  "node_modules/lodash/words.js"(exports, module) {
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString5 = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string, pattern, guard) {
      string = toString5(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module.exports = words;
  }
});

// node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
  "node_modules/lodash/_createCompounder.js"(exports, module) {
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "[']";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    module.exports = createCompounder;
  }
});

// node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/lodash/camelCase.js"(exports, module) {
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module.exports = camelCase;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver2) {
      if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key57 = resolver2 ? resolver2.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key57)) {
          return cache.get(key57);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key57, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values3) {
      var index = -1, length3 = values3 == null ? 0 : values3.length;
      this.__data__ = new MapCache();
      while (++index < length3) {
        this.add(values3[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module) {
    function arraySome(array2, predicate) {
      var index = -1, length3 = array2 == null ? 0 : array2.length;
      while (++index < length3) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    module.exports = arraySome;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    function cacheHas(cache, key57) {
      return cache.has(key57);
    }
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index < arrLength) {
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    module.exports = equalArrays;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module) {
    function mapToArray(map5) {
      var index = -1, result = Array(map5.size);
      map5.forEach(function(value, key57) {
        result[++index] = [key57, value];
      });
      return result;
    }
    module.exports = mapToArray;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    function setToArray(set4) {
      var index = -1, result = Array(set4.size);
      set4.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var Uint8Array2 = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module.exports = equalByTag;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush2(array2, values3) {
      var index = -1, length3 = values3.length, offset = array2.length;
      while (++index < length3) {
        array2[offset + index] = values3[index];
      }
      return array2;
    }
    module.exports = arrayPush2;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush2 = require_arrayPush();
    var isArray4 = require_isArray();
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray4(object2) ? result : arrayPush2(result, symbolsFunc(object2));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array2, predicate) {
      var index = -1, length3 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length3) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key57 in Object(object2)) {
        if (hasOwnProperty3.call(object2, key57) && key57 != "constructor") {
          result.push(key57);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike3 = require_isArrayLike();
    function keys4(object2) {
      return isArrayLike3(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    module.exports = keys4;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys4 = require_keys();
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys4, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key57 = objProps[index];
        if (!(isPartial ? key57 in other : hasOwnProperty3.call(other, key57))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key57 = objProps[index];
        var objValue = object2[key57], othValue = other[key57];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key57, other, object2, stack) : customizer(objValue, othValue, key57, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key57 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    module.exports = equalObjects;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView2 = getNative(root, "DataView");
    module.exports = DataView2;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set3 = getNative(root, "Set");
    module.exports = Set3;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    var DataView2 = require_DataView();
    var Map3 = require_Map();
    var Promise2 = require_Promise();
    var Set3 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map3);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set3);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map3 && getTag(new Map3()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set3 && getTag(new Set3()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray4 = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray4(object2), othIsArr = isArray4(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty3.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports, module) {
    var Stack = require_Stack();
    var baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index = matchData.length, length3 = index, noCustomizer = !customizer;
      if (object2 == null) {
        return !length3;
      }
      object2 = Object(object2);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index < length3) {
        data = matchData[index];
        var key57 = data[0], objValue = object2[key57], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key57 in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key57, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module.exports = baseIsMatch;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports, module) {
    var isObject6 = require_isObject();
    function isStrictComparable(value) {
      return value === value && !isObject6(value);
    }
    module.exports = isStrictComparable;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports, module) {
    var isStrictComparable = require_isStrictComparable();
    var keys4 = require_keys();
    function getMatchData(object2) {
      var result = keys4(object2), length3 = result.length;
      while (length3--) {
        var key57 = result[length3], value = object2[key57];
        result[length3] = [key57, value, isStrictComparable(value)];
      }
      return result;
    }
    module.exports = getMatchData;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports, module) {
    function matchesStrictComparable(key57, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key57] === srcValue && (srcValue !== void 0 || key57 in Object(object2));
      };
    }
    module.exports = matchesStrictComparable;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports, module) {
    var baseIsMatch = require_baseIsMatch();
    var getMatchData = require_getMatchData();
    var matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    module.exports = baseMatches;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray4 = require_isArray();
    var isSymbol2 = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey2(value, object2) {
      if (isArray4(value)) {
        return false;
      }
      var type5 = typeof value;
      if (type5 == "number" || type5 == "symbol" || type5 == "boolean" || value == null || isSymbol2(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    module.exports = isKey2;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key57) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key57;
      });
      var cache = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match3, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match3);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray4 = require_isArray();
    var isKey2 = require_isKey();
    var stringToPath = require_stringToPath();
    var toString5 = require_toString();
    function castPath(value, object2) {
      if (isArray4(value)) {
        return value;
      }
      return isKey2(value, object2) ? [value] : stringToPath(toString5(value));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol2 = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol2(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object2, path4) {
      path4 = castPath(path4, object2);
      var index = 0, length3 = path4.length;
      while (object2 != null && index < length3) {
        object2 = object2[toKey(path4[index++])];
      }
      return index && index == length3 ? object2 : void 0;
    }
    module.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    var baseGet = require_baseGet();
    function get3(object2, path4, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path4);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get3;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports, module) {
    function baseHasIn(object2, key57) {
      return object2 != null && key57 in Object(object2);
    }
    module.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports, module) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray4 = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath3(object2, path4, hasFunc) {
      path4 = castPath(path4, object2);
      var index = -1, length3 = path4.length, result = false;
      while (++index < length3) {
        var key57 = toKey(path4[index]);
        if (!(result = object2 != null && hasFunc(object2, key57))) {
          break;
        }
        object2 = object2[key57];
      }
      if (result || ++index != length3) {
        return result;
      }
      length3 = object2 == null ? 0 : object2.length;
      return !!length3 && isLength(length3) && isIndex(key57, length3) && (isArray4(object2) || isArguments(object2));
    }
    module.exports = hasPath3;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports, module) {
    var baseHasIn = require_baseHasIn();
    var hasPath3 = require_hasPath();
    function hasIn3(object2, path4) {
      return object2 != null && hasPath3(object2, path4, baseHasIn);
    }
    module.exports = hasIn3;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    var get3 = require_get();
    var hasIn3 = require_hasIn();
    var isKey2 = require_isKey();
    var isStrictComparable = require_isStrictComparable();
    var matchesStrictComparable = require_matchesStrictComparable();
    var toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path4, srcValue) {
      if (isKey2(path4) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path4), srcValue);
      }
      return function(object2) {
        var objValue = get3(object2, path4);
        return objValue === void 0 && objValue === srcValue ? hasIn3(object2, path4) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    module.exports = baseMatchesProperty;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports, module) {
    function baseProperty(key57) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key57];
      };
    }
    module.exports = baseProperty;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports, module) {
    var baseGet = require_baseGet();
    function basePropertyDeep(path4) {
      return function(object2) {
        return baseGet(object2, path4);
      };
    }
    module.exports = basePropertyDeep;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports, module) {
    var baseProperty = require_baseProperty();
    var basePropertyDeep = require_basePropertyDeep();
    var isKey2 = require_isKey();
    var toKey = require_toKey();
    function property2(path4) {
      return isKey2(path4) ? baseProperty(toKey(path4)) : basePropertyDeep(path4);
    }
    module.exports = property2;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports, module) {
    var baseMatches = require_baseMatches();
    var baseMatchesProperty = require_baseMatchesProperty();
    var identity2 = require_identity();
    var isArray4 = require_isArray();
    var property2 = require_property();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity2;
      }
      if (typeof value == "object") {
        return isArray4(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property2(value);
    }
    module.exports = baseIteratee;
  }
});

// node_modules/lodash/_createFind.js
var require_createFind = __commonJS({
  "node_modules/lodash/_createFind.js"(exports, module) {
    var baseIteratee = require_baseIteratee();
    var isArrayLike3 = require_isArrayLike();
    var keys4 = require_keys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike3(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys4(collection);
          predicate = function(key57) {
            return iteratee(iterable[key57], key57, iterable);
          };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
      };
    }
    module.exports = createFind;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length3 = array2.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length3) {
        if (predicate(array2[index], index, array2)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports, module) {
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    module.exports = trimmedEndIndex;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports, module) {
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    module.exports = baseTrim;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports, module) {
    var baseTrim = require_baseTrim();
    var isObject6 = require_isObject();
    var isSymbol2 = require_isSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber2(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject6(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject6(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary2 = reIsBinary.test(value);
      return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = toNumber2;
  }
});

// node_modules/lodash/toFinite.js
var require_toFinite = __commonJS({
  "node_modules/lodash/toFinite.js"(exports, module) {
    var toNumber2 = require_toNumber();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber2(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    module.exports = toFinite;
  }
});

// node_modules/lodash/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/lodash/toInteger.js"(exports, module) {
    var toFinite = require_toFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    module.exports = toInteger;
  }
});

// node_modules/lodash/findIndex.js
var require_findIndex = __commonJS({
  "node_modules/lodash/findIndex.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIteratee = require_baseIteratee();
    var toInteger = require_toInteger();
    var nativeMax = Math.max;
    function findIndex3(array2, predicate, fromIndex) {
      var length3 = array2 == null ? 0 : array2.length;
      if (!length3) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length3 + index, 0);
      }
      return baseFindIndex(array2, baseIteratee(predicate, 3), index);
    }
    module.exports = findIndex3;
  }
});

// node_modules/lodash/find.js
var require_find = __commonJS({
  "node_modules/lodash/find.js"(exports, module) {
    var createFind = require_createFind();
    var findIndex3 = require_findIndex();
    var find4 = createFind(findIndex3);
    module.exports = find4;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports, module) {
    var baseFor = require_baseFor();
    var keys4 = require_keys();
    function baseForOwn(object2, iteratee) {
      return object2 && baseFor(object2, iteratee, keys4);
    }
    module.exports = baseForOwn;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports, module) {
    var isArrayLike3 = require_isArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike3(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length3 = collection.length, index = fromRight ? length3 : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length3) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module.exports = createBaseEach;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports, module) {
    var baseForOwn = require_baseForOwn();
    var createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    module.exports = baseEach;
  }
});

// node_modules/lodash/_baseSome.js
var require_baseSome = __commonJS({
  "node_modules/lodash/_baseSome.js"(exports, module) {
    var baseEach = require_baseEach();
    function baseSome(collection, predicate) {
      var result;
      baseEach(collection, function(value, index, collection2) {
        result = predicate(value, index, collection2);
        return !result;
      });
      return !!result;
    }
    module.exports = baseSome;
  }
});

// node_modules/lodash/some.js
var require_some = __commonJS({
  "node_modules/lodash/some.js"(exports, module) {
    var arraySome = require_arraySome();
    var baseIteratee = require_baseIteratee();
    var baseSome = require_baseSome();
    var isArray4 = require_isArray();
    var isIterateeCall = require_isIterateeCall();
    function some(collection, predicate, guard) {
      var func = isArray4(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = void 0;
      }
      return func(collection, baseIteratee(predicate, 3));
    }
    module.exports = some;
  }
});

// node_modules/css.escape/css.escape.js
var require_css_escape = __commonJS({
  "node_modules/css.escape/css.escape.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports == "object") {
        module.exports = factory(root);
      } else if (typeof define == "function" && define.amd) {
        define([], factory.bind(root, root));
      } else {
        factory(root);
      }
    })(typeof global != "undefined" ? global : exports, function(root) {
      if (root.CSS && root.CSS.escape) {
        return root.CSS.escape;
      }
      var cssEscape = function(value) {
        if (arguments.length == 0) {
          throw new TypeError("`CSS.escape` requires an argument.");
        }
        var string = String(value);
        var length3 = string.length;
        var index = -1;
        var codeUnit;
        var result = "";
        var firstCodeUnit = string.charCodeAt(0);
        while (++index < length3) {
          codeUnit = string.charCodeAt(index);
          if (codeUnit == 0) {
            result += "";
            continue;
          }
          if (
            // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
            // U+007F, []
            codeUnit >= 1 && codeUnit <= 31 || codeUnit == 127 || // If the character is the first character and is in the range [0-9]
            // (U+0030 to U+0039), []
            index == 0 && codeUnit >= 48 && codeUnit <= 57 || // If the character is the second character and is in the range [0-9]
            // (U+0030 to U+0039) and the first character is a `-` (U+002D), []
            index == 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit == 45
          ) {
            result += "\\" + codeUnit.toString(16) + " ";
            continue;
          }
          if (
            // If the character is the first character and is a `-` (U+002D), and
            // there is no second character, []
            index == 0 && length3 == 1 && codeUnit == 45
          ) {
            result += "\\" + string.charAt(index);
            continue;
          }
          if (codeUnit >= 128 || codeUnit == 45 || codeUnit == 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {
            result += string.charAt(index);
            continue;
          }
          result += "\\" + string.charAt(index);
        }
        return result;
      };
      if (!root.CSS) {
        root.CSS = {};
      }
      root.CSS.escape = cssEscape;
      return cssEscape;
    });
  }
});

// node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "node_modules/requires-port/index.js"(exports, module) {
    "use strict";
    module.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port) return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "node_modules/querystringify/index.js"(exports) {
    "use strict";
    var has4 = Object.prototype.hasOwnProperty;
    var undef;
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e2) {
        return null;
      }
    }
    function encode(input) {
      try {
        return encodeURIComponent(input);
      } catch (e2) {
        return null;
      }
    }
    function querystring(query4) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query4)) {
        var key57 = decode(part[1]), value = decode(part[2]);
        if (key57 === null || value === null || key57 in result) continue;
        result[key57] = value;
      }
      return result;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs2 = [], value, key57;
      if ("string" !== typeof prefix) prefix = "?";
      for (key57 in obj) {
        if (has4.call(obj, key57)) {
          value = obj[key57];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key57 = encode(key57);
          value = encode(value);
          if (key57 === null || value === null) continue;
          pairs2.push(key57 + "=" + value);
        }
      }
      return pairs2.length ? prefix + pairs2.join("&") : "";
    }
    exports.stringify = querystringify;
    exports.parse = querystring;
  }
});

// node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "node_modules/url-parse/index.js"(exports, module) {
    "use strict";
    var required = require_requires_port();
    var qs2 = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str2) {
      return (str2 ? str2 : "").toString().replace(controlOrWhitespace, "");
    }
    var rules2 = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize2(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined") globalVar = window;
      else if (typeof global !== "undefined") globalVar = global;
      else if (typeof self !== "undefined") globalVar = self;
      else globalVar = {};
      var location = globalVar.location || {};
      loc = loc || location;
      var finaldestination = {}, type5 = typeof loc, key57;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type5) {
        finaldestination = new Url(loc, {});
        for (key57 in ignore) delete finaldestination[key57];
      } else if ("object" === type5) {
        for (key57 in loc) {
          if (key57 in ignore) continue;
          finaldestination[key57] = loc[key57];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location = location || {};
      var match3 = protocolre.exec(address);
      var protocol = match3[1] ? match3[1].toLowerCase() : "";
      var forwardSlashes = !!match3[2];
      var otherSlashes = !!match3[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match3[2] + match3[3] + match3[4];
          slashesCount = match3[2].length + match3[3].length;
        } else {
          rest = match3[2] + match3[4];
          slashesCount = match3[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match3[3] + match3[4];
          slashesCount = match3[3].length;
        } else {
          rest = match3[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match3[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
        rest = match3[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve4(relative, base2) {
      if (relative === "") return base2;
      var path4 = (base2 || "/").split("/").slice(0, -1).concat(relative.split("/")), i2 = path4.length, last2 = path4[i2 - 1], unshift = false, up = 0;
      while (i2--) {
        if (path4[i2] === ".") {
          path4.splice(i2, 1);
        } else if (path4[i2] === "..") {
          path4.splice(i2, 1);
          up++;
        } else if (up) {
          if (i2 === 0) unshift = true;
          path4.splice(i2, 1);
          up--;
        }
      }
      if (unshift) path4.unshift("");
      if (last2 === "." || last2 === "..") path4.push("");
      return path4.join("/");
    }
    function Url(address, location, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }
      var relative, extracted, parse6, instruction, index, key57, instructions = rules2.slice(), type5 = typeof location, url = this, i2 = 0;
      if ("object" !== type5 && "string" !== type5) {
        parser = location;
        location = null;
      }
      if (parser && "function" !== typeof parser) parser = qs2.parse;
      location = lolcation(location);
      extracted = extractProtocol(address || "", location);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i2 < instructions.length; i2++) {
        instruction = instructions[i2];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse6 = instruction[0];
        key57 = instruction[1];
        if (parse6 !== parse6) {
          url[key57] = address;
        } else if ("string" === typeof parse6) {
          index = parse6 === "@" ? address.lastIndexOf(parse6) : address.indexOf(parse6);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key57] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key57] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse6.exec(address)) {
          url[key57] = index[1];
          address = address.slice(0, index.index);
        }
        url[key57] = url[key57] || (relative && instruction[3] ? location[key57] || "" : "");
        if (instruction[4]) url[key57] = url[key57].toLowerCase();
      }
      if (parser) url.query = parser(url.query);
      if (relative && location.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location.pathname !== "")) {
        url.pathname = resolve4(url.pathname, location.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set4(part, value, fn2) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn2 || qs2.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port) value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn2;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i2 = 0; i2 < rules2.length; i2++) {
        var ins2 = rules2[i2];
        if (ins2[4]) url[ins2[1]] = url[ins2[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString5(stringify2) {
      if (!stringify2 || "function" !== typeof stringify2) stringify2 = qs2.stringify;
      var query4, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":") protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password) result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query4 = "object" === typeof url.query ? stringify2(url.query) : url.query;
      if (query4) result += "?" !== query4.charAt(0) ? "?" + query4 : query4;
      if (url.hash) result += url.hash;
      return result;
    }
    Url.prototype = { set: set4, toString: toString5 };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs2;
    module.exports = Url;
  }
});

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE2 = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE2 = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE2 = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE2 = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE2 = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE2 = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE2 = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE2 = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE2 = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE2 = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE2 = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE2 = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType2(type5) {
          return typeof type5 === "string" || typeof type5 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type5 === REACT_FRAGMENT_TYPE2 || type5 === REACT_CONCURRENT_MODE_TYPE || type5 === REACT_PROFILER_TYPE2 || type5 === REACT_STRICT_MODE_TYPE2 || type5 === REACT_SUSPENSE_TYPE2 || type5 === REACT_SUSPENSE_LIST_TYPE2 || typeof type5 === "object" && type5 !== null && (type5.$$typeof === REACT_LAZY_TYPE2 || type5.$$typeof === REACT_MEMO_TYPE2 || type5.$$typeof === REACT_PROVIDER_TYPE2 || type5.$$typeof === REACT_CONTEXT_TYPE2 || type5.$$typeof === REACT_FORWARD_REF_TYPE2 || type5.$$typeof === REACT_FUNDAMENTAL_TYPE || type5.$$typeof === REACT_RESPONDER_TYPE || type5.$$typeof === REACT_SCOPE_TYPE || type5.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf3(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE2:
                var type5 = object2.type;
                switch (type5) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE2:
                  case REACT_PROFILER_TYPE2:
                  case REACT_STRICT_MODE_TYPE2:
                  case REACT_SUSPENSE_TYPE2:
                    return type5;
                  default:
                    var $$typeofType = type5 && type5.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE2:
                      case REACT_FORWARD_REF_TYPE2:
                      case REACT_LAZY_TYPE2:
                      case REACT_MEMO_TYPE2:
                      case REACT_PROVIDER_TYPE2:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE2:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE2;
        var ContextProvider = REACT_PROVIDER_TYPE2;
        var Element3 = REACT_ELEMENT_TYPE2;
        var ForwardRef2 = REACT_FORWARD_REF_TYPE2;
        var Fragment = REACT_FRAGMENT_TYPE2;
        var Lazy = REACT_LAZY_TYPE2;
        var Memo2 = REACT_MEMO_TYPE2;
        var Portal = REACT_PORTAL_TYPE2;
        var Profiler = REACT_PROFILER_TYPE2;
        var StrictMode = REACT_STRICT_MODE_TYPE2;
        var Suspense = REACT_SUSPENSE_TYPE2;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf3(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf3(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer2(object2) {
          return typeOf3(object2) === REACT_CONTEXT_TYPE2;
        }
        function isContextProvider(object2) {
          return typeOf3(object2) === REACT_PROVIDER_TYPE2;
        }
        function isElement2(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE2;
        }
        function isForwardRef(object2) {
          return typeOf3(object2) === REACT_FORWARD_REF_TYPE2;
        }
        function isFragment(object2) {
          return typeOf3(object2) === REACT_FRAGMENT_TYPE2;
        }
        function isLazy(object2) {
          return typeOf3(object2) === REACT_LAZY_TYPE2;
        }
        function isMemo2(object2) {
          return typeOf3(object2) === REACT_MEMO_TYPE2;
        }
        function isPortal(object2) {
          return typeOf3(object2) === REACT_PORTAL_TYPE2;
        }
        function isProfiler(object2) {
          return typeOf3(object2) === REACT_PROFILER_TYPE2;
        }
        function isStrictMode(object2) {
          return typeOf3(object2) === REACT_STRICT_MODE_TYPE2;
        }
        function isSuspense(object2) {
          return typeOf3(object2) === REACT_SUSPENSE_TYPE2;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element3;
        exports.ForwardRef = ForwardRef2;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo2;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer2;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement2;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo2;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType2;
        exports.typeOf = typeOf3;
      })();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols2 = Object.getOwnPropertySymbols;
    var hasOwnProperty3 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test22 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test22["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test22).map(function(n) {
          return test22[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test32 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test32[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test32)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err2) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to2 = toObject(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from2 = Object(arguments[s2]);
        for (var key57 in from2) {
          if (hasOwnProperty3.call(from2, key57)) {
            to2[key57] = from2[key57];
          }
        }
        if (getOwnPropertySymbols2) {
          symbols = getOwnPropertySymbols2(from2);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from2, symbols[i2])) {
              to2[symbols[i2]] = from2[symbols[i2]];
            }
          }
        }
      }
      return to2;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has4 = require_has();
      printWarning = function(text3) {
        var message = "Warning: " + text3;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has4;
    function checkPropTypes(typeSpecs, values3, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has4(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err2 = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err2.name = "Invariant Violation";
                throw err2;
              }
              error = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign2 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has4 = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text3) {
        var message = "Warning: " + text3;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x2) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn2 = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn2 === "function") {
          return iteratorFn2;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is6(x2, y2) {
        if (x2 === y2) {
          return x2 !== 0 || 1 / x2 === 1 / y2;
        } else {
          return x2 !== x2 && y2 !== y2;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate2) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props3, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err2 = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err2.name = "Invariant Violation";
              throw err2;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props3[propName] == null) {
            if (isRequired) {
              if (props3[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate2(props3, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate2(props3, propName, componentName, location, propFullName, secret) {
          var propValue = props3[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate2(props3, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props3[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i2 = 0; i2 < propValue.length; i2++) {
            var error = typeChecker(propValue, i2, componentName, location, propFullName + "[" + i2 + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createElementTypeChecker() {
        function validate2(props3, propName, componentName, location, propFullName) {
          var propValue = props3[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createElementTypeTypeChecker() {
        function validate2(props3, propName, componentName, location, propFullName) {
          var propValue = props3[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate2(props3, propName, componentName, location, propFullName) {
          if (!(props3[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props3[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate2(props3, propName, componentName, location, propFullName) {
          var propValue = props3[propName];
          for (var i2 = 0; i2 < expectedValues.length; i2++) {
            if (is6(propValue, expectedValues[i2])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key57, value) {
            var type5 = getPreciseType(value);
            if (type5 === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate2);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate2(props3, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props3[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key57 in propValue) {
            if (has4(propValue, key57)) {
              var error = typeChecker(propValue, key57, componentName, location, propFullName + "." + key57, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
          var checker = arrayOfTypeCheckers[i2];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i2 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate2(props3, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i3 = 0; i3 < arrayOfTypeCheckers.length; i3++) {
            var checker2 = arrayOfTypeCheckers[i3];
            var checkerResult = checker2(props3, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has4(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate2);
      }
      function createNodeChecker() {
        function validate2(props3, propName, componentName, location, propFullName) {
          if (!isNode3(props3[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function invalidValidatorError(componentName, location, propFullName, key57, type5) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key57 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type5 + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate2(props3, propName, componentName, location, propFullName) {
          var propValue = props3[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key57 in shapeTypes) {
            var checker = shapeTypes[key57];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key57, getPreciseType(checker));
            }
            var error = checker(propValue, key57, componentName, location, propFullName + "." + key57, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate2(props3, propName, componentName, location, propFullName) {
          var propValue = props3[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign2({}, props3[propName], shapeTypes);
          for (var key57 in allKeys) {
            var checker = shapeTypes[key57];
            if (has4(shapeTypes, key57) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key57, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key57 + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props3[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key57, componentName, location, propFullName + "." + key57, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate2);
      }
      function isNode3(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode3);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn2 = getIteratorFn(propValue);
            if (iteratorFn2) {
              var iterator = iteratorFn2.call(propValue);
              var step;
              if (iteratorFn2 !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode3(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode3(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol2(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol2(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type5 = getPreciseType(value);
        switch (type5) {
          case "array":
          case "object":
            return "an " + type5;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type5;
          default:
            return type5;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array2, iteratee) {
      var index = -1, length3 = array2 == null ? 0 : array2.length;
      while (++index < length3) {
        if (iteratee(array2[index], index, array2) === false) {
          break;
        }
      }
      return array2;
    }
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module) {
    var copyObject = require_copyObject();
    var keys4 = require_keys();
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys4(source), object2);
    }
    module.exports = baseAssign;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn3 = require_keysIn();
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn3(source), object2);
    }
    module.exports = baseAssignIn;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols(source), object2);
    }
    module.exports = copySymbols;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    var arrayPush2 = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush2(result, getSymbols(object2));
        object2 = getPrototype(object2);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn(source), object2);
    }
    module.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn3 = require_keysIn();
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn3, getSymbolsIn);
    }
    module.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function initCloneArray(array2) {
      var length3 = array2.length, result = new array2.constructor(length3);
      if (length3 && typeof array2[0] == "string" && hasOwnProperty3.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    module.exports = initCloneArray;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module.exports = cloneSymbol;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object2);
        case boolTag:
        case dateTag:
          return new Ctor(+object2);
        case dataViewTag:
          return cloneDataView(object2, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object2, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object2);
        case regexpTag:
          return cloneRegExp(object2);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object2);
      }
    }
    module.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    module.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap2;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    module.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet2;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray3 = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray4 = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap2 = require_isMap();
    var isObject6 = require_isObject();
    var isSet2 = require_isSet();
    var keys4 = require_keys();
    var keysIn3 = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key57, object2, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object2 ? customizer(value, key57, object2, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject6(value)) {
        return value;
      }
      var isArr = isArray4(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray3(value, result);
        }
      } else {
        var tag = getTag(value), isFunc2 = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc2 && !object2) {
          result = isFlat || isFunc2 ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet2(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap2(value)) {
        value.forEach(function(subValue, key58) {
          result.set(key58, baseClone(subValue, bitmask, customizer, key58, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn3 : keys4;
      var props3 = isArr ? void 0 : keysFunc(value);
      arrayEach(props3 || value, function(subValue, key58) {
        if (props3) {
          key58 = subValue;
          subValue = value[key58];
        }
        assignValue(result, key58, baseClone(subValue, bitmask, customizer, key58, value, stack));
      });
      return result;
    }
    module.exports = baseClone;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports, module) {
    function last2(array2) {
      var length3 = array2 == null ? 0 : array2.length;
      return length3 ? array2[length3 - 1] : void 0;
    }
    module.exports = last2;
  }
});

// node_modules/lodash/_parent.js
var require_parent = __commonJS({
  "node_modules/lodash/_parent.js"(exports, module) {
    var baseGet = require_baseGet();
    var baseSlice = require_baseSlice();
    function parent(object2, path4) {
      return path4.length < 2 ? object2 : baseGet(object2, baseSlice(path4, 0, -1));
    }
    module.exports = parent;
  }
});

// node_modules/lodash/_baseUnset.js
var require_baseUnset = __commonJS({
  "node_modules/lodash/_baseUnset.js"(exports, module) {
    var castPath = require_castPath();
    var last2 = require_last();
    var parent = require_parent();
    var toKey = require_toKey();
    function baseUnset(object2, path4) {
      path4 = castPath(path4, object2);
      object2 = parent(object2, path4);
      return object2 == null || delete object2[toKey(last2(path4))];
    }
    module.exports = baseUnset;
  }
});

// node_modules/lodash/_customOmitClone.js
var require_customOmitClone = __commonJS({
  "node_modules/lodash/_customOmitClone.js"(exports, module) {
    var isPlainObject3 = require_isPlainObject();
    function customOmitClone(value) {
      return isPlainObject3(value) ? void 0 : value;
    }
    module.exports = customOmitClone;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray4 = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray4(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module) {
    var arrayPush2 = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array2, depth, predicate, isStrict, result) {
      var index = -1, length3 = array2.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length3) {
        var value = array2[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush2(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    function flatten3(array2) {
      var length3 = array2 == null ? 0 : array2.length;
      return length3 ? baseFlatten(array2, 1) : [];
    }
    module.exports = flatten3;
  }
});

// node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "node_modules/lodash/_flatRest.js"(exports, module) {
    var flatten3 = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten3), func + "");
    }
    module.exports = flatRest;
  }
});

// node_modules/lodash/omit.js
var require_omit = __commonJS({
  "node_modules/lodash/omit.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var baseClone = require_baseClone();
    var baseUnset = require_baseUnset();
    var castPath = require_castPath();
    var copyObject = require_copyObject();
    var customOmitClone = require_customOmitClone();
    var flatRest = require_flatRest();
    var getAllKeysIn = require_getAllKeysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var omit3 = flatRest(function(object2, paths4) {
      var result = {};
      if (object2 == null) {
        return result;
      }
      var isDeep = false;
      paths4 = arrayMap(paths4, function(path4) {
        path4 = castPath(path4, object2);
        isDeep || (isDeep = path4.length > 1);
        return path4;
      });
      copyObject(object2, getAllKeysIn(object2), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length3 = paths4.length;
      while (length3--) {
        baseUnset(result, paths4[length3]);
      }
      return result;
    });
    module.exports = omit3;
  }
});

// node_modules/zenscroll/zenscroll.js
var require_zenscroll = __commonJS({
  "node_modules/zenscroll/zenscroll.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory());
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        (function install() {
          if (document && document.body) {
            root.zenscroll = factory();
          } else {
            setTimeout(install, 9);
          }
        })();
      }
    })(exports, function() {
      "use strict";
      var isNativeSmoothScrollEnabledOn = function(elem) {
        return elem && "getComputedStyle" in window && window.getComputedStyle(elem)["scroll-behavior"] === "smooth";
      };
      if (typeof window === "undefined" || !("document" in window)) {
        return {};
      }
      var makeScroller = function(container, defaultDuration, edgeOffset) {
        defaultDuration = defaultDuration || 999;
        if (!edgeOffset && edgeOffset !== 0) {
          edgeOffset = 9;
        }
        var scrollTimeoutId;
        var setScrollTimeoutId = function(newValue) {
          scrollTimeoutId = newValue;
        };
        var stopScroll = function() {
          clearTimeout(scrollTimeoutId);
          setScrollTimeoutId(0);
        };
        var getTopWithEdgeOffset = function(elem) {
          return Math.max(0, container.getTopOf(elem) - edgeOffset);
        };
        var scrollToY = function(targetY, duration2, onDone) {
          stopScroll();
          if (duration2 === 0 || duration2 && duration2 < 0 || isNativeSmoothScrollEnabledOn(container.body)) {
            container.toY(targetY);
            if (onDone) {
              onDone();
            }
          } else {
            var startY = container.getY();
            var distance = Math.max(0, targetY) - startY;
            var startTime = (/* @__PURE__ */ new Date()).getTime();
            duration2 = duration2 || Math.min(Math.abs(distance), defaultDuration);
            (function loopScroll() {
              setScrollTimeoutId(setTimeout(function() {
                var p2 = Math.min(1, ((/* @__PURE__ */ new Date()).getTime() - startTime) / duration2);
                var y2 = Math.max(0, Math.floor(startY + distance * (p2 < 0.5 ? 2 * p2 * p2 : p2 * (4 - p2 * 2) - 1)));
                container.toY(y2);
                if (p2 < 1 && container.getHeight() + y2 < container.body.scrollHeight) {
                  loopScroll();
                } else {
                  setTimeout(stopScroll, 99);
                  if (onDone) {
                    onDone();
                  }
                }
              }, 9));
            })();
          }
        };
        var scrollToElem = function(elem, duration2, onDone) {
          scrollToY(getTopWithEdgeOffset(elem), duration2, onDone);
        };
        var scrollIntoView = function(elem, duration2, onDone) {
          var elemHeight = elem.getBoundingClientRect().height;
          var elemBottom = container.getTopOf(elem) + elemHeight;
          var containerHeight = container.getHeight();
          var y2 = container.getY();
          var containerBottom = y2 + containerHeight;
          if (getTopWithEdgeOffset(elem) < y2 || elemHeight + edgeOffset > containerHeight) {
            scrollToElem(elem, duration2, onDone);
          } else if (elemBottom + edgeOffset > containerBottom) {
            scrollToY(elemBottom - containerHeight + edgeOffset, duration2, onDone);
          } else if (onDone) {
            onDone();
          }
        };
        var scrollToCenterOf = function(elem, duration2, offset, onDone) {
          scrollToY(Math.max(0, container.getTopOf(elem) - container.getHeight() / 2 + (offset || elem.getBoundingClientRect().height / 2)), duration2, onDone);
        };
        var setup = function(newDefaultDuration, newEdgeOffset) {
          if (newDefaultDuration === 0 || newDefaultDuration) {
            defaultDuration = newDefaultDuration;
          }
          if (newEdgeOffset === 0 || newEdgeOffset) {
            edgeOffset = newEdgeOffset;
          }
          return {
            defaultDuration,
            edgeOffset
          };
        };
        return {
          setup,
          to: scrollToElem,
          toY: scrollToY,
          intoView: scrollIntoView,
          center: scrollToCenterOf,
          stop: stopScroll,
          moving: function() {
            return !!scrollTimeoutId;
          },
          getY: container.getY,
          getTopOf: container.getTopOf
        };
      };
      var docElem = document.documentElement;
      var getDocY = function() {
        return window.scrollY || docElem.scrollTop;
      };
      var zenscroll = makeScroller({
        body: document.scrollingElement || document.body,
        toY: function(y2) {
          window.scrollTo(0, y2);
        },
        getY: getDocY,
        getHeight: function() {
          return window.innerHeight || docElem.clientHeight;
        },
        getTopOf: function(elem) {
          return elem.getBoundingClientRect().top + getDocY() - docElem.offsetTop;
        }
      });
      zenscroll.createScroller = function(scrollContainer, defaultDuration, edgeOffset) {
        return makeScroller({
          body: scrollContainer,
          toY: function(y2) {
            scrollContainer.scrollTop = y2;
          },
          getY: function() {
            return scrollContainer.scrollTop;
          },
          getHeight: function() {
            return Math.min(scrollContainer.clientHeight, window.innerHeight || docElem.clientHeight);
          },
          getTopOf: function(elem) {
            return elem.offsetTop;
          }
        }, defaultDuration, edgeOffset);
      };
      if ("addEventListener" in window && !window.noZensmooth && !isNativeSmoothScrollEnabledOn(document.body)) {
        var isHistorySupported = "history" in window && "pushState" in history;
        var isScrollRestorationSupported = isHistorySupported && "scrollRestoration" in history;
        if (isScrollRestorationSupported) {
          history.scrollRestoration = "auto";
        }
        window.addEventListener("load", function() {
          if (isScrollRestorationSupported) {
            setTimeout(function() {
              history.scrollRestoration = "manual";
            }, 9);
            window.addEventListener("popstate", function(event) {
              if (event.state && "zenscrollY" in event.state) {
                zenscroll.toY(event.state.zenscrollY);
              }
            }, false);
          }
          if (window.location.hash) {
            setTimeout(function() {
              var edgeOffset = zenscroll.setup().edgeOffset;
              if (edgeOffset) {
                var targetElem = document.getElementById(window.location.href.split("#")[1]);
                if (targetElem) {
                  var targetY = Math.max(0, zenscroll.getTopOf(targetElem) - edgeOffset);
                  var diff = zenscroll.getY() - targetY;
                  if (0 <= diff && diff < 9) {
                    window.scrollTo(0, targetY);
                  }
                }
              }
            }, 9);
          }
        }, false);
        var RE_noZensmooth = new RegExp("(^|\\s)noZensmooth(\\s|$)");
        window.addEventListener("click", function(event) {
          var anchor = event.target;
          while (anchor && anchor.tagName !== "A") {
            anchor = anchor.parentNode;
          }
          if (!anchor || event.which !== 1 || event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {
            return;
          }
          if (isScrollRestorationSupported) {
            var historyState = history.state && typeof history.state === "object" ? history.state : {};
            historyState.zenscrollY = zenscroll.getY();
            try {
              history.replaceState(historyState, "");
            } catch (e2) {
            }
          }
          var href = anchor.getAttribute("href") || "";
          if (href.indexOf("#") === 0 && !RE_noZensmooth.test(anchor.className)) {
            var targetY = 0;
            var targetElem = document.getElementById(href.substring(1));
            if (href !== "#") {
              if (!targetElem) {
                return;
              }
              targetY = zenscroll.getTopOf(targetElem);
            }
            event.preventDefault();
            var onDone = function() {
              window.location = href;
            };
            var edgeOffset = zenscroll.setup().edgeOffset;
            if (edgeOffset) {
              targetY = Math.max(0, targetY - edgeOffset);
              if (isHistorySupported) {
                onDone = function() {
                  history.pushState({}, "", href);
                };
              }
            }
            zenscroll.toY(targetY, null, onDone);
          }
        }, false);
      }
      return zenscroll;
    });
  }
});

// node_modules/react-immutable-proptypes/dist/ImmutablePropTypes.js
var require_ImmutablePropTypes = __commonJS({
  "node_modules/react-immutable-proptypes/dist/ImmutablePropTypes.js"(exports, module) {
    "use strict";
    var Immutable = require_immutable();
    var ANONYMOUS = "<<anonymous>>";
    var ImmutablePropTypes;
    if (true) {
      ImmutablePropTypes = {
        listOf: createListOfTypeChecker,
        mapOf: createMapOfTypeChecker,
        orderedMapOf: createOrderedMapOfTypeChecker,
        setOf: createSetOfTypeChecker,
        orderedSetOf: createOrderedSetOfTypeChecker,
        stackOf: createStackOfTypeChecker,
        iterableOf: createIterableOfTypeChecker,
        recordOf: createRecordOfTypeChecker,
        shape: createShapeChecker,
        contains: createShapeChecker,
        mapContains: createMapContainsChecker,
        orderedMapContains: createOrderedMapContainsChecker,
        // Primitive Types
        list: createImmutableTypeChecker("List", Immutable.List.isList),
        map: createImmutableTypeChecker("Map", Immutable.Map.isMap),
        orderedMap: createImmutableTypeChecker("OrderedMap", Immutable.OrderedMap.isOrderedMap),
        set: createImmutableTypeChecker("Set", Immutable.Set.isSet),
        orderedSet: createImmutableTypeChecker("OrderedSet", Immutable.OrderedSet.isOrderedSet),
        stack: createImmutableTypeChecker("Stack", Immutable.Stack.isStack),
        seq: createImmutableTypeChecker("Seq", Immutable.Seq.isSeq),
        record: createImmutableTypeChecker("Record", function(isRecord) {
          return isRecord instanceof Immutable.Record;
        }),
        iterable: createImmutableTypeChecker("Iterable", Immutable.Iterable.isIterable)
      };
    } else {
      productionTypeChecker = function productionTypeChecker2() {
        invariant(false, "ImmutablePropTypes type checking code is stripped in production.");
      };
      productionTypeChecker.isRequired = productionTypeChecker;
      getProductionTypeChecker = function getProductionTypeChecker2() {
        return productionTypeChecker;
      };
      ImmutablePropTypes = {
        listOf: getProductionTypeChecker,
        mapOf: getProductionTypeChecker,
        orderedMapOf: getProductionTypeChecker,
        setOf: getProductionTypeChecker,
        orderedSetOf: getProductionTypeChecker,
        stackOf: getProductionTypeChecker,
        iterableOf: getProductionTypeChecker,
        recordOf: getProductionTypeChecker,
        shape: getProductionTypeChecker,
        contains: getProductionTypeChecker,
        mapContains: getProductionTypeChecker,
        orderedMapContains: getProductionTypeChecker,
        // Primitive Types
        list: productionTypeChecker,
        map: productionTypeChecker,
        orderedMap: productionTypeChecker,
        set: productionTypeChecker,
        orderedSet: productionTypeChecker,
        stack: productionTypeChecker,
        seq: productionTypeChecker,
        record: productionTypeChecker,
        iterable: productionTypeChecker
      };
    }
    var productionTypeChecker;
    var getProductionTypeChecker;
    ImmutablePropTypes.iterable.indexed = createIterableSubclassTypeChecker("Indexed", Immutable.Iterable.isIndexed);
    ImmutablePropTypes.iterable.keyed = createIterableSubclassTypeChecker("Keyed", Immutable.Iterable.isKeyed);
    function getPropType(propValue) {
      var propType = typeof propValue;
      if (Array.isArray(propValue)) {
        return "array";
      }
      if (propValue instanceof RegExp) {
        return "object";
      }
      if (propValue instanceof Immutable.Iterable) {
        return "Immutable." + propValue.toSource().split(" ")[0];
      }
      return propType;
    }
    function createChainableTypeChecker(validate2) {
      function checkType(isRequired, props3, propName, componentName, location, propFullName) {
        for (var _len = arguments.length, rest = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
          rest[_key - 6] = arguments[_key];
        }
        propFullName = propFullName || propName;
        componentName = componentName || ANONYMOUS;
        if (props3[propName] == null) {
          var locationName = location;
          if (isRequired) {
            return new Error("Required " + locationName + " `" + propFullName + "` was not specified in " + ("`" + componentName + "`."));
          }
        } else {
          return validate2.apply(void 0, [props3, propName, componentName, location, propFullName].concat(rest));
        }
      }
      var chainedCheckType = checkType.bind(null, false);
      chainedCheckType.isRequired = checkType.bind(null, true);
      return chainedCheckType;
    }
    function createImmutableTypeChecker(immutableClassName, immutableClassTypeValidator) {
      function validate2(props3, propName, componentName, location, propFullName) {
        var propValue = props3[propName];
        if (!immutableClassTypeValidator(propValue)) {
          var propType = getPropType(propValue);
          return new Error("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `" + immutableClassName + "`."));
        }
        return null;
      }
      return createChainableTypeChecker(validate2);
    }
    function createIterableSubclassTypeChecker(subclassName, validator2) {
      return createImmutableTypeChecker("Iterable." + subclassName, function(propValue) {
        return Immutable.Iterable.isIterable(propValue) && validator2(propValue);
      });
    }
    function createIterableTypeChecker(typeChecker, immutableClassName, immutableClassTypeValidator) {
      function validate2(props3, propName, componentName, location, propFullName) {
        for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
          rest[_key - 5] = arguments[_key];
        }
        var propValue = props3[propName];
        if (!immutableClassTypeValidator(propValue)) {
          var locationName = location;
          var propType = getPropType(propValue);
          return new Error("Invalid " + locationName + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
        }
        if (typeof typeChecker !== "function") {
          return new Error("Invalid typeChecker supplied to `" + componentName + "` " + ("for propType `" + propFullName + "`, expected a function."));
        }
        var propValues = propValue.valueSeq().toArray();
        for (var i2 = 0, len = propValues.length; i2 < len; i2++) {
          var error = typeChecker.apply(void 0, [propValues, i2, componentName, location, "" + propFullName + "[" + i2 + "]"].concat(rest));
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return createChainableTypeChecker(validate2);
    }
    function createKeysTypeChecker(typeChecker) {
      function validate2(props3, propName, componentName, location, propFullName) {
        for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
          rest[_key - 5] = arguments[_key];
        }
        var propValue = props3[propName];
        if (typeof typeChecker !== "function") {
          return new Error("Invalid keysTypeChecker (optional second argument) supplied to `" + componentName + "` " + ("for propType `" + propFullName + "`, expected a function."));
        }
        var keys4 = propValue.keySeq().toArray();
        for (var i2 = 0, len = keys4.length; i2 < len; i2++) {
          var error = typeChecker.apply(void 0, [keys4, i2, componentName, location, "" + propFullName + " -> key(" + keys4[i2] + ")"].concat(rest));
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return createChainableTypeChecker(validate2);
    }
    function createListOfTypeChecker(typeChecker) {
      return createIterableTypeChecker(typeChecker, "List", Immutable.List.isList);
    }
    function createMapOfTypeCheckerFactory(valuesTypeChecker, keysTypeChecker, immutableClassName, immutableClassTypeValidator) {
      function validate2() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return createIterableTypeChecker(valuesTypeChecker, immutableClassName, immutableClassTypeValidator).apply(void 0, args) || keysTypeChecker && createKeysTypeChecker(keysTypeChecker).apply(void 0, args);
      }
      return createChainableTypeChecker(validate2);
    }
    function createMapOfTypeChecker(valuesTypeChecker, keysTypeChecker) {
      return createMapOfTypeCheckerFactory(valuesTypeChecker, keysTypeChecker, "Map", Immutable.Map.isMap);
    }
    function createOrderedMapOfTypeChecker(valuesTypeChecker, keysTypeChecker) {
      return createMapOfTypeCheckerFactory(valuesTypeChecker, keysTypeChecker, "OrderedMap", Immutable.OrderedMap.isOrderedMap);
    }
    function createSetOfTypeChecker(typeChecker) {
      return createIterableTypeChecker(typeChecker, "Set", Immutable.Set.isSet);
    }
    function createOrderedSetOfTypeChecker(typeChecker) {
      return createIterableTypeChecker(typeChecker, "OrderedSet", Immutable.OrderedSet.isOrderedSet);
    }
    function createStackOfTypeChecker(typeChecker) {
      return createIterableTypeChecker(typeChecker, "Stack", Immutable.Stack.isStack);
    }
    function createIterableOfTypeChecker(typeChecker) {
      return createIterableTypeChecker(typeChecker, "Iterable", Immutable.Iterable.isIterable);
    }
    function createRecordOfTypeChecker(recordKeys) {
      function validate2(props3, propName, componentName, location, propFullName) {
        for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
          rest[_key - 5] = arguments[_key];
        }
        var propValue = props3[propName];
        if (!(propValue instanceof Immutable.Record)) {
          var propType = getPropType(propValue);
          var locationName = location;
          return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js Record."));
        }
        for (var key57 in recordKeys) {
          var checker = recordKeys[key57];
          if (!checker) {
            continue;
          }
          var mutablePropValue = propValue.toObject();
          var error = checker.apply(void 0, [mutablePropValue, key57, componentName, location, "" + propFullName + "." + key57].concat(rest));
          if (error) {
            return error;
          }
        }
      }
      return createChainableTypeChecker(validate2);
    }
    function createShapeTypeChecker(shapeTypes) {
      var immutableClassName = arguments[1] === void 0 ? "Iterable" : arguments[1];
      var immutableClassTypeValidator = arguments[2] === void 0 ? Immutable.Iterable.isIterable : arguments[2];
      function validate2(props3, propName, componentName, location, propFullName) {
        for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
          rest[_key - 5] = arguments[_key];
        }
        var propValue = props3[propName];
        if (!immutableClassTypeValidator(propValue)) {
          var propType = getPropType(propValue);
          var locationName = location;
          return new Error("Invalid " + locationName + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected an Immutable.js " + immutableClassName + "."));
        }
        var mutablePropValue = propValue.toObject();
        for (var key57 in shapeTypes) {
          var checker = shapeTypes[key57];
          if (!checker) {
            continue;
          }
          var error = checker.apply(void 0, [mutablePropValue, key57, componentName, location, "" + propFullName + "." + key57].concat(rest));
          if (error) {
            return error;
          }
        }
      }
      return createChainableTypeChecker(validate2);
    }
    function createShapeChecker(shapeTypes) {
      return createShapeTypeChecker(shapeTypes);
    }
    function createMapContainsChecker(shapeTypes) {
      return createShapeTypeChecker(shapeTypes, "Map", Immutable.Map.isMap);
    }
    function createOrderedMapContainsChecker(shapeTypes) {
      return createShapeTypeChecker(shapeTypes, "OrderedMap", Immutable.OrderedMap.isOrderedMap);
    }
    module.exports = ImmutablePropTypes;
  }
});

// node_modules/lodash/_baseReduce.js
var require_baseReduce = __commonJS({
  "node_modules/lodash/_baseReduce.js"(exports, module) {
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    module.exports = baseReduce;
  }
});

// node_modules/lodash/reduce.js
var require_reduce = __commonJS({
  "node_modules/lodash/reduce.js"(exports, module) {
    var arrayReduce = require_arrayReduce();
    var baseEach = require_baseEach();
    var baseIteratee = require_baseIteratee();
    var baseReduce = require_baseReduce();
    var isArray4 = require_isArray();
    function reduce2(collection, iteratee, accumulator) {
      var func = isArray4(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    module.exports = reduce2;
  }
});

// node_modules/core-js-pure/internals/global-this.js
var require_global_this = __commonJS({
  "node_modules/core-js-pure/internals/global-this.js"(exports, module) {
    "use strict";
    var check2 = function(it2) {
      return it2 && it2.Math === Math && it2;
    };
    module.exports = // eslint-disable-next-line es/no-global-this -- safe
    check2(typeof globalThis == "object" && globalThis) || check2(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
    check2(typeof self == "object" && self) || check2(typeof global == "object" && global) || check2(typeof exports == "object" && exports) || // eslint-disable-next-line no-new-func -- fallback
    /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")();
  }
});

// node_modules/core-js-pure/internals/fails.js
var require_fails = __commonJS({
  "node_modules/core-js-pure/internals/fails.js"(exports, module) {
    "use strict";
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// node_modules/core-js-pure/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "node_modules/core-js-pure/internals/function-bind-native.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      var test4 = (function() {
      }).bind();
      return typeof test4 != "function" || test4.hasOwnProperty("prototype");
    });
  }
});

// node_modules/core-js-pure/internals/function-apply.js
var require_function_apply = __commonJS({
  "node_modules/core-js-pure/internals/function-apply.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply4 = FunctionPrototype.apply;
    var call3 = FunctionPrototype.call;
    module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call3.bind(apply4) : function() {
      return call3.apply(apply4, arguments);
    });
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call3 = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call3, call3);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn2) {
      return function() {
        return call3.apply(fn2, arguments);
      };
    };
  }
});

// node_modules/core-js-pure/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "node_modules/core-js-pure/internals/classof-raw.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toString5 = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it2) {
      return stringSlice(toString5(it2), 8, -1);
    };
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this-clause.js"(exports, module) {
    "use strict";
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(fn2) {
      if (classofRaw(fn2) === "Function") return uncurryThis(fn2);
    };
  }
});

// node_modules/core-js-pure/internals/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/core-js-pure/internals/is-callable.js"(exports, module) {
    "use strict";
    var documentAll = typeof document == "object" && document.all;
    module.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// node_modules/core-js-pure/internals/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/core-js-pure/internals/descriptors.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] !== 7;
    });
  }
});

// node_modules/core-js-pure/internals/function-call.js
var require_function_call = __commonJS({
  "node_modules/core-js-pure/internals/function-call.js"(exports, module) {
    "use strict";
    var NATIVE_BIND = require_function_bind_native();
    var call3 = Function.prototype.call;
    module.exports = NATIVE_BIND ? call3.bind(call3) : function() {
      return call3.apply(call3, arguments);
    };
  }
});

// node_modules/core-js-pure/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "node_modules/core-js-pure/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor3 = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor3 && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor3(this, V);
      return !!descriptor && descriptor.enumerable;
    } : $propertyIsEnumerable;
  }
});

// node_modules/core-js-pure/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "node_modules/core-js-pure/internals/create-property-descriptor.js"(exports, module) {
    "use strict";
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// node_modules/core-js-pure/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "node_modules/core-js-pure/internals/indexed-object.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split3 = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it2) {
      return classof(it2) === "String" ? split3(it2, "") : $Object(it2);
    } : $Object;
  }
});

// node_modules/core-js-pure/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "node_modules/core-js-pure/internals/is-null-or-undefined.js"(exports, module) {
    "use strict";
    module.exports = function(it2) {
      return it2 === null || it2 === void 0;
    };
  }
});

// node_modules/core-js-pure/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "node_modules/core-js-pure/internals/require-object-coercible.js"(exports, module) {
    "use strict";
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it2) {
      if (isNullOrUndefined(it2)) throw new $TypeError("Can't call method on " + it2);
      return it2;
    };
  }
});

// node_modules/core-js-pure/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "node_modules/core-js-pure/internals/to-indexed-object.js"(exports, module) {
    "use strict";
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it2) {
      return IndexedObject(requireObjectCoercible(it2));
    };
  }
});

// node_modules/core-js-pure/internals/is-object.js
var require_is_object = __commonJS({
  "node_modules/core-js-pure/internals/is-object.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    module.exports = function(it2) {
      return typeof it2 == "object" ? it2 !== null : isCallable(it2);
    };
  }
});

// node_modules/core-js-pure/internals/path.js
var require_path = __commonJS({
  "node_modules/core-js-pure/internals/path.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "node_modules/core-js-pure/internals/get-built-in.js"(exports, module) {
    "use strict";
    var path4 = require_path();
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var aFunction = function(variable) {
      return isCallable(variable) ? variable : void 0;
    };
    module.exports = function(namespace2, method) {
      return arguments.length < 2 ? aFunction(path4[namespace2]) || aFunction(globalThis2[namespace2]) : path4[namespace2] && path4[namespace2][method] || globalThis2[namespace2] && globalThis2[namespace2][method];
    };
  }
});

// node_modules/core-js-pure/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-is-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// node_modules/core-js-pure/internals/environment-user-agent.js
var require_environment_user_agent = __commonJS({
  "node_modules/core-js-pure/internals/environment-user-agent.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var navigator2 = globalThis2.navigator;
    var userAgent = navigator2 && navigator2.userAgent;
    module.exports = userAgent ? String(userAgent) : "";
  }
});

// node_modules/core-js-pure/internals/environment-v8-version.js
var require_environment_v8_version = __commonJS({
  "node_modules/core-js-pure/internals/environment-v8-version.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var userAgent = require_environment_user_agent();
    var process3 = globalThis2.process;
    var Deno = globalThis2.Deno;
    var versions2 = process3 && process3.versions || Deno && Deno.version;
    var v8 = versions2 && versions2.v8;
    var match3;
    var version2;
    if (v8) {
      match3 = v8.split(".");
      version2 = match3[0] > 0 && match3[0] < 4 ? 1 : +(match3[0] + match3[1]);
    }
    if (!version2 && userAgent) {
      match3 = userAgent.match(/Edge\/(\d+)/);
      if (!match3 || match3[1] >= 74) {
        match3 = userAgent.match(/Chrome\/(\d+)/);
        if (match3) version2 = +match3[1];
      }
    }
    module.exports = version2;
  }
});

// node_modules/core-js-pure/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "node_modules/core-js-pure/internals/symbol-constructor-detection.js"(exports, module) {
    "use strict";
    var V8_VERSION = require_environment_v8_version();
    var fails = require_fails();
    var globalThis2 = require_global_this();
    var $String = globalThis2.String;
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol("symbol detection");
      return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
      !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// node_modules/core-js-pure/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "node_modules/core-js-pure/internals/use-symbol-as-uid.js"(exports, module) {
    "use strict";
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// node_modules/core-js-pure/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/core-js-pure/internals/is-symbol.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf2 = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it2) {
      return typeof it2 == "symbol";
    } : function(it2) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf2($Symbol.prototype, $Object(it2));
    };
  }
});

// node_modules/core-js-pure/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "node_modules/core-js-pure/internals/try-to-string.js"(exports, module) {
    "use strict";
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// node_modules/core-js-pure/internals/a-callable.js
var require_a_callable = __commonJS({
  "node_modules/core-js-pure/internals/a-callable.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument)) return argument;
      throw new $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// node_modules/core-js-pure/internals/get-method.js
var require_get_method = __commonJS({
  "node_modules/core-js-pure/internals/get-method.js"(exports, module) {
    "use strict";
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V, P2) {
      var func = V[P2];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// node_modules/core-js-pure/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/ordinary-to-primitive.js"(exports, module) {
    "use strict";
    var call3 = require_function_call();
    var isCallable = require_is_callable();
    var isObject6 = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn2, val;
      if (pref === "string" && isCallable(fn2 = input.toString) && !isObject6(val = call3(fn2, input))) return val;
      if (isCallable(fn2 = input.valueOf) && !isObject6(val = call3(fn2, input))) return val;
      if (pref !== "string" && isCallable(fn2 = input.toString) && !isObject6(val = call3(fn2, input))) return val;
      throw new $TypeError("Can't convert object to primitive value");
    };
  }
});

// node_modules/core-js-pure/internals/is-pure.js
var require_is_pure = __commonJS({
  "node_modules/core-js-pure/internals/is-pure.js"(exports, module) {
    "use strict";
    module.exports = true;
  }
});

// node_modules/core-js-pure/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "node_modules/core-js-pure/internals/define-global-property.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var defineProperty2 = Object.defineProperty;
    module.exports = function(key57, value) {
      try {
        defineProperty2(globalThis2, key57, { value, configurable: true, writable: true });
      } catch (error) {
        globalThis2[key57] = value;
      }
      return value;
    };
  }
});

// node_modules/core-js-pure/internals/shared-store.js
var require_shared_store = __commonJS({
  "node_modules/core-js-pure/internals/shared-store.js"(exports, module) {
    "use strict";
    var IS_PURE = require_is_pure();
    var globalThis2 = require_global_this();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = module.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
    (store.versions || (store.versions = [])).push({
      version: "3.39.0",
      mode: IS_PURE ? "pure" : "global",
      copyright: " 2014-2024 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.39.0/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// node_modules/core-js-pure/internals/shared.js
var require_shared = __commonJS({
  "node_modules/core-js-pure/internals/shared.js"(exports, module) {
    "use strict";
    var store = require_shared_store();
    module.exports = function(key57, value) {
      return store[key57] || (store[key57] = value || {});
    };
  }
});

// node_modules/core-js-pure/internals/to-object.js
var require_to_object = __commonJS({
  "node_modules/core-js-pure/internals/to-object.js"(exports, module) {
    "use strict";
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// node_modules/core-js-pure/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/core-js-pure/internals/has-own-property.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty3 = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || function hasOwn2(it2, key57) {
      return hasOwnProperty3(toObject(it2), key57);
    };
  }
});

// node_modules/core-js-pure/internals/uid.js
var require_uid = __commonJS({
  "node_modules/core-js-pure/internals/uid.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString5 = uncurryThis(1 .toString);
    module.exports = function(key57) {
      return "Symbol(" + (key57 === void 0 ? "" : key57) + ")_" + toString5(++id + postfix, 36);
    };
  }
});

// node_modules/core-js-pure/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "node_modules/core-js-pure/internals/well-known-symbol.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var shared = require_shared();
    var hasOwn2 = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var Symbol2 = globalThis2.Symbol;
    var WellKnownSymbolsStore = shared("wks");
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name2) {
      if (!hasOwn2(WellKnownSymbolsStore, name2)) {
        WellKnownSymbolsStore[name2] = NATIVE_SYMBOL && hasOwn2(Symbol2, name2) ? Symbol2[name2] : createWellKnownSymbol("Symbol." + name2);
      }
      return WellKnownSymbolsStore[name2];
    };
  }
});

// node_modules/core-js-pure/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "node_modules/core-js-pure/internals/to-primitive.js"(exports, module) {
    "use strict";
    var call3 = require_function_call();
    var isObject6 = require_is_object();
    var isSymbol2 = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject6(input) || isSymbol2(input)) return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0) pref = "default";
        result = call3(exoticToPrim, input, pref);
        if (!isObject6(result) || isSymbol2(result)) return result;
        throw new $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0) pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// node_modules/core-js-pure/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "node_modules/core-js-pure/internals/to-property-key.js"(exports, module) {
    "use strict";
    var toPrimitive2 = require_to_primitive();
    var isSymbol2 = require_is_symbol();
    module.exports = function(argument) {
      var key57 = toPrimitive2(argument, "string");
      return isSymbol2(key57) ? key57 : key57 + "";
    };
  }
});

// node_modules/core-js-pure/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "node_modules/core-js-pure/internals/document-create-element.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isObject6 = require_is_object();
    var document2 = globalThis2.document;
    var EXISTS = isObject6(document2) && isObject6(document2.createElement);
    module.exports = function(it2) {
      return EXISTS ? document2.createElement(it2) : {};
    };
  }
});

// node_modules/core-js-pure/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "node_modules/core-js-pure/internals/ie8-dom-define.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement3 = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement3("div"), "a", {
        get: function() {
          return 7;
        }
      }).a !== 7;
    });
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-descriptor.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var call3 = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey2 = require_to_property_key();
    var hasOwn2 = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor3(O2, P2) {
      O2 = toIndexedObject(O2);
      P2 = toPropertyKey2(P2);
      if (IE8_DOM_DEFINE) try {
        return $getOwnPropertyDescriptor(O2, P2);
      } catch (error) {
      }
      if (hasOwn2(O2, P2)) return createPropertyDescriptor(!call3(propertyIsEnumerableModule.f, O2, P2), O2[P2]);
    };
  }
});

// node_modules/core-js-pure/internals/is-forced.js
var require_is_forced = __commonJS({
  "node_modules/core-js-pure/internals/is-forced.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = function(feature, detection) {
      var value = data[normalize3(feature)];
      return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    };
    var normalize3 = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// node_modules/core-js-pure/internals/function-bind-context.js
var require_function_bind_context = __commonJS({
  "node_modules/core-js-pure/internals/function-bind-context.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this_clause();
    var aCallable = require_a_callable();
    var NATIVE_BIND = require_function_bind_native();
    var bind3 = uncurryThis(uncurryThis.bind);
    module.exports = function(fn2, that) {
      aCallable(fn2);
      return that === void 0 ? fn2 : NATIVE_BIND ? bind3(fn2, that) : function() {
        return fn2.apply(that, arguments);
      };
    };
  }
});

// node_modules/core-js-pure/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "node_modules/core-js-pure/internals/v8-prototype-define-bug.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype !== 42;
    });
  }
});

// node_modules/core-js-pure/internals/an-object.js
var require_an_object = __commonJS({
  "node_modules/core-js-pure/internals/an-object.js"(exports, module) {
    "use strict";
    var isObject6 = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject6(argument)) return argument;
      throw new $TypeError($String(argument) + " is not an object");
    };
  }
});

// node_modules/core-js-pure/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "node_modules/core-js-pure/internals/object-define-property.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey2 = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty2(O2, P2, Attributes) {
      anObject(O2);
      P2 = toPropertyKey2(P2);
      anObject(Attributes);
      if (typeof O2 === "function" && P2 === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current2 = $getOwnPropertyDescriptor(O2, P2);
        if (current2 && current2[WRITABLE]) {
          O2[P2] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current2[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current2[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O2, P2, Attributes);
    } : $defineProperty : function defineProperty2(O2, P2, Attributes) {
      anObject(O2);
      P2 = toPropertyKey2(P2);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return $defineProperty(O2, P2, Attributes);
      } catch (error) {
      }
      if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
      if ("value" in Attributes) O2[P2] = Attributes.value;
      return O2;
    };
  }
});

// node_modules/core-js-pure/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "node_modules/core-js-pure/internals/create-non-enumerable-property.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object2, key57, value) {
      return definePropertyModule.f(object2, key57, createPropertyDescriptor(1, value));
    } : function(object2, key57, value) {
      object2[key57] = value;
      return object2;
    };
  }
});

// node_modules/core-js-pure/internals/export.js
var require_export = __commonJS({
  "node_modules/core-js-pure/internals/export.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var apply4 = require_function_apply();
    var uncurryThis = require_function_uncurry_this_clause();
    var isCallable = require_is_callable();
    var getOwnPropertyDescriptor3 = require_object_get_own_property_descriptor().f;
    var isForced = require_is_forced();
    var path4 = require_path();
    var bind3 = require_function_bind_context();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn2 = require_has_own_property();
    require_shared_store();
    var wrapConstructor = function(NativeConstructor) {
      var Wrapper = function(a2, b, c2) {
        if (this instanceof Wrapper) {
          switch (arguments.length) {
            case 0:
              return new NativeConstructor();
            case 1:
              return new NativeConstructor(a2);
            case 2:
              return new NativeConstructor(a2, b);
          }
          return new NativeConstructor(a2, b, c2);
        }
        return apply4(NativeConstructor, this, arguments);
      };
      Wrapper.prototype = NativeConstructor.prototype;
      return Wrapper;
    };
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var PROTO = options.proto;
      var nativeSource = GLOBAL ? globalThis2 : STATIC ? globalThis2[TARGET] : globalThis2[TARGET] && globalThis2[TARGET].prototype;
      var target = GLOBAL ? path4 : path4[TARGET] || createNonEnumerableProperty(path4, TARGET, {})[TARGET];
      var targetPrototype = target.prototype;
      var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
      var key57, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
      for (key57 in source) {
        FORCED = isForced(GLOBAL ? key57 : TARGET + (STATIC ? "." : "#") + key57, options.forced);
        USE_NATIVE = !FORCED && nativeSource && hasOwn2(nativeSource, key57);
        targetProperty = target[key57];
        if (USE_NATIVE) if (options.dontCallGetSet) {
          descriptor = getOwnPropertyDescriptor3(nativeSource, key57);
          nativeProperty = descriptor && descriptor.value;
        } else nativeProperty = nativeSource[key57];
        sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key57];
        if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;
        if (options.bind && USE_NATIVE) resultProperty = bind3(sourceProperty, globalThis2);
        else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
        else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
        else resultProperty = sourceProperty;
        if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(resultProperty, "sham", true);
        }
        createNonEnumerableProperty(target, key57, resultProperty);
        if (PROTO) {
          VIRTUAL_PROTOTYPE = TARGET + "Prototype";
          if (!hasOwn2(path4, VIRTUAL_PROTOTYPE)) {
            createNonEnumerableProperty(path4, VIRTUAL_PROTOTYPE, {});
          }
          createNonEnumerableProperty(path4[VIRTUAL_PROTOTYPE], key57, sourceProperty);
          if (options.real && targetPrototype && (FORCED || !targetPrototype[key57])) {
            createNonEnumerableProperty(targetPrototype, key57, sourceProperty);
          }
        }
      }
    };
  }
});

// node_modules/core-js-pure/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "node_modules/core-js-pure/internals/math-trunc.js"(exports, module) {
    "use strict";
    var ceil2 = Math.ceil;
    var floor2 = Math.floor;
    module.exports = Math.trunc || function trunc2(x2) {
      var n = +x2;
      return (n > 0 ? floor2 : ceil2)(n);
    };
  }
});

// node_modules/core-js-pure/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "node_modules/core-js-pure/internals/to-integer-or-infinity.js"(exports, module) {
    "use strict";
    var trunc2 = require_math_trunc();
    module.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc2(number);
    };
  }
});

// node_modules/core-js-pure/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "node_modules/core-js-pure/internals/to-absolute-index.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max3 = Math.max;
    var min3 = Math.min;
    module.exports = function(index, length3) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max3(integer + length3, 0) : min3(integer, length3);
    };
  }
});

// node_modules/core-js-pure/internals/to-length.js
var require_to_length = __commonJS({
  "node_modules/core-js-pure/internals/to-length.js"(exports, module) {
    "use strict";
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min3 = Math.min;
    module.exports = function(argument) {
      var len = toIntegerOrInfinity(argument);
      return len > 0 ? min3(len, 9007199254740991) : 0;
    };
  }
});

// node_modules/core-js-pure/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "node_modules/core-js-pure/internals/length-of-array-like.js"(exports, module) {
    "use strict";
    var toLength = require_to_length();
    module.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// node_modules/core-js-pure/internals/array-includes.js
var require_array_includes = __commonJS({
  "node_modules/core-js-pure/internals/array-includes.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = function(IS_INCLUDES) {
      return function($this, el2, fromIndex) {
        var O2 = toIndexedObject($this);
        var length3 = lengthOfArrayLike(O2);
        if (length3 === 0) return !IS_INCLUDES && -1;
        var index = toAbsoluteIndex(fromIndex, length3);
        var value;
        if (IS_INCLUDES && el2 !== el2) while (length3 > index) {
          value = O2[index++];
          if (value !== value) return true;
        }
        else for (; length3 > index; index++) {
          if ((IS_INCLUDES || index in O2) && O2[index] === el2) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };
    module.exports = {
      // `Array.prototype.includes` method
      // https://tc39.es/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.es/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
  }
});

// node_modules/core-js-pure/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "node_modules/core-js-pure/internals/hidden-keys.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "node_modules/core-js-pure/internals/object-keys-internal.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var hasOwn2 = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf4 = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module.exports = function(object2, names) {
      var O2 = toIndexedObject(object2);
      var i2 = 0;
      var result = [];
      var key57;
      for (key57 in O2) !hasOwn2(hiddenKeys, key57) && hasOwn2(O2, key57) && push(result, key57);
      while (names.length > i2) if (hasOwn2(O2, key57 = names[i2++])) {
        ~indexOf4(result, key57) || push(result, key57);
      }
      return result;
    };
  }
});

// node_modules/core-js-pure/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "node_modules/core-js-pure/internals/enum-bug-keys.js"(exports, module) {
    "use strict";
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// node_modules/core-js-pure/internals/object-keys.js
var require_object_keys = __commonJS({
  "node_modules/core-js-pure/internals/object-keys.js"(exports, module) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || function keys4(O2) {
      return internalObjectKeys(O2, enumBugKeys);
    };
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-symbols.js"(exports) {
    "use strict";
    exports.f = Object.getOwnPropertySymbols;
  }
});

// node_modules/core-js-pure/internals/object-assign.js
var require_object_assign2 = __commonJS({
  "node_modules/core-js-pure/internals/object-assign.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var uncurryThis = require_function_uncurry_this();
    var call3 = require_function_call();
    var fails = require_fails();
    var objectKeys = require_object_keys();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var toObject = require_to_object();
    var IndexedObject = require_indexed_object();
    var $assign = Object.assign;
    var defineProperty2 = Object.defineProperty;
    var concat4 = uncurryThis([].concat);
    module.exports = !$assign || fails(function() {
      if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty2({}, "a", {
        enumerable: true,
        get: function() {
          defineProperty2(this, "b", {
            value: 3,
            enumerable: false
          });
        }
      }), { b: 2 })).b !== 1) return true;
      var A2 = {};
      var B2 = {};
      var symbol = Symbol("assign detection");
      var alphabet = "abcdefghijklmnopqrst";
      A2[symbol] = 7;
      alphabet.split("").forEach(function(chr) {
        B2[chr] = chr;
      });
      return $assign({}, A2)[symbol] !== 7 || objectKeys($assign({}, B2)).join("") !== alphabet;
    }) ? function assign2(target, source) {
      var T3 = toObject(target);
      var argumentsLength = arguments.length;
      var index = 1;
      var getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
      var propertyIsEnumerable = propertyIsEnumerableModule.f;
      while (argumentsLength > index) {
        var S = IndexedObject(arguments[index++]);
        var keys4 = getOwnPropertySymbols2 ? concat4(objectKeys(S), getOwnPropertySymbols2(S)) : objectKeys(S);
        var length3 = keys4.length;
        var j2 = 0;
        var key57;
        while (length3 > j2) {
          key57 = keys4[j2++];
          if (!DESCRIPTORS || call3(propertyIsEnumerable, S, key57)) T3[key57] = S[key57];
        }
      }
      return T3;
    } : $assign;
  }
});

// node_modules/core-js-pure/modules/es.object.assign.js
var require_es_object_assign = __commonJS({
  "node_modules/core-js-pure/modules/es.object.assign.js"() {
    "use strict";
    var $ = require_export();
    var assign2 = require_object_assign2();
    $({ target: "Object", stat: true, arity: 2, forced: Object.assign !== assign2 }, {
      assign: assign2
    });
  }
});

// node_modules/core-js-pure/es/object/assign.js
var require_assign = __commonJS({
  "node_modules/core-js-pure/es/object/assign.js"(exports, module) {
    "use strict";
    require_es_object_assign();
    var path4 = require_path();
    module.exports = path4.Object.assign;
  }
});

// node_modules/core-js-pure/stable/object/assign.js
var require_assign2 = __commonJS({
  "node_modules/core-js-pure/stable/object/assign.js"(exports, module) {
    "use strict";
    var parent = require_assign();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/object/assign.js
var require_assign3 = __commonJS({
  "node_modules/core-js-pure/actual/object/assign.js"(exports, module) {
    "use strict";
    var parent = require_assign2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/object/assign.js
var require_assign4 = __commonJS({
  "node_modules/core-js-pure/full/object/assign.js"(exports, module) {
    "use strict";
    var parent = require_assign3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/object/assign.js
var require_assign5 = __commonJS({
  "node_modules/core-js-pure/features/object/assign.js"(exports, module) {
    "use strict";
    module.exports = require_assign4();
  }
});

// node_modules/core-js-pure/internals/array-slice.js
var require_array_slice = __commonJS({
  "node_modules/core-js-pure/internals/array-slice.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis([].slice);
  }
});

// node_modules/core-js-pure/internals/function-bind.js
var require_function_bind = __commonJS({
  "node_modules/core-js-pure/internals/function-bind.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    var isObject6 = require_is_object();
    var hasOwn2 = require_has_own_property();
    var arraySlice = require_array_slice();
    var NATIVE_BIND = require_function_bind_native();
    var $Function = Function;
    var concat4 = uncurryThis([].concat);
    var join2 = uncurryThis([].join);
    var factories = {};
    var construct4 = function(C2, argsLength, args) {
      if (!hasOwn2(factories, argsLength)) {
        var list4 = [];
        var i2 = 0;
        for (; i2 < argsLength; i2++) list4[i2] = "a[" + i2 + "]";
        factories[argsLength] = $Function("C,a", "return new C(" + join2(list4, ",") + ")");
      }
      return factories[argsLength](C2, args);
    };
    module.exports = NATIVE_BIND ? $Function.bind : function bind3(that) {
      var F2 = aCallable(this);
      var Prototype = F2.prototype;
      var partArgs = arraySlice(arguments, 1);
      var boundFunction = function bound() {
        var args = concat4(partArgs, arraySlice(arguments));
        return this instanceof boundFunction ? construct4(F2, args.length, args) : F2.apply(that, args);
      };
      if (isObject6(Prototype)) boundFunction.prototype = Prototype;
      return boundFunction;
    };
  }
});

// node_modules/core-js-pure/modules/es.function.bind.js
var require_es_function_bind = __commonJS({
  "node_modules/core-js-pure/modules/es.function.bind.js"() {
    "use strict";
    var $ = require_export();
    var bind3 = require_function_bind();
    $({ target: "Function", proto: true, forced: Function.bind !== bind3 }, {
      bind: bind3
    });
  }
});

// node_modules/core-js-pure/internals/get-built-in-prototype-method.js
var require_get_built_in_prototype_method = __commonJS({
  "node_modules/core-js-pure/internals/get-built-in-prototype-method.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var path4 = require_path();
    module.exports = function(CONSTRUCTOR, METHOD) {
      var Namespace2 = path4[CONSTRUCTOR + "Prototype"];
      var pureMethod = Namespace2 && Namespace2[METHOD];
      if (pureMethod) return pureMethod;
      var NativeConstructor = globalThis2[CONSTRUCTOR];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      return NativePrototype && NativePrototype[METHOD];
    };
  }
});

// node_modules/core-js-pure/es/function/virtual/bind.js
var require_bind = __commonJS({
  "node_modules/core-js-pure/es/function/virtual/bind.js"(exports, module) {
    "use strict";
    require_es_function_bind();
    var getBuiltInPrototypeMethod = require_get_built_in_prototype_method();
    module.exports = getBuiltInPrototypeMethod("Function", "bind");
  }
});

// node_modules/core-js-pure/es/instance/bind.js
var require_bind2 = __commonJS({
  "node_modules/core-js-pure/es/instance/bind.js"(exports, module) {
    "use strict";
    var isPrototypeOf2 = require_object_is_prototype_of();
    var method = require_bind();
    var FunctionPrototype = Function.prototype;
    module.exports = function(it2) {
      var own = it2.bind;
      return it2 === FunctionPrototype || isPrototypeOf2(FunctionPrototype, it2) && own === FunctionPrototype.bind ? method : own;
    };
  }
});

// node_modules/core-js-pure/stable/instance/bind.js
var require_bind3 = __commonJS({
  "node_modules/core-js-pure/stable/instance/bind.js"(exports, module) {
    "use strict";
    var parent = require_bind2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/instance/bind.js
var require_bind4 = __commonJS({
  "node_modules/core-js-pure/actual/instance/bind.js"(exports, module) {
    "use strict";
    var parent = require_bind3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/instance/bind.js
var require_bind5 = __commonJS({
  "node_modules/core-js-pure/full/instance/bind.js"(exports, module) {
    "use strict";
    var parent = require_bind4();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/instance/bind.js
var require_bind6 = __commonJS({
  "node_modules/core-js-pure/features/instance/bind.js"(exports, module) {
    "use strict";
    module.exports = require_bind5();
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn2 = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i2 = 0; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key57 in arg) {
          if (hasOwn2.call(arg, key57) && arg[key57]) {
            classes = appendClass(classes, key57);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i2 = 0; i2 < selection.rangeCount; i2++) {
        ranges.push(selection.getRangeAt(i2));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range3) {
            selection.addRange(range3);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy3(text3, options) {
      var debug, message, reselectPrevious, range3, selection, mark2, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range3 = document.createRange();
        selection = document.getSelection();
        mark2 = document.createElement("span");
        mark2.textContent = text3;
        mark2.ariaHidden = "true";
        mark2.style.all = "unset";
        mark2.style.position = "fixed";
        mark2.style.top = 0;
        mark2.style.clip = "rect(0, 0, 0, 0)";
        mark2.style.whiteSpace = "pre";
        mark2.style.webkitUserSelect = "text";
        mark2.style.MozUserSelect = "text";
        mark2.style.msUserSelect = "text";
        mark2.style.userSelect = "text";
        mark2.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text3);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text3);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark2);
        range3.selectNodeContents(mark2);
        selection.addRange(range3);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err2) {
        debug && console.error("unable to copy using execCommand: ", err2);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text3);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err3) {
          debug && console.error("unable to copy using clipboardData: ", err3);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text3);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range3);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark2) {
          document.body.removeChild(mark2);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy3;
  }
});

// node_modules/react-copy-to-clipboard/lib/Component.js
var require_Component = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/Component.js"(exports) {
    "use strict";
    function _typeof11(obj) {
      "@babel/helpers - typeof";
      return _typeof11 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof11(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CopyToClipboard = void 0;
    var _react = _interopRequireDefault(require_react());
    var _copyToClipboard = _interopRequireDefault(require_copy_to_clipboard());
    var _excluded2 = ["text", "onCopy", "options", "children"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys5(object2, enumerableOnly) {
      var keys4 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys4.push.apply(keys4, symbols);
      }
      return keys4;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys5(Object(source), true).forEach(function(key57) {
          _defineProperty6(target, key57, source[key57]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key57) {
          Object.defineProperty(target, key57, Object.getOwnPropertyDescriptor(source, key57));
        });
      }
      return target;
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null) return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded);
      var key57, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key57 = sourceSymbolKeys[i2];
          if (excluded.indexOf(key57) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key57)) continue;
          target[key57] = source[key57];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key57, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key57 = sourceKeys[i2];
        if (excluded.indexOf(key57) >= 0) continue;
        target[key57] = source[key57];
      }
      return target;
    }
    function _classCallCheck4(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties5(target, props3) {
      for (var i2 = 0; i2 < props3.length; i2++) {
        var descriptor = props3[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass4(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties5(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties5(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits3(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf3(subClass, superClass);
    }
    function _setPrototypeOf3(o4, p2) {
      _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf4(o5, p3) {
        o5.__proto__ = p3;
        return o5;
      };
      return _setPrototypeOf3(o4, p2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct2();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf3(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf3(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn3(this, result);
      };
    }
    function _possibleConstructorReturn3(self3, call3) {
      if (call3 && (_typeof11(call3) === "object" || typeof call3 === "function")) {
        return call3;
      } else if (call3 !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized3(self3);
    }
    function _assertThisInitialized3(self3) {
      if (self3 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self3;
    }
    function _isNativeReflectConstruct2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf3(o4) {
      _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf4(o5) {
        return o5.__proto__ || Object.getPrototypeOf(o5);
      };
      return _getPrototypeOf3(o4);
    }
    function _defineProperty6(obj, key57, value) {
      if (key57 in obj) {
        Object.defineProperty(obj, key57, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key57] = value;
      }
      return obj;
    }
    var CopyToClipboard2 = function(_React$PureComponent) {
      _inherits3(CopyToClipboard3, _React$PureComponent);
      var _super = _createSuper(CopyToClipboard3);
      function CopyToClipboard3() {
        var _this;
        _classCallCheck4(this, CopyToClipboard3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty6(_assertThisInitialized3(_this), "onClick", function(event) {
          var _this$props = _this.props, text3 = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
          var elem = _react["default"].Children.only(children);
          var result = (0, _copyToClipboard["default"])(text3, options);
          if (onCopy) {
            onCopy(text3, result);
          }
          if (elem && elem.props && typeof elem.props.onClick === "function") {
            elem.props.onClick(event);
          }
        });
        return _this;
      }
      _createClass4(CopyToClipboard3, [{
        key: "render",
        value: function render2() {
          var _this$props2 = this.props, _text = _this$props2.text, _onCopy = _this$props2.onCopy, _options2 = _this$props2.options, children = _this$props2.children, props3 = _objectWithoutProperties2(_this$props2, _excluded2);
          var elem = _react["default"].Children.only(children);
          return _react["default"].cloneElement(elem, _objectSpread5(_objectSpread5({}, props3), {}, {
            onClick: this.onClick
          }));
        }
      }]);
      return CopyToClipboard3;
    }(_react["default"].PureComponent);
    exports.CopyToClipboard = CopyToClipboard2;
    _defineProperty6(CopyToClipboard2, "defaultProps", {
      onCopy: void 0,
      options: void 0
    });
  }
});

// node_modules/react-copy-to-clipboard/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/index.js"(exports, module) {
    "use strict";
    var _require = require_Component();
    var CopyToClipboard2 = _require.CopyToClipboard;
    CopyToClipboard2.CopyToClipboard = CopyToClipboard2;
    module.exports = CopyToClipboard2;
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber2(wait) || 0;
      if (isObject6(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time2 = now(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject6(value) {
      var type5 = typeof value;
      return !!value && (type5 == "object" || type5 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber2(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject6(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject6(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary2 = reIsBinary.test(value);
      return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce;
  }
});

// node_modules/react-debounce-input/lib/Component.js
var require_Component2 = __commonJS({
  "node_modules/react-debounce-input/lib/Component.js"(exports) {
    "use strict";
    function _typeof11(obj) {
      "@babel/helpers - typeof";
      return _typeof11 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof11(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DebounceInput = void 0;
    var _react = _interopRequireDefault(require_react());
    var _lodash = _interopRequireDefault(require_lodash());
    var _excluded2 = ["element", "onChange", "value", "minLength", "debounceTimeout", "forceNotifyByEnter", "forceNotifyOnBlur", "onKeyDown", "onBlur", "inputRef"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _objectWithoutProperties2(source, excluded) {
      if (source == null) return {};
      var target = _objectWithoutPropertiesLoose2(source, excluded);
      var key57, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key57 = sourceSymbolKeys[i2];
          if (excluded.indexOf(key57) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key57)) continue;
          target[key57] = source[key57];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key57, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key57 = sourceKeys[i2];
        if (excluded.indexOf(key57) >= 0) continue;
        target[key57] = source[key57];
      }
      return target;
    }
    function ownKeys5(object2, enumerableOnly) {
      var keys4 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys4.push.apply(keys4, symbols);
      }
      return keys4;
    }
    function _objectSpread5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys5(Object(source), true).forEach(function(key57) {
          _defineProperty6(target, key57, source[key57]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key57) {
          Object.defineProperty(target, key57, Object.getOwnPropertyDescriptor(source, key57));
        });
      }
      return target;
    }
    function _classCallCheck4(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties5(target, props3) {
      for (var i2 = 0; i2 < props3.length; i2++) {
        var descriptor = props3[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass4(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties5(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties5(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits3(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf3(subClass, superClass);
    }
    function _setPrototypeOf3(o4, p2) {
      _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf4(o5, p3) {
        o5.__proto__ = p3;
        return o5;
      };
      return _setPrototypeOf3(o4, p2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct2();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf3(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf3(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn3(this, result);
      };
    }
    function _possibleConstructorReturn3(self3, call3) {
      if (call3 && (_typeof11(call3) === "object" || typeof call3 === "function")) {
        return call3;
      } else if (call3 !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized3(self3);
    }
    function _assertThisInitialized3(self3) {
      if (self3 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self3;
    }
    function _isNativeReflectConstruct2() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf3(o4) {
      _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf4(o5) {
        return o5.__proto__ || Object.getPrototypeOf(o5);
      };
      return _getPrototypeOf3(o4);
    }
    function _defineProperty6(obj, key57, value) {
      if (key57 in obj) {
        Object.defineProperty(obj, key57, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key57] = value;
      }
      return obj;
    }
    var DebounceInput = function(_React$PureComponent) {
      _inherits3(DebounceInput2, _React$PureComponent);
      var _super = _createSuper(DebounceInput2);
      function DebounceInput2(props3) {
        var _this;
        _classCallCheck4(this, DebounceInput2);
        _this = _super.call(this, props3);
        _defineProperty6(_assertThisInitialized3(_this), "onChange", function(event) {
          event.persist();
          var oldValue = _this.state.value;
          var minLength = _this.props.minLength;
          _this.setState({
            value: event.target.value
          }, function() {
            var value = _this.state.value;
            if (value.length >= minLength) {
              _this.notify(event);
              return;
            }
            if (oldValue.length > value.length) {
              _this.notify(_objectSpread5(_objectSpread5({}, event), {}, {
                target: _objectSpread5(_objectSpread5({}, event.target), {}, {
                  value: ""
                })
              }));
            }
          });
        });
        _defineProperty6(_assertThisInitialized3(_this), "onKeyDown", function(event) {
          if (event.key === "Enter") {
            _this.forceNotify(event);
          }
          var onKeyDown = _this.props.onKeyDown;
          if (onKeyDown) {
            event.persist();
            onKeyDown(event);
          }
        });
        _defineProperty6(_assertThisInitialized3(_this), "onBlur", function(event) {
          _this.forceNotify(event);
          var onBlur = _this.props.onBlur;
          if (onBlur) {
            event.persist();
            onBlur(event);
          }
        });
        _defineProperty6(_assertThisInitialized3(_this), "createNotifier", function(debounceTimeout) {
          if (debounceTimeout < 0) {
            _this.notify = function() {
              return null;
            };
          } else if (debounceTimeout === 0) {
            _this.notify = _this.doNotify;
          } else {
            var debouncedChangeFunc = (0, _lodash["default"])(function(event) {
              _this.isDebouncing = false;
              _this.doNotify(event);
            }, debounceTimeout);
            _this.notify = function(event) {
              _this.isDebouncing = true;
              debouncedChangeFunc(event);
            };
            _this.flush = function() {
              return debouncedChangeFunc.flush();
            };
            _this.cancel = function() {
              _this.isDebouncing = false;
              debouncedChangeFunc.cancel();
            };
          }
        });
        _defineProperty6(_assertThisInitialized3(_this), "doNotify", function() {
          var onChange = _this.props.onChange;
          onChange.apply(void 0, arguments);
        });
        _defineProperty6(_assertThisInitialized3(_this), "forceNotify", function(event) {
          var debounceTimeout = _this.props.debounceTimeout;
          if (!_this.isDebouncing && debounceTimeout > 0) {
            return;
          }
          if (_this.cancel) {
            _this.cancel();
          }
          var value = _this.state.value;
          var minLength = _this.props.minLength;
          if (value.length >= minLength) {
            _this.doNotify(event);
          } else {
            _this.doNotify(_objectSpread5(_objectSpread5({}, event), {}, {
              target: _objectSpread5(_objectSpread5({}, event.target), {}, {
                value
              })
            }));
          }
        });
        _this.isDebouncing = false;
        _this.state = {
          value: typeof props3.value === "undefined" || props3.value === null ? "" : props3.value
        };
        var _debounceTimeout2 = _this.props.debounceTimeout;
        _this.createNotifier(_debounceTimeout2);
        return _this;
      }
      _createClass4(DebounceInput2, [{
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (this.isDebouncing) {
            return;
          }
          var _this$props = this.props, value = _this$props.value, debounceTimeout = _this$props.debounceTimeout;
          var oldTimeout = prevProps.debounceTimeout, oldValue = prevProps.value;
          var stateValue = this.state.value;
          if (typeof value !== "undefined" && oldValue !== value && stateValue !== value) {
            this.setState({
              value
            });
          }
          if (debounceTimeout !== oldTimeout) {
            this.createNotifier(debounceTimeout);
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (this.flush) {
            this.flush();
          }
        }
      }, {
        key: "render",
        value: function render2() {
          var _this$props2 = this.props, element = _this$props2.element, _onChange = _this$props2.onChange, _value2 = _this$props2.value, _minLength = _this$props2.minLength, _debounceTimeout = _this$props2.debounceTimeout, forceNotifyByEnter = _this$props2.forceNotifyByEnter, forceNotifyOnBlur = _this$props2.forceNotifyOnBlur, onKeyDown = _this$props2.onKeyDown, onBlur = _this$props2.onBlur, inputRef = _this$props2.inputRef, props3 = _objectWithoutProperties2(_this$props2, _excluded2);
          var value = this.state.value;
          var maybeOnKeyDown;
          if (forceNotifyByEnter) {
            maybeOnKeyDown = {
              onKeyDown: this.onKeyDown
            };
          } else if (onKeyDown) {
            maybeOnKeyDown = {
              onKeyDown
            };
          } else {
            maybeOnKeyDown = {};
          }
          var maybeOnBlur;
          if (forceNotifyOnBlur) {
            maybeOnBlur = {
              onBlur: this.onBlur
            };
          } else if (onBlur) {
            maybeOnBlur = {
              onBlur
            };
          } else {
            maybeOnBlur = {};
          }
          var maybeRef = inputRef ? {
            ref: inputRef
          } : {};
          return _react["default"].createElement(element, _objectSpread5(_objectSpread5(_objectSpread5(_objectSpread5({}, props3), {}, {
            onChange: this.onChange,
            value
          }, maybeOnKeyDown), maybeOnBlur), maybeRef));
        }
      }]);
      return DebounceInput2;
    }(_react["default"].PureComponent);
    exports.DebounceInput = DebounceInput;
    _defineProperty6(DebounceInput, "defaultProps", {
      element: "input",
      type: "text",
      onKeyDown: void 0,
      onBlur: void 0,
      value: void 0,
      minLength: 0,
      debounceTimeout: 100,
      forceNotifyByEnter: true,
      forceNotifyOnBlur: true,
      inputRef: void 0
    });
  }
});

// node_modules/react-debounce-input/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/react-debounce-input/lib/index.js"(exports, module) {
    "use strict";
    var _require = require_Component2();
    var DebounceInput = _require.DebounceInput;
    DebounceInput.DebounceInput = DebounceInput;
    module.exports = DebounceInput;
  }
});

// node_modules/swagger-ui/node_modules/ret/lib/types.js
var require_types = __commonJS({
  "node_modules/swagger-ui/node_modules/ret/lib/types.js"(exports, module) {
    module.exports = {
      ROOT: 0,
      GROUP: 1,
      POSITION: 2,
      SET: 3,
      RANGE: 4,
      REPETITION: 5,
      REFERENCE: 6,
      CHAR: 7
    };
  }
});

// node_modules/swagger-ui/node_modules/ret/lib/sets.js
var require_sets = __commonJS({
  "node_modules/swagger-ui/node_modules/ret/lib/sets.js"(exports) {
    var types2 = require_types();
    var INTS = () => [{ type: types2.RANGE, from: 48, to: 57 }];
    var WORDS = () => {
      return [
        { type: types2.CHAR, value: 95 },
        { type: types2.RANGE, from: 97, to: 122 },
        { type: types2.RANGE, from: 65, to: 90 }
      ].concat(INTS());
    };
    var WHITESPACE = () => {
      return [
        { type: types2.CHAR, value: 9 },
        { type: types2.CHAR, value: 10 },
        { type: types2.CHAR, value: 11 },
        { type: types2.CHAR, value: 12 },
        { type: types2.CHAR, value: 13 },
        { type: types2.CHAR, value: 32 },
        { type: types2.CHAR, value: 160 },
        { type: types2.CHAR, value: 5760 },
        { type: types2.RANGE, from: 8192, to: 8202 },
        { type: types2.CHAR, value: 8232 },
        { type: types2.CHAR, value: 8233 },
        { type: types2.CHAR, value: 8239 },
        { type: types2.CHAR, value: 8287 },
        { type: types2.CHAR, value: 12288 },
        { type: types2.CHAR, value: 65279 }
      ];
    };
    var NOTANYCHAR = () => {
      return [
        { type: types2.CHAR, value: 10 },
        { type: types2.CHAR, value: 13 },
        { type: types2.CHAR, value: 8232 },
        { type: types2.CHAR, value: 8233 }
      ];
    };
    exports.words = () => ({ type: types2.SET, set: WORDS(), not: false });
    exports.notWords = () => ({ type: types2.SET, set: WORDS(), not: true });
    exports.ints = () => ({ type: types2.SET, set: INTS(), not: false });
    exports.notInts = () => ({ type: types2.SET, set: INTS(), not: true });
    exports.whitespace = () => ({ type: types2.SET, set: WHITESPACE(), not: false });
    exports.notWhitespace = () => ({ type: types2.SET, set: WHITESPACE(), not: true });
    exports.anyChar = () => ({ type: types2.SET, set: NOTANYCHAR(), not: true });
  }
});

// node_modules/swagger-ui/node_modules/ret/lib/util.js
var require_util = __commonJS({
  "node_modules/swagger-ui/node_modules/ret/lib/util.js"(exports) {
    var types2 = require_types();
    var sets = require_sets();
    var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
    var SLSH = { "0": 0, "t": 9, "n": 10, "v": 11, "f": 12, "r": 13 };
    exports.strToChars = function(str2) {
      var chars_regex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
      str2 = str2.replace(chars_regex, function(s2, b, lbs, a16, b16, c8, dctrl, eslsh) {
        if (lbs) {
          return s2;
        }
        var code2 = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : c8 ? parseInt(c8, 8) : dctrl ? CTRL.indexOf(dctrl) : SLSH[eslsh];
        var c2 = String.fromCharCode(code2);
        if (/[[\]{}^$.|?*+()]/.test(c2)) {
          c2 = "\\" + c2;
        }
        return c2;
      });
      return str2;
    };
    exports.tokenizeClass = (str2, regexpStr) => {
      var tokens = [];
      var regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?([^])/g;
      var rs2, c2;
      while ((rs2 = regexp.exec(str2)) != null) {
        if (rs2[1]) {
          tokens.push(sets.words());
        } else if (rs2[2]) {
          tokens.push(sets.ints());
        } else if (rs2[3]) {
          tokens.push(sets.whitespace());
        } else if (rs2[4]) {
          tokens.push(sets.notWords());
        } else if (rs2[5]) {
          tokens.push(sets.notInts());
        } else if (rs2[6]) {
          tokens.push(sets.notWhitespace());
        } else if (rs2[7]) {
          tokens.push({
            type: types2.RANGE,
            from: (rs2[8] || rs2[9]).charCodeAt(0),
            to: rs2[10].charCodeAt(0)
          });
        } else if (c2 = rs2[12]) {
          tokens.push({
            type: types2.CHAR,
            value: c2.charCodeAt(0)
          });
        } else {
          return [tokens, regexp.lastIndex];
        }
      }
      exports.error(regexpStr, "Unterminated character class");
    };
    exports.error = (regexp, msg) => {
      throw new SyntaxError("Invalid regular expression: /" + regexp + "/: " + msg);
    };
  }
});

// node_modules/swagger-ui/node_modules/ret/lib/positions.js
var require_positions = __commonJS({
  "node_modules/swagger-ui/node_modules/ret/lib/positions.js"(exports) {
    var types2 = require_types();
    exports.wordBoundary = () => ({ type: types2.POSITION, value: "b" });
    exports.nonWordBoundary = () => ({ type: types2.POSITION, value: "B" });
    exports.begin = () => ({ type: types2.POSITION, value: "^" });
    exports.end = () => ({ type: types2.POSITION, value: "$" });
  }
});

// node_modules/swagger-ui/node_modules/ret/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/swagger-ui/node_modules/ret/lib/index.js"(exports, module) {
    var util2 = require_util();
    var types2 = require_types();
    var sets = require_sets();
    var positions = require_positions();
    module.exports = (regexpStr) => {
      var i2 = 0, l2, c2, start = { type: types2.ROOT, stack: [] }, lastGroup = start, last2 = start.stack, groupStack = [];
      var repeatErr = (i3) => {
        util2.error(regexpStr, `Nothing to repeat at column ${i3 - 1}`);
      };
      var str2 = util2.strToChars(regexpStr);
      l2 = str2.length;
      while (i2 < l2) {
        c2 = str2[i2++];
        switch (c2) {
          case "\\":
            c2 = str2[i2++];
            switch (c2) {
              case "b":
                last2.push(positions.wordBoundary());
                break;
              case "B":
                last2.push(positions.nonWordBoundary());
                break;
              case "w":
                last2.push(sets.words());
                break;
              case "W":
                last2.push(sets.notWords());
                break;
              case "d":
                last2.push(sets.ints());
                break;
              case "D":
                last2.push(sets.notInts());
                break;
              case "s":
                last2.push(sets.whitespace());
                break;
              case "S":
                last2.push(sets.notWhitespace());
                break;
              default:
                if (/\d/.test(c2)) {
                  last2.push({ type: types2.REFERENCE, value: parseInt(c2, 10) });
                } else {
                  last2.push({ type: types2.CHAR, value: c2.charCodeAt(0) });
                }
            }
            break;
          case "^":
            last2.push(positions.begin());
            break;
          case "$":
            last2.push(positions.end());
            break;
          case "[":
            var not3;
            if (str2[i2] === "^") {
              not3 = true;
              i2++;
            } else {
              not3 = false;
            }
            var classTokens = util2.tokenizeClass(str2.slice(i2), regexpStr);
            i2 += classTokens[1];
            last2.push({
              type: types2.SET,
              set: classTokens[0],
              not: not3
            });
            break;
          case ".":
            last2.push(sets.anyChar());
            break;
          case "(":
            var group = {
              type: types2.GROUP,
              stack: [],
              remember: true
            };
            c2 = str2[i2];
            if (c2 === "?") {
              c2 = str2[i2 + 1];
              i2 += 2;
              if (c2 === "=") {
                group.followedBy = true;
              } else if (c2 === "!") {
                group.notFollowedBy = true;
              } else if (c2 !== ":") {
                util2.error(
                  regexpStr,
                  `Invalid group, character '${c2}' after '?' at column ${i2 - 1}`
                );
              }
              group.remember = false;
            }
            last2.push(group);
            groupStack.push(lastGroup);
            lastGroup = group;
            last2 = group.stack;
            break;
          case ")":
            if (groupStack.length === 0) {
              util2.error(regexpStr, `Unmatched ) at column ${i2 - 1}`);
            }
            lastGroup = groupStack.pop();
            last2 = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
            break;
          case "|":
            if (!lastGroup.options) {
              lastGroup.options = [lastGroup.stack];
              delete lastGroup.stack;
            }
            var stack = [];
            lastGroup.options.push(stack);
            last2 = stack;
            break;
          case "{":
            var rs2 = /^(\d+)(,(\d+)?)?\}/.exec(str2.slice(i2)), min3, max3;
            if (rs2 !== null) {
              if (last2.length === 0) {
                repeatErr(i2);
              }
              min3 = parseInt(rs2[1], 10);
              max3 = rs2[2] ? rs2[3] ? parseInt(rs2[3], 10) : Infinity : min3;
              i2 += rs2[0].length;
              last2.push({
                type: types2.REPETITION,
                min: min3,
                max: max3,
                value: last2.pop()
              });
            } else {
              last2.push({
                type: types2.CHAR,
                value: 123
              });
            }
            break;
          case "?":
            if (last2.length === 0) {
              repeatErr(i2);
            }
            last2.push({
              type: types2.REPETITION,
              min: 0,
              max: 1,
              value: last2.pop()
            });
            break;
          case "+":
            if (last2.length === 0) {
              repeatErr(i2);
            }
            last2.push({
              type: types2.REPETITION,
              min: 1,
              max: Infinity,
              value: last2.pop()
            });
            break;
          case "*":
            if (last2.length === 0) {
              repeatErr(i2);
            }
            last2.push({
              type: types2.REPETITION,
              min: 0,
              max: Infinity,
              value: last2.pop()
            });
            break;
          default:
            last2.push({
              type: types2.CHAR,
              value: c2.charCodeAt(0)
            });
        }
      }
      if (groupStack.length !== 0) {
        util2.error(regexpStr, "Unterminated group");
      }
      return start;
    };
    module.exports.types = types2;
  }
});

// node_modules/drange/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/drange/lib/index.js"(exports, module) {
    "use strict";
    var SubRange = class _SubRange {
      constructor(low, high) {
        this.low = low;
        this.high = high;
        this.length = 1 + high - low;
      }
      overlaps(range3) {
        return !(this.high < range3.low || this.low > range3.high);
      }
      touches(range3) {
        return !(this.high + 1 < range3.low || this.low - 1 > range3.high);
      }
      // Returns inclusive combination of SubRanges as a SubRange.
      add(range3) {
        return new _SubRange(
          Math.min(this.low, range3.low),
          Math.max(this.high, range3.high)
        );
      }
      // Returns subtraction of SubRanges as an array of SubRanges.
      // (There's a case where subtraction divides it in 2)
      subtract(range3) {
        if (range3.low <= this.low && range3.high >= this.high) {
          return [];
        } else if (range3.low > this.low && range3.high < this.high) {
          return [
            new _SubRange(this.low, range3.low - 1),
            new _SubRange(range3.high + 1, this.high)
          ];
        } else if (range3.low <= this.low) {
          return [new _SubRange(range3.high + 1, this.high)];
        } else {
          return [new _SubRange(this.low, range3.low - 1)];
        }
      }
      toString() {
        return this.low == this.high ? this.low.toString() : this.low + "-" + this.high;
      }
    };
    var DRange = class _DRange {
      constructor(a2, b) {
        this.ranges = [];
        this.length = 0;
        if (a2 != null) this.add(a2, b);
      }
      _update_length() {
        this.length = this.ranges.reduce((previous, range3) => {
          return previous + range3.length;
        }, 0);
      }
      add(a2, b) {
        var _add = (subrange) => {
          var i2 = 0;
          while (i2 < this.ranges.length && !subrange.touches(this.ranges[i2])) {
            i2++;
          }
          var newRanges = this.ranges.slice(0, i2);
          while (i2 < this.ranges.length && subrange.touches(this.ranges[i2])) {
            subrange = subrange.add(this.ranges[i2]);
            i2++;
          }
          newRanges.push(subrange);
          this.ranges = newRanges.concat(this.ranges.slice(i2));
          this._update_length();
        };
        if (a2 instanceof _DRange) {
          a2.ranges.forEach(_add);
        } else {
          if (b == null) b = a2;
          _add(new SubRange(a2, b));
        }
        return this;
      }
      subtract(a2, b) {
        var _subtract = (subrange) => {
          var i2 = 0;
          while (i2 < this.ranges.length && !subrange.overlaps(this.ranges[i2])) {
            i2++;
          }
          var newRanges = this.ranges.slice(0, i2);
          while (i2 < this.ranges.length && subrange.overlaps(this.ranges[i2])) {
            newRanges = newRanges.concat(this.ranges[i2].subtract(subrange));
            i2++;
          }
          this.ranges = newRanges.concat(this.ranges.slice(i2));
          this._update_length();
        };
        if (a2 instanceof _DRange) {
          a2.ranges.forEach(_subtract);
        } else {
          if (b == null) b = a2;
          _subtract(new SubRange(a2, b));
        }
        return this;
      }
      intersect(a2, b) {
        var newRanges = [];
        var _intersect = (subrange) => {
          var i2 = 0;
          while (i2 < this.ranges.length && !subrange.overlaps(this.ranges[i2])) {
            i2++;
          }
          while (i2 < this.ranges.length && subrange.overlaps(this.ranges[i2])) {
            var low = Math.max(this.ranges[i2].low, subrange.low);
            var high = Math.min(this.ranges[i2].high, subrange.high);
            newRanges.push(new SubRange(low, high));
            i2++;
          }
        };
        if (a2 instanceof _DRange) {
          a2.ranges.forEach(_intersect);
        } else {
          if (b == null) b = a2;
          _intersect(new SubRange(a2, b));
        }
        this.ranges = newRanges;
        this._update_length();
        return this;
      }
      index(index) {
        var i2 = 0;
        while (i2 < this.ranges.length && this.ranges[i2].length <= index) {
          index -= this.ranges[i2].length;
          i2++;
        }
        return this.ranges[i2].low + index;
      }
      toString() {
        return "[ " + this.ranges.join(", ") + " ]";
      }
      clone() {
        return new _DRange(this);
      }
      numbers() {
        return this.ranges.reduce((result, subrange) => {
          var i2 = subrange.low;
          while (i2 <= subrange.high) {
            result.push(i2);
            i2++;
          }
          return result;
        }, []);
      }
      subranges() {
        return this.ranges.map((subrange) => ({
          low: subrange.low,
          high: subrange.high,
          length: 1 + subrange.high - subrange.low
        }));
      }
    };
    module.exports = DRange;
  }
});

// node_modules/swagger-ui/node_modules/randexp/lib/randexp.js
var require_randexp = __commonJS({
  "node_modules/swagger-ui/node_modules/randexp/lib/randexp.js"(exports, module) {
    var ret = require_lib3();
    var DRange = require_lib4();
    var types2 = ret.types;
    module.exports = class RandExp {
      /**
       * @constructor
       * @param {RegExp|String} regexp
       * @param {String} m
       */
      constructor(regexp, m2) {
        this._setDefaults(regexp);
        if (regexp instanceof RegExp) {
          this.ignoreCase = regexp.ignoreCase;
          this.multiline = regexp.multiline;
          regexp = regexp.source;
        } else if (typeof regexp === "string") {
          this.ignoreCase = m2 && m2.indexOf("i") !== -1;
          this.multiline = m2 && m2.indexOf("m") !== -1;
        } else {
          throw new Error("Expected a regexp or string");
        }
        this.tokens = ret(regexp);
      }
      /**
       * Checks if some custom properties have been set for this regexp.
       *
       * @param {RandExp} randexp
       * @param {RegExp} regexp
       */
      _setDefaults(regexp) {
        this.max = regexp.max != null ? regexp.max : RandExp.prototype.max != null ? RandExp.prototype.max : 100;
        this.defaultRange = regexp.defaultRange ? regexp.defaultRange : this.defaultRange.clone();
        if (regexp.randInt) {
          this.randInt = regexp.randInt;
        }
      }
      /**
       * Generates the random string.
       *
       * @return {String}
       */
      gen() {
        return this._gen(this.tokens, []);
      }
      /**
       * Generate random string modeled after given tokens.
       *
       * @param {Object} token
       * @param {Array.<String>} groups
       * @return {String}
       */
      _gen(token, groups) {
        var stack, str2, n, i2, l2;
        switch (token.type) {
          case types2.ROOT:
          case types2.GROUP:
            if (token.followedBy || token.notFollowedBy) {
              return "";
            }
            if (token.remember && token.groupNumber === void 0) {
              token.groupNumber = groups.push(null) - 1;
            }
            stack = token.options ? this._randSelect(token.options) : token.stack;
            str2 = "";
            for (i2 = 0, l2 = stack.length; i2 < l2; i2++) {
              str2 += this._gen(stack[i2], groups);
            }
            if (token.remember) {
              groups[token.groupNumber] = str2;
            }
            return str2;
          case types2.POSITION:
            return "";
          case types2.SET:
            var expandedSet = this._expand(token);
            if (!expandedSet.length) {
              return "";
            }
            return String.fromCharCode(this._randSelect(expandedSet));
          case types2.REPETITION:
            n = this.randInt(
              token.min,
              token.max === Infinity ? token.min + this.max : token.max
            );
            str2 = "";
            for (i2 = 0; i2 < n; i2++) {
              str2 += this._gen(token.value, groups);
            }
            return str2;
          case types2.REFERENCE:
            return groups[token.value - 1] || "";
          case types2.CHAR:
            var code2 = this.ignoreCase && this._randBool() ? this._toOtherCase(token.value) : token.value;
            return String.fromCharCode(code2);
        }
      }
      /**
       * If code is alphabetic, converts to other case.
       * If not alphabetic, returns back code.
       *
       * @param {Number} code
       * @return {Number}
       */
      _toOtherCase(code2) {
        return code2 + (97 <= code2 && code2 <= 122 ? -32 : 65 <= code2 && code2 <= 90 ? 32 : 0);
      }
      /**
       * Randomly returns a true or false value.
       *
       * @return {Boolean}
       */
      _randBool() {
        return !this.randInt(0, 1);
      }
      /**
       * Randomly selects and returns a value from the array.
       *
       * @param {Array.<Object>} arr
       * @return {Object}
       */
      _randSelect(arr) {
        if (arr instanceof DRange) {
          return arr.index(this.randInt(0, arr.length - 1));
        }
        return arr[this.randInt(0, arr.length - 1)];
      }
      /**
       * expands a token to a DiscontinuousRange of characters which has a
       * length and an index function (for random selecting)
       *
       * @param {Object} token
       * @return {DiscontinuousRange}
       */
      _expand(token) {
        if (token.type === ret.types.CHAR) {
          return new DRange(token.value);
        } else if (token.type === ret.types.RANGE) {
          return new DRange(token.from, token.to);
        } else {
          let drange = new DRange();
          for (let i2 = 0; i2 < token.set.length; i2++) {
            let subrange = this._expand(token.set[i2]);
            drange.add(subrange);
            if (this.ignoreCase) {
              for (let j2 = 0; j2 < subrange.length; j2++) {
                let code2 = subrange.index(j2);
                let otherCaseCode = this._toOtherCase(code2);
                if (code2 !== otherCaseCode) {
                  drange.add(otherCaseCode);
                }
              }
            }
          }
          if (token.not) {
            return this.defaultRange.clone().subtract(drange);
          } else {
            return this.defaultRange.clone().intersect(drange);
          }
        }
      }
      /**
       * Randomly generates and returns a number between a and b (inclusive).
       *
       * @param {Number} a
       * @param {Number} b
       * @return {Number}
       */
      randInt(a2, b) {
        return a2 + Math.floor(Math.random() * (1 + b - a2));
      }
      /**
       * Default range of characters to generate from.
       */
      get defaultRange() {
        return this._range = this._range || new DRange(32, 126);
      }
      set defaultRange(range3) {
        this._range = range3;
      }
      /**
       *
       * Enables use of randexp with a shorter call.
       *
       * @param {RegExp|String| regexp}
       * @param {String} m
       * @return {String}
       */
      static randexp(regexp, m2) {
        var randexp;
        if (typeof regexp === "string") {
          regexp = new RegExp(regexp, m2);
        }
        if (regexp._randexp === void 0) {
          randexp = new RandExp(regexp, m2);
          regexp._randexp = randexp;
        } else {
          randexp = regexp._randexp;
          randexp._setDefaults(regexp);
        }
        return randexp.gen();
      }
      /**
       * Enables sugary /regexp/.gen syntax.
       */
      static sugar() {
        RegExp.prototype.gen = function() {
          return RandExp.randexp(this);
        };
      }
    };
  }
});

// node_modules/lodash/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/lodash/isEmpty.js"(exports, module) {
    var baseKeys = require_baseKeys();
    var getTag = require_getTag();
    var isArguments = require_isArguments();
    var isArray4 = require_isArray();
    var isArrayLike3 = require_isArrayLike();
    var isBuffer = require_isBuffer();
    var isPrototype = require_isPrototype();
    var isTypedArray = require_isTypedArray();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function isEmpty4(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike3(value) && (isArray4(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key57 in value) {
        if (hasOwnProperty3.call(value, key57)) {
          return false;
        }
      }
      return true;
    }
    module.exports = isEmpty4;
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isArray4 = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString4(value) {
      return typeof value == "string" || !isArray4(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module.exports = isString4;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports, module) {
    var root = require_root();
    var now = function() {
      return root.Date.now();
    };
    module.exports = now;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports, module) {
    var isObject6 = require_isObject();
    var now = require_now();
    var toNumber2 = require_toNumber();
    var FUNC_ERROR_TEXT = "Expected a function";
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber2(wait) || 0;
      if (isObject6(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time2) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time2;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time2) {
        lastInvokeTime = time2;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time2) : result;
      }
      function remainingWait(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time2) {
        var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time2 = now();
        if (shouldInvoke(time2)) {
          return trailingEdge(time2);
        }
        timerId = setTimeout(timerExpired, remainingWait(time2));
      }
      function trailingEdge(time2) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time2);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time2 = now(), isInvoking = shouldInvoke(time2);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time2;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    module.exports = debounce;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports, module) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject6 = require_isObject();
    var toKey = require_toKey();
    function baseSet(object2, path4, value, customizer) {
      if (!isObject6(object2)) {
        return object2;
      }
      path4 = castPath(path4, object2);
      var index = -1, length3 = path4.length, lastIndex = length3 - 1, nested = object2;
      while (nested != null && ++index < length3) {
        var key57 = toKey(path4[index]), newValue = value;
        if (key57 === "__proto__" || key57 === "constructor" || key57 === "prototype") {
          return object2;
        }
        if (index != lastIndex) {
          var objValue = nested[key57];
          newValue = customizer ? customizer(objValue, key57, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject6(objValue) ? objValue : isIndex(path4[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key57, newValue);
        nested = nested[key57];
      }
      return object2;
    }
    module.exports = baseSet;
  }
});

// node_modules/lodash/set.js
var require_set = __commonJS({
  "node_modules/lodash/set.js"(exports, module) {
    var baseSet = require_baseSet();
    function set4(object2, path4, value) {
      return object2 == null ? object2 : baseSet(object2, path4, value);
    }
    module.exports = set4;
  }
});

// node_modules/lodash/fp/_mapping.js
var require_mapping = __commonJS({
  "node_modules/lodash/fp/_mapping.js"(exports) {
    exports.aliasToReal = {
      // Lodash aliases.
      "each": "forEach",
      "eachRight": "forEachRight",
      "entries": "toPairs",
      "entriesIn": "toPairsIn",
      "extend": "assignIn",
      "extendAll": "assignInAll",
      "extendAllWith": "assignInAllWith",
      "extendWith": "assignInWith",
      "first": "head",
      // Methods that are curried variants of others.
      "conforms": "conformsTo",
      "matches": "isMatch",
      "property": "get",
      // Ramda aliases.
      "__": "placeholder",
      "F": "stubFalse",
      "T": "stubTrue",
      "all": "every",
      "allPass": "overEvery",
      "always": "constant",
      "any": "some",
      "anyPass": "overSome",
      "apply": "spread",
      "assoc": "set",
      "assocPath": "set",
      "complement": "negate",
      "compose": "flowRight",
      "contains": "includes",
      "dissoc": "unset",
      "dissocPath": "unset",
      "dropLast": "dropRight",
      "dropLastWhile": "dropRightWhile",
      "equals": "isEqual",
      "identical": "eq",
      "indexBy": "keyBy",
      "init": "initial",
      "invertObj": "invert",
      "juxt": "over",
      "omitAll": "omit",
      "nAry": "ary",
      "path": "get",
      "pathEq": "matchesProperty",
      "pathOr": "getOr",
      "paths": "at",
      "pickAll": "pick",
      "pipe": "flow",
      "pluck": "map",
      "prop": "get",
      "propEq": "matchesProperty",
      "propOr": "getOr",
      "props": "at",
      "symmetricDifference": "xor",
      "symmetricDifferenceBy": "xorBy",
      "symmetricDifferenceWith": "xorWith",
      "takeLast": "takeRight",
      "takeLastWhile": "takeRightWhile",
      "unapply": "rest",
      "unnest": "flatten",
      "useWith": "overArgs",
      "where": "conformsTo",
      "whereEq": "isMatch",
      "zipObj": "zipObject"
    };
    exports.aryMethod = {
      "1": [
        "assignAll",
        "assignInAll",
        "attempt",
        "castArray",
        "ceil",
        "create",
        "curry",
        "curryRight",
        "defaultsAll",
        "defaultsDeepAll",
        "floor",
        "flow",
        "flowRight",
        "fromPairs",
        "invert",
        "iteratee",
        "memoize",
        "method",
        "mergeAll",
        "methodOf",
        "mixin",
        "nthArg",
        "over",
        "overEvery",
        "overSome",
        "rest",
        "reverse",
        "round",
        "runInContext",
        "spread",
        "template",
        "trim",
        "trimEnd",
        "trimStart",
        "uniqueId",
        "words",
        "zipAll"
      ],
      "2": [
        "add",
        "after",
        "ary",
        "assign",
        "assignAllWith",
        "assignIn",
        "assignInAllWith",
        "at",
        "before",
        "bind",
        "bindAll",
        "bindKey",
        "chunk",
        "cloneDeepWith",
        "cloneWith",
        "concat",
        "conformsTo",
        "countBy",
        "curryN",
        "curryRightN",
        "debounce",
        "defaults",
        "defaultsDeep",
        "defaultTo",
        "delay",
        "difference",
        "divide",
        "drop",
        "dropRight",
        "dropRightWhile",
        "dropWhile",
        "endsWith",
        "eq",
        "every",
        "filter",
        "find",
        "findIndex",
        "findKey",
        "findLast",
        "findLastIndex",
        "findLastKey",
        "flatMap",
        "flatMapDeep",
        "flattenDepth",
        "forEach",
        "forEachRight",
        "forIn",
        "forInRight",
        "forOwn",
        "forOwnRight",
        "get",
        "groupBy",
        "gt",
        "gte",
        "has",
        "hasIn",
        "includes",
        "indexOf",
        "intersection",
        "invertBy",
        "invoke",
        "invokeMap",
        "isEqual",
        "isMatch",
        "join",
        "keyBy",
        "lastIndexOf",
        "lt",
        "lte",
        "map",
        "mapKeys",
        "mapValues",
        "matchesProperty",
        "maxBy",
        "meanBy",
        "merge",
        "mergeAllWith",
        "minBy",
        "multiply",
        "nth",
        "omit",
        "omitBy",
        "overArgs",
        "pad",
        "padEnd",
        "padStart",
        "parseInt",
        "partial",
        "partialRight",
        "partition",
        "pick",
        "pickBy",
        "propertyOf",
        "pull",
        "pullAll",
        "pullAt",
        "random",
        "range",
        "rangeRight",
        "rearg",
        "reject",
        "remove",
        "repeat",
        "restFrom",
        "result",
        "sampleSize",
        "some",
        "sortBy",
        "sortedIndex",
        "sortedIndexOf",
        "sortedLastIndex",
        "sortedLastIndexOf",
        "sortedUniqBy",
        "split",
        "spreadFrom",
        "startsWith",
        "subtract",
        "sumBy",
        "take",
        "takeRight",
        "takeRightWhile",
        "takeWhile",
        "tap",
        "throttle",
        "thru",
        "times",
        "trimChars",
        "trimCharsEnd",
        "trimCharsStart",
        "truncate",
        "union",
        "uniqBy",
        "uniqWith",
        "unset",
        "unzipWith",
        "without",
        "wrap",
        "xor",
        "zip",
        "zipObject",
        "zipObjectDeep"
      ],
      "3": [
        "assignInWith",
        "assignWith",
        "clamp",
        "differenceBy",
        "differenceWith",
        "findFrom",
        "findIndexFrom",
        "findLastFrom",
        "findLastIndexFrom",
        "getOr",
        "includesFrom",
        "indexOfFrom",
        "inRange",
        "intersectionBy",
        "intersectionWith",
        "invokeArgs",
        "invokeArgsMap",
        "isEqualWith",
        "isMatchWith",
        "flatMapDepth",
        "lastIndexOfFrom",
        "mergeWith",
        "orderBy",
        "padChars",
        "padCharsEnd",
        "padCharsStart",
        "pullAllBy",
        "pullAllWith",
        "rangeStep",
        "rangeStepRight",
        "reduce",
        "reduceRight",
        "replace",
        "set",
        "slice",
        "sortedIndexBy",
        "sortedLastIndexBy",
        "transform",
        "unionBy",
        "unionWith",
        "update",
        "xorBy",
        "xorWith",
        "zipWith"
      ],
      "4": [
        "fill",
        "setWith",
        "updateWith"
      ]
    };
    exports.aryRearg = {
      "2": [1, 0],
      "3": [2, 0, 1],
      "4": [3, 2, 0, 1]
    };
    exports.iterateeAry = {
      "dropRightWhile": 1,
      "dropWhile": 1,
      "every": 1,
      "filter": 1,
      "find": 1,
      "findFrom": 1,
      "findIndex": 1,
      "findIndexFrom": 1,
      "findKey": 1,
      "findLast": 1,
      "findLastFrom": 1,
      "findLastIndex": 1,
      "findLastIndexFrom": 1,
      "findLastKey": 1,
      "flatMap": 1,
      "flatMapDeep": 1,
      "flatMapDepth": 1,
      "forEach": 1,
      "forEachRight": 1,
      "forIn": 1,
      "forInRight": 1,
      "forOwn": 1,
      "forOwnRight": 1,
      "map": 1,
      "mapKeys": 1,
      "mapValues": 1,
      "partition": 1,
      "reduce": 2,
      "reduceRight": 2,
      "reject": 1,
      "remove": 1,
      "some": 1,
      "takeRightWhile": 1,
      "takeWhile": 1,
      "times": 1,
      "transform": 2
    };
    exports.iterateeRearg = {
      "mapKeys": [1],
      "reduceRight": [1, 0]
    };
    exports.methodRearg = {
      "assignInAllWith": [1, 0],
      "assignInWith": [1, 2, 0],
      "assignAllWith": [1, 0],
      "assignWith": [1, 2, 0],
      "differenceBy": [1, 2, 0],
      "differenceWith": [1, 2, 0],
      "getOr": [2, 1, 0],
      "intersectionBy": [1, 2, 0],
      "intersectionWith": [1, 2, 0],
      "isEqualWith": [1, 2, 0],
      "isMatchWith": [2, 1, 0],
      "mergeAllWith": [1, 0],
      "mergeWith": [1, 2, 0],
      "padChars": [2, 1, 0],
      "padCharsEnd": [2, 1, 0],
      "padCharsStart": [2, 1, 0],
      "pullAllBy": [2, 1, 0],
      "pullAllWith": [2, 1, 0],
      "rangeStep": [1, 2, 0],
      "rangeStepRight": [1, 2, 0],
      "setWith": [3, 1, 2, 0],
      "sortedIndexBy": [2, 1, 0],
      "sortedLastIndexBy": [2, 1, 0],
      "unionBy": [1, 2, 0],
      "unionWith": [1, 2, 0],
      "updateWith": [3, 1, 2, 0],
      "xorBy": [1, 2, 0],
      "xorWith": [1, 2, 0],
      "zipWith": [1, 2, 0]
    };
    exports.methodSpread = {
      "assignAll": { "start": 0 },
      "assignAllWith": { "start": 0 },
      "assignInAll": { "start": 0 },
      "assignInAllWith": { "start": 0 },
      "defaultsAll": { "start": 0 },
      "defaultsDeepAll": { "start": 0 },
      "invokeArgs": { "start": 2 },
      "invokeArgsMap": { "start": 2 },
      "mergeAll": { "start": 0 },
      "mergeAllWith": { "start": 0 },
      "partial": { "start": 1 },
      "partialRight": { "start": 1 },
      "without": { "start": 1 },
      "zipAll": { "start": 0 }
    };
    exports.mutate = {
      "array": {
        "fill": true,
        "pull": true,
        "pullAll": true,
        "pullAllBy": true,
        "pullAllWith": true,
        "pullAt": true,
        "remove": true,
        "reverse": true
      },
      "object": {
        "assign": true,
        "assignAll": true,
        "assignAllWith": true,
        "assignIn": true,
        "assignInAll": true,
        "assignInAllWith": true,
        "assignInWith": true,
        "assignWith": true,
        "defaults": true,
        "defaultsAll": true,
        "defaultsDeep": true,
        "defaultsDeepAll": true,
        "merge": true,
        "mergeAll": true,
        "mergeAllWith": true,
        "mergeWith": true
      },
      "set": {
        "set": true,
        "setWith": true,
        "unset": true,
        "update": true,
        "updateWith": true
      }
    };
    exports.realToAlias = function() {
      var hasOwnProperty3 = Object.prototype.hasOwnProperty, object2 = exports.aliasToReal, result = {};
      for (var key57 in object2) {
        var value = object2[key57];
        if (hasOwnProperty3.call(result, value)) {
          result[value].push(key57);
        } else {
          result[value] = [key57];
        }
      }
      return result;
    }();
    exports.remap = {
      "assignAll": "assign",
      "assignAllWith": "assignWith",
      "assignInAll": "assignIn",
      "assignInAllWith": "assignInWith",
      "curryN": "curry",
      "curryRightN": "curryRight",
      "defaultsAll": "defaults",
      "defaultsDeepAll": "defaultsDeep",
      "findFrom": "find",
      "findIndexFrom": "findIndex",
      "findLastFrom": "findLast",
      "findLastIndexFrom": "findLastIndex",
      "getOr": "get",
      "includesFrom": "includes",
      "indexOfFrom": "indexOf",
      "invokeArgs": "invoke",
      "invokeArgsMap": "invokeMap",
      "lastIndexOfFrom": "lastIndexOf",
      "mergeAll": "merge",
      "mergeAllWith": "mergeWith",
      "padChars": "pad",
      "padCharsEnd": "padEnd",
      "padCharsStart": "padStart",
      "propertyOf": "get",
      "rangeStep": "range",
      "rangeStepRight": "rangeRight",
      "restFrom": "rest",
      "spreadFrom": "spread",
      "trimChars": "trim",
      "trimCharsEnd": "trimEnd",
      "trimCharsStart": "trimStart",
      "zipAll": "zip"
    };
    exports.skipFixed = {
      "castArray": true,
      "flow": true,
      "flowRight": true,
      "iteratee": true,
      "mixin": true,
      "rearg": true,
      "runInContext": true
    };
    exports.skipRearg = {
      "add": true,
      "assign": true,
      "assignIn": true,
      "bind": true,
      "bindKey": true,
      "concat": true,
      "difference": true,
      "divide": true,
      "eq": true,
      "gt": true,
      "gte": true,
      "isEqual": true,
      "lt": true,
      "lte": true,
      "matchesProperty": true,
      "merge": true,
      "multiply": true,
      "overArgs": true,
      "partial": true,
      "partialRight": true,
      "propertyOf": true,
      "random": true,
      "range": true,
      "rangeRight": true,
      "subtract": true,
      "zip": true,
      "zipObject": true,
      "zipObjectDeep": true
    };
  }
});

// node_modules/lodash/fp/placeholder.js
var require_placeholder = __commonJS({
  "node_modules/lodash/fp/placeholder.js"(exports, module) {
    module.exports = {};
  }
});

// node_modules/lodash/fp/_baseConvert.js
var require_baseConvert = __commonJS({
  "node_modules/lodash/fp/_baseConvert.js"(exports, module) {
    var mapping = require_mapping();
    var fallbackHolder = require_placeholder();
    var push = Array.prototype.push;
    function baseArity(func, n) {
      return n == 2 ? function(a2, b) {
        return func.apply(void 0, arguments);
      } : function(a2) {
        return func.apply(void 0, arguments);
      };
    }
    function baseAry(func, n) {
      return n == 2 ? function(a2, b) {
        return func(a2, b);
      } : function(a2) {
        return func(a2);
      };
    }
    function cloneArray(array2) {
      var length3 = array2 ? array2.length : 0, result = Array(length3);
      while (length3--) {
        result[length3] = array2[length3];
      }
      return result;
    }
    function createCloner(func) {
      return function(object2) {
        return func({}, object2);
      };
    }
    function flatSpread(func, start) {
      return function() {
        var length3 = arguments.length, lastIndex = length3 - 1, args = Array(length3);
        while (length3--) {
          args[length3] = arguments[length3];
        }
        var array2 = args[start], otherArgs = args.slice(0, start);
        if (array2) {
          push.apply(otherArgs, array2);
        }
        if (start != lastIndex) {
          push.apply(otherArgs, args.slice(start + 1));
        }
        return func.apply(this, otherArgs);
      };
    }
    function wrapImmutable(func, cloner) {
      return function() {
        var length3 = arguments.length;
        if (!length3) {
          return;
        }
        var args = Array(length3);
        while (length3--) {
          args[length3] = arguments[length3];
        }
        var result = args[0] = cloner.apply(void 0, args);
        func.apply(void 0, args);
        return result;
      };
    }
    function baseConvert(util2, name2, func, options) {
      var isLib = typeof name2 == "function", isObj2 = name2 === Object(name2);
      if (isObj2) {
        options = func;
        func = name2;
        name2 = void 0;
      }
      if (func == null) {
        throw new TypeError();
      }
      options || (options = {});
      var config2 = {
        "cap": "cap" in options ? options.cap : true,
        "curry": "curry" in options ? options.curry : true,
        "fixed": "fixed" in options ? options.fixed : true,
        "immutable": "immutable" in options ? options.immutable : true,
        "rearg": "rearg" in options ? options.rearg : true
      };
      var defaultHolder = isLib ? func : fallbackHolder, forceCurry = "curry" in options && options.curry, forceFixed = "fixed" in options && options.fixed, forceRearg = "rearg" in options && options.rearg, pristine = isLib ? func.runInContext() : void 0;
      var helpers = isLib ? func : {
        "ary": util2.ary,
        "assign": util2.assign,
        "clone": util2.clone,
        "curry": util2.curry,
        "forEach": util2.forEach,
        "isArray": util2.isArray,
        "isError": util2.isError,
        "isFunction": util2.isFunction,
        "isWeakMap": util2.isWeakMap,
        "iteratee": util2.iteratee,
        "keys": util2.keys,
        "rearg": util2.rearg,
        "toInteger": util2.toInteger,
        "toPath": util2.toPath
      };
      var ary = helpers.ary, assign2 = helpers.assign, clone4 = helpers.clone, curry3 = helpers.curry, each = helpers.forEach, isArray4 = helpers.isArray, isError4 = helpers.isError, isFunction3 = helpers.isFunction, isWeakMap = helpers.isWeakMap, keys4 = helpers.keys, rearg = helpers.rearg, toInteger = helpers.toInteger, toPath2 = helpers.toPath;
      var aryMethodKeys = keys4(mapping.aryMethod);
      var wrappers = {
        "castArray": function(castArray) {
          return function() {
            var value = arguments[0];
            return isArray4(value) ? castArray(cloneArray(value)) : castArray.apply(void 0, arguments);
          };
        },
        "iteratee": function(iteratee) {
          return function() {
            var func2 = arguments[0], arity = arguments[1], result = iteratee(func2, arity), length3 = result.length;
            if (config2.cap && typeof arity == "number") {
              arity = arity > 2 ? arity - 2 : 1;
              return length3 && length3 <= arity ? result : baseAry(result, arity);
            }
            return result;
          };
        },
        "mixin": function(mixin) {
          return function(source) {
            var func2 = this;
            if (!isFunction3(func2)) {
              return mixin(func2, Object(source));
            }
            var pairs3 = [];
            each(keys4(source), function(key57) {
              if (isFunction3(source[key57])) {
                pairs3.push([key57, func2.prototype[key57]]);
              }
            });
            mixin(func2, Object(source));
            each(pairs3, function(pair3) {
              var value = pair3[1];
              if (isFunction3(value)) {
                func2.prototype[pair3[0]] = value;
              } else {
                delete func2.prototype[pair3[0]];
              }
            });
            return func2;
          };
        },
        "nthArg": function(nthArg3) {
          return function(n) {
            var arity = n < 0 ? 1 : toInteger(n) + 1;
            return curry3(nthArg3(n), arity);
          };
        },
        "rearg": function(rearg2) {
          return function(func2, indexes) {
            var arity = indexes ? indexes.length : 0;
            return curry3(rearg2(func2, indexes), arity);
          };
        },
        "runInContext": function(runInContext) {
          return function(context2) {
            return baseConvert(util2, runInContext(context2), options);
          };
        }
      };
      function castCap(name3, func2) {
        if (config2.cap) {
          var indexes = mapping.iterateeRearg[name3];
          if (indexes) {
            return iterateeRearg(func2, indexes);
          }
          var n = !isLib && mapping.iterateeAry[name3];
          if (n) {
            return iterateeAry(func2, n);
          }
        }
        return func2;
      }
      function castCurry(name3, func2, n) {
        return forceCurry || config2.curry && n > 1 ? curry3(func2, n) : func2;
      }
      function castFixed(name3, func2, n) {
        if (config2.fixed && (forceFixed || !mapping.skipFixed[name3])) {
          var data = mapping.methodSpread[name3], start = data && data.start;
          return start === void 0 ? ary(func2, n) : flatSpread(func2, start);
        }
        return func2;
      }
      function castRearg(name3, func2, n) {
        return config2.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name3]) ? rearg(func2, mapping.methodRearg[name3] || mapping.aryRearg[n]) : func2;
      }
      function cloneByPath(object2, path4) {
        path4 = toPath2(path4);
        var index = -1, length3 = path4.length, lastIndex = length3 - 1, result = clone4(Object(object2)), nested = result;
        while (nested != null && ++index < length3) {
          var key57 = path4[index], value = nested[key57];
          if (value != null && !(isFunction3(value) || isError4(value) || isWeakMap(value))) {
            nested[key57] = clone4(index == lastIndex ? value : Object(value));
          }
          nested = nested[key57];
        }
        return result;
      }
      function convertLib(options2) {
        return _2.runInContext.convert(options2)(void 0);
      }
      function createConverter(name3, func2) {
        var realName = mapping.aliasToReal[name3] || name3, methodName = mapping.remap[realName] || realName, oldOptions = options;
        return function(options2) {
          var newUtil = isLib ? pristine : helpers, newFunc = isLib ? pristine[methodName] : func2, newOptions = assign2(assign2({}, oldOptions), options2);
          return baseConvert(newUtil, realName, newFunc, newOptions);
        };
      }
      function iterateeAry(func2, n) {
        return overArg(func2, function(func3) {
          return typeof func3 == "function" ? baseAry(func3, n) : func3;
        });
      }
      function iterateeRearg(func2, indexes) {
        return overArg(func2, function(func3) {
          var n = indexes.length;
          return baseArity(rearg(baseAry(func3, n), indexes), n);
        });
      }
      function overArg(func2, transform2) {
        return function() {
          var length3 = arguments.length;
          if (!length3) {
            return func2();
          }
          var args = Array(length3);
          while (length3--) {
            args[length3] = arguments[length3];
          }
          var index = config2.rearg ? 0 : length3 - 1;
          args[index] = transform2(args[index]);
          return func2.apply(void 0, args);
        };
      }
      function wrap(name3, func2, placeholder) {
        var result, realName = mapping.aliasToReal[name3] || name3, wrapped = func2, wrapper = wrappers[realName];
        if (wrapper) {
          wrapped = wrapper(func2);
        } else if (config2.immutable) {
          if (mapping.mutate.array[realName]) {
            wrapped = wrapImmutable(func2, cloneArray);
          } else if (mapping.mutate.object[realName]) {
            wrapped = wrapImmutable(func2, createCloner(func2));
          } else if (mapping.mutate.set[realName]) {
            wrapped = wrapImmutable(func2, cloneByPath);
          }
        }
        each(aryMethodKeys, function(aryKey) {
          each(mapping.aryMethod[aryKey], function(otherName) {
            if (realName == otherName) {
              var data = mapping.methodSpread[realName], afterRearg = data && data.afterRearg;
              result = afterRearg ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey) : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);
              result = castCap(realName, result);
              result = castCurry(realName, result, aryKey);
              return false;
            }
          });
          return !result;
        });
        result || (result = wrapped);
        if (result == func2) {
          result = forceCurry ? curry3(result, 1) : function() {
            return func2.apply(this, arguments);
          };
        }
        result.convert = createConverter(realName, func2);
        result.placeholder = func2.placeholder = placeholder;
        return result;
      }
      if (!isObj2) {
        return wrap(name2, func, defaultHolder);
      }
      var _2 = func;
      var pairs2 = [];
      each(aryMethodKeys, function(aryKey) {
        each(mapping.aryMethod[aryKey], function(key57) {
          var func2 = _2[mapping.remap[key57] || key57];
          if (func2) {
            pairs2.push([key57, wrap(key57, func2, _2)]);
          }
        });
      });
      each(keys4(_2), function(key57) {
        var func2 = _2[key57];
        if (typeof func2 == "function") {
          var length3 = pairs2.length;
          while (length3--) {
            if (pairs2[length3][0] == key57) {
              return;
            }
          }
          func2.convert = createConverter(key57, func2);
          pairs2.push([key57, func2]);
        }
      });
      each(pairs2, function(pair3) {
        _2[pair3[0]] = pair3[1];
      });
      _2.convert = convertLib;
      _2.placeholder = _2;
      each(keys4(_2), function(key57) {
        each(mapping.realToAlias[key57] || [], function(alias) {
          _2[alias] = _2[key57];
        });
      });
      return _2;
    }
    module.exports = baseConvert;
  }
});

// node_modules/lodash/_metaMap.js
var require_metaMap = __commonJS({
  "node_modules/lodash/_metaMap.js"(exports, module) {
    var WeakMap2 = require_WeakMap();
    var metaMap = WeakMap2 && new WeakMap2();
    module.exports = metaMap;
  }
});

// node_modules/lodash/_baseSetData.js
var require_baseSetData = __commonJS({
  "node_modules/lodash/_baseSetData.js"(exports, module) {
    var identity2 = require_identity();
    var metaMap = require_metaMap();
    var baseSetData = !metaMap ? identity2 : function(func, data) {
      metaMap.set(func, data);
      return func;
    };
    module.exports = baseSetData;
  }
});

// node_modules/lodash/_createCtor.js
var require_createCtor = __commonJS({
  "node_modules/lodash/_createCtor.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var isObject6 = require_isObject();
    function createCtor(Ctor) {
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return new Ctor();
          case 1:
            return new Ctor(args[0]);
          case 2:
            return new Ctor(args[0], args[1]);
          case 3:
            return new Ctor(args[0], args[1], args[2]);
          case 4:
            return new Ctor(args[0], args[1], args[2], args[3]);
          case 5:
            return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
        return isObject6(result) ? result : thisBinding;
      };
    }
    module.exports = createCtor;
  }
});

// node_modules/lodash/_createBind.js
var require_createBind = __commonJS({
  "node_modules/lodash/_createBind.js"(exports, module) {
    var createCtor = require_createCtor();
    var root = require_root();
    var WRAP_BIND_FLAG = 1;
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
      function wrapper() {
        var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
        return fn2.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }
    module.exports = createBind;
  }
});

// node_modules/lodash/_composeArgs.js
var require_composeArgs = __commonJS({
  "node_modules/lodash/_composeArgs.js"(exports, module) {
    var nativeMax = Math.max;
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }
    module.exports = composeArgs;
  }
});

// node_modules/lodash/_composeArgsRight.js
var require_composeArgsRight = __commonJS({
  "node_modules/lodash/_composeArgsRight.js"(exports, module) {
    var nativeMax = Math.max;
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }
    module.exports = composeArgsRight;
  }
});

// node_modules/lodash/_countHolders.js
var require_countHolders = __commonJS({
  "node_modules/lodash/_countHolders.js"(exports, module) {
    function countHolders(array2, placeholder) {
      var length3 = array2.length, result = 0;
      while (length3--) {
        if (array2[length3] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    module.exports = countHolders;
  }
});

// node_modules/lodash/_baseLodash.js
var require_baseLodash = __commonJS({
  "node_modules/lodash/_baseLodash.js"(exports, module) {
    function baseLodash() {
    }
    module.exports = baseLodash;
  }
});

// node_modules/lodash/_LazyWrapper.js
var require_LazyWrapper = __commonJS({
  "node_modules/lodash/_LazyWrapper.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var baseLodash = require_baseLodash();
    var MAX_ARRAY_LENGTH = 4294967295;
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;
    module.exports = LazyWrapper;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop3() {
    }
    module.exports = noop3;
  }
});

// node_modules/lodash/_getData.js
var require_getData = __commonJS({
  "node_modules/lodash/_getData.js"(exports, module) {
    var metaMap = require_metaMap();
    var noop3 = require_noop();
    var getData = !metaMap ? noop3 : function(func) {
      return metaMap.get(func);
    };
    module.exports = getData;
  }
});

// node_modules/lodash/_realNames.js
var require_realNames = __commonJS({
  "node_modules/lodash/_realNames.js"(exports, module) {
    var realNames = {};
    module.exports = realNames;
  }
});

// node_modules/lodash/_getFuncName.js
var require_getFuncName = __commonJS({
  "node_modules/lodash/_getFuncName.js"(exports, module) {
    var realNames = require_realNames();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function getFuncName(func) {
      var result = func.name + "", array2 = realNames[result], length3 = hasOwnProperty3.call(realNames, result) ? array2.length : 0;
      while (length3--) {
        var data = array2[length3], otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }
    module.exports = getFuncName;
  }
});

// node_modules/lodash/_LodashWrapper.js
var require_LodashWrapper = __commonJS({
  "node_modules/lodash/_LodashWrapper.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var baseLodash = require_baseLodash();
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = void 0;
    }
    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;
    module.exports = LodashWrapper;
  }
});

// node_modules/lodash/_wrapperClone.js
var require_wrapperClone = __commonJS({
  "node_modules/lodash/_wrapperClone.js"(exports, module) {
    var LazyWrapper = require_LazyWrapper();
    var LodashWrapper = require_LodashWrapper();
    var copyArray3 = require_copyArray();
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray3(wrapper.__actions__);
      result.__index__ = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }
    module.exports = wrapperClone;
  }
});

// node_modules/lodash/wrapperLodash.js
var require_wrapperLodash = __commonJS({
  "node_modules/lodash/wrapperLodash.js"(exports, module) {
    var LazyWrapper = require_LazyWrapper();
    var LodashWrapper = require_LodashWrapper();
    var baseLodash = require_baseLodash();
    var isArray4 = require_isArray();
    var isObjectLike = require_isObjectLike();
    var wrapperClone = require_wrapperClone();
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function lodash(value) {
      if (isObjectLike(value) && !isArray4(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty3.call(value, "__wrapped__")) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;
    module.exports = lodash;
  }
});

// node_modules/lodash/_isLaziable.js
var require_isLaziable = __commonJS({
  "node_modules/lodash/_isLaziable.js"(exports, module) {
    var LazyWrapper = require_LazyWrapper();
    var getData = require_getData();
    var getFuncName = require_getFuncName();
    var lodash = require_wrapperLodash();
    function isLaziable(func) {
      var funcName = getFuncName(func), other = lodash[funcName];
      if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }
    module.exports = isLaziable;
  }
});

// node_modules/lodash/_setData.js
var require_setData = __commonJS({
  "node_modules/lodash/_setData.js"(exports, module) {
    var baseSetData = require_baseSetData();
    var shortOut = require_shortOut();
    var setData = shortOut(baseSetData);
    module.exports = setData;
  }
});

// node_modules/lodash/_getWrapDetails.js
var require_getWrapDetails = __commonJS({
  "node_modules/lodash/_getWrapDetails.js"(exports, module) {
    var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
    var reSplitDetails = /,? & /;
    function getWrapDetails(source) {
      var match3 = source.match(reWrapDetails);
      return match3 ? match3[1].split(reSplitDetails) : [];
    }
    module.exports = getWrapDetails;
  }
});

// node_modules/lodash/_insertWrapDetails.js
var require_insertWrapDetails = __commonJS({
  "node_modules/lodash/_insertWrapDetails.js"(exports, module) {
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
    function insertWrapDetails(source, details) {
      var length3 = details.length;
      if (!length3) {
        return source;
      }
      var lastIndex = length3 - 1;
      details[lastIndex] = (length3 > 1 ? "& " : "") + details[lastIndex];
      details = details.join(length3 > 2 ? ", " : " ");
      return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
    }
    module.exports = insertWrapDetails;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array2, value, fromIndex) {
      var index = fromIndex - 1, length3 = array2.length;
      while (++index < length3) {
        if (array2[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array2, value) {
      var length3 = array2 == null ? 0 : array2.length;
      return !!length3 && baseIndexOf(array2, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_updateWrapDetails.js
var require_updateWrapDetails = __commonJS({
  "node_modules/lodash/_updateWrapDetails.js"(exports, module) {
    var arrayEach = require_arrayEach();
    var arrayIncludes = require_arrayIncludes();
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_CURRY_RIGHT_FLAG = 16;
    var WRAP_PARTIAL_FLAG = 32;
    var WRAP_PARTIAL_RIGHT_FLAG = 64;
    var WRAP_ARY_FLAG = 128;
    var WRAP_REARG_FLAG = 256;
    var WRAP_FLIP_FLAG = 512;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair3) {
        var value = "_." + pair3[0];
        if (bitmask & pair3[1] && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }
    module.exports = updateWrapDetails;
  }
});

// node_modules/lodash/_setWrapToString.js
var require_setWrapToString = __commonJS({
  "node_modules/lodash/_setWrapToString.js"(exports, module) {
    var getWrapDetails = require_getWrapDetails();
    var insertWrapDetails = require_insertWrapDetails();
    var setToString = require_setToString();
    var updateWrapDetails = require_updateWrapDetails();
    function setWrapToString(wrapper, reference, bitmask) {
      var source = reference + "";
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }
    module.exports = setWrapToString;
  }
});

// node_modules/lodash/_createRecurry.js
var require_createRecurry = __commonJS({
  "node_modules/lodash/_createRecurry.js"(exports, module) {
    var isLaziable = require_isLaziable();
    var setData = require_setData();
    var setWrapToString = require_setWrapToString();
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_BOUND_FLAG = 4;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_PARTIAL_FLAG = 32;
    var WRAP_PARTIAL_RIGHT_FLAG = 64;
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
      bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func,
        bitmask,
        thisArg,
        newPartials,
        newHolders,
        newPartialsRight,
        newHoldersRight,
        argPos,
        ary,
        arity
      ];
      var result = wrapFunc.apply(void 0, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }
    module.exports = createRecurry;
  }
});

// node_modules/lodash/_getHolder.js
var require_getHolder = __commonJS({
  "node_modules/lodash/_getHolder.js"(exports, module) {
    function getHolder(func) {
      var object2 = func;
      return object2.placeholder;
    }
    module.exports = getHolder;
  }
});

// node_modules/lodash/_reorder.js
var require_reorder = __commonJS({
  "node_modules/lodash/_reorder.js"(exports, module) {
    var copyArray3 = require_copyArray();
    var isIndex = require_isIndex();
    var nativeMin = Math.min;
    function reorder(array2, indexes) {
      var arrLength = array2.length, length3 = nativeMin(indexes.length, arrLength), oldArray = copyArray3(array2);
      while (length3--) {
        var index = indexes[length3];
        array2[length3] = isIndex(index, arrLength) ? oldArray[index] : void 0;
      }
      return array2;
    }
    module.exports = reorder;
  }
});

// node_modules/lodash/_replaceHolders.js
var require_replaceHolders = __commonJS({
  "node_modules/lodash/_replaceHolders.js"(exports, module) {
    var PLACEHOLDER = "__lodash_placeholder__";
    function replaceHolders(array2, placeholder) {
      var index = -1, length3 = array2.length, resIndex = 0, result = [];
      while (++index < length3) {
        var value = array2[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array2[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    module.exports = replaceHolders;
  }
});

// node_modules/lodash/_createHybrid.js
var require_createHybrid = __commonJS({
  "node_modules/lodash/_createHybrid.js"(exports, module) {
    var composeArgs = require_composeArgs();
    var composeArgsRight = require_composeArgsRight();
    var countHolders = require_countHolders();
    var createCtor = require_createCtor();
    var createRecurry = require_createRecurry();
    var getHolder = require_getHolder();
    var reorder = require_reorder();
    var replaceHolders = require_replaceHolders();
    var root = require_root();
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_CURRY_RIGHT_FLAG = 16;
    var WRAP_ARY_FLAG = 128;
    var WRAP_FLIP_FLAG = 512;
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? void 0 : createCtor(func);
      function wrapper() {
        var length3 = arguments.length, args = Array(length3), index = length3;
        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length3 -= holdersCount;
        if (isCurried && length3 < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func,
            bitmask,
            createHybrid,
            wrapper.placeholder,
            thisArg,
            args,
            newHolders,
            argPos,
            ary,
            arity - length3
          );
        }
        var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
        length3 = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length3 > 1) {
          args.reverse();
        }
        if (isAry && ary < length3) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn2 = Ctor || createCtor(fn2);
        }
        return fn2.apply(thisBinding, args);
      }
      return wrapper;
    }
    module.exports = createHybrid;
  }
});

// node_modules/lodash/_createCurry.js
var require_createCurry = __commonJS({
  "node_modules/lodash/_createCurry.js"(exports, module) {
    var apply4 = require_apply();
    var createCtor = require_createCtor();
    var createHybrid = require_createHybrid();
    var createRecurry = require_createRecurry();
    var getHolder = require_getHolder();
    var replaceHolders = require_replaceHolders();
    var root = require_root();
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);
      function wrapper() {
        var length3 = arguments.length, args = Array(length3), index = length3, placeholder = getHolder(wrapper);
        while (index--) {
          args[index] = arguments[index];
        }
        var holders = length3 < 3 && args[0] !== placeholder && args[length3 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
        length3 -= holders.length;
        if (length3 < arity) {
          return createRecurry(
            func,
            bitmask,
            createHybrid,
            wrapper.placeholder,
            void 0,
            args,
            holders,
            void 0,
            void 0,
            arity - length3
          );
        }
        var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
        return apply4(fn2, this, args);
      }
      return wrapper;
    }
    module.exports = createCurry;
  }
});

// node_modules/lodash/_createPartial.js
var require_createPartial = __commonJS({
  "node_modules/lodash/_createPartial.js"(exports, module) {
    var apply4 = require_apply();
    var createCtor = require_createCtor();
    var root = require_root();
    var WRAP_BIND_FLAG = 1;
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
      function wrapper() {
        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply4(fn2, isBind ? thisArg : this, args);
      }
      return wrapper;
    }
    module.exports = createPartial;
  }
});

// node_modules/lodash/_mergeData.js
var require_mergeData = __commonJS({
  "node_modules/lodash/_mergeData.js"(exports, module) {
    var composeArgs = require_composeArgs();
    var composeArgsRight = require_composeArgsRight();
    var replaceHolders = require_replaceHolders();
    var PLACEHOLDER = "__lodash_placeholder__";
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_BOUND_FLAG = 4;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_ARY_FLAG = 128;
    var WRAP_REARG_FLAG = 256;
    var nativeMin = Math.min;
    function mergeData(data, source) {
      var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
      var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
      if (!(isCommon || isCombo)) {
        return data;
      }
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      value = source[7];
      if (value) {
        data[7] = value;
      }
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      if (data[9] == null) {
        data[9] = source[9];
      }
      data[0] = source[0];
      data[1] = newBitmask;
      return data;
    }
    module.exports = mergeData;
  }
});

// node_modules/lodash/_createWrap.js
var require_createWrap = __commonJS({
  "node_modules/lodash/_createWrap.js"(exports, module) {
    var baseSetData = require_baseSetData();
    var createBind = require_createBind();
    var createCurry = require_createCurry();
    var createHybrid = require_createHybrid();
    var createPartial = require_createPartial();
    var getData = require_getData();
    var mergeData = require_mergeData();
    var setData = require_setData();
    var setWrapToString = require_setWrapToString();
    var toInteger = require_toInteger();
    var FUNC_ERROR_TEXT = "Expected a function";
    var WRAP_BIND_FLAG = 1;
    var WRAP_BIND_KEY_FLAG = 2;
    var WRAP_CURRY_FLAG = 8;
    var WRAP_CURRY_RIGHT_FLAG = 16;
    var WRAP_PARTIAL_FLAG = 32;
    var WRAP_PARTIAL_RIGHT_FLAG = 64;
    var nativeMax = Math.max;
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length3 = partials ? partials.length : 0;
      if (!length3) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = void 0;
      }
      ary = ary === void 0 ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === void 0 ? arity : toInteger(arity);
      length3 -= holders ? holders.length : 0;
      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials, holdersRight = holders;
        partials = holders = void 0;
      }
      var data = isBindKey ? void 0 : getData(func);
      var newData = [
        func,
        bitmask,
        thisArg,
        partials,
        holders,
        partialsRight,
        holdersRight,
        argPos,
        ary,
        arity
      ];
      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length3, 0);
      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(void 0, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }
    module.exports = createWrap;
  }
});

// node_modules/lodash/ary.js
var require_ary = __commonJS({
  "node_modules/lodash/ary.js"(exports, module) {
    var createWrap = require_createWrap();
    var WRAP_ARY_FLAG = 128;
    function ary(func, n, guard) {
      n = guard ? void 0 : n;
      n = func && n == null ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, void 0, void 0, void 0, void 0, n);
    }
    module.exports = ary;
  }
});

// node_modules/lodash/clone.js
var require_clone = __commonJS({
  "node_modules/lodash/clone.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone4(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    module.exports = clone4;
  }
});

// node_modules/lodash/curry.js
var require_curry = __commonJS({
  "node_modules/lodash/curry.js"(exports, module) {
    var createWrap = require_createWrap();
    var WRAP_CURRY_FLAG = 8;
    function curry3(func, arity, guard) {
      arity = guard ? void 0 : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, void 0, void 0, void 0, void 0, void 0, arity);
      result.placeholder = curry3.placeholder;
      return result;
    }
    curry3.placeholder = {};
    module.exports = curry3;
  }
});

// node_modules/lodash/isError.js
var require_isError = __commonJS({
  "node_modules/lodash/isError.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var isPlainObject3 = require_isPlainObject();
    var domExcTag = "[object DOMException]";
    var errorTag = "[object Error]";
    function isError4(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject3(value);
    }
    module.exports = isError4;
  }
});

// node_modules/lodash/isWeakMap.js
var require_isWeakMap = __commonJS({
  "node_modules/lodash/isWeakMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var weakMapTag = "[object WeakMap]";
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }
    module.exports = isWeakMap;
  }
});

// node_modules/lodash/iteratee.js
var require_iteratee = __commonJS({
  "node_modules/lodash/iteratee.js"(exports, module) {
    var baseClone = require_baseClone();
    var baseIteratee = require_baseIteratee();
    var CLONE_DEEP_FLAG = 1;
    function iteratee(func) {
      return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
    }
    module.exports = iteratee;
  }
});

// node_modules/lodash/rearg.js
var require_rearg = __commonJS({
  "node_modules/lodash/rearg.js"(exports, module) {
    var createWrap = require_createWrap();
    var flatRest = require_flatRest();
    var WRAP_REARG_FLAG = 256;
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, void 0, void 0, void 0, indexes);
    });
    module.exports = rearg;
  }
});

// node_modules/lodash/toPath.js
var require_toPath = __commonJS({
  "node_modules/lodash/toPath.js"(exports, module) {
    var arrayMap = require_arrayMap();
    var copyArray3 = require_copyArray();
    var isArray4 = require_isArray();
    var isSymbol2 = require_isSymbol();
    var stringToPath = require_stringToPath();
    var toKey = require_toKey();
    var toString5 = require_toString();
    function toPath2(value) {
      if (isArray4(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol2(value) ? [value] : copyArray3(stringToPath(toString5(value)));
    }
    module.exports = toPath2;
  }
});

// node_modules/lodash/fp/_util.js
var require_util2 = __commonJS({
  "node_modules/lodash/fp/_util.js"(exports, module) {
    module.exports = {
      "ary": require_ary(),
      "assign": require_baseAssign(),
      "clone": require_clone(),
      "curry": require_curry(),
      "forEach": require_arrayEach(),
      "isArray": require_isArray(),
      "isError": require_isError(),
      "isFunction": require_isFunction(),
      "isWeakMap": require_isWeakMap(),
      "iteratee": require_iteratee(),
      "keys": require_baseKeys(),
      "rearg": require_rearg(),
      "toInteger": require_toInteger(),
      "toPath": require_toPath()
    };
  }
});

// node_modules/lodash/fp/convert.js
var require_convert = __commonJS({
  "node_modules/lodash/fp/convert.js"(exports, module) {
    var baseConvert = require_baseConvert();
    var util2 = require_util2();
    function convert(name2, func, options) {
      return baseConvert(util2, name2, func, options);
    }
    module.exports = convert;
  }
});

// node_modules/lodash/fp/set.js
var require_set2 = __commonJS({
  "node_modules/lodash/fp/set.js"(exports, module) {
    var convert = require_convert();
    var func = convert("set", require_set());
    func.placeholder = require_placeholder();
    module.exports = func;
  }
});

// node_modules/lodash/fp/assocPath.js
var require_assocPath = __commonJS({
  "node_modules/lodash/fp/assocPath.js"(exports, module) {
    module.exports = require_set2();
  }
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE2 = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE2;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified2(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge3(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified2(element, options);
      });
    }
    function getMergeFunction2(key57, options) {
      if (!options.customMerge) {
        return deepmerge3;
      }
      var customMerge = options.customMerge(key57);
      return typeof customMerge === "function" ? customMerge : deepmerge3;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object2, property2) {
      try {
        return property2 in object2;
      } catch (_2) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key57) {
      return propertyIsOnObject(target, key57) && !(Object.hasOwnProperty.call(target, key57) && Object.propertyIsEnumerable.call(target, key57));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key57) {
          destination[key57] = cloneUnlessOtherwiseSpecified2(target[key57], options);
        });
      }
      getKeys(source).forEach(function(key57) {
        if (propertyIsUnsafe(target, key57)) {
          return;
        }
        if (propertyIsOnObject(target, key57) && options.isMergeableObject(source[key57])) {
          destination[key57] = getMergeFunction2(key57, options)(target[key57], source[key57], options);
        } else {
          destination[key57] = cloneUnlessOtherwiseSpecified2(source[key57], options);
        }
      });
      return destination;
    }
    function deepmerge3(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified2;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified2(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge3.all = function deepmergeAll(array2, options) {
      if (!Array.isArray(array2)) {
        throw new Error("first argument should be an array");
      }
      return array2.reduce(function(prev, next) {
        return deepmerge3(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge3;
    module.exports = deepmerge_1;
  }
});

// node_modules/core-js-pure/internals/shared-key.js
var require_shared_key = __commonJS({
  "node_modules/core-js-pure/internals/shared-key.js"(exports, module) {
    "use strict";
    var shared = require_shared();
    var uid = require_uid();
    var keys4 = shared("keys");
    module.exports = function(key57) {
      return keys4[key57] || (keys4[key57] = uid(key57));
    };
  }
});

// node_modules/core-js-pure/internals/correct-prototype-getter.js
var require_correct_prototype_getter = __commonJS({
  "node_modules/core-js-pure/internals/correct-prototype-getter.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    module.exports = !fails(function() {
      function F2() {
      }
      F2.prototype.constructor = null;
      return Object.getPrototypeOf(new F2()) !== F2.prototype;
    });
  }
});

// node_modules/core-js-pure/internals/object-get-prototype-of.js
var require_object_get_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-get-prototype-of.js"(exports, module) {
    "use strict";
    var hasOwn2 = require_has_own_property();
    var isCallable = require_is_callable();
    var toObject = require_to_object();
    var sharedKey = require_shared_key();
    var CORRECT_PROTOTYPE_GETTER = require_correct_prototype_getter();
    var IE_PROTO = sharedKey("IE_PROTO");
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O2) {
      var object2 = toObject(O2);
      if (hasOwn2(object2, IE_PROTO)) return object2[IE_PROTO];
      var constructor = object2.constructor;
      if (isCallable(constructor) && object2 instanceof constructor) {
        return constructor.prototype;
      }
      return object2 instanceof $Object ? ObjectPrototype : null;
    };
  }
});

// node_modules/core-js-pure/internals/function-uncurry-this-accessor.js
var require_function_uncurry_this_accessor = __commonJS({
  "node_modules/core-js-pure/internals/function-uncurry-this-accessor.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var aCallable = require_a_callable();
    module.exports = function(object2, key57, method) {
      try {
        return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object2, key57)[method]));
      } catch (error) {
      }
    };
  }
});

// node_modules/core-js-pure/internals/is-possible-prototype.js
var require_is_possible_prototype = __commonJS({
  "node_modules/core-js-pure/internals/is-possible-prototype.js"(exports, module) {
    "use strict";
    var isObject6 = require_is_object();
    module.exports = function(argument) {
      return isObject6(argument) || argument === null;
    };
  }
});

// node_modules/core-js-pure/internals/a-possible-prototype.js
var require_a_possible_prototype = __commonJS({
  "node_modules/core-js-pure/internals/a-possible-prototype.js"(exports, module) {
    "use strict";
    var isPossiblePrototype = require_is_possible_prototype();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isPossiblePrototype(argument)) return argument;
      throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
    };
  }
});

// node_modules/core-js-pure/internals/object-set-prototype-of.js
var require_object_set_prototype_of = __commonJS({
  "node_modules/core-js-pure/internals/object-set-prototype-of.js"(exports, module) {
    "use strict";
    var uncurryThisAccessor = require_function_uncurry_this_accessor();
    var isObject6 = require_is_object();
    var requireObjectCoercible = require_require_object_coercible();
    var aPossiblePrototype = require_a_possible_prototype();
    module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var CORRECT_SETTER = false;
      var test4 = {};
      var setter;
      try {
        setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
        setter(test4, []);
        CORRECT_SETTER = test4 instanceof Array;
      } catch (error) {
      }
      return function setPrototypeOf2(O2, proto2) {
        requireObjectCoercible(O2);
        aPossiblePrototype(proto2);
        if (!isObject6(O2)) return O2;
        if (CORRECT_SETTER) setter(O2, proto2);
        else O2.__proto__ = proto2;
        return O2;
      };
    }() : void 0);
  }
});

// node_modules/core-js-pure/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "node_modules/core-js-pure/internals/object-get-own-property-names.js"(exports) {
    "use strict";
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames2(O2) {
      return internalObjectKeys(O2, hiddenKeys);
    };
  }
});

// node_modules/core-js-pure/internals/own-keys.js
var require_own_keys = __commonJS({
  "node_modules/core-js-pure/internals/own-keys.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat4 = uncurryThis([].concat);
    module.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys5(it2) {
      var keys4 = getOwnPropertyNamesModule.f(anObject(it2));
      var getOwnPropertySymbols2 = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols2 ? concat4(keys4, getOwnPropertySymbols2(it2)) : keys4;
    };
  }
});

// node_modules/core-js-pure/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "node_modules/core-js-pure/internals/copy-constructor-properties.js"(exports, module) {
    "use strict";
    var hasOwn2 = require_has_own_property();
    var ownKeys5 = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module.exports = function(target, source, exceptions) {
      var keys4 = ownKeys5(source);
      var defineProperty2 = definePropertyModule.f;
      var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
      for (var i2 = 0; i2 < keys4.length; i2++) {
        var key57 = keys4[i2];
        if (!hasOwn2(target, key57) && !(exceptions && hasOwn2(exceptions, key57))) {
          defineProperty2(target, key57, getOwnPropertyDescriptor3(source, key57));
        }
      }
    };
  }
});

// node_modules/core-js-pure/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "node_modules/core-js-pure/internals/object-define-properties.js"(exports) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O2, Properties) {
      anObject(O2);
      var props3 = toIndexedObject(Properties);
      var keys4 = objectKeys(Properties);
      var length3 = keys4.length;
      var index = 0;
      var key57;
      while (length3 > index) definePropertyModule.f(O2, key57 = keys4[index++], props3[key57]);
      return O2;
    };
  }
});

// node_modules/core-js-pure/internals/html.js
var require_html = __commonJS({
  "node_modules/core-js-pure/internals/html.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("document", "documentElement");
  }
});

// node_modules/core-js-pure/internals/object-create.js
var require_object_create = __commonJS({
  "node_modules/core-js-pure/internals/object-create.js"(exports, module) {
    "use strict";
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html2 = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = function() {
    };
    var scriptTag = function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    };
    var NullProtoObjectViaActiveX = function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    };
    var NullProtoObjectViaIFrame = function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html2.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    };
    var activeXDocument;
    var NullProtoObject = function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length3 = enumBugKeys.length;
      while (length3--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length3]];
      return NullProtoObject();
    };
    hiddenKeys[IE_PROTO] = true;
    module.exports = Object.create || function create2(O2, Properties) {
      var result;
      if (O2 !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O2);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O2;
      } else result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    };
  }
});

// node_modules/core-js-pure/internals/install-error-cause.js
var require_install_error_cause = __commonJS({
  "node_modules/core-js-pure/internals/install-error-cause.js"(exports, module) {
    "use strict";
    var isObject6 = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    module.exports = function(O2, options) {
      if (isObject6(options) && "cause" in options) {
        createNonEnumerableProperty(O2, "cause", options.cause);
      }
    };
  }
});

// node_modules/core-js-pure/internals/error-stack-clear.js
var require_error_stack_clear = __commonJS({
  "node_modules/core-js-pure/internals/error-stack-clear.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var $Error = Error;
    var replace5 = uncurryThis("".replace);
    var TEST = function(arg) {
      return String(new $Error(arg).stack);
    }("zxcasd");
    var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
    var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
    module.exports = function(stack, dropEntries) {
      if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
        while (dropEntries--) stack = replace5(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
      }
      return stack;
    };
  }
});

// node_modules/core-js-pure/internals/error-stack-installable.js
var require_error_stack_installable = __commonJS({
  "node_modules/core-js-pure/internals/error-stack-installable.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = !fails(function() {
      var error = new Error("a");
      if (!("stack" in error)) return true;
      Object.defineProperty(error, "stack", createPropertyDescriptor(1, 7));
      return error.stack !== 7;
    });
  }
});

// node_modules/core-js-pure/internals/error-stack-install.js
var require_error_stack_install = __commonJS({
  "node_modules/core-js-pure/internals/error-stack-install.js"(exports, module) {
    "use strict";
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var clearErrorStack = require_error_stack_clear();
    var ERROR_STACK_INSTALLABLE = require_error_stack_installable();
    var captureStackTrace = Error.captureStackTrace;
    module.exports = function(error, C2, stack, dropEntries) {
      if (ERROR_STACK_INSTALLABLE) {
        if (captureStackTrace) captureStackTrace(error, C2);
        else createNonEnumerableProperty(error, "stack", clearErrorStack(stack, dropEntries));
      }
    };
  }
});

// node_modules/core-js-pure/internals/iterators.js
var require_iterators = __commonJS({
  "node_modules/core-js-pure/internals/iterators.js"(exports, module) {
    "use strict";
    module.exports = {};
  }
});

// node_modules/core-js-pure/internals/is-array-iterator-method.js
var require_is_array_iterator_method = __commonJS({
  "node_modules/core-js-pure/internals/is-array-iterator-method.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var ITERATOR = wellKnownSymbol("iterator");
    var ArrayPrototype = Array.prototype;
    module.exports = function(it2) {
      return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
    };
  }
});

// node_modules/core-js-pure/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "node_modules/core-js-pure/internals/to-string-tag-support.js"(exports, module) {
    "use strict";
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test4 = {};
    test4[TO_STRING_TAG] = "z";
    module.exports = String(test4) === "[object z]";
  }
});

// node_modules/core-js-pure/internals/classof.js
var require_classof = __commonJS({
  "node_modules/core-js-pure/internals/classof.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
      return arguments;
    }()) === "Arguments";
    var tryGet = function(it2, key57) {
      try {
        return it2[key57];
      } catch (error) {
      }
    };
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
      var O2, tag, result;
      return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = $Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) === "Object" && isCallable(O2.callee) ? "Arguments" : result;
    };
  }
});

// node_modules/core-js-pure/internals/get-iterator-method.js
var require_get_iterator_method = __commonJS({
  "node_modules/core-js-pure/internals/get-iterator-method.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var getMethod = require_get_method();
    var isNullOrUndefined = require_is_null_or_undefined();
    var Iterators = require_iterators();
    var wellKnownSymbol = require_well_known_symbol();
    var ITERATOR = wellKnownSymbol("iterator");
    module.exports = function(it2) {
      if (!isNullOrUndefined(it2)) return getMethod(it2, ITERATOR) || getMethod(it2, "@@iterator") || Iterators[classof(it2)];
    };
  }
});

// node_modules/core-js-pure/internals/get-iterator.js
var require_get_iterator = __commonJS({
  "node_modules/core-js-pure/internals/get-iterator.js"(exports, module) {
    "use strict";
    var call3 = require_function_call();
    var aCallable = require_a_callable();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var getIteratorMethod = require_get_iterator_method();
    var $TypeError = TypeError;
    module.exports = function(argument, usingIterator) {
      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
      if (aCallable(iteratorMethod)) return anObject(call3(iteratorMethod, argument));
      throw new $TypeError(tryToString(argument) + " is not iterable");
    };
  }
});

// node_modules/core-js-pure/internals/iterator-close.js
var require_iterator_close = __commonJS({
  "node_modules/core-js-pure/internals/iterator-close.js"(exports, module) {
    "use strict";
    var call3 = require_function_call();
    var anObject = require_an_object();
    var getMethod = require_get_method();
    module.exports = function(iterator, kind, value) {
      var innerResult, innerError;
      anObject(iterator);
      try {
        innerResult = getMethod(iterator, "return");
        if (!innerResult) {
          if (kind === "throw") throw value;
          return value;
        }
        innerResult = call3(innerResult, iterator);
      } catch (error) {
        innerError = true;
        innerResult = error;
      }
      if (kind === "throw") throw value;
      if (innerError) throw innerResult;
      anObject(innerResult);
      return value;
    };
  }
});

// node_modules/core-js-pure/internals/iterate.js
var require_iterate = __commonJS({
  "node_modules/core-js-pure/internals/iterate.js"(exports, module) {
    "use strict";
    var bind3 = require_function_bind_context();
    var call3 = require_function_call();
    var anObject = require_an_object();
    var tryToString = require_try_to_string();
    var isArrayIteratorMethod = require_is_array_iterator_method();
    var lengthOfArrayLike = require_length_of_array_like();
    var isPrototypeOf2 = require_object_is_prototype_of();
    var getIterator = require_get_iterator();
    var getIteratorMethod = require_get_iterator_method();
    var iteratorClose = require_iterator_close();
    var $TypeError = TypeError;
    var Result = function(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };
    var ResultPrototype = Result.prototype;
    module.exports = function(iterable, unboundFunction, options) {
      var that = options && options.that;
      var AS_ENTRIES = !!(options && options.AS_ENTRIES);
      var IS_RECORD = !!(options && options.IS_RECORD);
      var IS_ITERATOR = !!(options && options.IS_ITERATOR);
      var INTERRUPTED = !!(options && options.INTERRUPTED);
      var fn2 = bind3(unboundFunction, that);
      var iterator, iterFn, index, length3, result, next, step;
      var stop = function(condition) {
        if (iterator) iteratorClose(iterator, "normal", condition);
        return new Result(true, condition);
      };
      var callFn = function(value) {
        if (AS_ENTRIES) {
          anObject(value);
          return INTERRUPTED ? fn2(value[0], value[1], stop) : fn2(value[0], value[1]);
        }
        return INTERRUPTED ? fn2(value, stop) : fn2(value);
      };
      if (IS_RECORD) {
        iterator = iterable.iterator;
      } else if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (!iterFn) throw new $TypeError(tryToString(iterable) + " is not iterable");
        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length3 = lengthOfArrayLike(iterable); length3 > index; index++) {
            result = callFn(iterable[index]);
            if (result && isPrototypeOf2(ResultPrototype, result)) return result;
          }
          return new Result(false);
        }
        iterator = getIterator(iterable, iterFn);
      }
      next = IS_RECORD ? iterable.next : iterator.next;
      while (!(step = call3(next, iterator)).done) {
        try {
          result = callFn(step.value);
        } catch (error) {
          iteratorClose(iterator, "throw", error);
        }
        if (typeof result == "object" && result && isPrototypeOf2(ResultPrototype, result)) return result;
      }
      return new Result(false);
    };
  }
});

// node_modules/core-js-pure/internals/to-string.js
var require_to_string = __commonJS({
  "node_modules/core-js-pure/internals/to-string.js"(exports, module) {
    "use strict";
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// node_modules/core-js-pure/internals/normalize-string-argument.js
var require_normalize_string_argument = __commonJS({
  "node_modules/core-js-pure/internals/normalize-string-argument.js"(exports, module) {
    "use strict";
    var toString5 = require_to_string();
    module.exports = function(argument, $default) {
      return argument === void 0 ? arguments.length < 2 ? "" : $default : toString5(argument);
    };
  }
});

// node_modules/core-js-pure/modules/es.aggregate-error.constructor.js
var require_es_aggregate_error_constructor = __commonJS({
  "node_modules/core-js-pure/modules/es.aggregate-error.constructor.js"() {
    "use strict";
    var $ = require_export();
    var isPrototypeOf2 = require_object_is_prototype_of();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var setPrototypeOf2 = require_object_set_prototype_of();
    var copyConstructorProperties = require_copy_constructor_properties();
    var create2 = require_object_create();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    var installErrorCause = require_install_error_cause();
    var installErrorStack = require_error_stack_install();
    var iterate = require_iterate();
    var normalizeStringArgument = require_normalize_string_argument();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Error = Error;
    var push = [].push;
    var $AggregateError = function AggregateError(errors, message) {
      var isInstance = isPrototypeOf2(AggregateErrorPrototype, this);
      var that;
      if (setPrototypeOf2) {
        that = setPrototypeOf2(new $Error(), isInstance ? getPrototypeOf3(this) : AggregateErrorPrototype);
      } else {
        that = isInstance ? this : create2(AggregateErrorPrototype);
        createNonEnumerableProperty(that, TO_STRING_TAG, "Error");
      }
      if (message !== void 0) createNonEnumerableProperty(that, "message", normalizeStringArgument(message));
      installErrorStack(that, $AggregateError, that.stack, 1);
      if (arguments.length > 2) installErrorCause(that, arguments[2]);
      var errorsArray = [];
      iterate(errors, push, { that: errorsArray });
      createNonEnumerableProperty(that, "errors", errorsArray);
      return that;
    };
    if (setPrototypeOf2) setPrototypeOf2($AggregateError, $Error);
    else copyConstructorProperties($AggregateError, $Error, { name: true });
    var AggregateErrorPrototype = $AggregateError.prototype = create2($Error.prototype, {
      constructor: createPropertyDescriptor(1, $AggregateError),
      message: createPropertyDescriptor(1, ""),
      name: createPropertyDescriptor(1, "AggregateError")
    });
    $({ global: true, constructor: true, arity: 2 }, {
      AggregateError: $AggregateError
    });
  }
});

// node_modules/core-js-pure/modules/es.aggregate-error.js
var require_es_aggregate_error = __commonJS({
  "node_modules/core-js-pure/modules/es.aggregate-error.js"() {
    "use strict";
    require_es_aggregate_error_constructor();
  }
});

// node_modules/core-js-pure/modules/esnext.aggregate-error.js
var require_esnext_aggregate_error = __commonJS({
  "node_modules/core-js-pure/modules/esnext.aggregate-error.js"() {
    "use strict";
    require_es_aggregate_error();
  }
});

// node_modules/core-js-pure/internals/proxy-accessor.js
var require_proxy_accessor = __commonJS({
  "node_modules/core-js-pure/internals/proxy-accessor.js"(exports, module) {
    "use strict";
    var defineProperty2 = require_object_define_property().f;
    module.exports = function(Target, Source, key57) {
      key57 in Target || defineProperty2(Target, key57, {
        configurable: true,
        get: function() {
          return Source[key57];
        },
        set: function(it2) {
          Source[key57] = it2;
        }
      });
    };
  }
});

// node_modules/core-js-pure/internals/inherit-if-required.js
var require_inherit_if_required = __commonJS({
  "node_modules/core-js-pure/internals/inherit-if-required.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var isObject6 = require_is_object();
    var setPrototypeOf2 = require_object_set_prototype_of();
    module.exports = function($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if (
        // it can work only with native `setPrototypeOf`
        setPrototypeOf2 && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject6(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
      ) setPrototypeOf2($this, NewTargetPrototype);
      return $this;
    };
  }
});

// node_modules/core-js-pure/internals/wrap-error-constructor-with-cause.js
var require_wrap_error_constructor_with_cause = __commonJS({
  "node_modules/core-js-pure/internals/wrap-error-constructor-with-cause.js"(exports, module) {
    "use strict";
    var getBuiltIn = require_get_built_in();
    var hasOwn2 = require_has_own_property();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var isPrototypeOf2 = require_object_is_prototype_of();
    var setPrototypeOf2 = require_object_set_prototype_of();
    var copyConstructorProperties = require_copy_constructor_properties();
    var proxyAccessor = require_proxy_accessor();
    var inheritIfRequired = require_inherit_if_required();
    var normalizeStringArgument = require_normalize_string_argument();
    var installErrorCause = require_install_error_cause();
    var installErrorStack = require_error_stack_install();
    var DESCRIPTORS = require_descriptors();
    var IS_PURE = require_is_pure();
    module.exports = function(FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {
      var STACK_TRACE_LIMIT = "stackTraceLimit";
      var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;
      var path4 = FULL_NAME.split(".");
      var ERROR_NAME = path4[path4.length - 1];
      var OriginalError = getBuiltIn.apply(null, path4);
      if (!OriginalError) return;
      var OriginalErrorPrototype = OriginalError.prototype;
      if (!IS_PURE && hasOwn2(OriginalErrorPrototype, "cause")) delete OriginalErrorPrototype.cause;
      if (!FORCED) return OriginalError;
      var BaseError = getBuiltIn("Error");
      var WrappedError = wrapper(function(a2, b) {
        var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a2, void 0);
        var result = IS_AGGREGATE_ERROR ? new OriginalError(a2) : new OriginalError();
        if (message !== void 0) createNonEnumerableProperty(result, "message", message);
        installErrorStack(result, WrappedError, result.stack, 2);
        if (this && isPrototypeOf2(OriginalErrorPrototype, this)) inheritIfRequired(result, this, WrappedError);
        if (arguments.length > OPTIONS_POSITION) installErrorCause(result, arguments[OPTIONS_POSITION]);
        return result;
      });
      WrappedError.prototype = OriginalErrorPrototype;
      if (ERROR_NAME !== "Error") {
        if (setPrototypeOf2) setPrototypeOf2(WrappedError, BaseError);
        else copyConstructorProperties(WrappedError, BaseError, { name: true });
      } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {
        proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);
        proxyAccessor(WrappedError, OriginalError, "prepareStackTrace");
      }
      copyConstructorProperties(WrappedError, OriginalError);
      if (!IS_PURE) try {
        if (OriginalErrorPrototype.name !== ERROR_NAME) {
          createNonEnumerableProperty(OriginalErrorPrototype, "name", ERROR_NAME);
        }
        OriginalErrorPrototype.constructor = WrappedError;
      } catch (error) {
      }
      return WrappedError;
    };
  }
});

// node_modules/core-js-pure/modules/es.error.cause.js
var require_es_error_cause = __commonJS({
  "node_modules/core-js-pure/modules/es.error.cause.js"() {
    "use strict";
    var $ = require_export();
    var globalThis2 = require_global_this();
    var apply4 = require_function_apply();
    var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
    var WEB_ASSEMBLY = "WebAssembly";
    var WebAssembly = globalThis2[WEB_ASSEMBLY];
    var FORCED = new Error("e", { cause: 7 }).cause !== 7;
    var exportGlobalErrorCauseWrapper = function(ERROR_NAME, wrapper) {
      var O2 = {};
      O2[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);
      $({ global: true, constructor: true, arity: 1, forced: FORCED }, O2);
    };
    var exportWebAssemblyErrorCauseWrapper = function(ERROR_NAME, wrapper) {
      if (WebAssembly && WebAssembly[ERROR_NAME]) {
        var O2 = {};
        O2[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + "." + ERROR_NAME, wrapper, FORCED);
        $({ target: WEB_ASSEMBLY, stat: true, constructor: true, arity: 1, forced: FORCED }, O2);
      }
    };
    exportGlobalErrorCauseWrapper("Error", function(init2) {
      return function Error2(message) {
        return apply4(init2, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("EvalError", function(init2) {
      return function EvalError2(message) {
        return apply4(init2, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("RangeError", function(init2) {
      return function RangeError2(message) {
        return apply4(init2, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("ReferenceError", function(init2) {
      return function ReferenceError2(message) {
        return apply4(init2, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("SyntaxError", function(init2) {
      return function SyntaxError2(message) {
        return apply4(init2, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("TypeError", function(init2) {
      return function TypeError2(message) {
        return apply4(init2, this, arguments);
      };
    });
    exportGlobalErrorCauseWrapper("URIError", function(init2) {
      return function URIError2(message) {
        return apply4(init2, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper("CompileError", function(init2) {
      return function CompileError(message) {
        return apply4(init2, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper("LinkError", function(init2) {
      return function LinkError(message) {
        return apply4(init2, this, arguments);
      };
    });
    exportWebAssemblyErrorCauseWrapper("RuntimeError", function(init2) {
      return function RuntimeError(message) {
        return apply4(init2, this, arguments);
      };
    });
  }
});

// node_modules/core-js-pure/modules/es.aggregate-error.cause.js
var require_es_aggregate_error_cause = __commonJS({
  "node_modules/core-js-pure/modules/es.aggregate-error.cause.js"() {
    "use strict";
    var $ = require_export();
    var getBuiltIn = require_get_built_in();
    var apply4 = require_function_apply();
    var fails = require_fails();
    var wrapErrorConstructorWithCause = require_wrap_error_constructor_with_cause();
    var AGGREGATE_ERROR = "AggregateError";
    var $AggregateError = getBuiltIn(AGGREGATE_ERROR);
    var FORCED = !fails(function() {
      return $AggregateError([1]).errors[0] !== 1;
    }) && fails(function() {
      return $AggregateError([1], AGGREGATE_ERROR, { cause: 7 }).cause !== 7;
    });
    $({ global: true, constructor: true, arity: 2, forced: FORCED }, {
      AggregateError: wrapErrorConstructorWithCause(AGGREGATE_ERROR, function(init2) {
        return function AggregateError(errors, message) {
          return apply4(init2, this, arguments);
        };
      }, FORCED, true)
    });
  }
});

// node_modules/core-js-pure/internals/add-to-unscopables.js
var require_add_to_unscopables = __commonJS({
  "node_modules/core-js-pure/internals/add-to-unscopables.js"(exports, module) {
    "use strict";
    module.exports = function() {
    };
  }
});

// node_modules/core-js-pure/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "node_modules/core-js-pure/internals/weak-map-basic-detection.js"(exports, module) {
    "use strict";
    var globalThis2 = require_global_this();
    var isCallable = require_is_callable();
    var WeakMap2 = globalThis2.WeakMap;
    module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
  }
});

// node_modules/core-js-pure/internals/internal-state.js
var require_internal_state = __commonJS({
  "node_modules/core-js-pure/internals/internal-state.js"(exports, module) {
    "use strict";
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var globalThis2 = require_global_this();
    var isObject6 = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn2 = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = globalThis2.TypeError;
    var WeakMap2 = globalThis2.WeakMap;
    var set4;
    var get3;
    var has4;
    var enforce = function(it2) {
      return has4(it2) ? get3(it2) : set4(it2, {});
    };
    var getterFor = function(TYPE) {
      return function(it2) {
        var state2;
        if (!isObject6(it2) || (state2 = get3(it2)).type !== TYPE) {
          throw new TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state2;
      };
    };
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set4 = function(it2, metadata) {
        if (store.has(it2)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it2;
        store.set(it2, metadata);
        return metadata;
      };
      get3 = function(it2) {
        return store.get(it2) || {};
      };
      has4 = function(it2) {
        return store.has(it2);
      };
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set4 = function(it2, metadata) {
        if (hasOwn2(it2, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it2;
        createNonEnumerableProperty(it2, STATE, metadata);
        return metadata;
      };
      get3 = function(it2) {
        return hasOwn2(it2, STATE) ? it2[STATE] : {};
      };
      has4 = function(it2) {
        return hasOwn2(it2, STATE);
      };
    }
    var store;
    var STATE;
    module.exports = {
      set: set4,
      get: get3,
      has: has4,
      enforce,
      getterFor
    };
  }
});

// node_modules/core-js-pure/internals/function-name.js
var require_function_name = __commonJS({
  "node_modules/core-js-pure/internals/function-name.js"(exports, module) {
    "use strict";
    var DESCRIPTORS = require_descriptors();
    var hasOwn2 = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn2(FunctionPrototype, "name");
    var PROPER = EXISTS && (function something() {
    }).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// node_modules/core-js-pure/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "node_modules/core-js-pure/internals/define-built-in.js"(exports, module) {
    "use strict";
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    module.exports = function(target, key57, value, options) {
      if (options && options.enumerable) target[key57] = value;
      else createNonEnumerableProperty(target, key57, value);
      return target;
    };
  }
});

// node_modules/core-js-pure/internals/iterators-core.js
var require_iterators_core = __commonJS({
  "node_modules/core-js-pure/internals/iterators-core.js"(exports, module) {
    "use strict";
    var fails = require_fails();
    var isCallable = require_is_callable();
    var isObject6 = require_is_object();
    var create2 = require_object_create();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var ITERATOR = wellKnownSymbol("iterator");
    var BUGGY_SAFARI_ITERATORS = false;
    var IteratorPrototype;
    var PrototypeOfArrayIteratorPrototype;
    var arrayIterator;
    if ([].keys) {
      arrayIterator = [].keys();
      if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
      else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf3(getPrototypeOf3(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }
    var NEW_ITERATOR_PROTOTYPE = !isObject6(IteratorPrototype) || fails(function() {
      var test4 = {};
      return IteratorPrototype[ITERATOR].call(test4) !== test4;
    });
    if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
    else if (IS_PURE) IteratorPrototype = create2(IteratorPrototype);
    if (!isCallable(IteratorPrototype[ITERATOR])) {
      defineBuiltIn(IteratorPrototype, ITERATOR, function() {
        return this;
      });
    }
    module.exports = {
      IteratorPrototype,
      BUGGY_SAFARI_ITERATORS
    };
  }
});

// node_modules/core-js-pure/internals/object-to-string.js
var require_object_to_string = __commonJS({
  "node_modules/core-js-pure/internals/object-to-string.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var classof = require_classof();
    module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString5() {
      return "[object " + classof(this) + "]";
    };
  }
});

// node_modules/core-js-pure/internals/set-to-string-tag.js
var require_set_to_string_tag = __commonJS({
  "node_modules/core-js-pure/internals/set-to-string-tag.js"(exports, module) {
    "use strict";
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var defineProperty2 = require_object_define_property().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn2 = require_has_own_property();
    var toString5 = require_object_to_string();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    module.exports = function(it2, TAG, STATIC, SET_METHOD) {
      var target = STATIC ? it2 : it2 && it2.prototype;
      if (target) {
        if (!hasOwn2(target, TO_STRING_TAG)) {
          defineProperty2(target, TO_STRING_TAG, { configurable: true, value: TAG });
        }
        if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
          createNonEnumerableProperty(target, "toString", toString5);
        }
      }
    };
  }
});

// node_modules/core-js-pure/internals/iterator-create-constructor.js
var require_iterator_create_constructor = __commonJS({
  "node_modules/core-js-pure/internals/iterator-create-constructor.js"(exports, module) {
    "use strict";
    var IteratorPrototype = require_iterators_core().IteratorPrototype;
    var create2 = require_object_create();
    var createPropertyDescriptor = require_create_property_descriptor();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    var returnThis = function() {
      return this;
    };
    module.exports = function(IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
      var TO_STRING_TAG = NAME + " Iterator";
      IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
  }
});

// node_modules/core-js-pure/internals/iterator-define.js
var require_iterator_define = __commonJS({
  "node_modules/core-js-pure/internals/iterator-define.js"(exports, module) {
    "use strict";
    var $ = require_export();
    var call3 = require_function_call();
    var IS_PURE = require_is_pure();
    var FunctionName = require_function_name();
    var isCallable = require_is_callable();
    var createIteratorConstructor = require_iterator_create_constructor();
    var getPrototypeOf3 = require_object_get_prototype_of();
    var setPrototypeOf2 = require_object_set_prototype_of();
    var setToStringTag = require_set_to_string_tag();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var wellKnownSymbol = require_well_known_symbol();
    var Iterators = require_iterators();
    var IteratorsCore = require_iterators_core();
    var PROPER_FUNCTION_NAME = FunctionName.PROPER;
    var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol("iterator");
    var KEYS = "keys";
    var VALUES = "values";
    var ENTRIES = "entries";
    var returnThis = function() {
      return this;
    };
    module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);
      var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch (KIND) {
          case KEYS:
            return function keys4() {
              return new IteratorConstructor(this, KIND);
            };
          case VALUES:
            return function values3() {
              return new IteratorConstructor(this, KIND);
            };
          case ENTRIES:
            return function entries2() {
              return new IteratorConstructor(this, KIND);
            };
        }
        return function() {
          return new IteratorConstructor(this);
        };
      };
      var TO_STRING_TAG = NAME + " Iterator";
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME === "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY;
      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf3(anyNativeIterator.call(new Iterable()));
        if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf3(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf2) {
              setPrototypeOf2(CurrentIteratorPrototype, IteratorPrototype);
            } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
              defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          }
          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
      }
      if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
          createNonEnumerableProperty(IterablePrototype, "name", VALUES);
        } else {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values3() {
            return call3(nativeIterator, this);
          };
        }
      }
      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
          }
        }
        else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
      }
      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
      }
      Iterators[NAME] = defaultIterator;
      return methods;
    };
  }
});

// node_modules/core-js-pure/internals/create-iter-result-object.js
var require_create_iter_result_object = __commonJS({
  "node_modules/core-js-pure/internals/create-iter-result-object.js"(exports, module) {
    "use strict";
    module.exports = function(value, done) {
      return { value, done };
    };
  }
});

// node_modules/core-js-pure/modules/es.array.iterator.js
var require_es_array_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.array.iterator.js"(exports, module) {
    "use strict";
    var toIndexedObject = require_to_indexed_object();
    var addToUnscopables = require_add_to_unscopables();
    var Iterators = require_iterators();
    var InternalStateModule = require_internal_state();
    var defineProperty2 = require_object_define_property().f;
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var IS_PURE = require_is_pure();
    var DESCRIPTORS = require_descriptors();
    var ARRAY_ITERATOR = "Array Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
    module.exports = defineIterator(Array, "Array", function(iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind
        // kind
      });
    }, function() {
      var state2 = getInternalState(this);
      var target = state2.target;
      var index = state2.index++;
      if (!target || index >= target.length) {
        state2.target = null;
        return createIterResultObject(void 0, true);
      }
      switch (state2.kind) {
        case "keys":
          return createIterResultObject(index, false);
        case "values":
          return createIterResultObject(target[index], false);
      }
      return createIterResultObject([index, target[index]], false);
    }, "values");
    var values3 = Iterators.Arguments = Iterators.Array;
    addToUnscopables("keys");
    addToUnscopables("values");
    addToUnscopables("entries");
    if (!IS_PURE && DESCRIPTORS && values3.name !== "values") try {
      defineProperty2(values3, "name", { value: "values" });
    } catch (error) {
    }
  }
});

// node_modules/core-js-pure/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "node_modules/core-js-pure/internals/string-multibyte.js"(exports, module) {
    "use strict";
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString5 = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = toString5(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? "" : void 0;
        first = charCodeAt(S, position);
        return first < 55296 || first > 56319 || position + 1 === size || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
      };
    };
    module.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.es/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
  }
});

// node_modules/core-js-pure/modules/es.string.iterator.js
var require_es_string_iterator = __commonJS({
  "node_modules/core-js-pure/modules/es.string.iterator.js"() {
    "use strict";
    var charAt = require_string_multibyte().charAt;
    var toString5 = require_to_string();
    var InternalStateModule = require_internal_state();
    var defineIterator = require_iterator_define();
    var createIterResultObject = require_create_iter_result_object();
    var STRING_ITERATOR = "String Iterator";
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
    defineIterator(String, "String", function(iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: toString5(iterated),
        index: 0
      });
    }, function next() {
      var state2 = getInternalState(this);
      var string = state2.string;
      var index = state2.index;
      var point;
      if (index >= string.length) return createIterResultObject(void 0, true);
      point = charAt(string, index);
      state2.index += point.length;
      return createIterResultObject(point, false);
    });
  }
});

// node_modules/core-js-pure/es/aggregate-error.js
var require_aggregate_error = __commonJS({
  "node_modules/core-js-pure/es/aggregate-error.js"(exports, module) {
    "use strict";
    require_es_error_cause();
    require_es_aggregate_error();
    require_es_aggregate_error_cause();
    require_es_array_iterator();
    require_es_string_iterator();
    var path4 = require_path();
    module.exports = path4.AggregateError;
  }
});

// node_modules/core-js-pure/internals/dom-iterables.js
var require_dom_iterables = __commonJS({
  "node_modules/core-js-pure/internals/dom-iterables.js"(exports, module) {
    "use strict";
    module.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
  }
});

// node_modules/core-js-pure/modules/web.dom-collections.iterator.js
var require_web_dom_collections_iterator = __commonJS({
  "node_modules/core-js-pure/modules/web.dom-collections.iterator.js"() {
    "use strict";
    require_es_array_iterator();
    var DOMIterables = require_dom_iterables();
    var globalThis2 = require_global_this();
    var setToStringTag = require_set_to_string_tag();
    var Iterators = require_iterators();
    for (COLLECTION_NAME in DOMIterables) {
      setToStringTag(globalThis2[COLLECTION_NAME], COLLECTION_NAME);
      Iterators[COLLECTION_NAME] = Iterators.Array;
    }
    var COLLECTION_NAME;
  }
});

// node_modules/core-js-pure/stable/aggregate-error.js
var require_aggregate_error2 = __commonJS({
  "node_modules/core-js-pure/stable/aggregate-error.js"(exports, module) {
    "use strict";
    require_esnext_aggregate_error();
    var parent = require_aggregate_error();
    require_web_dom_collections_iterator();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/actual/aggregate-error.js
var require_aggregate_error3 = __commonJS({
  "node_modules/core-js-pure/actual/aggregate-error.js"(exports, module) {
    "use strict";
    var parent = require_aggregate_error2();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/full/aggregate-error.js
var require_aggregate_error4 = __commonJS({
  "node_modules/core-js-pure/full/aggregate-error.js"(exports, module) {
    "use strict";
    require_esnext_aggregate_error();
    var parent = require_aggregate_error3();
    module.exports = parent;
  }
});

// node_modules/core-js-pure/features/aggregate-error.js
var require_aggregate_error5 = __commonJS({
  "node_modules/core-js-pure/features/aggregate-error.js"(exports, module) {
    "use strict";
    module.exports = require_aggregate_error4();
  }
});

// node_modules/@babel/runtime-corejs3/core-js/aggregate-error.js
var require_aggregate_error6 = __commonJS({
  "node_modules/@babel/runtime-corejs3/core-js/aggregate-error.js"(exports, module) {
    module.exports = require_aggregate_error5();
  }
});

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports, module) {
    var process3 = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e2) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e2) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e2) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e3) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e2) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e3) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process3.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          args[i2 - 1] = arguments[i2];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array2) {
      this.fun = fun;
      this.array = array2;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop3() {
    }
    process3.on = noop3;
    process3.addListener = noop3;
    process3.once = noop3;
    process3.off = noop3;
    process3.removeListener = noop3;
    process3.removeAllListeners = noop3;
    process3.emit = noop3;
    process3.prependListener = noop3;
    process3.prependOnceListener = noop3;
    process3.listeners = function(name2) {
      return [];
    };
    process3.binding = function(name2) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
  }
});

// node_modules/lodash/isNull.js
var require_isNull = __commonJS({
  "node_modules/lodash/isNull.js"(exports, module) {
    function isNull4(value) {
      return value === null;
    }
    module.exports = isNull4;
  }
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber3(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber3;
  }
});

// node_modules/lodash/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/lodash/isBoolean.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var boolTag = "[object Boolean]";
    function isBoolean3(value) {
      return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
    }
    module.exports = isBoolean3;
  }
});

// node_modules/minim/lib/serialisers/JSONSerialiser.js
var require_JSONSerialiser = __commonJS({
  "node_modules/minim/lib/serialisers/JSONSerialiser.js"(exports, module) {
    var JSONSerialiser = class {
      constructor(namespace2) {
        this.namespace = namespace2 || new this.Namespace();
      }
      /**
       * @param {Element} element
       * @returns {object}
       */
      serialise(element) {
        if (!(element instanceof this.namespace.elements.Element)) {
          throw new TypeError(`Given element \`${element}\` is not an Element instance`);
        }
        const payload = {
          element: element.element
        };
        if (element._meta && element._meta.length > 0) {
          payload.meta = this.serialiseObject(element.meta);
        }
        if (element._attributes && element._attributes.length > 0) {
          payload.attributes = this.serialiseObject(element.attributes);
        }
        const content = this.serialiseContent(element.content);
        if (content !== void 0) {
          payload.content = content;
        }
        return payload;
      }
      /**
       * @param {object} value
       * @returns {Element}
       */
      deserialise(value) {
        if (!value.element) {
          throw new Error("Given value is not an object containing an element name");
        }
        const ElementClass = this.namespace.getElementClass(value.element);
        const element = new ElementClass();
        if (element.element !== value.element) {
          element.element = value.element;
        }
        if (value.meta) {
          this.deserialiseObject(value.meta, element.meta);
        }
        if (value.attributes) {
          this.deserialiseObject(value.attributes, element.attributes);
        }
        const content = this.deserialiseContent(value.content);
        if (content !== void 0 || element.content === null) {
          element.content = content;
        }
        return element;
      }
      // Private API
      serialiseContent(content) {
        if (content instanceof this.namespace.elements.Element) {
          return this.serialise(content);
        }
        if (content instanceof this.namespace.KeyValuePair) {
          const pair3 = {
            key: this.serialise(content.key)
          };
          if (content.value) {
            pair3.value = this.serialise(content.value);
          }
          return pair3;
        }
        if (content && content.map) {
          if (content.length === 0) {
            return void 0;
          }
          return content.map(this.serialise, this);
        }
        return content;
      }
      deserialiseContent(content) {
        if (content) {
          if (content.element) {
            return this.deserialise(content);
          }
          if (content.key) {
            const pair3 = new this.namespace.KeyValuePair(this.deserialise(content.key));
            if (content.value) {
              pair3.value = this.deserialise(content.value);
            }
            return pair3;
          }
          if (content.map) {
            return content.map(this.deserialise, this);
          }
        }
        return content;
      }
      serialiseObject(obj) {
        const result = {};
        obj.forEach((value, key57) => {
          if (value) {
            result[key57.toValue()] = this.serialise(value);
          }
        });
        if (Object.keys(result).length === 0) {
          return void 0;
        }
        return result;
      }
      deserialiseObject(from2, to2) {
        Object.keys(from2).forEach((key57) => {
          to2.set(key57, this.deserialise(from2[key57]));
        });
      }
    };
    module.exports = JSONSerialiser;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    module.exports = isEqual;
  }
});

// node_modules/minim/lib/KeyValuePair.js
var require_KeyValuePair = __commonJS({
  "node_modules/minim/lib/KeyValuePair.js"(exports, module) {
    var KeyValuePair3 = class _KeyValuePair {
      constructor(key57, value) {
        this.key = key57;
        this.value = value;
      }
      /**
       * @returns {KeyValuePair}
       */
      clone() {
        const clone4 = new _KeyValuePair();
        if (this.key) {
          clone4.key = this.key.clone();
        }
        if (this.value) {
          clone4.value = this.value.clone();
        }
        return clone4;
      }
    };
    module.exports = KeyValuePair3;
  }
});

// node_modules/lodash/negate.js
var require_negate = __commonJS({
  "node_modules/lodash/negate.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    function negate3(predicate) {
      if (typeof predicate != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0:
            return !predicate.call(this);
          case 1:
            return !predicate.call(this, args[0]);
          case 2:
            return !predicate.call(this, args[0], args[1]);
          case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }
    module.exports = negate3;
  }
});

// node_modules/minim/lib/ArraySlice.js
var require_ArraySlice = __commonJS({
  "node_modules/minim/lib/ArraySlice.js"(exports, module) {
    var negate3 = require_negate();
    function coerceElementMatchingCallback(value) {
      if (typeof value === "string") {
        return (element) => element.element === value;
      }
      if (value.constructor && value.extend) {
        return (element) => element instanceof value;
      }
      return value;
    }
    var ArraySlice4 = class _ArraySlice {
      constructor(elements) {
        this.elements = elements || [];
      }
      /**
       * @returns {Array}
       */
      toValue() {
        return this.elements.map((element) => element.toValue());
      }
      // High Order Functions
      /**
       * @param callback - Function to execute for each element
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @returns {array} A new array with each element being the result of the callback function
       */
      map(callback, thisArg) {
        return this.elements.map(callback, thisArg);
      }
      /**
       * Maps and then flattens the results.
       * @param callback - Function to execute for each element.
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @returns {array}
       */
      flatMap(callback, thisArg) {
        return this.map(callback, thisArg).reduce((a2, b) => a2.concat(b), []);
      }
      /**
       * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
       * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @memberof ArraySlice.prototype
       * @returns An array of the non-undefined results of calling transform with each element of the array
       */
      compactMap(transform2, thisArg) {
        const results = [];
        this.forEach((element) => {
          const result = transform2.bind(thisArg)(element);
          if (result) {
            results.push(result);
          }
        });
        return results;
      }
      /**
       * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @returns {ArraySlice}
       * @memberof ArraySlice.prototype
       */
      filter(callback, thisArg) {
        callback = coerceElementMatchingCallback(callback);
        return new _ArraySlice(this.elements.filter(callback, thisArg));
      }
      /**
       * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @returns {ArraySlice}
       * @memberof ArraySlice.prototype
       */
      reject(callback, thisArg) {
        callback = coerceElementMatchingCallback(callback);
        return new _ArraySlice(this.elements.filter(negate3(callback), thisArg));
      }
      /**
       * Returns the first element in the array that satisfies the given value
       * @param callback - Function to execute for each element. This may be a callback, an element name or an element class.
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @returns {Element}
       * @memberof ArraySlice.prototype
       */
      find(callback, thisArg) {
        callback = coerceElementMatchingCallback(callback);
        return this.elements.find(callback, thisArg);
      }
      /**
       * @param callback - Function to execute for each element
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @memberof ArraySlice.prototype
       */
      forEach(callback, thisArg) {
        this.elements.forEach(callback, thisArg);
      }
      /**
       * @param callback - Function to execute for each element
       * @param initialValue
       * @memberof ArraySlice.prototype
       */
      reduce(callback, initialValue) {
        return this.elements.reduce(callback, initialValue);
      }
      /**
       * @param value
       * @returns {boolean}
       * @memberof ArraySlice.prototype
       */
      includes(value) {
        return this.elements.some((element) => element.equals(value));
      }
      // Mutation
      /**
       * Removes the first element from the slice
       * @returns {Element} The removed element or undefined if the slice is empty
       * @memberof ArraySlice.prototype
       */
      shift() {
        return this.elements.shift();
      }
      /**
       * Adds the given element to the begining of the slice
       * @parameter {Element} value
       * @memberof ArraySlice.prototype
       */
      unshift(value) {
        this.elements.unshift(this.refract(value));
      }
      /**
       * Adds the given element to the end of the slice
       * @parameter {Element} value
       * @memberof ArraySlice.prototype
       */
      push(value) {
        this.elements.push(this.refract(value));
        return this;
      }
      /**
       * @parameter {Element} value
       * @memberof ArraySlice.prototype
       */
      add(value) {
        this.push(value);
      }
      // Accessors
      /**
       * @parameter {number} index
       * @returns {Element}
       * @memberof ArraySlice.prototype
       */
      get(index) {
        return this.elements[index];
      }
      /**
       * @parameter {number} index
       * @memberof ArraySlice.prototype
       */
      getValue(index) {
        const element = this.elements[index];
        if (element) {
          return element.toValue();
        }
        return void 0;
      }
      /**
       * Returns the number of elements in the slice
       * @type number
       */
      get length() {
        return this.elements.length;
      }
      /**
       * Returns whether the slice is empty
       * @type boolean
       */
      get isEmpty() {
        return this.elements.length === 0;
      }
      /**
       * Returns the first element in the slice or undefined if the slice is empty
       * @type Element
       */
      get first() {
        return this.elements[0];
      }
    };
    if (typeof Symbol !== "undefined") {
      ArraySlice4.prototype[Symbol.iterator] = function symbol() {
        return this.elements[Symbol.iterator]();
      };
    }
    module.exports = ArraySlice4;
  }
});

// node_modules/minim/lib/primitives/Element.js
var require_Element = __commonJS({
  "node_modules/minim/lib/primitives/Element.js"(exports, module) {
    var isEqual = require_isEqual();
    var KeyValuePair3 = require_KeyValuePair();
    var ArraySlice4 = require_ArraySlice();
    var Element3 = class _Element {
      constructor(content, meta, attributes) {
        if (meta) {
          this.meta = meta;
        }
        if (attributes) {
          this.attributes = attributes;
        }
        this.content = content;
      }
      /**
       * Freezes the element to prevent any mutation.
       * A frozen element will add `parent` property to every child element
       * to allow traversing up the element tree.
       */
      freeze() {
        if (Object.isFrozen(this)) {
          return;
        }
        if (this._meta) {
          this.meta.parent = this;
          this.meta.freeze();
        }
        if (this._attributes) {
          this.attributes.parent = this;
          this.attributes.freeze();
        }
        this.children.forEach((element) => {
          element.parent = this;
          element.freeze();
        }, this);
        if (this.content && Array.isArray(this.content)) {
          Object.freeze(this.content);
        }
        Object.freeze(this);
      }
      primitive() {
      }
      /**
       * Creates a deep clone of the instance
       */
      clone() {
        const copy3 = new this.constructor();
        copy3.element = this.element;
        if (this.meta.length) {
          copy3._meta = this.meta.clone();
        }
        if (this.attributes.length) {
          copy3._attributes = this.attributes.clone();
        }
        if (this.content) {
          if (this.content.clone) {
            copy3.content = this.content.clone();
          } else if (Array.isArray(this.content)) {
            copy3.content = this.content.map((element) => element.clone());
          } else {
            copy3.content = this.content;
          }
        } else {
          copy3.content = this.content;
        }
        return copy3;
      }
      /**
       */
      toValue() {
        if (this.content instanceof _Element) {
          return this.content.toValue();
        }
        if (this.content instanceof KeyValuePair3) {
          return {
            key: this.content.key.toValue(),
            value: this.content.value ? this.content.value.toValue() : void 0
          };
        }
        if (this.content && this.content.map) {
          return this.content.map((element) => element.toValue(), this);
        }
        return this.content;
      }
      /**
       * Creates a reference pointing at the Element
       * @returns {RefElement}
       * @memberof Element.prototype
       */
      toRef(path4) {
        if (this.id.toValue() === "") {
          throw Error("Cannot create reference to an element that does not contain an ID");
        }
        const ref = new this.RefElement(this.id.toValue());
        if (path4) {
          ref.path = path4;
        }
        return ref;
      }
      /**
       * Finds the given elements in the element tree.
       * When providing multiple element names, you must first freeze the element.
       *
       * @param names {...elementNames}
       * @returns {ArraySlice}
       */
      findRecursive(...elementNames) {
        if (arguments.length > 1 && !this.isFrozen) {
          throw new Error("Cannot find recursive with multiple element names without first freezing the element. Call `element.freeze()`");
        }
        const elementName = elementNames.pop();
        let elements = new ArraySlice4();
        const append3 = (array2, element) => {
          array2.push(element);
          return array2;
        };
        const checkElement = (array2, element) => {
          if (element.element === elementName) {
            array2.push(element);
          }
          const items = element.findRecursive(elementName);
          if (items) {
            items.reduce(append3, array2);
          }
          if (element.content instanceof KeyValuePair3) {
            if (element.content.key) {
              checkElement(array2, element.content.key);
            }
            if (element.content.value) {
              checkElement(array2, element.content.value);
            }
          }
          return array2;
        };
        if (this.content) {
          if (this.content.element) {
            checkElement(elements, this.content);
          }
          if (Array.isArray(this.content)) {
            this.content.reduce(checkElement, elements);
          }
        }
        if (!elementNames.isEmpty) {
          elements = elements.filter((element) => {
            let parentElements = element.parents.map((e2) => e2.element);
            for (const namesIndex in elementNames) {
              const name2 = elementNames[namesIndex];
              const index = parentElements.indexOf(name2);
              if (index !== -1) {
                parentElements = parentElements.splice(0, index);
              } else {
                return false;
              }
            }
            return true;
          });
        }
        return elements;
      }
      set(content) {
        this.content = content;
        return this;
      }
      equals(value) {
        return isEqual(this.toValue(), value);
      }
      getMetaProperty(name2, value) {
        if (!this.meta.hasKey(name2)) {
          if (this.isFrozen) {
            const element = this.refract(value);
            element.freeze();
            return element;
          }
          this.meta.set(name2, value);
        }
        return this.meta.get(name2);
      }
      setMetaProperty(name2, value) {
        this.meta.set(name2, value);
      }
      /**
       * @type String
       */
      get element() {
        return this._storedElement || "element";
      }
      set element(element) {
        this._storedElement = element;
      }
      get content() {
        return this._content;
      }
      set content(value) {
        if (value instanceof _Element) {
          this._content = value;
        } else if (value instanceof ArraySlice4) {
          this.content = value.elements;
        } else if (typeof value == "string" || typeof value == "number" || typeof value == "boolean" || value === "null" || value == void 0) {
          this._content = value;
        } else if (value instanceof KeyValuePair3) {
          this._content = value;
        } else if (Array.isArray(value)) {
          this._content = value.map(this.refract);
        } else if (typeof value === "object") {
          this._content = Object.keys(value).map((key57) => new this.MemberElement(key57, value[key57]));
        } else {
          throw new Error("Cannot set content to given value");
        }
      }
      /**
       * @type ObjectElement
       */
      get meta() {
        if (!this._meta) {
          if (this.isFrozen) {
            const meta = new this.ObjectElement();
            meta.freeze();
            return meta;
          }
          this._meta = new this.ObjectElement();
        }
        return this._meta;
      }
      set meta(value) {
        if (value instanceof this.ObjectElement) {
          this._meta = value;
        } else {
          this.meta.set(value || {});
        }
      }
      /**
       * The attributes property defines attributes about the given instance
       * of the element, as specified by the element property.
       *
       * @type ObjectElement
       */
      get attributes() {
        if (!this._attributes) {
          if (this.isFrozen) {
            const meta = new this.ObjectElement();
            meta.freeze();
            return meta;
          }
          this._attributes = new this.ObjectElement();
        }
        return this._attributes;
      }
      set attributes(value) {
        if (value instanceof this.ObjectElement) {
          this._attributes = value;
        } else {
          this.attributes.set(value || {});
        }
      }
      /**
       * Unique Identifier, MUST be unique throughout an entire element tree.
       * @type StringElement
       */
      get id() {
        return this.getMetaProperty("id", "");
      }
      set id(element) {
        this.setMetaProperty("id", element);
      }
      /**
       * @type ArrayElement
       */
      get classes() {
        return this.getMetaProperty("classes", []);
      }
      set classes(element) {
        this.setMetaProperty("classes", element);
      }
      /**
       * Human-readable title of element
       * @type StringElement
       */
      get title() {
        return this.getMetaProperty("title", "");
      }
      set title(element) {
        this.setMetaProperty("title", element);
      }
      /**
       * Human-readable description of element
       * @type StringElement
       */
      get description() {
        return this.getMetaProperty("description", "");
      }
      set description(element) {
        this.setMetaProperty("description", element);
      }
      /**
       * @type ArrayElement
       */
      get links() {
        return this.getMetaProperty("links", []);
      }
      set links(element) {
        this.setMetaProperty("links", element);
      }
      /**
       * Returns whether the element is frozen.
       * @type boolean
       * @see freeze
       */
      get isFrozen() {
        return Object.isFrozen(this);
      }
      /**
       * Returns all of the parent elements.
       * @type ArraySlice
       */
      get parents() {
        let { parent } = this;
        const parents = new ArraySlice4();
        while (parent) {
          parents.push(parent);
          parent = parent.parent;
        }
        return parents;
      }
      /**
       * Returns all of the children elements found within the element.
       * @type ArraySlice
       * @see recursiveChildren
       */
      get children() {
        if (Array.isArray(this.content)) {
          return new ArraySlice4(this.content);
        }
        if (this.content instanceof KeyValuePair3) {
          const children = new ArraySlice4([this.content.key]);
          if (this.content.value) {
            children.push(this.content.value);
          }
          return children;
        }
        if (this.content instanceof _Element) {
          return new ArraySlice4([this.content]);
        }
        return new ArraySlice4();
      }
      /**
      * Returns all of the children elements found within the element recursively.
      * @type ArraySlice
      * @see children
      */
      get recursiveChildren() {
        const children = new ArraySlice4();
        this.children.forEach((element) => {
          children.push(element);
          element.recursiveChildren.forEach((child) => {
            children.push(child);
          });
        });
        return children;
      }
    };
    module.exports = Element3;
  }
});

// node_modules/minim/lib/primitives/NullElement.js
var require_NullElement = __commonJS({
  "node_modules/minim/lib/primitives/NullElement.js"(exports, module) {
    var Element3 = require_Element();
    var NullElement3 = class extends Element3 {
      constructor(content, meta, attributes) {
        super(content || null, meta, attributes);
        this.element = "null";
      }
      primitive() {
        return "null";
      }
      set() {
        return new Error("Cannot set the value of null");
      }
    };
    module.exports = NullElement3;
  }
});

// node_modules/minim/lib/primitives/StringElement.js
var require_StringElement = __commonJS({
  "node_modules/minim/lib/primitives/StringElement.js"(exports, module) {
    var Element3 = require_Element();
    module.exports = class StringElement extends Element3 {
      constructor(content, meta, attributes) {
        super(content, meta, attributes);
        this.element = "string";
      }
      primitive() {
        return "string";
      }
      /**
       * The length of the string.
       * @type number
       */
      get length() {
        return this.content.length;
      }
    };
  }
});

// node_modules/minim/lib/primitives/NumberElement.js
var require_NumberElement = __commonJS({
  "node_modules/minim/lib/primitives/NumberElement.js"(exports, module) {
    var Element3 = require_Element();
    module.exports = class NumberElement extends Element3 {
      constructor(content, meta, attributes) {
        super(content, meta, attributes);
        this.element = "number";
      }
      primitive() {
        return "number";
      }
    };
  }
});

// node_modules/minim/lib/primitives/BooleanElement.js
var require_BooleanElement = __commonJS({
  "node_modules/minim/lib/primitives/BooleanElement.js"(exports, module) {
    var Element3 = require_Element();
    module.exports = class BooleanElement extends Element3 {
      constructor(content, meta, attributes) {
        super(content, meta, attributes);
        this.element = "boolean";
      }
      primitive() {
        return "boolean";
      }
    };
  }
});

// node_modules/minim/lib/primitives/ArrayElement.js
var require_ArrayElement = __commonJS({
  "node_modules/minim/lib/primitives/ArrayElement.js"(exports, module) {
    var negate3 = require_negate();
    var Element3 = require_Element();
    var ArraySlice4 = require_ArraySlice();
    var ArrayElement6 = class extends Element3 {
      constructor(content, meta, attributes) {
        super(content || [], meta, attributes);
        this.element = "array";
      }
      primitive() {
        return "array";
      }
      /**
       * @returns {Element}
       */
      get(index) {
        return this.content[index];
      }
      /**
       * Helper for returning the value of an item
       * This works for both ArrayElement and ObjectElement instances
       */
      getValue(indexOrKey) {
        const item = this.get(indexOrKey);
        if (item) {
          return item.toValue();
        }
        return void 0;
      }
      /**
       * @returns {Element}
       */
      getIndex(index) {
        return this.content[index];
      }
      set(index, value) {
        this.content[index] = this.refract(value);
        return this;
      }
      remove(index) {
        const removed = this.content.splice(index, 1);
        if (removed.length) {
          return removed[0];
        }
        return null;
      }
      /**
       * @param callback - Function to execute for each element
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       */
      map(callback, thisArg) {
        return this.content.map(callback, thisArg);
      }
      /**
       * Maps and then flattens the results.
       * @param callback - Function to execute for each element.
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @returns {array}
       */
      flatMap(callback, thisArg) {
        return this.map(callback, thisArg).reduce((a2, b) => a2.concat(b), []);
      }
      /**
       * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
       * @param transform - A closure that accepts an element of this array as its argument and returns an optional value.
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @memberof ArrayElement.prototype
       * @returns An array of the non-undefined results of calling transform with each element of the array
       */
      compactMap(transform2, thisArg) {
        const results = [];
        this.forEach((element) => {
          const result = transform2.bind(thisArg)(element);
          if (result) {
            results.push(result);
          }
        });
        return results;
      }
      /**
       * @param callback - Function to execute for each element
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @returns {ArraySlice}
       */
      filter(callback, thisArg) {
        return new ArraySlice4(this.content.filter(callback, thisArg));
      }
      /**
       * @param callback - Function to execute for each element
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @returns {ArraySlice}
       */
      reject(callback, thisArg) {
        return this.filter(negate3(callback), thisArg);
      }
      /**
       * This is a reduce function specifically for Minim arrays and objects. It
       * allows for returning normal values or Minim instances, so it converts any
       * primitives on each step.
       */
      reduce(callback, initialValue) {
        let startIndex;
        let memo;
        if (initialValue !== void 0) {
          startIndex = 0;
          memo = this.refract(initialValue);
        } else {
          startIndex = 1;
          memo = this.primitive() === "object" ? this.first.value : this.first;
        }
        for (let i2 = startIndex; i2 < this.length; i2 += 1) {
          const item = this.content[i2];
          if (this.primitive() === "object") {
            memo = this.refract(callback(memo, item.value, item.key, item, this));
          } else {
            memo = this.refract(callback(memo, item, i2, this));
          }
        }
        return memo;
      }
      /**
       * @callback forEachCallback
       * @param {Element} currentValue
       * @param {NumberElement} index
       */
      /**
       * @param {forEachCallback} callback - Function to execute for each element
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @memberof ArrayElement.prototype
       */
      forEach(callback, thisArg) {
        this.content.forEach((item, index) => {
          callback.bind(thisArg)(item, this.refract(index));
        });
      }
      /**
       * @returns {Element}
       */
      shift() {
        return this.content.shift();
      }
      /**
       * @param value
       */
      unshift(value) {
        this.content.unshift(this.refract(value));
      }
      /**
       * @param value
       */
      push(value) {
        this.content.push(this.refract(value));
        return this;
      }
      /**
       * @param value
       */
      add(value) {
        this.push(value);
      }
      /**
       * Recusively search all descendents using a condition function.
       * @returns {Element[]}
       */
      findElements(condition, givenOptions) {
        const options = givenOptions || {};
        const recursive = !!options.recursive;
        const results = options.results === void 0 ? [] : options.results;
        this.forEach((item, keyOrIndex, member) => {
          if (recursive && item.findElements !== void 0) {
            item.findElements(condition, {
              results,
              recursive
            });
          }
          if (condition(item, keyOrIndex, member)) {
            results.push(item);
          }
        });
        return results;
      }
      /**
       * Recusively search all descendents using a condition function.
       * @param condition
       * @returns {ArraySlice}
       */
      find(condition) {
        return new ArraySlice4(this.findElements(condition, { recursive: true }));
      }
      /**
       * @param {string} element
       * @returns {ArraySlice}
       */
      findByElement(element) {
        return this.find((item) => item.element === element);
      }
      /**
       * @param {string} className
       * @returns {ArraySlice}
       * @memberof ArrayElement.prototype
       */
      findByClass(className) {
        return this.find((item) => item.classes.includes(className));
      }
      /**
       * Search the tree recursively and find the element with the matching ID
       * @param {string} id
       * @returns {Element}
       * @memberof ArrayElement.prototype
       */
      getById(id) {
        return this.find((item) => item.id.toValue() === id).first;
      }
      /**
       * Looks for matching children using deep equality
       * @param value
       * @returns {boolean}
       */
      includes(value) {
        return this.content.some((element) => element.equals(value));
      }
      /**
       * Looks for matching children using deep equality
       * @param value
       * @returns {boolean}
       * @see includes
       * @deprecated method was replaced by includes
       */
      contains(value) {
        return this.includes(value);
      }
      // Fantasy Land
      /**
       * @returns {ArrayElement} An empty array element
       */
      empty() {
        return new this.constructor([]);
      }
      ["fantasy-land/empty"]() {
        return this.empty();
      }
      /**
       * @param {ArrayElement} other
       * @returns {ArrayElement}
       */
      concat(other) {
        return new this.constructor(this.content.concat(other.content));
      }
      ["fantasy-land/concat"](other) {
        return this.concat(other);
      }
      ["fantasy-land/map"](transform2) {
        return new this.constructor(this.map(transform2));
      }
      ["fantasy-land/chain"](transform2) {
        return this.map((element) => transform2(element), this).reduce((a2, b) => a2.concat(b), this.empty());
      }
      ["fantasy-land/filter"](callback) {
        return new this.constructor(this.content.filter(callback));
      }
      ["fantasy-land/reduce"](transform2, initialValue) {
        return this.content.reduce(transform2, initialValue);
      }
      /**
       * Returns the length of the collection
       * @type number
       */
      get length() {
        return this.content.length;
      }
      /**
       * Returns whether the collection is empty
       * @type boolean
       */
      get isEmpty() {
        return this.content.length === 0;
      }
      /**
       * Return the first item in the collection
       * @type Element
       */
      get first() {
        return this.getIndex(0);
      }
      /**
       * Return the second item in the collection
       * @type Element
       */
      get second() {
        return this.getIndex(1);
      }
      /**
       * Return the last item in the collection
       * @type Element
       */
      get last() {
        return this.getIndex(this.length - 1);
      }
    };
    ArrayElement6.empty = function empty4() {
      return new this();
    };
    ArrayElement6["fantasy-land/empty"] = ArrayElement6.empty;
    if (typeof Symbol !== "undefined") {
      ArrayElement6.prototype[Symbol.iterator] = function symbol() {
        return this.content[Symbol.iterator]();
      };
    }
    module.exports = ArrayElement6;
  }
});

// node_modules/minim/lib/primitives/MemberElement.js
var require_MemberElement = __commonJS({
  "node_modules/minim/lib/primitives/MemberElement.js"(exports, module) {
    var KeyValuePair3 = require_KeyValuePair();
    var Element3 = require_Element();
    module.exports = class MemberElement extends Element3 {
      constructor(key57, value, meta, attributes) {
        super(new KeyValuePair3(), meta, attributes);
        this.element = "member";
        this.key = key57;
        this.value = value;
      }
      /**
       * @type Element
       */
      get key() {
        return this.content.key;
      }
      set key(key57) {
        this.content.key = this.refract(key57);
      }
      /**
       * @type Element
       */
      get value() {
        return this.content.value;
      }
      set value(value) {
        this.content.value = this.refract(value);
      }
    };
  }
});

// node_modules/minim/lib/ObjectSlice.js
var require_ObjectSlice = __commonJS({
  "node_modules/minim/lib/ObjectSlice.js"(exports, module) {
    var negate3 = require_negate();
    var ArraySlice4 = require_ArraySlice();
    var ObjectSlice3 = class _ObjectSlice extends ArraySlice4 {
      map(callback, thisArg) {
        return this.elements.map((member) => callback.bind(thisArg)(member.value, member.key, member));
      }
      filter(callback, thisArg) {
        return new _ObjectSlice(this.elements.filter((member) => callback.bind(thisArg)(member.value, member.key, member)));
      }
      reject(callback, thisArg) {
        return this.filter(negate3(callback.bind(thisArg)));
      }
      forEach(callback, thisArg) {
        return this.elements.forEach((member, index) => {
          callback.bind(thisArg)(member.value, member.key, member, index);
        });
      }
      /**
       * @returns {array}
       */
      keys() {
        return this.map((value, key57) => key57.toValue());
      }
      /**
       * @returns {array}
       */
      values() {
        return this.map((value) => value.toValue());
      }
    };
    module.exports = ObjectSlice3;
  }
});

// node_modules/minim/lib/primitives/ObjectElement.js
var require_ObjectElement = __commonJS({
  "node_modules/minim/lib/primitives/ObjectElement.js"(exports, module) {
    var negate3 = require_negate();
    var isObject6 = require_isObject();
    var ArrayElement6 = require_ArrayElement();
    var MemberElement3 = require_MemberElement();
    var ObjectSlice3 = require_ObjectSlice();
    var ObjectElement5 = class extends ArrayElement6 {
      constructor(content, meta, attributes) {
        super(content || [], meta, attributes);
        this.element = "object";
      }
      primitive() {
        return "object";
      }
      toValue() {
        return this.content.reduce((results, el2) => {
          results[el2.key.toValue()] = el2.value ? el2.value.toValue() : void 0;
          return results;
        }, {});
      }
      /**
       * @param key
       * @returns {Element}
       */
      get(name2) {
        const member = this.getMember(name2);
        if (member) {
          return member.value;
        }
        return void 0;
      }
      /**
       * @param key
       * @returns {MemberElement}
       */
      getMember(name2) {
        if (name2 === void 0) {
          return void 0;
        }
        return this.content.find((element) => element.key.toValue() === name2);
      }
      /**
       * @param key
       */
      remove(name2) {
        let removed = null;
        this.content = this.content.filter((item) => {
          if (item.key.toValue() === name2) {
            removed = item;
            return false;
          }
          return true;
        });
        return removed;
      }
      /**
       * @param key
       * @returns {Element}
       */
      getKey(name2) {
        const member = this.getMember(name2);
        if (member) {
          return member.key;
        }
        return void 0;
      }
      /**
       * Set allows either a key/value pair to be given or an object
       * If an object is given, each key is set to its respective value
       */
      set(keyOrObject, value) {
        if (isObject6(keyOrObject)) {
          Object.keys(keyOrObject).forEach((objectKey) => {
            this.set(objectKey, keyOrObject[objectKey]);
          });
          return this;
        }
        const key57 = keyOrObject;
        const member = this.getMember(key57);
        if (member) {
          member.value = value;
        } else {
          this.content.push(new MemberElement3(key57, value));
        }
        return this;
      }
      /**
       */
      keys() {
        return this.content.map((item) => item.key.toValue());
      }
      /**
       */
      values() {
        return this.content.map((item) => item.value.toValue());
      }
      /**
       * @returns {boolean}
       */
      hasKey(value) {
        return this.content.some((member) => member.key.equals(value));
      }
      /**
       * @returns {array}
       */
      items() {
        return this.content.map((item) => [item.key.toValue(), item.value.toValue()]);
      }
      /**
       * @param callback
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       */
      map(callback, thisArg) {
        return this.content.map((item) => callback.bind(thisArg)(item.value, item.key, item));
      }
      /**
       * Returns an array containing the truthy results of calling the given transformation with each element of this sequence
       * @param transform - A closure that accepts the value, key and member element of this object as its argument and returns an optional value.
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       * @returns An array of the non-undefined results of calling transform with each element of the array
       */
      compactMap(callback, thisArg) {
        const results = [];
        this.forEach((value, key57, member) => {
          const result = callback.bind(thisArg)(value, key57, member);
          if (result) {
            results.push(result);
          }
        });
        return results;
      }
      /**
       * @param callback
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       *
       * @returns {ObjectSlice}
       */
      filter(callback, thisArg) {
        return new ObjectSlice3(this.content).filter(callback, thisArg);
      }
      /**
       * @param callback
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       *
       * @returns {ObjectSlice}
       *
       * @memberof ObjectElement.prototype
       */
      reject(callback, thisArg) {
        return this.filter(negate3(callback), thisArg);
      }
      /**
       * @param callback
       * @param thisArg - Value to use as this (i.e the reference Object) when executing callback
       *
       * @memberof ObjectElement.prototype
       */
      forEach(callback, thisArg) {
        return this.content.forEach((item) => callback.bind(thisArg)(item.value, item.key, item));
      }
    };
    module.exports = ObjectElement5;
  }
});

// node_modules/minim/lib/elements/LinkElement.js
var require_LinkElement = __commonJS({
  "node_modules/minim/lib/elements/LinkElement.js"(exports, module) {
    var Element3 = require_Element();
    module.exports = class LinkElement extends Element3 {
      constructor(content, meta, attributes) {
        super(content || [], meta, attributes);
        this.element = "link";
      }
      /**
       * The relation identifier for the link, as defined in RFC 5988.
       * @type StringElement
       */
      get relation() {
        return this.attributes.get("relation");
      }
      set relation(relation) {
        this.attributes.set("relation", relation);
      }
      /**
       * The URI for the given link.
       * @type StringElement
       */
      get href() {
        return this.attributes.get("href");
      }
      set href(href) {
        this.attributes.set("href", href);
      }
    };
  }
});

// node_modules/minim/lib/elements/RefElement.js
var require_RefElement = __commonJS({
  "node_modules/minim/lib/elements/RefElement.js"(exports, module) {
    var Element3 = require_Element();
    module.exports = class RefElement extends Element3 {
      constructor(content, meta, attributes) {
        super(content || [], meta, attributes);
        this.element = "ref";
        if (!this.path) {
          this.path = "element";
        }
      }
      /**
       * Path of referenced element to transclude instead of element itself.
       * @type StringElement
       * @default element
       */
      get path() {
        return this.attributes.get("path");
      }
      set path(newValue) {
        this.attributes.set("path", newValue);
      }
    };
  }
});

// node_modules/minim/lib/elements.js
var require_elements = __commonJS({
  "node_modules/minim/lib/elements.js"(exports, module) {
    var Element3 = require_Element();
    var NullElement3 = require_NullElement();
    var StringElement6 = require_StringElement();
    var NumberElement3 = require_NumberElement();
    var BooleanElement3 = require_BooleanElement();
    var ArrayElement6 = require_ArrayElement();
    var MemberElement3 = require_MemberElement();
    var ObjectElement5 = require_ObjectElement();
    var LinkElement3 = require_LinkElement();
    var RefElement3 = require_RefElement();
    var ArraySlice4 = require_ArraySlice();
    var ObjectSlice3 = require_ObjectSlice();
    var KeyValuePair3 = require_KeyValuePair();
    function refract6(value) {
      if (value instanceof Element3) {
        return value;
      }
      if (typeof value === "string") {
        return new StringElement6(value);
      }
      if (typeof value === "number") {
        return new NumberElement3(value);
      }
      if (typeof value === "boolean") {
        return new BooleanElement3(value);
      }
      if (value === null) {
        return new NullElement3();
      }
      if (Array.isArray(value)) {
        return new ArrayElement6(value.map(refract6));
      }
      if (typeof value === "object") {
        const element = new ObjectElement5(value);
        return element;
      }
      return value;
    }
    Element3.prototype.ObjectElement = ObjectElement5;
    Element3.prototype.RefElement = RefElement3;
    Element3.prototype.MemberElement = MemberElement3;
    Element3.prototype.refract = refract6;
    ArraySlice4.prototype.refract = refract6;
    module.exports = {
      Element: Element3,
      NullElement: NullElement3,
      StringElement: StringElement6,
      NumberElement: NumberElement3,
      BooleanElement: BooleanElement3,
      ArrayElement: ArrayElement6,
      MemberElement: MemberElement3,
      ObjectElement: ObjectElement5,
      LinkElement: LinkElement3,
      RefElement: RefElement3,
      refract: refract6,
      ArraySlice: ArraySlice4,
      ObjectSlice: ObjectSlice3,
      KeyValuePair: KeyValuePair3
    };
  }
});

// node_modules/minim/lib/Namespace.js
var require_Namespace = __commonJS({
  "node_modules/minim/lib/Namespace.js"(exports, module) {
    var isNull4 = require_isNull();
    var isString4 = require_isString();
    var isNumber3 = require_isNumber();
    var isBoolean3 = require_isBoolean();
    var isObject6 = require_isObject();
    var JSONSerialiser = require_JSONSerialiser();
    var elements = require_elements();
    var Namespace2 = class {
      constructor(options) {
        this.elementMap = {};
        this.elementDetection = [];
        this.Element = elements.Element;
        this.KeyValuePair = elements.KeyValuePair;
        if (!options || !options.noDefault) {
          this.useDefault();
        }
        this._attributeElementKeys = [];
        this._attributeElementArrayKeys = [];
      }
      /**
       * Use a namespace plugin or load a generic plugin.
       *
       * @param plugin
       */
      use(plugin7) {
        if (plugin7.namespace) {
          plugin7.namespace({ base: this });
        }
        if (plugin7.load) {
          plugin7.load({ base: this });
        }
        return this;
      }
      /*
       * Use the default namespace. This preloads all the default elements
       * into this registry instance.
       */
      useDefault() {
        this.register("null", elements.NullElement).register("string", elements.StringElement).register("number", elements.NumberElement).register("boolean", elements.BooleanElement).register("array", elements.ArrayElement).register("object", elements.ObjectElement).register("member", elements.MemberElement).register("ref", elements.RefElement).register("link", elements.LinkElement);
        this.detect(isNull4, elements.NullElement, false).detect(isString4, elements.StringElement, false).detect(isNumber3, elements.NumberElement, false).detect(isBoolean3, elements.BooleanElement, false).detect(Array.isArray, elements.ArrayElement, false).detect(isObject6, elements.ObjectElement, false);
        return this;
      }
      /**
       * Register a new element class for an element.
       *
       * @param {string} name
       * @param elementClass
       */
      register(name2, ElementClass) {
        this._elements = void 0;
        this.elementMap[name2] = ElementClass;
        return this;
      }
      /**
       * Unregister a previously registered class for an element.
       *
       * @param {string} name
       */
      unregister(name2) {
        this._elements = void 0;
        delete this.elementMap[name2];
        return this;
      }
      /*
       * Add a new detection function to determine which element
       * class to use when converting existing js instances into
       * refract element.
       */
      detect(test4, ElementClass, givenPrepend) {
        const prepend3 = givenPrepend === void 0 ? true : givenPrepend;
        if (prepend3) {
          this.elementDetection.unshift([test4, ElementClass]);
        } else {
          this.elementDetection.push([test4, ElementClass]);
        }
        return this;
      }
      /*
       * Convert an existing Javascript object into refract element instances, which
       * can be further processed or serialized into refract.
       * If the item passed in is already refracted, then it is returned
       * unmodified.
       */
      toElement(value) {
        if (value instanceof this.Element) {
          return value;
        }
        let element;
        for (let i2 = 0; i2 < this.elementDetection.length; i2 += 1) {
          const test4 = this.elementDetection[i2][0];
          const ElementClass = this.elementDetection[i2][1];
          if (test4(value)) {
            element = new ElementClass(value);
            break;
          }
        }
        return element;
      }
      /*
       * Get an element class given an element name.
       */
      getElementClass(element) {
        const ElementClass = this.elementMap[element];
        if (ElementClass === void 0) {
          return this.Element;
        }
        return ElementClass;
      }
      /*
       * Convert a refract document into refract element instances.
       */
      fromRefract(doc) {
        return this.serialiser.deserialise(doc);
      }
      /*
       * Convert an element to a Refracted JSON object.
       */
      toRefract(element) {
        return this.serialiser.serialise(element);
      }
      /*
       * Get an object that contains all registered element classes, where
       * the key is the PascalCased element name and the value is the class.
       */
      get elements() {
        if (this._elements === void 0) {
          this._elements = {
            Element: this.Element
          };
          Object.keys(this.elementMap).forEach((name2) => {
            const pascal = name2[0].toUpperCase() + name2.substr(1);
            this._elements[pascal] = this.elementMap[name2];
          });
        }
        return this._elements;
      }
      /**
       * Convinience method for getting a JSON Serialiser configured with the
       * current namespace
       *
       * @type JSONSerialiser
       * @readonly
       *
       * @memberof Namespace.prototype
       */
      get serialiser() {
        return new JSONSerialiser(this);
      }
    };
    JSONSerialiser.prototype.Namespace = Namespace2;
    module.exports = Namespace2;
  }
});

// node_modules/minim/lib/serialisers/JSON06Serialiser.js
var require_JSON06Serialiser = __commonJS({
  "node_modules/minim/lib/serialisers/JSON06Serialiser.js"(exports, module) {
    var JSONSerialiser = require_JSONSerialiser();
    module.exports = class JSON06Serialiser extends JSONSerialiser {
      serialise(element) {
        if (!(element instanceof this.namespace.elements.Element)) {
          throw new TypeError(`Given element \`${element}\` is not an Element instance`);
        }
        let variable;
        if (element._attributes && element.attributes.get("variable")) {
          variable = element.attributes.get("variable");
        }
        const payload = {
          element: element.element
        };
        if (element._meta && element._meta.length > 0) {
          payload.meta = this.serialiseObject(element.meta);
        }
        const isEnum = element.element === "enum" || element.attributes.keys().indexOf("enumerations") !== -1;
        if (isEnum) {
          const attributes = this.enumSerialiseAttributes(element);
          if (attributes) {
            payload.attributes = attributes;
          }
        } else if (element._attributes && element._attributes.length > 0) {
          let { attributes } = element;
          if (attributes.get("metadata")) {
            attributes = attributes.clone();
            attributes.set("meta", attributes.get("metadata"));
            attributes.remove("metadata");
          }
          if (element.element === "member" && variable) {
            attributes = attributes.clone();
            attributes.remove("variable");
          }
          if (attributes.length > 0) {
            payload.attributes = this.serialiseObject(attributes);
          }
        }
        if (isEnum) {
          payload.content = this.enumSerialiseContent(element, payload);
        } else if (this[`${element.element}SerialiseContent`]) {
          payload.content = this[`${element.element}SerialiseContent`](element, payload);
        } else if (element.content !== void 0) {
          let content;
          if (variable && element.content.key) {
            content = element.content.clone();
            content.key.attributes.set("variable", variable);
            content = this.serialiseContent(content);
          } else {
            content = this.serialiseContent(element.content);
          }
          if (this.shouldSerialiseContent(element, content)) {
            payload.content = content;
          }
        } else if (this.shouldSerialiseContent(element, element.content) && element instanceof this.namespace.elements.Array) {
          payload.content = [];
        }
        return payload;
      }
      shouldSerialiseContent(element, content) {
        if (element.element === "parseResult" || element.element === "httpRequest" || element.element === "httpResponse" || element.element === "category" || element.element === "link") {
          return true;
        }
        if (content === void 0) {
          return false;
        }
        if (Array.isArray(content) && content.length === 0) {
          return false;
        }
        return true;
      }
      refSerialiseContent(element, payload) {
        delete payload.attributes;
        return {
          href: element.toValue(),
          path: element.path.toValue()
        };
      }
      sourceMapSerialiseContent(element) {
        return element.toValue();
      }
      dataStructureSerialiseContent(element) {
        return [this.serialiseContent(element.content)];
      }
      enumSerialiseAttributes(element) {
        const attributes = element.attributes.clone();
        const enumerations = attributes.remove("enumerations") || new this.namespace.elements.Array([]);
        const defaultValue = attributes.get("default");
        let samples = attributes.get("samples") || new this.namespace.elements.Array([]);
        if (defaultValue && defaultValue.content) {
          if (defaultValue.content.attributes) {
            defaultValue.content.attributes.remove("typeAttributes");
          }
          attributes.set("default", new this.namespace.elements.Array([defaultValue.content]));
        }
        samples.forEach((sample) => {
          if (sample.content && sample.content.element) {
            sample.content.attributes.remove("typeAttributes");
          }
        });
        if (element.content && enumerations.length !== 0) {
          samples.unshift(element.content);
        }
        samples = samples.map((sample) => {
          if (sample instanceof this.namespace.elements.Array) {
            return [sample];
          }
          return new this.namespace.elements.Array([sample.content]);
        });
        if (samples.length) {
          attributes.set("samples", samples);
        }
        if (attributes.length > 0) {
          return this.serialiseObject(attributes);
        }
        return void 0;
      }
      enumSerialiseContent(element) {
        if (element._attributes) {
          const enumerations = element.attributes.get("enumerations");
          if (enumerations && enumerations.length > 0) {
            return enumerations.content.map((enumeration) => {
              const e2 = enumeration.clone();
              e2.attributes.remove("typeAttributes");
              return this.serialise(e2);
            });
          }
        }
        if (element.content) {
          const value = element.content.clone();
          value.attributes.remove("typeAttributes");
          return [this.serialise(value)];
        }
        return [];
      }
      deserialise(value) {
        if (typeof value === "string") {
          return new this.namespace.elements.String(value);
        }
        if (typeof value === "number") {
          return new this.namespace.elements.Number(value);
        }
        if (typeof value === "boolean") {
          return new this.namespace.elements.Boolean(value);
        }
        if (value === null) {
          return new this.namespace.elements.Null();
        }
        if (Array.isArray(value)) {
          return new this.namespace.elements.Array(value.map(this.deserialise, this));
        }
        const ElementClass = this.namespace.getElementClass(value.element);
        const element = new ElementClass();
        if (element.element !== value.element) {
          element.element = value.element;
        }
        if (value.meta) {
          this.deserialiseObject(value.meta, element.meta);
        }
        if (value.attributes) {
          this.deserialiseObject(value.attributes, element.attributes);
        }
        const content = this.deserialiseContent(value.content);
        if (content !== void 0 || element.content === null) {
          element.content = content;
        }
        if (element.element === "enum") {
          if (element.content) {
            element.attributes.set("enumerations", element.content);
          }
          let samples = element.attributes.get("samples");
          element.attributes.remove("samples");
          if (samples) {
            const existingSamples = samples;
            samples = new this.namespace.elements.Array();
            existingSamples.forEach((existingSample) => {
              existingSample.forEach((sample2) => {
                const enumElement = new ElementClass(sample2);
                enumElement.element = element.element;
                samples.push(enumElement);
              });
            });
            const sample = samples.shift();
            if (sample) {
              element.content = sample.content;
            } else {
              element.content = void 0;
            }
            element.attributes.set("samples", samples);
          } else {
            element.content = void 0;
          }
          let defaultValue = element.attributes.get("default");
          if (defaultValue && defaultValue.length > 0) {
            defaultValue = defaultValue.get(0);
            const defaultElement = new ElementClass(defaultValue);
            defaultElement.element = element.element;
            element.attributes.set("default", defaultElement);
          }
        } else if (element.element === "dataStructure" && Array.isArray(element.content)) {
          [element.content] = element.content;
        } else if (element.element === "category") {
          const metadata = element.attributes.get("meta");
          if (metadata) {
            element.attributes.set("metadata", metadata);
            element.attributes.remove("meta");
          }
        } else if (element.element === "member" && element.key && element.key._attributes && element.key._attributes.getValue("variable")) {
          element.attributes.set("variable", element.key.attributes.get("variable"));
          element.key.attributes.remove("variable");
        }
        return element;
      }
      // Private API
      serialiseContent(content) {
        if (content instanceof this.namespace.elements.Element) {
          return this.serialise(content);
        }
        if (content instanceof this.namespace.KeyValuePair) {
          const pair3 = {
            key: this.serialise(content.key)
          };
          if (content.value) {
            pair3.value = this.serialise(content.value);
          }
          return pair3;
        }
        if (content && content.map) {
          return content.map(this.serialise, this);
        }
        return content;
      }
      deserialiseContent(content) {
        if (content) {
          if (content.element) {
            return this.deserialise(content);
          }
          if (content.key) {
            const pair3 = new this.namespace.KeyValuePair(this.deserialise(content.key));
            if (content.value) {
              pair3.value = this.deserialise(content.value);
            }
            return pair3;
          }
          if (content.map) {
            return content.map(this.deserialise, this);
          }
        }
        return content;
      }
      shouldRefract(element) {
        if (element._attributes && element.attributes.keys().length || element._meta && element.meta.keys().length) {
          return true;
        }
        if (element.element === "enum") {
          return false;
        }
        if (element.element !== element.primitive() || element.element === "member") {
          return true;
        }
        return false;
      }
      convertKeyToRefract(key57, item) {
        if (this.shouldRefract(item)) {
          return this.serialise(item);
        }
        if (item.element === "enum") {
          return this.serialiseEnum(item);
        }
        if (item.element === "array") {
          return item.map((subItem) => {
            if (this.shouldRefract(subItem) || key57 === "default") {
              return this.serialise(subItem);
            }
            if (subItem.element === "array" || subItem.element === "object" || subItem.element === "enum") {
              return subItem.children.map((subSubItem) => this.serialise(subSubItem));
            }
            return subItem.toValue();
          });
        }
        if (item.element === "object") {
          return (item.content || []).map(this.serialise, this);
        }
        return item.toValue();
      }
      serialiseEnum(element) {
        return element.children.map((item) => this.serialise(item));
      }
      serialiseObject(obj) {
        const result = {};
        obj.forEach((value, key57) => {
          if (value) {
            const keyValue = key57.toValue();
            result[keyValue] = this.convertKeyToRefract(keyValue, value);
          }
        });
        return result;
      }
      deserialiseObject(from2, to2) {
        Object.keys(from2).forEach((key57) => {
          to2.set(key57, this.deserialise(from2[key57]));
        });
      }
    };
  }
});

// node_modules/minim/lib/minim.js
var require_minim = __commonJS({
  "node_modules/minim/lib/minim.js"(exports) {
    var Namespace2 = require_Namespace();
    var elements = require_elements();
    exports.Namespace = Namespace2;
    exports.namespace = function namespace2(options) {
      return new Namespace2(options);
    };
    exports.KeyValuePair = require_KeyValuePair();
    exports.ArraySlice = elements.ArraySlice;
    exports.ObjectSlice = elements.ObjectSlice;
    exports.Element = elements.Element;
    exports.StringElement = elements.StringElement;
    exports.NumberElement = elements.NumberElement;
    exports.BooleanElement = elements.BooleanElement;
    exports.NullElement = elements.NullElement;
    exports.ArrayElement = elements.ArrayElement;
    exports.ObjectElement = elements.ObjectElement;
    exports.MemberElement = elements.MemberElement;
    exports.RefElement = elements.RefElement;
    exports.LinkElement = elements.LinkElement;
    exports.refract = elements.refract;
    exports.JSONSerialiser = require_JSONSerialiser();
    exports.JSON06Serialiser = require_JSON06Serialiser();
  }
});

// node_modules/unraw/dist/errors.js
var require_errors = __commonJS({
  "node_modules/unraw/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorMessages = exports.ErrorType = void 0;
    var ErrorType;
    (function(ErrorType2) {
      ErrorType2["MalformedUnicode"] = "MALFORMED_UNICODE";
      ErrorType2["MalformedHexadecimal"] = "MALFORMED_HEXADECIMAL";
      ErrorType2["CodePointLimit"] = "CODE_POINT_LIMIT";
      ErrorType2["OctalDeprecation"] = "OCTAL_DEPRECATION";
      ErrorType2["EndOfString"] = "END_OF_STRING";
    })(ErrorType = exports.ErrorType || (exports.ErrorType = {}));
    exports.errorMessages = /* @__PURE__ */ new Map([
      [ErrorType.MalformedUnicode, "malformed Unicode character escape sequence"],
      [
        ErrorType.MalformedHexadecimal,
        "malformed hexadecimal character escape sequence"
      ],
      [
        ErrorType.CodePointLimit,
        "Unicode codepoint must not be greater than 0x10FFFF in escape sequence"
      ],
      [
        ErrorType.OctalDeprecation,
        '"0"-prefixed octal literals and octal escape sequences are deprecated; for octal literals use the "0o" prefix instead'
      ],
      [ErrorType.EndOfString, "malformed escape sequence at end of string"]
    ]);
  }
});

// node_modules/unraw/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/unraw/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unraw = exports.errorMessages = exports.ErrorType = void 0;
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ErrorType", { enumerable: true, get: function() {
      return errors_1.ErrorType;
    } });
    Object.defineProperty(exports, "errorMessages", { enumerable: true, get: function() {
      return errors_1.errorMessages;
    } });
    function parseHexToInt(hex) {
      const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);
      return isOnlyHexChars ? parseInt(hex, 16) : NaN;
    }
    function validateAndParseHex(hex, errorName, enforcedLength) {
      const parsedHex = parseHexToInt(hex);
      if (Number.isNaN(parsedHex) || enforcedLength !== void 0 && enforcedLength !== hex.length) {
        throw new SyntaxError(errors_1.errorMessages.get(errorName));
      }
      return parsedHex;
    }
    function parseHexadecimalCode(code2) {
      const parsedCode = validateAndParseHex(code2, errors_1.ErrorType.MalformedHexadecimal, 2);
      return String.fromCharCode(parsedCode);
    }
    function parseUnicodeCode(code2, surrogateCode) {
      const parsedCode = validateAndParseHex(code2, errors_1.ErrorType.MalformedUnicode, 4);
      if (surrogateCode !== void 0) {
        const parsedSurrogateCode = validateAndParseHex(surrogateCode, errors_1.ErrorType.MalformedUnicode, 4);
        return String.fromCharCode(parsedCode, parsedSurrogateCode);
      }
      return String.fromCharCode(parsedCode);
    }
    function isCurlyBraced(text3) {
      return text3.charAt(0) === "{" && text3.charAt(text3.length - 1) === "}";
    }
    function parseUnicodeCodePointCode(codePoint) {
      if (!isCurlyBraced(codePoint)) {
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.MalformedUnicode));
      }
      const withoutBraces = codePoint.slice(1, -1);
      const parsedCode = validateAndParseHex(withoutBraces, errors_1.ErrorType.MalformedUnicode);
      try {
        return String.fromCodePoint(parsedCode);
      } catch (err2) {
        throw err2 instanceof RangeError ? new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.CodePointLimit)) : err2;
      }
    }
    function parseOctalCode(code2, error = false) {
      if (error) {
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.OctalDeprecation));
      }
      const parsedCode = parseInt(code2, 8);
      return String.fromCharCode(parsedCode);
    }
    var singleCharacterEscapes = /* @__PURE__ */ new Map([
      ["b", "\b"],
      ["f", "\f"],
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["v", "\v"],
      ["0", "\0"]
    ]);
    function parseSingleCharacterCode(code2) {
      return singleCharacterEscapes.get(code2) || code2;
    }
    var escapeMatch = /\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;
    function unraw2(raw, allowOctals = false) {
      return raw.replace(escapeMatch, function(_2, backslash, hex, codePoint, unicodeWithSurrogate, surrogate, unicode, octal, singleCharacter) {
        if (backslash !== void 0) {
          return "\\";
        }
        if (hex !== void 0) {
          return parseHexadecimalCode(hex);
        }
        if (codePoint !== void 0) {
          return parseUnicodeCodePointCode(codePoint);
        }
        if (unicodeWithSurrogate !== void 0) {
          return parseUnicodeCode(unicodeWithSurrogate, surrogate);
        }
        if (unicode !== void 0) {
          return parseUnicodeCode(unicode);
        }
        if (octal === "0") {
          return "\0";
        }
        if (octal !== void 0) {
          return parseOctalCode(octal, !allowOctals);
        }
        if (singleCharacter !== void 0) {
          return parseSingleCharacterCode(singleCharacter);
        }
        throw new SyntaxError(errors_1.errorMessages.get(errors_1.ErrorType.EndOfString));
      });
    }
    exports.unraw = unraw2;
    exports.default = unraw2;
  }
});

// node_modules/short-unique-id/dist/short-unique-id.js
var require_short_unique_id = __commonJS({
  "node_modules/short-unique-id/dist/short-unique-id.js"(exports, module) {
    "use strict";
    var ShortUniqueId2 = (() => {
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp = (obj, key57, value) => key57 in obj ? __defProp(obj, key57, { enumerable: true, configurable: true, writable: true, value }) : obj[key57] = value;
      var __spreadValues = (a2, b) => {
        for (var prop3 in b || (b = {}))
          if (__hasOwnProp.call(b, prop3))
            __defNormalProp(a2, prop3, b[prop3]);
        if (__getOwnPropSymbols)
          for (var prop3 of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop3))
              __defNormalProp(a2, prop3, b[prop3]);
          }
        return a2;
      };
      var __export2 = (target, all3) => {
        for (var name2 in all3)
          __defProp(target, name2, { get: all3[name2], enumerable: true });
      };
      var __copyProps = (to2, from2, except, desc) => {
        if (from2 && typeof from2 === "object" || typeof from2 === "function") {
          for (let key57 of __getOwnPropNames(from2))
            if (!__hasOwnProp.call(to2, key57) && key57 !== except)
              __defProp(to2, key57, { get: () => from2[key57], enumerable: !(desc = __getOwnPropDesc(from2, key57)) || desc.enumerable });
        }
        return to2;
      };
      var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
      var __publicField2 = (obj, key57, value) => {
        __defNormalProp(obj, typeof key57 !== "symbol" ? key57 + "" : key57, value);
        return value;
      };
      var src_exports = {};
      __export2(src_exports, {
        DEFAULT_OPTIONS: () => DEFAULT_OPTIONS,
        DEFAULT_UUID_LENGTH: () => DEFAULT_UUID_LENGTH,
        default: () => ShortUniqueId3
      });
      var version2 = "5.2.0";
      var DEFAULT_UUID_LENGTH = 6;
      var DEFAULT_OPTIONS = {
        dictionary: "alphanum",
        shuffle: true,
        debug: false,
        length: DEFAULT_UUID_LENGTH,
        counter: 0
      };
      var _ShortUniqueId = class _ShortUniqueId {
        constructor(argOptions = {}) {
          __publicField2(this, "counter");
          __publicField2(this, "debug");
          __publicField2(this, "dict");
          __publicField2(this, "version");
          __publicField2(this, "dictIndex", 0);
          __publicField2(this, "dictRange", []);
          __publicField2(this, "lowerBound", 0);
          __publicField2(this, "upperBound", 0);
          __publicField2(this, "dictLength", 0);
          __publicField2(this, "uuidLength");
          __publicField2(this, "_digit_first_ascii", 48);
          __publicField2(this, "_digit_last_ascii", 58);
          __publicField2(this, "_alpha_lower_first_ascii", 97);
          __publicField2(this, "_alpha_lower_last_ascii", 123);
          __publicField2(this, "_hex_last_ascii", 103);
          __publicField2(this, "_alpha_upper_first_ascii", 65);
          __publicField2(this, "_alpha_upper_last_ascii", 91);
          __publicField2(this, "_number_dict_ranges", {
            digits: [this._digit_first_ascii, this._digit_last_ascii]
          });
          __publicField2(this, "_alpha_dict_ranges", {
            lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],
            upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]
          });
          __publicField2(this, "_alpha_lower_dict_ranges", {
            lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]
          });
          __publicField2(this, "_alpha_upper_dict_ranges", {
            upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]
          });
          __publicField2(this, "_alphanum_dict_ranges", {
            digits: [this._digit_first_ascii, this._digit_last_ascii],
            lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii],
            upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]
          });
          __publicField2(this, "_alphanum_lower_dict_ranges", {
            digits: [this._digit_first_ascii, this._digit_last_ascii],
            lowerCase: [this._alpha_lower_first_ascii, this._alpha_lower_last_ascii]
          });
          __publicField2(this, "_alphanum_upper_dict_ranges", {
            digits: [this._digit_first_ascii, this._digit_last_ascii],
            upperCase: [this._alpha_upper_first_ascii, this._alpha_upper_last_ascii]
          });
          __publicField2(this, "_hex_dict_ranges", {
            decDigits: [this._digit_first_ascii, this._digit_last_ascii],
            alphaDigits: [this._alpha_lower_first_ascii, this._hex_last_ascii]
          });
          __publicField2(this, "_dict_ranges", {
            _number_dict_ranges: this._number_dict_ranges,
            _alpha_dict_ranges: this._alpha_dict_ranges,
            _alpha_lower_dict_ranges: this._alpha_lower_dict_ranges,
            _alpha_upper_dict_ranges: this._alpha_upper_dict_ranges,
            _alphanum_dict_ranges: this._alphanum_dict_ranges,
            _alphanum_lower_dict_ranges: this._alphanum_lower_dict_ranges,
            _alphanum_upper_dict_ranges: this._alphanum_upper_dict_ranges,
            _hex_dict_ranges: this._hex_dict_ranges
          });
          __publicField2(this, "log", (...args) => {
            const finalArgs = [...args];
            finalArgs[0] = `[short-unique-id] ${args[0]}`;
            if (this.debug === true) {
              if (typeof console !== "undefined" && console !== null) {
                return console.log(...finalArgs);
              }
            }
          });
          __publicField2(this, "_normalizeDictionary", (dictionary2, shuffle2) => {
            let finalDict;
            if (dictionary2 && Array.isArray(dictionary2) && dictionary2.length > 1) {
              finalDict = dictionary2;
            } else {
              finalDict = [];
              let i2;
              this.dictIndex = i2 = 0;
              const rangesName = `_${dictionary2}_dict_ranges`;
              const ranges = this._dict_ranges[rangesName];
              Object.keys(ranges).forEach((rangeType) => {
                const rangeTypeKey = rangeType;
                this.dictRange = ranges[rangeTypeKey];
                this.lowerBound = this.dictRange[0];
                this.upperBound = this.dictRange[1];
                for (this.dictIndex = i2 = this.lowerBound; this.lowerBound <= this.upperBound ? i2 < this.upperBound : i2 > this.upperBound; this.dictIndex = this.lowerBound <= this.upperBound ? i2 += 1 : i2 -= 1) {
                  finalDict.push(String.fromCharCode(this.dictIndex));
                }
              });
            }
            if (shuffle2) {
              const PROBABILITY = 0.5;
              finalDict = finalDict.sort(() => Math.random() - PROBABILITY);
            }
            return finalDict;
          });
          __publicField2(this, "setDictionary", (dictionary2, shuffle2) => {
            this.dict = this._normalizeDictionary(dictionary2, shuffle2);
            this.dictLength = this.dict.length;
            this.setCounter(0);
          });
          __publicField2(this, "seq", () => {
            return this.sequentialUUID();
          });
          __publicField2(this, "sequentialUUID", () => {
            let counterDiv;
            let counterRem;
            let id = "";
            counterDiv = this.counter;
            do {
              counterRem = counterDiv % this.dictLength;
              counterDiv = Math.trunc(counterDiv / this.dictLength);
              id += this.dict[counterRem];
            } while (counterDiv !== 0);
            this.counter += 1;
            return id;
          });
          __publicField2(this, "rnd", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH) => {
            return this.randomUUID(uuidLength);
          });
          __publicField2(this, "randomUUID", (uuidLength = this.uuidLength || DEFAULT_UUID_LENGTH) => {
            let id;
            let randomPartIdx;
            let j2;
            if (uuidLength === null || typeof uuidLength === "undefined" || uuidLength < 1) {
              throw new Error("Invalid UUID Length Provided");
            }
            const isPositive2 = uuidLength >= 0;
            id = "";
            for (j2 = 0; j2 < uuidLength; j2 += 1) {
              randomPartIdx = parseInt(
                (Math.random() * this.dictLength).toFixed(0),
                10
              ) % this.dictLength;
              id += this.dict[randomPartIdx];
            }
            return id;
          });
          __publicField2(this, "fmt", (format, date2) => {
            return this.formattedUUID(format, date2);
          });
          __publicField2(this, "formattedUUID", (format, date2) => {
            const fnMap = {
              "$r": this.randomUUID,
              "$s": this.sequentialUUID,
              "$t": this.stamp
            };
            const result = format.replace(
              /\$[rs]\d{0,}|\$t0|\$t[1-9]\d{1,}/g,
              (m2) => {
                const fn2 = m2.slice(0, 2);
                const len = parseInt(m2.slice(2), 10);
                if (fn2 === "$s") {
                  return fnMap[fn2]().padStart(len, "0");
                }
                if (fn2 === "$t" && date2) {
                  return fnMap[fn2](len, date2);
                }
                return fnMap[fn2](len);
              }
            );
            return result;
          });
          __publicField2(this, "availableUUIDs", (uuidLength = this.uuidLength) => {
            return parseFloat(
              Math.pow([...new Set(this.dict)].length, uuidLength).toFixed(0)
            );
          });
          __publicField2(this, "approxMaxBeforeCollision", (rounds = this.availableUUIDs(this.uuidLength)) => {
            return parseFloat(
              Math.sqrt(Math.PI / 2 * rounds).toFixed(20)
            );
          });
          __publicField2(this, "collisionProbability", (rounds = this.availableUUIDs(this.uuidLength), uuidLength = this.uuidLength) => {
            return parseFloat(
              (this.approxMaxBeforeCollision(rounds) / this.availableUUIDs(uuidLength)).toFixed(20)
            );
          });
          __publicField2(this, "uniqueness", (rounds = this.availableUUIDs(this.uuidLength)) => {
            const score = parseFloat(
              (1 - this.approxMaxBeforeCollision(rounds) / rounds).toFixed(20)
            );
            return score > 1 ? 1 : score < 0 ? 0 : score;
          });
          __publicField2(this, "getVersion", () => {
            return this.version;
          });
          __publicField2(this, "stamp", (finalLength, date2) => {
            const hexStamp = Math.floor(+(date2 || /* @__PURE__ */ new Date()) / 1e3).toString(16);
            if (typeof finalLength === "number" && finalLength === 0) {
              return hexStamp;
            }
            if (typeof finalLength !== "number" || finalLength < 10) {
              throw new Error(
                [
                  "Param finalLength must be a number greater than or equal to 10,",
                  "or 0 if you want the raw hexadecimal timestamp"
                ].join("\n")
              );
            }
            const idLength = finalLength - 9;
            const rndIdx = Math.round(Math.random() * (idLength > 15 ? 15 : idLength));
            const id = this.randomUUID(idLength);
            return `${id.substring(0, rndIdx)}${hexStamp}${id.substring(rndIdx)}${rndIdx.toString(16)}`;
          });
          __publicField2(this, "parseStamp", (suid, format) => {
            if (format && !/t0|t[1-9]\d{1,}/.test(format)) {
              throw new Error("Cannot extract date from a formated UUID with no timestamp in the format");
            }
            const stamp = format ? format.replace(
              /\$[rs]\d{0,}|\$t0|\$t[1-9]\d{1,}/g,
              (m2) => {
                const fnMap = {
                  "$r": (len2) => [...Array(len2)].map(() => "r").join(""),
                  "$s": (len2) => [...Array(len2)].map(() => "s").join(""),
                  "$t": (len2) => [...Array(len2)].map(() => "t").join("")
                };
                const fn2 = m2.slice(0, 2);
                const len = parseInt(m2.slice(2), 10);
                return fnMap[fn2](len);
              }
            ).replace(
              /^(.*?)(t{8,})(.*)$/g,
              (_m, p1, p2) => {
                return suid.substring(p1.length, p1.length + p2.length);
              }
            ) : suid;
            if (stamp.length === 8) {
              return new Date(parseInt(stamp, 16) * 1e3);
            }
            if (stamp.length < 10) {
              throw new Error("Stamp length invalid");
            }
            const rndIdx = parseInt(stamp.substring(stamp.length - 1), 16);
            return new Date(parseInt(stamp.substring(rndIdx, rndIdx + 8), 16) * 1e3);
          });
          __publicField2(this, "setCounter", (counter2) => {
            this.counter = counter2;
          });
          __publicField2(this, "validate", (uid, dictionary2) => {
            const finalDictionary = dictionary2 ? this._normalizeDictionary(dictionary2) : this.dict;
            return uid.split("").every((c2) => finalDictionary.includes(c2));
          });
          const options = __spreadValues(__spreadValues({}, DEFAULT_OPTIONS), argOptions);
          this.counter = 0;
          this.debug = false;
          this.dict = [];
          this.version = version2;
          const {
            dictionary,
            shuffle,
            length: length3,
            counter
          } = options;
          this.uuidLength = length3;
          this.setDictionary(dictionary, shuffle);
          this.setCounter(counter);
          this.debug = options.debug;
          this.log(this.dict);
          this.log(
            `Generator instantiated with Dictionary Size ${this.dictLength} and counter set to ${this.counter}`
          );
          this.log = this.log.bind(this);
          this.setDictionary = this.setDictionary.bind(this);
          this.setCounter = this.setCounter.bind(this);
          this.seq = this.seq.bind(this);
          this.sequentialUUID = this.sequentialUUID.bind(this);
          this.rnd = this.rnd.bind(this);
          this.randomUUID = this.randomUUID.bind(this);
          this.fmt = this.fmt.bind(this);
          this.formattedUUID = this.formattedUUID.bind(this);
          this.availableUUIDs = this.availableUUIDs.bind(this);
          this.approxMaxBeforeCollision = this.approxMaxBeforeCollision.bind(this);
          this.collisionProbability = this.collisionProbability.bind(this);
          this.uniqueness = this.uniqueness.bind(this);
          this.getVersion = this.getVersion.bind(this);
          this.stamp = this.stamp.bind(this);
          this.parseStamp = this.parseStamp.bind(this);
          return this;
        }
      };
      __publicField2(_ShortUniqueId, "default", _ShortUniqueId);
      var ShortUniqueId3 = _ShortUniqueId;
      return __toCommonJS(src_exports);
    })();
    "undefined" != typeof module && (module.exports = ShortUniqueId2.default), "undefined" != typeof window && (ShortUniqueId2 = ShortUniqueId2.default);
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse6;
    exports.serialize = serialize2;
    var __toString = Object.prototype.toString;
    var __hasOwnProperty = Object.prototype.hasOwnProperty;
    var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    var cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    function parse6(str2, opt) {
      if (typeof str2 !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var len = str2.length;
      if (len < 2) return obj;
      var dec2 = opt && opt.decode || decode;
      var index = 0;
      var eqIdx = 0;
      var endIdx = 0;
      do {
        eqIdx = str2.indexOf("=", index);
        if (eqIdx === -1) break;
        endIdx = str2.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = len;
        } else if (eqIdx > endIdx) {
          index = str2.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var keyStartIdx = startIndex(str2, index, eqIdx);
        var keyEndIdx = endIndex(str2, eqIdx, keyStartIdx);
        var key57 = str2.slice(keyStartIdx, keyEndIdx);
        if (!__hasOwnProperty.call(obj, key57)) {
          var valStartIdx = startIndex(str2, eqIdx + 1, endIdx);
          var valEndIdx = endIndex(str2, endIdx, valStartIdx);
          if (str2.charCodeAt(valStartIdx) === 34 && str2.charCodeAt(valEndIdx - 1) === 34) {
            valStartIdx++;
            valEndIdx--;
          }
          var val = str2.slice(valStartIdx, valEndIdx);
          obj[key57] = tryDecode(val, dec2);
        }
        index = endIdx + 1;
      } while (index < len);
      return obj;
    }
    function startIndex(str2, index, max3) {
      do {
        var code2 = str2.charCodeAt(index);
        if (code2 !== 32 && code2 !== 9) return index;
      } while (++index < max3);
      return max3;
    }
    function endIndex(str2, index, min3) {
      while (index > min3) {
        var code2 = str2.charCodeAt(--index);
        if (code2 !== 32 && code2 !== 9) return index + 1;
      }
      return min3;
    }
    function serialize2(name2, val, opt) {
      var enc = opt && opt.encode || encodeURIComponent;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!cookieNameRegExp.test(name2)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str2 = name2 + "=" + value;
      if (!opt) return str2;
      if (null != opt.maxAge) {
        var maxAge = Math.floor(opt.maxAge);
        if (!isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str2 += "; Max-Age=" + maxAge;
      }
      if (opt.domain) {
        if (!domainValueRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str2 += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!pathValueRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str2 += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate3(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str2 += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str2 += "; HttpOnly";
      }
      if (opt.secure) {
        str2 += "; Secure";
      }
      if (opt.partitioned) {
        str2 += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str2 += "; Priority=Low";
            break;
          case "medium":
            str2 += "; Priority=Medium";
            break;
          case "high":
            str2 += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str2 += "; SameSite=Strict";
            break;
          case "lax":
            str2 += "; SameSite=Lax";
            break;
          case "strict":
            str2 += "; SameSite=Strict";
            break;
          case "none":
            str2 += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str2;
    }
    function decode(str2) {
      return str2.indexOf("%") !== -1 ? decodeURIComponent(str2) : str2;
    }
    function isDate3(val) {
      return __toString.call(val) === "[object Date]";
    }
    function tryDecode(str2, decode2) {
      try {
        return decode2(str2);
      } catch (e2) {
        return str2;
      }
    }
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS({
  "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var enableSchedulerDebugging = false;
        var enableProfiling = false;
        var frameYieldMs = 5;
        function push(heap, node) {
          var index = heap.length;
          heap.push(node);
          siftUp(heap, node, index);
        }
        function peek(heap) {
          return heap.length === 0 ? null : heap[0];
        }
        function pop(heap) {
          if (heap.length === 0) {
            return null;
          }
          var first = heap[0];
          var last2 = heap.pop();
          if (last2 !== first) {
            heap[0] = last2;
            siftDown(heap, last2, 0);
          }
          return first;
        }
        function siftUp(heap, node, i2) {
          var index = i2;
          while (index > 0) {
            var parentIndex = index - 1 >>> 1;
            var parent = heap[parentIndex];
            if (compare2(parent, node) > 0) {
              heap[parentIndex] = node;
              heap[index] = parent;
              index = parentIndex;
            } else {
              return;
            }
          }
        }
        function siftDown(heap, node, i2) {
          var index = i2;
          var length3 = heap.length;
          var halfLength = length3 >>> 1;
          while (index < halfLength) {
            var leftIndex = (index + 1) * 2 - 1;
            var left = heap[leftIndex];
            var rightIndex = leftIndex + 1;
            var right = heap[rightIndex];
            if (compare2(left, node) < 0) {
              if (rightIndex < length3 && compare2(right, left) < 0) {
                heap[index] = right;
                heap[rightIndex] = node;
                index = rightIndex;
              } else {
                heap[index] = left;
                heap[leftIndex] = node;
                index = leftIndex;
              }
            } else if (rightIndex < length3 && compare2(right, node) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              return;
            }
          }
        }
        function compare2(a2, b) {
          var diff = a2.sortIndex - b.sortIndex;
          return diff !== 0 ? diff : a2.id - b.id;
        }
        var ImmediatePriority = 1;
        var UserBlockingPriority = 2;
        var NormalPriority = 3;
        var LowPriority = 4;
        var IdlePriority = 5;
        function markTaskErrored(task, ms2) {
        }
        var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
        if (hasPerformanceNow) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date;
          var initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var maxSigned31BitInt = 1073741823;
        var IMMEDIATE_PRIORITY_TIMEOUT = -1;
        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
        var NORMAL_PRIORITY_TIMEOUT = 5e3;
        var LOW_PRIORITY_TIMEOUT = 1e4;
        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
        var taskQueue = [];
        var timerQueue = [];
        var taskIdCounter = 1;
        var currentTask = null;
        var currentPriorityLevel = NormalPriority;
        var isPerformingWork = false;
        var isHostCallbackScheduled = false;
        var isHostTimeoutScheduled = false;
        var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
        var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
        var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
        var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
        function advanceTimers(currentTime) {
          var timer = peek(timerQueue);
          while (timer !== null) {
            if (timer.callback === null) {
              pop(timerQueue);
            } else if (timer.startTime <= currentTime) {
              pop(timerQueue);
              timer.sortIndex = timer.expirationTime;
              push(taskQueue, timer);
            } else {
              return;
            }
            timer = peek(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled) {
            if (peek(taskQueue) !== null) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
            }
          }
        }
        function flushWork(hasTimeRemaining, initialTime2) {
          isHostCallbackScheduled = false;
          if (isHostTimeoutScheduled) {
            isHostTimeoutScheduled = false;
            cancelHostTimeout();
          }
          isPerformingWork = true;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            if (enableProfiling) {
              try {
                return workLoop(hasTimeRemaining, initialTime2);
              } catch (error) {
                if (currentTask !== null) {
                  var currentTime = exports.unstable_now();
                  markTaskErrored(currentTask, currentTime);
                  currentTask.isQueued = false;
                }
                throw error;
              }
            } else {
              return workLoop(hasTimeRemaining, initialTime2);
            }
          } finally {
            currentTask = null;
            currentPriorityLevel = previousPriorityLevel;
            isPerformingWork = false;
          }
        }
        function workLoop(hasTimeRemaining, initialTime2) {
          var currentTime = initialTime2;
          advanceTimers(currentTime);
          currentTask = peek(taskQueue);
          while (currentTask !== null && !enableSchedulerDebugging) {
            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
              break;
            }
            var callback = currentTask.callback;
            if (typeof callback === "function") {
              currentTask.callback = null;
              currentPriorityLevel = currentTask.priorityLevel;
              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
              var continuationCallback = callback(didUserCallbackTimeout);
              currentTime = exports.unstable_now();
              if (typeof continuationCallback === "function") {
                currentTask.callback = continuationCallback;
              } else {
                if (currentTask === peek(taskQueue)) {
                  pop(taskQueue);
                }
              }
              advanceTimers(currentTime);
            } else {
              pop(taskQueue);
            }
            currentTask = peek(taskQueue);
          }
          if (currentTask !== null) {
            return true;
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
            return false;
          }
        }
        function unstable_runWithPriority(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
            case LowPriority:
            case IdlePriority:
              break;
            default:
              priorityLevel = NormalPriority;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_next(eventHandler) {
          var priorityLevel;
          switch (currentPriorityLevel) {
            case ImmediatePriority:
            case UserBlockingPriority:
            case NormalPriority:
              priorityLevel = NormalPriority;
              break;
            default:
              priorityLevel = currentPriorityLevel;
              break;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        }
        function unstable_wrapCallback(callback) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        }
        function unstable_scheduleCallback(priorityLevel, callback, options) {
          var currentTime = exports.unstable_now();
          var startTime2;
          if (typeof options === "object" && options !== null) {
            var delay = options.delay;
            if (typeof delay === "number" && delay > 0) {
              startTime2 = currentTime + delay;
            } else {
              startTime2 = currentTime;
            }
          } else {
            startTime2 = currentTime;
          }
          var timeout;
          switch (priorityLevel) {
            case ImmediatePriority:
              timeout = IMMEDIATE_PRIORITY_TIMEOUT;
              break;
            case UserBlockingPriority:
              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
              break;
            case IdlePriority:
              timeout = IDLE_PRIORITY_TIMEOUT;
              break;
            case LowPriority:
              timeout = LOW_PRIORITY_TIMEOUT;
              break;
            case NormalPriority:
            default:
              timeout = NORMAL_PRIORITY_TIMEOUT;
              break;
          }
          var expirationTime = startTime2 + timeout;
          var newTask = {
            id: taskIdCounter++,
            callback,
            priorityLevel,
            startTime: startTime2,
            expirationTime,
            sortIndex: -1
          };
          if (startTime2 > currentTime) {
            newTask.sortIndex = startTime2;
            push(timerQueue, newTask);
            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
              if (isHostTimeoutScheduled) {
                cancelHostTimeout();
              } else {
                isHostTimeoutScheduled = true;
              }
              requestHostTimeout(handleTimeout, startTime2 - currentTime);
            }
          } else {
            newTask.sortIndex = expirationTime;
            push(taskQueue, newTask);
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          return newTask;
        }
        function unstable_pauseExecution() {
        }
        function unstable_continueExecution() {
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        function unstable_getFirstCallbackNode() {
          return peek(taskQueue);
        }
        function unstable_cancelCallback(task) {
          task.callback = null;
        }
        function unstable_getCurrentPriorityLevel() {
          return currentPriorityLevel;
        }
        var isMessageLoopRunning = false;
        var scheduledHostCallback = null;
        var taskTimeoutID = -1;
        var frameInterval = frameYieldMs;
        var startTime = -1;
        function shouldYieldToHost() {
          var timeElapsed = exports.unstable_now() - startTime;
          if (timeElapsed < frameInterval) {
            return false;
          }
          return true;
        }
        function requestPaint() {
        }
        function forceFrameRate(fps) {
          if (fps < 0 || fps > 125) {
            console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
            return;
          }
          if (fps > 0) {
            frameInterval = Math.floor(1e3 / fps);
          } else {
            frameInterval = frameYieldMs;
          }
        }
        var performWorkUntilDeadline = function() {
          if (scheduledHostCallback !== null) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasTimeRemaining = true;
            var hasMoreWork = true;
            try {
              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
            } finally {
              if (hasMoreWork) {
                schedulePerformWorkUntilDeadline();
              } else {
                isMessageLoopRunning = false;
                scheduledHostCallback = null;
              }
            }
          } else {
            isMessageLoopRunning = false;
          }
        };
        var schedulePerformWorkUntilDeadline;
        if (typeof localSetImmediate === "function") {
          schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          var port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else {
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        }
        function requestHostCallback(callback) {
          scheduledHostCallback = callback;
          if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            schedulePerformWorkUntilDeadline();
          }
        }
        function requestHostTimeout(callback, ms2) {
          taskTimeoutID = localSetTimeout(function() {
            callback(exports.unstable_now());
          }, ms2);
        }
        function cancelHostTimeout() {
          localClearTimeout(taskTimeoutID);
          taskTimeoutID = -1;
        }
        var unstable_requestPaint = requestPaint;
        var unstable_Profiling = null;
        exports.unstable_IdlePriority = IdlePriority;
        exports.unstable_ImmediatePriority = ImmediatePriority;
        exports.unstable_LowPriority = LowPriority;
        exports.unstable_NormalPriority = NormalPriority;
        exports.unstable_Profiling = unstable_Profiling;
        exports.unstable_UserBlockingPriority = UserBlockingPriority;
        exports.unstable_cancelCallback = unstable_cancelCallback;
        exports.unstable_continueExecution = unstable_continueExecution;
        exports.unstable_forceFrameRate = forceFrameRate;
        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
        exports.unstable_next = unstable_next;
        exports.unstable_pauseExecution = unstable_pauseExecution;
        exports.unstable_requestPaint = unstable_requestPaint;
        exports.unstable_runWithPriority = unstable_runWithPriority;
        exports.unstable_scheduleCallback = unstable_scheduleCallback;
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = unstable_wrapCallback;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_scheduler_development();
    }
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React6 = require_react();
        var Scheduler = require_scheduler();
        var ReactSharedInternals = React6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        var suppressWarning = false;
        function setSuppressWarning(newSuppressWarning) {
          {
            suppressWarning = newSuppressWarning;
          }
        }
        function warn(format) {
          {
            if (!suppressWarning) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            if (!suppressWarning) {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var IndeterminateComponent = 2;
        var HostRoot = 3;
        var HostPortal = 4;
        var HostComponent = 5;
        var HostText = 6;
        var Fragment = 7;
        var Mode = 8;
        var ContextConsumer = 9;
        var ContextProvider = 10;
        var ForwardRef2 = 11;
        var Profiler = 12;
        var SuspenseComponent = 13;
        var MemoComponent = 14;
        var SimpleMemoComponent = 15;
        var LazyComponent = 16;
        var IncompleteClassComponent = 17;
        var DehydratedFragment = 18;
        var SuspenseListComponent = 19;
        var ScopeComponent = 21;
        var OffscreenComponent = 22;
        var LegacyHiddenComponent = 23;
        var CacheComponent = 24;
        var TracingMarkerComponent = 25;
        var enableClientRenderFallbackOnTextMismatch = true;
        var enableNewReconciler = false;
        var enableLazyContextPropagation = false;
        var enableLegacyHidden = false;
        var enableSuspenseAvoidThisFallback = false;
        var disableCommentsAsDOMContainers = true;
        var enableCustomElementPropertySupport = false;
        var warnAboutStringRefs = true;
        var enableSchedulingProfiler = true;
        var enableProfilerTimer = true;
        var enableProfilerCommitHooks = true;
        var allNativeEvents = /* @__PURE__ */ new Set();
        var registrationNameDependencies = {};
        var possibleRegistrationNames = {};
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          {
            if (registrationNameDependencies[registrationName]) {
              error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
            }
          }
          registrationNameDependencies[registrationName] = dependencies;
          {
            var lowerCasedName = registrationName.toLowerCase();
            possibleRegistrationNames[lowerCasedName] = registrationName;
            if (registrationName === "onDoubleClick") {
              possibleRegistrationNames.ondblclick = registrationName;
            }
          }
          for (var i2 = 0; i2 < dependencies.length; i2++) {
            allNativeEvents.add(dependencies[i2]);
          }
        }
        var canUseDOM2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var hasOwnProperty3 = Object.prototype.hasOwnProperty;
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type5 = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type5;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e2) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkPropStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          {
            if (willCoercionThrow(value)) {
              error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkHtmlStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function checkFormFieldValueStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty3.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty3.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name2.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name2) {
          return properties.hasOwnProperty(name2) ? properties[name2] : null;
        }
        function PropertyInfoRecord(name2, type5, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type5 === BOOLEANISH_STRING || type5 === BOOLEAN || type5 === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name2;
          this.type = type5;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            RESERVED,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name2 = _ref[0], attributeName = _ref[1];
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEAN,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEAN,
            true,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            NUMERIC,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        function getValueForProperty(node, name2, expected, propertyInfo) {
          {
            if (propertyInfo.mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              return node[propertyName];
            } else {
              {
                checkAttributeStringCoercion(expected, name2);
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL("" + expected);
              }
              var attributeName = propertyInfo.attributeName;
              var stringValue = null;
              if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                if (node.hasAttribute(attributeName)) {
                  var value = node.getAttribute(attributeName);
                  if (value === "") {
                    return true;
                  }
                  if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                    return value;
                  }
                  if (value === "" + expected) {
                    return expected;
                  }
                  return value;
                }
              } else if (node.hasAttribute(attributeName)) {
                if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                  return node.getAttribute(attributeName);
                }
                if (propertyInfo.type === BOOLEAN) {
                  return expected;
                }
                stringValue = node.getAttribute(attributeName);
              }
              if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                return stringValue === null ? expected : stringValue;
              } else if (stringValue === "" + expected) {
                return expected;
              } else {
                return stringValue;
              }
            }
          }
        }
        function getValueForAttribute(node, name2, expected, isCustomComponentTag) {
          {
            if (!isAttributeNameSafe(name2)) {
              return;
            }
            if (!node.hasAttribute(name2)) {
              return expected === void 0 ? void 0 : null;
            }
            var value = node.getAttribute(name2);
            {
              checkAttributeStringCoercion(expected, name2);
            }
            if (value === "" + expected) {
              return expected;
            }
            return value;
          }
        }
        function setValueForProperty(node, name2, value, isCustomComponentTag) {
          var propertyInfo = getPropertyInfo(name2);
          if (shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag)) {
            return;
          }
          if (shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag)) {
            value = null;
          }
          if (isCustomComponentTag || propertyInfo === null) {
            if (isAttributeNameSafe(name2)) {
              var _attributeName = name2;
              if (value === null) {
                node.removeAttribute(_attributeName);
              } else {
                {
                  checkAttributeStringCoercion(value, name2);
                }
                node.setAttribute(_attributeName, "" + value);
              }
            }
            return;
          }
          var mustUseProperty = propertyInfo.mustUseProperty;
          if (mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            if (value === null) {
              var type5 = propertyInfo.type;
              node[propertyName] = type5 === BOOLEAN ? false : "";
            } else {
              node[propertyName] = value;
            }
            return;
          }
          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
          if (value === null) {
            node.removeAttribute(attributeName);
          } else {
            var _type = propertyInfo.type;
            var attributeValue;
            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
              attributeValue = "";
            } else {
              {
                {
                  checkAttributeStringCoercion(value, attributeName);
                }
                attributeValue = "" + value;
              }
              if (propertyInfo.sanitizeURL) {
                sanitizeURL(attributeValue.toString());
              }
            }
            if (attributeNamespace) {
              node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
            } else {
              node.setAttribute(attributeName, attributeValue);
            }
          }
        }
        var REACT_ELEMENT_TYPE2 = Symbol.for("react.element");
        var REACT_PORTAL_TYPE2 = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE2 = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE2 = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE2 = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE2 = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE2 = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE2 = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE2 = Symbol.for("react.memo");
        var REACT_LAZY_TYPE2 = Symbol.for("react.lazy");
        var REACT_SCOPE_TYPE = Symbol.for("react.scope");
        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
        var REACT_OFFSCREEN_TYPE2 = Symbol.for("react.offscreen");
        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
        var REACT_CACHE_TYPE = Symbol.for("react.cache");
        var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var assign2 = Object.assign;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props3 = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props3,
                log: props3,
                warn: props3,
                error: props3,
                group: props3,
                groupCollapsed: props3,
                groupEnd: props3
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props3 = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign2({}, props3, {
                  value: prevLog
                }),
                info: assign2({}, props3, {
                  value: prevInfo
                }),
                warn: assign2({}, props3, {
                  value: prevWarn
                }),
                error: assign2({}, props3, {
                  value: prevError
                }),
                group: assign2({}, props3, {
                  value: prevGroup
                }),
                groupCollapsed: assign2({}, props3, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign2({}, props3, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x2) {
                var match3 = x2.stack.trim().match(/\n( *(at )?)/);
                prefix = match3 && match3[1] || "";
              }
            }
            return "\n" + prefix + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct4) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct4) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x2) {
                  control = x2;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x2) {
                  control = x2;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x2) {
                control = x2;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s2 = sampleLines.length - 1;
              var c2 = controlLines.length - 1;
              while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                c2--;
              }
              for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                if (sampleLines[s2] !== controlLines[c2]) {
                  if (s2 !== 1 || c2 !== 1) {
                    do {
                      s2--;
                      c2--;
                      if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                        var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                        if (fn2.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn2.displayName);
                        }
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s2 >= 1 && c2 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeClassComponentFrame(ctor, source, ownerFn) {
          {
            return describeNativeComponentFrame(ctor, true);
          }
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type5, source, ownerFn) {
          if (type5 == null) {
            return "";
          }
          if (typeof type5 === "function") {
            {
              return describeNativeComponentFrame(type5, shouldConstruct(type5));
            }
          }
          if (typeof type5 === "string") {
            return describeBuiltInComponentFrame(type5);
          }
          switch (type5) {
            case REACT_SUSPENSE_TYPE2:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE2:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type5 === "object") {
            switch (type5.$$typeof) {
              case REACT_FORWARD_REF_TYPE2:
                return describeFunctionComponentFrame(type5.render);
              case REACT_MEMO_TYPE2:
                return describeUnknownElementTypeFrameInDEV(type5.type, source, ownerFn);
              case REACT_LAZY_TYPE2: {
                var lazyComponent = type5;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x2) {
                }
              }
            }
          }
          return "";
        }
        function describeFiber(fiber) {
          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
          var source = fiber._debugSource;
          switch (fiber.tag) {
            case HostComponent:
              return describeBuiltInComponentFrame(fiber.type);
            case LazyComponent:
              return describeBuiltInComponentFrame("Lazy");
            case SuspenseComponent:
              return describeBuiltInComponentFrame("Suspense");
            case SuspenseListComponent:
              return describeBuiltInComponentFrame("SuspenseList");
            case FunctionComponent:
            case IndeterminateComponent:
            case SimpleMemoComponent:
              return describeFunctionComponentFrame(fiber.type);
            case ForwardRef2:
              return describeFunctionComponentFrame(fiber.type.render);
            case ClassComponent:
              return describeClassComponentFrame(fiber.type);
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            var node = workInProgress2;
            do {
              info += describeFiber(node);
              node = node.return;
            } while (node);
            return info;
          } catch (x2) {
            return "\nError generating stack: " + x2.message + "\n" + x2.stack;
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type5) {
          return type5.displayName || "Context";
        }
        function getComponentNameFromType(type5) {
          if (type5 == null) {
            return null;
          }
          {
            if (typeof type5.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type5 === "function") {
            return type5.displayName || type5.name || null;
          }
          if (typeof type5 === "string") {
            return type5;
          }
          switch (type5) {
            case REACT_FRAGMENT_TYPE2:
              return "Fragment";
            case REACT_PORTAL_TYPE2:
              return "Portal";
            case REACT_PROFILER_TYPE2:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE2:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE2:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE2:
              return "SuspenseList";
          }
          if (typeof type5 === "object") {
            switch (type5.$$typeof) {
              case REACT_CONTEXT_TYPE2:
                var context2 = type5;
                return getContextName(context2) + ".Consumer";
              case REACT_PROVIDER_TYPE2:
                var provider = type5;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE2:
                return getWrappedName(type5, type5.render, "ForwardRef");
              case REACT_MEMO_TYPE2:
                var outerName = type5.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type5.type) || "Memo";
              case REACT_LAZY_TYPE2: {
                var lazyComponent = type5;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentNameFromType(init2(payload));
                } catch (x2) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        function getWrappedName$1(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName$1(type5) {
          return type5.displayName || "Context";
        }
        function getComponentNameFromFiber(fiber) {
          var tag = fiber.tag, type5 = fiber.type;
          switch (tag) {
            case CacheComponent:
              return "Cache";
            case ContextConsumer:
              var context2 = type5;
              return getContextName$1(context2) + ".Consumer";
            case ContextProvider:
              var provider = type5;
              return getContextName$1(provider._context) + ".Provider";
            case DehydratedFragment:
              return "DehydratedFragment";
            case ForwardRef2:
              return getWrappedName$1(type5, type5.render, "ForwardRef");
            case Fragment:
              return "Fragment";
            case HostComponent:
              return type5;
            case HostPortal:
              return "Portal";
            case HostRoot:
              return "Root";
            case HostText:
              return "Text";
            case LazyComponent:
              return getComponentNameFromType(type5);
            case Mode:
              if (type5 === REACT_STRICT_MODE_TYPE2) {
                return "StrictMode";
              }
              return "Mode";
            case OffscreenComponent:
              return "Offscreen";
            case Profiler:
              return "Profiler";
            case ScopeComponent:
              return "Scope";
            case SuspenseComponent:
              return "Suspense";
            case SuspenseListComponent:
              return "SuspenseList";
            case TracingMarkerComponent:
              return "TracingMarker";
            case ClassComponent:
            case FunctionComponent:
            case IncompleteClassComponent:
            case IndeterminateComponent:
            case MemoComponent:
            case SimpleMemoComponent:
              if (typeof type5 === "function") {
                return type5.displayName || type5.name || null;
              }
              if (typeof type5 === "string") {
                return type5;
              }
              break;
          }
          return null;
        }
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var current2 = null;
        var isRendering = false;
        function getCurrentFiberOwnerNameInDevOrNull() {
          {
            if (current2 === null) {
              return null;
            }
            var owner = current2._debugOwner;
            if (owner !== null && typeof owner !== "undefined") {
              return getComponentNameFromFiber(owner);
            }
          }
          return null;
        }
        function getCurrentFiberStackInDev() {
          {
            if (current2 === null) {
              return "";
            }
            return getStackByFiberInDevAndProd(current2);
          }
        }
        function resetCurrentFiber() {
          {
            ReactDebugCurrentFrame.getCurrentStack = null;
            current2 = null;
            isRendering = false;
          }
        }
        function setCurrentFiber(fiber) {
          {
            ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
            current2 = fiber;
            isRendering = false;
          }
        }
        function getCurrentFiber() {
          {
            return current2;
          }
        }
        function setIsRendering(rendering) {
          {
            isRendering = rendering;
          }
        }
        function toString5(value) {
          return "" + value;
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              {
                checkFormFieldValueStringCoercion(value);
              }
              return value;
            default:
              return "";
          }
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props3) {
          {
            if (!(hasReadOnlyValue[props3.type] || props3.onChange || props3.onInput || props3.readOnly || props3.disabled || props3.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props3.onChange || props3.readOnly || props3.disabled || props3.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        function isCheckable(elem) {
          var type5 = elem.type;
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (type5 === "checkbox" || type5 === "radio");
        }
        function getTracker(node) {
          return node._valueTracker;
        }
        function detachTracker(node) {
          node._valueTracker = null;
        }
        function getValueFromNode(node) {
          var value = "";
          if (!node) {
            return value;
          }
          if (isCheckable(node)) {
            value = node.checked ? "true" : "false";
          } else {
            value = node.value;
          }
          return value;
        }
        function trackValueOnNode(node) {
          var valueField = isCheckable(node) ? "checked" : "value";
          var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
          {
            checkFormFieldValueStringCoercion(node[valueField]);
          }
          var currentValue = "" + node[valueField];
          if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
            return;
          }
          var get4 = descriptor.get, set5 = descriptor.set;
          Object.defineProperty(node, valueField, {
            configurable: true,
            get: function() {
              return get4.call(this);
            },
            set: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
              set5.call(this, value);
            }
          });
          Object.defineProperty(node, valueField, {
            enumerable: descriptor.enumerable
          });
          var tracker = {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              {
                checkFormFieldValueStringCoercion(value);
              }
              currentValue = "" + value;
            },
            stopTracking: function() {
              detachTracker(node);
              delete node[valueField];
            }
          };
          return tracker;
        }
        function track(node) {
          if (getTracker(node)) {
            return;
          }
          node._valueTracker = trackValueOnNode(node);
        }
        function updateValueIfChanged(node) {
          if (!node) {
            return false;
          }
          var tracker = getTracker(node);
          if (!tracker) {
            return true;
          }
          var lastValue = tracker.getValue();
          var nextValue = getValueFromNode(node);
          if (nextValue !== lastValue) {
            tracker.setValue(nextValue);
            return true;
          }
          return false;
        }
        function getActiveElement(doc) {
          doc = doc || (typeof document !== "undefined" ? document : void 0);
          if (typeof doc === "undefined") {
            return null;
          }
          try {
            return doc.activeElement || doc.body;
          } catch (e2) {
            return doc.body;
          }
        }
        var didWarnValueDefaultValue = false;
        var didWarnCheckedDefaultChecked = false;
        var didWarnControlledToUncontrolled = false;
        var didWarnUncontrolledToControlled = false;
        function isControlled(props3) {
          var usesChecked = props3.type === "checkbox" || props3.type === "radio";
          return usesChecked ? props3.checked != null : props3.value != null;
        }
        function getHostProps(element, props3) {
          var node = element;
          var checked = props3.checked;
          var hostProps = assign2({}, props3, {
            defaultChecked: void 0,
            defaultValue: void 0,
            value: void 0,
            checked: checked != null ? checked : node._wrapperState.initialChecked
          });
          return hostProps;
        }
        function initWrapperState(element, props3) {
          {
            checkControlledValueProps("input", props3);
            if (props3.checked !== void 0 && props3.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
              error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props3.type);
              didWarnCheckedDefaultChecked = true;
            }
            if (props3.value !== void 0 && props3.defaultValue !== void 0 && !didWarnValueDefaultValue) {
              error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props3.type);
              didWarnValueDefaultValue = true;
            }
          }
          var node = element;
          var defaultValue = props3.defaultValue == null ? "" : props3.defaultValue;
          node._wrapperState = {
            initialChecked: props3.checked != null ? props3.checked : props3.defaultChecked,
            initialValue: getToStringValue(props3.value != null ? props3.value : defaultValue),
            controlled: isControlled(props3)
          };
        }
        function updateChecked(element, props3) {
          var node = element;
          var checked = props3.checked;
          if (checked != null) {
            setValueForProperty(node, "checked", checked, false);
          }
        }
        function updateWrapper(element, props3) {
          var node = element;
          {
            var controlled = isControlled(props3);
            if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
              error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnUncontrolledToControlled = true;
            }
            if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
              error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
              didWarnControlledToUncontrolled = true;
            }
          }
          updateChecked(element, props3);
          var value = getToStringValue(props3.value);
          var type5 = props3.type;
          if (value != null) {
            if (type5 === "number") {
              if (value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
              // eslint-disable-next-line
              node.value != value) {
                node.value = toString5(value);
              }
            } else if (node.value !== toString5(value)) {
              node.value = toString5(value);
            }
          } else if (type5 === "submit" || type5 === "reset") {
            node.removeAttribute("value");
            return;
          }
          {
            if (props3.hasOwnProperty("value")) {
              setDefaultValue(node, props3.type, value);
            } else if (props3.hasOwnProperty("defaultValue")) {
              setDefaultValue(node, props3.type, getToStringValue(props3.defaultValue));
            }
          }
          {
            if (props3.checked == null && props3.defaultChecked != null) {
              node.defaultChecked = !!props3.defaultChecked;
            }
          }
        }
        function postMountWrapper(element, props3, isHydrating2) {
          var node = element;
          if (props3.hasOwnProperty("value") || props3.hasOwnProperty("defaultValue")) {
            var type5 = props3.type;
            var isButton = type5 === "submit" || type5 === "reset";
            if (isButton && (props3.value === void 0 || props3.value === null)) {
              return;
            }
            var initialValue = toString5(node._wrapperState.initialValue);
            if (!isHydrating2) {
              {
                if (initialValue !== node.value) {
                  node.value = initialValue;
                }
              }
            }
            {
              node.defaultValue = initialValue;
            }
          }
          var name2 = node.name;
          if (name2 !== "") {
            node.name = "";
          }
          {
            node.defaultChecked = !node.defaultChecked;
            node.defaultChecked = !!node._wrapperState.initialChecked;
          }
          if (name2 !== "") {
            node.name = name2;
          }
        }
        function restoreControlledState(element, props3) {
          var node = element;
          updateWrapper(node, props3);
          updateNamedCousins(node, props3);
        }
        function updateNamedCousins(rootNode, props3) {
          var name2 = props3.name;
          if (props3.type === "radio" && name2 != null) {
            var queryRoot = rootNode;
            while (queryRoot.parentNode) {
              queryRoot = queryRoot.parentNode;
            }
            {
              checkAttributeStringCoercion(name2, "name");
            }
            var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name2) + '][type="radio"]');
            for (var i2 = 0; i2 < group.length; i2++) {
              var otherNode = group[i2];
              if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                continue;
              }
              var otherProps = getFiberCurrentPropsFromNode(otherNode);
              if (!otherProps) {
                throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
              }
              updateValueIfChanged(otherNode);
              updateWrapper(otherNode, otherProps);
            }
          }
        }
        function setDefaultValue(node, type5, value) {
          if (
            // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
            type5 !== "number" || getActiveElement(node.ownerDocument) !== node
          ) {
            if (value == null) {
              node.defaultValue = toString5(node._wrapperState.initialValue);
            } else if (node.defaultValue !== toString5(value)) {
              node.defaultValue = toString5(value);
            }
          }
        }
        var didWarnSelectedSetOnOption = false;
        var didWarnInvalidChild = false;
        var didWarnInvalidInnerHTML = false;
        function validateProps(element, props3) {
          {
            if (props3.value == null) {
              if (typeof props3.children === "object" && props3.children !== null) {
                React6.Children.forEach(props3.children, function(child) {
                  if (child == null) {
                    return;
                  }
                  if (typeof child === "string" || typeof child === "number") {
                    return;
                  }
                  if (!didWarnInvalidChild) {
                    didWarnInvalidChild = true;
                    error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                  }
                });
              } else if (props3.dangerouslySetInnerHTML != null) {
                if (!didWarnInvalidInnerHTML) {
                  didWarnInvalidInnerHTML = true;
                  error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                }
              }
            }
            if (props3.selected != null && !didWarnSelectedSetOnOption) {
              error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
              didWarnSelectedSetOnOption = true;
            }
          }
        }
        function postMountWrapper$1(element, props3) {
          if (props3.value != null) {
            element.setAttribute("value", toString5(getToStringValue(props3.value)));
          }
        }
        var isArrayImpl = Array.isArray;
        function isArray4(a2) {
          return isArrayImpl(a2);
        }
        var didWarnValueDefaultValue$1;
        {
          didWarnValueDefaultValue$1 = false;
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          if (ownerName) {
            return "\n\nCheck the render method of `" + ownerName + "`.";
          }
          return "";
        }
        var valuePropNames = ["value", "defaultValue"];
        function checkSelectPropTypes(props3) {
          {
            checkControlledValueProps("select", props3);
            for (var i2 = 0; i2 < valuePropNames.length; i2++) {
              var propName = valuePropNames[i2];
              if (props3[propName] == null) {
                continue;
              }
              var propNameIsArray = isArray4(props3[propName]);
              if (props3.multiple && !propNameIsArray) {
                error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
              } else if (!props3.multiple && propNameIsArray) {
                error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
              }
            }
          }
        }
        function updateOptions(node, multiple, propValue, setDefaultSelected) {
          var options2 = node.options;
          if (multiple) {
            var selectedValues = propValue;
            var selectedValue = {};
            for (var i2 = 0; i2 < selectedValues.length; i2++) {
              selectedValue["$" + selectedValues[i2]] = true;
            }
            for (var _i = 0; _i < options2.length; _i++) {
              var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
              if (options2[_i].selected !== selected) {
                options2[_i].selected = selected;
              }
              if (selected && setDefaultSelected) {
                options2[_i].defaultSelected = true;
              }
            }
          } else {
            var _selectedValue = toString5(getToStringValue(propValue));
            var defaultSelected = null;
            for (var _i2 = 0; _i2 < options2.length; _i2++) {
              if (options2[_i2].value === _selectedValue) {
                options2[_i2].selected = true;
                if (setDefaultSelected) {
                  options2[_i2].defaultSelected = true;
                }
                return;
              }
              if (defaultSelected === null && !options2[_i2].disabled) {
                defaultSelected = options2[_i2];
              }
            }
            if (defaultSelected !== null) {
              defaultSelected.selected = true;
            }
          }
        }
        function getHostProps$1(element, props3) {
          return assign2({}, props3, {
            value: void 0
          });
        }
        function initWrapperState$1(element, props3) {
          var node = element;
          {
            checkSelectPropTypes(props3);
          }
          node._wrapperState = {
            wasMultiple: !!props3.multiple
          };
          {
            if (props3.value !== void 0 && props3.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
              error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
              didWarnValueDefaultValue$1 = true;
            }
          }
        }
        function postMountWrapper$2(element, props3) {
          var node = element;
          node.multiple = !!props3.multiple;
          var value = props3.value;
          if (value != null) {
            updateOptions(node, !!props3.multiple, value, false);
          } else if (props3.defaultValue != null) {
            updateOptions(node, !!props3.multiple, props3.defaultValue, true);
          }
        }
        function postUpdateWrapper(element, props3) {
          var node = element;
          var wasMultiple = node._wrapperState.wasMultiple;
          node._wrapperState.wasMultiple = !!props3.multiple;
          var value = props3.value;
          if (value != null) {
            updateOptions(node, !!props3.multiple, value, false);
          } else if (wasMultiple !== !!props3.multiple) {
            if (props3.defaultValue != null) {
              updateOptions(node, !!props3.multiple, props3.defaultValue, true);
            } else {
              updateOptions(node, !!props3.multiple, props3.multiple ? [] : "", false);
            }
          }
        }
        function restoreControlledState$1(element, props3) {
          var node = element;
          var value = props3.value;
          if (value != null) {
            updateOptions(node, !!props3.multiple, value, false);
          }
        }
        var didWarnValDefaultVal = false;
        function getHostProps$2(element, props3) {
          var node = element;
          if (props3.dangerouslySetInnerHTML != null) {
            throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
          }
          var hostProps = assign2({}, props3, {
            value: void 0,
            defaultValue: void 0,
            children: toString5(node._wrapperState.initialValue)
          });
          return hostProps;
        }
        function initWrapperState$2(element, props3) {
          var node = element;
          {
            checkControlledValueProps("textarea", props3);
            if (props3.value !== void 0 && props3.defaultValue !== void 0 && !didWarnValDefaultVal) {
              error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
              didWarnValDefaultVal = true;
            }
          }
          var initialValue = props3.value;
          if (initialValue == null) {
            var children = props3.children, defaultValue = props3.defaultValue;
            if (children != null) {
              {
                error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              {
                if (defaultValue != null) {
                  throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                }
                if (isArray4(children)) {
                  if (children.length > 1) {
                    throw new Error("<textarea> can only have at most one child.");
                  }
                  children = children[0];
                }
                defaultValue = children;
              }
            }
            if (defaultValue == null) {
              defaultValue = "";
            }
            initialValue = defaultValue;
          }
          node._wrapperState = {
            initialValue: getToStringValue(initialValue)
          };
        }
        function updateWrapper$1(element, props3) {
          var node = element;
          var value = getToStringValue(props3.value);
          var defaultValue = getToStringValue(props3.defaultValue);
          if (value != null) {
            var newValue = toString5(value);
            if (newValue !== node.value) {
              node.value = newValue;
            }
            if (props3.defaultValue == null && node.defaultValue !== newValue) {
              node.defaultValue = newValue;
            }
          }
          if (defaultValue != null) {
            node.defaultValue = toString5(defaultValue);
          }
        }
        function postMountWrapper$3(element, props3) {
          var node = element;
          var textContent = node.textContent;
          if (textContent === node._wrapperState.initialValue) {
            if (textContent !== "" && textContent !== null) {
              node.value = textContent;
            }
          }
        }
        function restoreControlledState$2(element, props3) {
          updateWrapper$1(element, props3);
        }
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        function getIntrinsicNamespace(type5) {
          switch (type5) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type5) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type5);
          }
          if (parentNamespace === SVG_NAMESPACE && type5 === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var createMicrosoftUnsafeLocalFunction = function(func) {
          if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
            return function(arg0, arg1, arg2, arg3) {
              MSApp.execUnsafeLocalFunction(function() {
                return func(arg0, arg1, arg2, arg3);
              });
            };
          } else {
            return func;
          }
        };
        var reusableSVGContainer;
        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html2) {
          if (node.namespaceURI === SVG_NAMESPACE) {
            if (!("innerHTML" in node)) {
              reusableSVGContainer = reusableSVGContainer || document.createElement("div");
              reusableSVGContainer.innerHTML = "<svg>" + html2.valueOf().toString() + "</svg>";
              var svgNode = reusableSVGContainer.firstChild;
              while (node.firstChild) {
                node.removeChild(node.firstChild);
              }
              while (svgNode.firstChild) {
                node.appendChild(svgNode.firstChild);
              }
              return;
            }
          }
          node.innerHTML = html2;
        });
        var ELEMENT_NODE = 1;
        var TEXT_NODE = 3;
        var COMMENT_NODE = 8;
        var DOCUMENT_NODE = 9;
        var DOCUMENT_FRAGMENT_NODE = 11;
        var setTextContent = function(node, text3) {
          if (text3) {
            var firstChild = node.firstChild;
            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
              firstChild.nodeValue = text3;
              return;
            }
          }
          node.textContent = text3;
        };
        var shorthandToLonghand = {
          animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
          background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
          borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
          borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
          borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
          borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
          borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
          borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
          borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
          borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
          fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
          gap: ["columnGap", "rowGap"],
          grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
          wordWrap: ["overflowWrap"]
        };
        var isUnitlessNumber = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key57) {
          return prefix2 + key57.charAt(0).toUpperCase() + key57.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop3) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop3)] = isUnitlessNumber[prop3];
          });
        });
        function dangerousStyleValue(name2, value, isCustomProperty) {
          var isEmpty4 = value == null || typeof value === "boolean" || value === "";
          if (isEmpty4) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) {
            return value + "px";
          }
          {
            checkCSSPropertyStringCoercion(value, name2);
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name2) {
          return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_2, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error(
              "Unsupported style property %s. Did you mean %s?",
              name2,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name2.replace(msPattern$1, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name2, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name2, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name2);
          };
          var warnStyleValueIsInfinity = function(name2, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name2);
          };
          warnValidStyle = function(name2, value) {
            if (name2.indexOf("-") > -1) {
              warnHyphenatedStyleName(name2);
            } else if (badVendoredStyleNamePattern.test(name2)) {
              warnBadVendoredStyleName(name2);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name2, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name2, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name2, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        function createDangerousStringForStyles(styles) {
          {
            var serialized = "";
            var delimiter = "";
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var styleValue = styles[styleName];
              if (styleValue != null) {
                var isCustomProperty = styleName.indexOf("--") === 0;
                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                delimiter = ";";
              }
            }
            return serialized || null;
          }
        }
        function setValueForStyles(node, styles) {
          var style2 = node.style;
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styles[styleName]);
              }
            }
            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
            if (styleName === "float") {
              styleName = "cssFloat";
            }
            if (isCustomProperty) {
              style2.setProperty(styleName, styleValue);
            } else {
              style2[styleName] = styleValue;
            }
          }
        }
        function isValueEmpty(value) {
          return value == null || typeof value === "boolean" || value === "";
        }
        function expandShorthandMap(styles) {
          var expanded = {};
          for (var key57 in styles) {
            var longhands = shorthandToLonghand[key57] || [key57];
            for (var i2 = 0; i2 < longhands.length; i2++) {
              expanded[longhands[i2]] = key57;
            }
          }
          return expanded;
        }
        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
          {
            if (!nextStyles) {
              return;
            }
            var expandedUpdates = expandShorthandMap(styleUpdates);
            var expandedStyles = expandShorthandMap(nextStyles);
            var warnedAbout = {};
            for (var key57 in expandedUpdates) {
              var originalKey = expandedUpdates[key57];
              var correctOriginalKey = expandedStyles[key57];
              if (correctOriginalKey && originalKey !== correctOriginalKey) {
                var warningKey = originalKey + "," + correctOriginalKey;
                if (warnedAbout[warningKey]) {
                  continue;
                }
                warnedAbout[warningKey] = true;
                error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
              }
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
          // NOTE: menuitem's close tag should be omitted, but that causes problems.
        };
        var voidElementTags = assign2({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props3) {
          if (!props3) {
            return;
          }
          if (voidElementTags[tag]) {
            if (props3.children != null || props3.dangerouslySetInnerHTML != null) {
              throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            }
          }
          if (props3.dangerouslySetInnerHTML != null) {
            if (props3.children != null) {
              throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            }
            if (typeof props3.dangerouslySetInnerHTML !== "object" || !(HTML in props3.dangerouslySetInnerHTML)) {
              throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
            }
          }
          {
            if (!props3.suppressContentEditableWarning && props3.contentEditable && props3.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (props3.style != null && typeof props3.style !== "object") {
            throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
          }
        }
        function isCustomComponent(tagName, props3) {
          if (tagName.indexOf("-") === -1) {
            return typeof props3.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        function validateProperty(tagName, name2) {
          {
            if (hasOwnProperty3.call(warnedProperties, name2) && warnedProperties[name2]) {
              return true;
            }
            if (rARIACamel.test(name2)) {
              var ariaName = "aria-" + name2.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
                warnedProperties[name2] = true;
                return true;
              }
              if (name2 !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
                warnedProperties[name2] = true;
                return true;
              }
            }
            if (rARIA.test(name2)) {
              var lowerCasedName = name2.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name2] = true;
                return false;
              }
              if (name2 !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties[name2] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type5, props3) {
          {
            var invalidProps = [];
            for (var key57 in props3) {
              var isValid = validateProperty(type5, key57);
              if (!isValid) {
                invalidProps.push(key57);
              }
            }
            var unknownPropString = invalidProps.map(function(prop3) {
              return "`" + prop3 + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type5);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type5);
            }
          }
        }
        function validateProperties(type5, props3) {
          if (isCustomComponent(type5, props3)) {
            return;
          }
          warnInvalidARIAProps(type5, props3);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type5, props3) {
          {
            if (type5 !== "input" && type5 !== "textarea" && type5 !== "select") {
              return;
            }
            if (props3 != null && props3.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type5 === "select" && props3.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type5);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type5);
              }
            }
          }
        }
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name2, value, eventRegistry) {
            if (hasOwnProperty3.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
              return true;
            }
            var lowerCasedName = name2.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies2.hasOwnProperty(name2)) {
                return true;
              }
              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
                warnedProperties$1[name2] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name2)) {
                error("Unknown event handler property `%s`. It will be ignored.", name2);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name2)) {
              if (INVALID_EVENT_NAME_REGEX.test(name2)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2);
              warnedProperties$1[name2] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name2);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name2) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (!isReserved && name2 !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              warnedProperties$1[name2] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
              warnedProperties$1[name2] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type5, props3, eventRegistry) {
          {
            var unknownProps = [];
            for (var key57 in props3) {
              var isValid = validateProperty$1(type5, key57, props3[key57], eventRegistry);
              if (!isValid) {
                unknownProps.push(key57);
              }
            }
            var unknownPropString = unknownProps.map(function(prop3) {
              return "`" + prop3 + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type5);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type5);
            }
          }
        };
        function validateProperties$2(type5, props3, eventRegistry) {
          if (isCustomComponent(type5, props3)) {
            return;
          }
          warnUnknownProperties(type5, props3, eventRegistry);
        }
        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
        var IS_NON_DELEGATED = 1 << 1;
        var IS_CAPTURE_PHASE = 1 << 2;
        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
        var currentReplayingEvent = null;
        function setReplayingEvent(event) {
          {
            if (currentReplayingEvent !== null) {
              error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = event;
        }
        function resetReplayingEvent() {
          {
            if (currentReplayingEvent === null) {
              error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          currentReplayingEvent = null;
        }
        function isReplayingEvent(event) {
          return event === currentReplayingEvent;
        }
        function getEventTarget(nativeEvent) {
          var target = nativeEvent.target || nativeEvent.srcElement || window;
          if (target.correspondingUseElement) {
            target = target.correspondingUseElement;
          }
          return target.nodeType === TEXT_NODE ? target.parentNode : target;
        }
        var restoreImpl = null;
        var restoreTarget = null;
        var restoreQueue = null;
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (!internalInstance) {
            return;
          }
          if (typeof restoreImpl !== "function") {
            throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
          }
          var stateNode = internalInstance.stateNode;
          if (stateNode) {
            var _props = getFiberCurrentPropsFromNode(stateNode);
            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
          }
        }
        function setRestoreImplementation(impl) {
          restoreImpl = impl;
        }
        function enqueueStateRestore(target) {
          if (restoreTarget) {
            if (restoreQueue) {
              restoreQueue.push(target);
            } else {
              restoreQueue = [target];
            }
          } else {
            restoreTarget = target;
          }
        }
        function needsStateRestore() {
          return restoreTarget !== null || restoreQueue !== null;
        }
        function restoreStateIfNeeded() {
          if (!restoreTarget) {
            return;
          }
          var target = restoreTarget;
          var queuedTargets = restoreQueue;
          restoreTarget = null;
          restoreQueue = null;
          restoreStateOfTarget(target);
          if (queuedTargets) {
            for (var i2 = 0; i2 < queuedTargets.length; i2++) {
              restoreStateOfTarget(queuedTargets[i2]);
            }
          }
        }
        var batchedUpdatesImpl = function(fn2, bookkeeping) {
          return fn2(bookkeeping);
        };
        var flushSyncImpl = function() {
        };
        var isInsideEventHandler = false;
        function finishEventHandler() {
          var controlledComponentsHavePendingUpdates = needsStateRestore();
          if (controlledComponentsHavePendingUpdates) {
            flushSyncImpl();
            restoreStateIfNeeded();
          }
        }
        function batchedUpdates(fn2, a2, b) {
          if (isInsideEventHandler) {
            return fn2(a2, b);
          }
          isInsideEventHandler = true;
          try {
            return batchedUpdatesImpl(fn2, a2, b);
          } finally {
            isInsideEventHandler = false;
            finishEventHandler();
          }
        }
        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
          batchedUpdatesImpl = _batchedUpdatesImpl;
          flushSyncImpl = _flushSyncImpl;
        }
        function isInteractive(tag) {
          return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
        }
        function shouldPreventMouseEvent(name2, type5, props3) {
          switch (name2) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              return !!(props3.disabled && isInteractive(type5));
            default:
              return false;
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (stateNode === null) {
            return null;
          }
          var props3 = getFiberCurrentPropsFromNode(stateNode);
          if (props3 === null) {
            return null;
          }
          var listener = props3[registrationName];
          if (shouldPreventMouseEvent(registrationName, inst.type, props3)) {
            return null;
          }
          if (listener && typeof listener !== "function") {
            throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
          }
          return listener;
        }
        var passiveBrowserEventsSupported = false;
        if (canUseDOM2) {
          try {
            var options = {};
            Object.defineProperty(options, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options, options);
            window.removeEventListener("test", options, options);
          } catch (e2) {
            passiveBrowserEventsSupported = false;
          }
        }
        function invokeGuardedCallbackProd(name2, func, context2, a2, b, c2, d2, e2, f2) {
          var funcArgs = Array.prototype.slice.call(arguments, 3);
          try {
            func.apply(context2, funcArgs);
          } catch (error2) {
            this.onError(error2);
          }
        }
        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
        {
          if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
            var fakeNode = document.createElement("react");
            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name2, func, context2, a2, b, c2, d2, e2, f2) {
              if (typeof document === "undefined" || document === null) {
                throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
              }
              var evt = document.createEvent("Event");
              var didCall = false;
              var didError = true;
              var windowEvent = window.event;
              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
              function restoreAfterDispatch() {
                fakeNode.removeEventListener(evtType, callCallback2, false);
                if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                  window.event = windowEvent;
                }
              }
              var funcArgs = Array.prototype.slice.call(arguments, 3);
              function callCallback2() {
                didCall = true;
                restoreAfterDispatch();
                func.apply(context2, funcArgs);
                didError = false;
              }
              var error2;
              var didSetError = false;
              var isCrossOriginError = false;
              function handleWindowError(event) {
                error2 = event.error;
                didSetError = true;
                if (error2 === null && event.colno === 0 && event.lineno === 0) {
                  isCrossOriginError = true;
                }
                if (event.defaultPrevented) {
                  if (error2 != null && typeof error2 === "object") {
                    try {
                      error2._suppressLogging = true;
                    } catch (inner) {
                    }
                  }
                }
              }
              var evtType = "react-" + (name2 ? name2 : "invokeguardedcallback");
              window.addEventListener("error", handleWindowError);
              fakeNode.addEventListener(evtType, callCallback2, false);
              evt.initEvent(evtType, false, false);
              fakeNode.dispatchEvent(evt);
              if (windowEventDescriptor) {
                Object.defineProperty(window, "event", windowEventDescriptor);
              }
              if (didCall && didError) {
                if (!didSetError) {
                  error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                } else if (isCrossOriginError) {
                  error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                }
                this.onError(error2);
              }
              window.removeEventListener("error", handleWindowError);
              if (!didCall) {
                restoreAfterDispatch();
                return invokeGuardedCallbackProd.apply(this, arguments);
              }
            };
          }
        }
        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
        var hasError = false;
        var caughtError = null;
        var hasRethrowError = false;
        var rethrowError = null;
        var reporter = {
          onError: function(error2) {
            hasError = true;
            caughtError = error2;
          }
        };
        function invokeGuardedCallback(name2, func, context2, a2, b, c2, d2, e2, f2) {
          hasError = false;
          caughtError = null;
          invokeGuardedCallbackImpl$1.apply(reporter, arguments);
        }
        function invokeGuardedCallbackAndCatchFirstError(name2, func, context2, a2, b, c2, d2, e2, f2) {
          invokeGuardedCallback.apply(this, arguments);
          if (hasError) {
            var error2 = clearCaughtError();
            if (!hasRethrowError) {
              hasRethrowError = true;
              rethrowError = error2;
            }
          }
        }
        function rethrowCaughtError() {
          if (hasRethrowError) {
            var error2 = rethrowError;
            hasRethrowError = false;
            rethrowError = null;
            throw error2;
          }
        }
        function hasCaughtError() {
          return hasError;
        }
        function clearCaughtError() {
          if (hasError) {
            var error2 = caughtError;
            hasError = false;
            caughtError = null;
            return error2;
          } else {
            throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function get3(key57) {
          return key57._reactInternals;
        }
        function has4(key57) {
          return key57._reactInternals !== void 0;
        }
        function set4(key57, value) {
          key57._reactInternals = value;
        }
        var NoFlags = (
          /*                      */
          0
        );
        var PerformedWork = (
          /*                */
          1
        );
        var Placement = (
          /*                    */
          2
        );
        var Update = (
          /*                       */
          4
        );
        var ChildDeletion = (
          /*                */
          16
        );
        var ContentReset = (
          /*                 */
          32
        );
        var Callback3 = (
          /*                     */
          64
        );
        var DidCapture = (
          /*                   */
          128
        );
        var ForceClientRender = (
          /*            */
          256
        );
        var Ref2 = (
          /*                          */
          512
        );
        var Snapshot = (
          /*                     */
          1024
        );
        var Passive = (
          /*                      */
          2048
        );
        var Hydrating = (
          /*                    */
          4096
        );
        var Visibility = (
          /*                   */
          8192
        );
        var StoreConsistency = (
          /*             */
          16384
        );
        var LifecycleEffectMask = Passive | Update | Callback3 | Ref2 | Snapshot | StoreConsistency;
        var HostEffectMask = (
          /*               */
          32767
        );
        var Incomplete = (
          /*                   */
          32768
        );
        var ShouldCapture = (
          /*                */
          65536
        );
        var ForceUpdateForLegacySuspense = (
          /* */
          131072
        );
        var Forked = (
          /*                       */
          1048576
        );
        var RefStatic = (
          /*                    */
          2097152
        );
        var LayoutStatic = (
          /*                 */
          4194304
        );
        var PassiveStatic = (
          /*                */
          8388608
        );
        var MountLayoutDev = (
          /*               */
          16777216
        );
        var MountPassiveDev = (
          /*              */
          33554432
        );
        var BeforeMutationMask = (
          // TODO: Remove Update flag from before mutation phase by re-landing Visibility
          // flag logic (see #20043)
          Update | Snapshot | 0
        );
        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref2 | Hydrating | Visibility;
        var LayoutMask = Update | Callback3 | Ref2 | Visibility;
        var PassiveMask = Passive | ChildDeletion;
        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node = fiber;
          var nearestMounted = fiber;
          if (!fiber.alternate) {
            var nextNode = node;
            do {
              node = nextNode;
              if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                nearestMounted = node.return;
              }
              nextNode = node.return;
            } while (nextNode);
          } else {
            while (node.return) {
              node = node.return;
            }
          }
          if (node.tag === HostRoot) {
            return nearestMounted;
          }
          return null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (fiber.tag === SuspenseComponent) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState === null) {
              var current3 = fiber.alternate;
              if (current3 !== null) {
                suspenseState = current3.memoizedState;
              }
            }
            if (suspenseState !== null) {
              return suspenseState.dehydrated;
            }
          }
          return null;
        }
        function getContainerFromFiber(fiber) {
          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
        }
        function isFiberMounted(fiber) {
          return getNearestMountedFiber(fiber) === fiber;
        }
        function isMounted(component) {
          {
            var owner = ReactCurrentOwner.current;
            if (owner !== null && owner.tag === ClassComponent) {
              var ownerFiber = owner;
              var instance = ownerFiber.stateNode;
              if (!instance._warnedAboutRefsInRender) {
                error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
              }
              instance._warnedAboutRefsInRender = true;
            }
          }
          var fiber = get3(component);
          if (!fiber) {
            return false;
          }
          return getNearestMountedFiber(fiber) === fiber;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber) {
            throw new Error("Unable to find node on an unmounted component.");
          }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (nearestMounted === null) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (nearestMounted !== fiber) {
              return null;
            }
            return fiber;
          }
          var a2 = fiber;
          var b = alternate;
          while (true) {
            var parentA = a2.return;
            if (parentA === null) {
              break;
            }
            var parentB = parentA.alternate;
            if (parentB === null) {
              var nextParent = parentA.return;
              if (nextParent !== null) {
                a2 = b = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              var child = parentA.child;
              while (child) {
                if (child === a2) {
                  assertIsMounted(parentA);
                  return fiber;
                }
                if (child === b) {
                  assertIsMounted(parentA);
                  return alternate;
                }
                child = child.sibling;
              }
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a2.return !== b.return) {
              a2 = parentA;
              b = parentB;
            } else {
              var didFindChild = false;
              var _child = parentA.child;
              while (_child) {
                if (_child === a2) {
                  didFindChild = true;
                  a2 = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a2 = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                _child = parentB.child;
                while (_child) {
                  if (_child === a2) {
                    didFindChild = true;
                    a2 = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a2 = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                }
              }
            }
            if (a2.alternate !== b) {
              throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (a2.tag !== HostRoot) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a2.stateNode.current === a2) {
            return fiber;
          }
          return alternate;
        }
        function findCurrentHostFiber(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
        }
        function findCurrentHostFiberImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            var match3 = findCurrentHostFiberImpl(child);
            if (match3 !== null) {
              return match3;
            }
            child = child.sibling;
          }
          return null;
        }
        function findCurrentHostFiberWithNoPortals(parent) {
          var currentParent = findCurrentFiberUsingSlowPath(parent);
          return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
        }
        function findCurrentHostFiberWithNoPortalsImpl(node) {
          if (node.tag === HostComponent || node.tag === HostText) {
            return node;
          }
          var child = node.child;
          while (child !== null) {
            if (child.tag !== HostPortal) {
              var match3 = findCurrentHostFiberWithNoPortalsImpl(child);
              if (match3 !== null) {
                return match3;
              }
            }
            child = child.sibling;
          }
          return null;
        }
        var scheduleCallback = Scheduler.unstable_scheduleCallback;
        var cancelCallback = Scheduler.unstable_cancelCallback;
        var shouldYield = Scheduler.unstable_shouldYield;
        var requestPaint = Scheduler.unstable_requestPaint;
        var now = Scheduler.unstable_now;
        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
        var NormalPriority = Scheduler.unstable_NormalPriority;
        var LowPriority = Scheduler.unstable_LowPriority;
        var IdlePriority = Scheduler.unstable_IdlePriority;
        var unstable_yieldValue = Scheduler.unstable_yieldValue;
        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
        var rendererID = null;
        var injectedHook = null;
        var injectedProfilingHooks = null;
        var hasLoggedError = false;
        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
        function injectInternals(internals) {
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
            return false;
          }
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) {
            return true;
          }
          if (!hook.supportsFiber) {
            {
              error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
            }
            return true;
          }
          try {
            if (enableSchedulingProfiler) {
              internals = assign2({}, internals, {
                getLaneLabelMap,
                injectProfilingHooks
              });
            }
            rendererID = hook.inject(internals);
            injectedHook = hook;
          } catch (err2) {
            {
              error("React instrumentation encountered an error: %s.", err2);
            }
          }
          if (hook.checkDCE) {
            return true;
          } else {
            return false;
          }
        }
        function onScheduleRoot(root2, children) {
          {
            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
              try {
                injectedHook.onScheduleFiberRoot(rendererID, root2, children);
              } catch (err2) {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err2);
                }
              }
            }
          }
        }
        function onCommitRoot(root2, eventPriority) {
          if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
            try {
              var didError = (root2.current.flags & DidCapture) === DidCapture;
              if (enableProfilerTimer) {
                var schedulerPriority;
                switch (eventPriority) {
                  case DiscreteEventPriority:
                    schedulerPriority = ImmediatePriority;
                    break;
                  case ContinuousEventPriority:
                    schedulerPriority = UserBlockingPriority;
                    break;
                  case DefaultEventPriority:
                    schedulerPriority = NormalPriority;
                    break;
                  case IdleEventPriority:
                    schedulerPriority = IdlePriority;
                    break;
                  default:
                    schedulerPriority = NormalPriority;
                    break;
                }
                injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
              } else {
                injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
              }
            } catch (err2) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err2);
                }
              }
            }
          }
        }
        function onPostCommitRoot(root2) {
          if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root2);
            } catch (err2) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err2);
                }
              }
            }
          }
        }
        function onCommitUnmount(fiber) {
          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
            try {
              injectedHook.onCommitFiberUnmount(rendererID, fiber);
            } catch (err2) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err2);
                }
              }
            }
          }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          {
            if (typeof unstable_yieldValue === "function") {
              unstable_setDisableYieldValue(newIsStrictMode);
              setSuppressWarning(newIsStrictMode);
            }
            if (injectedHook && typeof injectedHook.setStrictMode === "function") {
              try {
                injectedHook.setStrictMode(rendererID, newIsStrictMode);
              } catch (err2) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err2);
                  }
                }
              }
            }
          }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function getLaneLabelMap() {
          {
            var map5 = /* @__PURE__ */ new Map();
            var lane = 1;
            for (var index2 = 0; index2 < TotalLanes; index2++) {
              var label = getLabelForLane(lane);
              map5.set(lane, label);
              lane *= 2;
            }
            return map5;
          }
        }
        function markCommitStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
              injectedProfilingHooks.markCommitStarted(lanes);
            }
          }
        }
        function markCommitStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
              injectedProfilingHooks.markCommitStopped();
            }
          }
        }
        function markComponentRenderStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
              injectedProfilingHooks.markComponentRenderStarted(fiber);
            }
          }
        }
        function markComponentRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
              injectedProfilingHooks.markComponentRenderStopped();
            }
          }
        }
        function markComponentPassiveEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectMountStopped();
            }
          }
        }
        function markComponentPassiveEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentPassiveEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
            }
          }
        }
        function markComponentLayoutEffectMountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectMountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectMountStopped();
            }
          }
        }
        function markComponentLayoutEffectUnmountStarted(fiber) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
            }
          }
        }
        function markComponentLayoutEffectUnmountStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
              injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
            }
          }
        }
        function markComponentErrored(fiber, thrownValue, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
              injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
            }
          }
        }
        function markComponentSuspended(fiber, wakeable, lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
              injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
            }
          }
        }
        function markLayoutEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
              injectedProfilingHooks.markLayoutEffectsStarted(lanes);
            }
          }
        }
        function markLayoutEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
              injectedProfilingHooks.markLayoutEffectsStopped();
            }
          }
        }
        function markPassiveEffectsStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
              injectedProfilingHooks.markPassiveEffectsStarted(lanes);
            }
          }
        }
        function markPassiveEffectsStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
              injectedProfilingHooks.markPassiveEffectsStopped();
            }
          }
        }
        function markRenderStarted(lanes) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
              injectedProfilingHooks.markRenderStarted(lanes);
            }
          }
        }
        function markRenderYielded() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
              injectedProfilingHooks.markRenderYielded();
            }
          }
        }
        function markRenderStopped() {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
              injectedProfilingHooks.markRenderStopped();
            }
          }
        }
        function markRenderScheduled(lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
              injectedProfilingHooks.markRenderScheduled(lane);
            }
          }
        }
        function markForceUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
              injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
            }
          }
        }
        function markStateUpdateScheduled(fiber, lane) {
          {
            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
              injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
            }
          }
        }
        var NoMode = (
          /*                         */
          0
        );
        var ConcurrentMode = (
          /*                 */
          1
        );
        var ProfileMode = (
          /*                    */
          2
        );
        var StrictLegacyMode = (
          /*               */
          8
        );
        var StrictEffectsMode = (
          /*              */
          16
        );
        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
        var log = Math.log;
        var LN2 = Math.LN2;
        function clz32Fallback(x2) {
          var asUint = x2 >>> 0;
          if (asUint === 0) {
            return 32;
          }
          return 31 - (log(asUint) / LN2 | 0) | 0;
        }
        var TotalLanes = 31;
        var NoLanes = (
          /*                        */
          0
        );
        var NoLane = (
          /*                          */
          0
        );
        var SyncLane = (
          /*                        */
          1
        );
        var InputContinuousHydrationLane = (
          /*    */
          2
        );
        var InputContinuousLane = (
          /*             */
          4
        );
        var DefaultHydrationLane = (
          /*            */
          8
        );
        var DefaultLane = (
          /*                     */
          16
        );
        var TransitionHydrationLane = (
          /*                */
          32
        );
        var TransitionLanes = (
          /*                       */
          4194240
        );
        var TransitionLane1 = (
          /*                        */
          64
        );
        var TransitionLane2 = (
          /*                        */
          128
        );
        var TransitionLane3 = (
          /*                        */
          256
        );
        var TransitionLane4 = (
          /*                        */
          512
        );
        var TransitionLane5 = (
          /*                        */
          1024
        );
        var TransitionLane6 = (
          /*                        */
          2048
        );
        var TransitionLane7 = (
          /*                        */
          4096
        );
        var TransitionLane8 = (
          /*                        */
          8192
        );
        var TransitionLane9 = (
          /*                        */
          16384
        );
        var TransitionLane10 = (
          /*                       */
          32768
        );
        var TransitionLane11 = (
          /*                       */
          65536
        );
        var TransitionLane12 = (
          /*                       */
          131072
        );
        var TransitionLane13 = (
          /*                       */
          262144
        );
        var TransitionLane14 = (
          /*                       */
          524288
        );
        var TransitionLane15 = (
          /*                       */
          1048576
        );
        var TransitionLane16 = (
          /*                       */
          2097152
        );
        var RetryLanes = (
          /*                            */
          130023424
        );
        var RetryLane1 = (
          /*                             */
          4194304
        );
        var RetryLane2 = (
          /*                             */
          8388608
        );
        var RetryLane3 = (
          /*                             */
          16777216
        );
        var RetryLane4 = (
          /*                             */
          33554432
        );
        var RetryLane5 = (
          /*                             */
          67108864
        );
        var SomeRetryLane = RetryLane1;
        var SelectiveHydrationLane = (
          /*          */
          134217728
        );
        var NonIdleLanes = (
          /*                          */
          268435455
        );
        var IdleHydrationLane = (
          /*               */
          268435456
        );
        var IdleLane = (
          /*                        */
          536870912
        );
        var OffscreenLane = (
          /*                   */
          1073741824
        );
        function getLabelForLane(lane) {
          {
            if (lane & SyncLane) {
              return "Sync";
            }
            if (lane & InputContinuousHydrationLane) {
              return "InputContinuousHydration";
            }
            if (lane & InputContinuousLane) {
              return "InputContinuous";
            }
            if (lane & DefaultHydrationLane) {
              return "DefaultHydration";
            }
            if (lane & DefaultLane) {
              return "Default";
            }
            if (lane & TransitionHydrationLane) {
              return "TransitionHydration";
            }
            if (lane & TransitionLanes) {
              return "Transition";
            }
            if (lane & RetryLanes) {
              return "Retry";
            }
            if (lane & SelectiveHydrationLane) {
              return "SelectiveHydration";
            }
            if (lane & IdleHydrationLane) {
              return "IdleHydration";
            }
            if (lane & IdleLane) {
              return "Idle";
            }
            if (lane & OffscreenLane) {
              return "Offscreen";
            }
          }
        }
        var NoTimestamp = -1;
        var nextTransitionLane = TransitionLane1;
        var nextRetryLane = RetryLane1;
        function getHighestPriorityLanes(lanes) {
          switch (getHighestPriorityLane(lanes)) {
            case SyncLane:
              return SyncLane;
            case InputContinuousHydrationLane:
              return InputContinuousHydrationLane;
            case InputContinuousLane:
              return InputContinuousLane;
            case DefaultHydrationLane:
              return DefaultHydrationLane;
            case DefaultLane:
              return DefaultLane;
            case TransitionHydrationLane:
              return TransitionHydrationLane;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return lanes & TransitionLanes;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return lanes & RetryLanes;
            case SelectiveHydrationLane:
              return SelectiveHydrationLane;
            case IdleHydrationLane:
              return IdleHydrationLane;
            case IdleLane:
              return IdleLane;
            case OffscreenLane:
              return OffscreenLane;
            default:
              {
                error("Should have found matching lanes. This is a bug in React.");
              }
              return lanes;
          }
        }
        function getNextLanes(root2, wipLanes) {
          var pendingLanes = root2.pendingLanes;
          if (pendingLanes === NoLanes) {
            return NoLanes;
          }
          var nextLanes = NoLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
          if (nonIdlePendingLanes !== NoLanes) {
            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
            if (nonIdleUnblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
            } else {
              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
              if (nonIdlePingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
              }
            }
          } else {
            var unblockedLanes = pendingLanes & ~suspendedLanes;
            if (unblockedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(unblockedLanes);
            } else {
              if (pingedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(pingedLanes);
              }
            }
          }
          if (nextLanes === NoLanes) {
            return NoLanes;
          }
          if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
          // bother waiting until the root is complete.
          (wipLanes & suspendedLanes) === NoLanes) {
            var nextLane = getHighestPriorityLane(nextLanes);
            var wipLane = getHighestPriorityLane(wipLanes);
            if (
              // Tests whether the next lane is equal or lower priority than the wip
              // one. This works because the bits decrease in priority as you go left.
              nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
              // only difference between default updates and transition updates is that
              // default updates do not support refresh transitions.
              nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
            ) {
              return wipLanes;
            }
          }
          if ((nextLanes & InputContinuousLane) !== NoLanes) {
            nextLanes |= pendingLanes & DefaultLane;
          }
          var entangledLanes = root2.entangledLanes;
          if (entangledLanes !== NoLanes) {
            var entanglements = root2.entanglements;
            var lanes = nextLanes & entangledLanes;
            while (lanes > 0) {
              var index2 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index2;
              nextLanes |= entanglements[index2];
              lanes &= ~lane;
            }
          }
          return nextLanes;
        }
        function getMostRecentEventTime(root2, lanes) {
          var eventTimes = root2.eventTimes;
          var mostRecentEventTime = NoTimestamp;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            var eventTime = eventTimes[index2];
            if (eventTime > mostRecentEventTime) {
              mostRecentEventTime = eventTime;
            }
            lanes &= ~lane;
          }
          return mostRecentEventTime;
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case SyncLane:
            case InputContinuousHydrationLane:
            case InputContinuousLane:
              return currentTime + 250;
            case DefaultHydrationLane:
            case DefaultLane:
            case TransitionHydrationLane:
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
              return currentTime + 5e3;
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              return NoTimestamp;
            case SelectiveHydrationLane:
            case IdleHydrationLane:
            case IdleLane:
            case OffscreenLane:
              return NoTimestamp;
            default:
              {
                error("Should have found matching lanes. This is a bug in React.");
              }
              return NoTimestamp;
          }
        }
        function markStarvedLanesAsExpired(root2, currentTime) {
          var pendingLanes = root2.pendingLanes;
          var suspendedLanes = root2.suspendedLanes;
          var pingedLanes = root2.pingedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = pendingLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            var expirationTime = expirationTimes[index2];
            if (expirationTime === NoTimestamp) {
              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                expirationTimes[index2] = computeExpirationTime(lane, currentTime);
              }
            } else if (expirationTime <= currentTime) {
              root2.expiredLanes |= lane;
            }
            lanes &= ~lane;
          }
        }
        function getHighestPriorityPendingLanes(root2) {
          return getHighestPriorityLanes(root2.pendingLanes);
        }
        function getLanesToRetrySynchronouslyOnError(root2) {
          var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
          if (everythingButOffscreen !== NoLanes) {
            return everythingButOffscreen;
          }
          if (everythingButOffscreen & OffscreenLane) {
            return OffscreenLane;
          }
          return NoLanes;
        }
        function includesSyncLane(lanes) {
          return (lanes & SyncLane) !== NoLanes;
        }
        function includesNonIdleWork(lanes) {
          return (lanes & NonIdleLanes) !== NoLanes;
        }
        function includesOnlyRetries(lanes) {
          return (lanes & RetryLanes) === lanes;
        }
        function includesOnlyNonUrgentLanes(lanes) {
          var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
          return (lanes & UrgentLanes) === NoLanes;
        }
        function includesOnlyTransitions(lanes) {
          return (lanes & TransitionLanes) === lanes;
        }
        function includesBlockingLane(root2, lanes) {
          var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
          return (lanes & SyncDefaultLanes) !== NoLanes;
        }
        function includesExpiredLane(root2, lanes) {
          return (lanes & root2.expiredLanes) !== NoLanes;
        }
        function isTransitionLane(lane) {
          return (lane & TransitionLanes) !== NoLanes;
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          if ((nextTransitionLane & TransitionLanes) === NoLanes) {
            nextTransitionLane = TransitionLane1;
          }
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          if ((nextRetryLane & RetryLanes) === NoLanes) {
            nextRetryLane = RetryLane1;
          }
          return lane;
        }
        function getHighestPriorityLane(lanes) {
          return lanes & -lanes;
        }
        function pickArbitraryLane(lanes) {
          return getHighestPriorityLane(lanes);
        }
        function pickArbitraryLaneIndex(lanes) {
          return 31 - clz32(lanes);
        }
        function laneToIndex(lane) {
          return pickArbitraryLaneIndex(lane);
        }
        function includesSomeLane(a2, b) {
          return (a2 & b) !== NoLanes;
        }
        function isSubsetOfLanes(set5, subset) {
          return (set5 & subset) === subset;
        }
        function mergeLanes(a2, b) {
          return a2 | b;
        }
        function removeLanes(set5, subset) {
          return set5 & ~subset;
        }
        function intersectLanes(a2, b) {
          return a2 & b;
        }
        function laneToLanes(lane) {
          return lane;
        }
        function higherPriorityLane(a2, b) {
          return a2 !== NoLane && a2 < b ? a2 : b;
        }
        function createLaneMap(initial) {
          var laneMap = [];
          for (var i2 = 0; i2 < TotalLanes; i2++) {
            laneMap.push(initial);
          }
          return laneMap;
        }
        function markRootUpdated(root2, updateLane, eventTime) {
          root2.pendingLanes |= updateLane;
          if (updateLane !== IdleLane) {
            root2.suspendedLanes = NoLanes;
            root2.pingedLanes = NoLanes;
          }
          var eventTimes = root2.eventTimes;
          var index2 = laneToIndex(updateLane);
          eventTimes[index2] = eventTime;
        }
        function markRootSuspended(root2, suspendedLanes) {
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          var expirationTimes = root2.expirationTimes;
          var lanes = suspendedLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            expirationTimes[index2] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootPinged(root2, pingedLanes, eventTime) {
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
        }
        function markRootFinished(root2, remainingLanes) {
          var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = NoLanes;
          root2.pingedLanes = NoLanes;
          root2.expiredLanes &= remainingLanes;
          root2.mutableReadLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          var entanglements = root2.entanglements;
          var eventTimes = root2.eventTimes;
          var expirationTimes = root2.expirationTimes;
          var lanes = noLongerPendingLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            entanglements[index2] = NoLanes;
            eventTimes[index2] = NoTimestamp;
            expirationTimes[index2] = NoTimestamp;
            lanes &= ~lane;
          }
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          var entanglements = root2.entanglements;
          var lanes = rootEntangledLanes;
          while (lanes) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            if (
              // Is this one of the newly entangled lanes?
              lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
              entanglements[index2] & entangledLanes
            ) {
              entanglements[index2] |= entangledLanes;
            }
            lanes &= ~lane;
          }
        }
        function getBumpedLaneForHydration(root2, renderLanes2) {
          var renderLane = getHighestPriorityLane(renderLanes2);
          var lane;
          switch (renderLane) {
            case InputContinuousLane:
              lane = InputContinuousHydrationLane;
              break;
            case DefaultLane:
              lane = DefaultHydrationLane;
              break;
            case TransitionLane1:
            case TransitionLane2:
            case TransitionLane3:
            case TransitionLane4:
            case TransitionLane5:
            case TransitionLane6:
            case TransitionLane7:
            case TransitionLane8:
            case TransitionLane9:
            case TransitionLane10:
            case TransitionLane11:
            case TransitionLane12:
            case TransitionLane13:
            case TransitionLane14:
            case TransitionLane15:
            case TransitionLane16:
            case RetryLane1:
            case RetryLane2:
            case RetryLane3:
            case RetryLane4:
            case RetryLane5:
              lane = TransitionHydrationLane;
              break;
            case IdleLane:
              lane = IdleHydrationLane;
              break;
            default:
              lane = NoLane;
              break;
          }
          if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
            return NoLane;
          }
          return lane;
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
          while (lanes > 0) {
            var index2 = laneToIndex(lanes);
            var lane = 1 << index2;
            var updaters = pendingUpdatersLaneMap[index2];
            updaters.add(fiber);
            lanes &= ~lane;
          }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (!isDevToolsPresent) {
            return;
          }
          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
          var memoizedUpdaters = root2.memoizedUpdaters;
          while (lanes > 0) {
            var index2 = laneToIndex(lanes);
            var lane = 1 << index2;
            var updaters = pendingUpdatersLaneMap[index2];
            if (updaters.size > 0) {
              updaters.forEach(function(fiber) {
                var alternate = fiber.alternate;
                if (alternate === null || !memoizedUpdaters.has(alternate)) {
                  memoizedUpdaters.add(fiber);
                }
              });
              updaters.clear();
            }
            lanes &= ~lane;
          }
        }
        function getTransitionsForLanes(root2, lanes) {
          {
            return null;
          }
        }
        var DiscreteEventPriority = SyncLane;
        var ContinuousEventPriority = InputContinuousLane;
        var DefaultEventPriority = DefaultLane;
        var IdleEventPriority = IdleLane;
        var currentUpdatePriority = NoLane;
        function getCurrentUpdatePriority() {
          return currentUpdatePriority;
        }
        function setCurrentUpdatePriority(newPriority) {
          currentUpdatePriority = newPriority;
        }
        function runWithPriority(priority, fn2) {
          var previousPriority = currentUpdatePriority;
          try {
            currentUpdatePriority = priority;
            return fn2();
          } finally {
            currentUpdatePriority = previousPriority;
          }
        }
        function higherEventPriority(a2, b) {
          return a2 !== 0 && a2 < b ? a2 : b;
        }
        function lowerEventPriority(a2, b) {
          return a2 === 0 || a2 > b ? a2 : b;
        }
        function isHigherEventPriority(a2, b) {
          return a2 !== 0 && a2 < b;
        }
        function lanesToEventPriority(lanes) {
          var lane = getHighestPriorityLane(lanes);
          if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
            return DiscreteEventPriority;
          }
          if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
            return ContinuousEventPriority;
          }
          if (includesNonIdleWork(lane)) {
            return DefaultEventPriority;
          }
          return IdleEventPriority;
        }
        function isRootDehydrated(root2) {
          var currentState = root2.current.memoizedState;
          return currentState.isDehydrated;
        }
        var _attemptSynchronousHydration;
        function setAttemptSynchronousHydration(fn2) {
          _attemptSynchronousHydration = fn2;
        }
        function attemptSynchronousHydration(fiber) {
          _attemptSynchronousHydration(fiber);
        }
        var attemptContinuousHydration;
        function setAttemptContinuousHydration(fn2) {
          attemptContinuousHydration = fn2;
        }
        var attemptHydrationAtCurrentPriority;
        function setAttemptHydrationAtCurrentPriority(fn2) {
          attemptHydrationAtCurrentPriority = fn2;
        }
        var getCurrentUpdatePriority$1;
        function setGetCurrentUpdatePriority(fn2) {
          getCurrentUpdatePriority$1 = fn2;
        }
        var attemptHydrationAtPriority;
        function setAttemptHydrationAtPriority(fn2) {
          attemptHydrationAtPriority = fn2;
        }
        var hasScheduledReplayAttempt = false;
        var queuedDiscreteEvents = [];
        var queuedFocus = null;
        var queuedDrag = null;
        var queuedMouse = null;
        var queuedPointers = /* @__PURE__ */ new Map();
        var queuedPointerCaptures = /* @__PURE__ */ new Map();
        var queuedExplicitHydrationTargets = [];
        var discreteReplayableEvents = [
          "mousedown",
          "mouseup",
          "touchcancel",
          "touchend",
          "touchstart",
          "auxclick",
          "dblclick",
          "pointercancel",
          "pointerdown",
          "pointerup",
          "dragend",
          "dragstart",
          "drop",
          "compositionend",
          "compositionstart",
          "keydown",
          "keypress",
          "keyup",
          "input",
          "textInput",
          // Intentionally camelCase
          "copy",
          "cut",
          "paste",
          "click",
          "change",
          "contextmenu",
          "reset",
          "submit"
        ];
        function isDiscreteEventThatRequiresHydration(eventType) {
          return discreteReplayableEvents.indexOf(eventType) > -1;
        }
        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          };
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout": {
              var pointerId = nativeEvent.pointerId;
              queuedPointers.delete(pointerId);
              break;
            }
            case "gotpointercapture":
            case "lostpointercapture": {
              var _pointerId = nativeEvent.pointerId;
              queuedPointerCaptures.delete(_pointerId);
              break;
            }
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn !== null) {
              var _fiber2 = getInstanceFromNode(blockedOn);
              if (_fiber2 !== null) {
                attemptContinuousHydration(_fiber2);
              }
            }
            return queuedEvent;
          }
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          var targetContainers = existingQueuedEvent.targetContainers;
          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
            targetContainers.push(targetContainer);
          }
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin": {
              var focusEvent = nativeEvent;
              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
              return true;
            }
            case "dragenter": {
              var dragEvent = nativeEvent;
              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
              return true;
            }
            case "mouseover": {
              var mouseEvent = nativeEvent;
              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
              return true;
            }
            case "pointerover": {
              var pointerEvent = nativeEvent;
              var pointerId = pointerEvent.pointerId;
              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
              return true;
            }
            case "gotpointercapture": {
              var _pointerEvent = nativeEvent;
              var _pointerId2 = _pointerEvent.pointerId;
              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
              return true;
            }
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted !== null) {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  queuedTarget.blockedOn = instance;
                  attemptHydrationAtPriority(queuedTarget.priority, function() {
                    attemptHydrationAtCurrentPriority(nearestMounted);
                  });
                  return;
                }
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (isRootDehydrated(root2)) {
                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                  return;
                }
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function queueExplicitHydrationTarget(target) {
          var updatePriority = getCurrentUpdatePriority$1();
          var queuedTarget = {
            blockedOn: null,
            target,
            priority: updatePriority
          };
          var i2 = 0;
          for (; i2 < queuedExplicitHydrationTargets.length; i2++) {
            if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i2].priority)) {
              break;
            }
          }
          queuedExplicitHydrationTargets.splice(i2, 0, queuedTarget);
          if (i2 === 0) {
            attemptExplicitHydrationTarget(queuedTarget);
          }
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (queuedEvent.blockedOn !== null) {
            return false;
          }
          var targetContainers = queuedEvent.targetContainers;
          while (targetContainers.length > 0) {
            var targetContainer = targetContainers[0];
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
            if (nextBlockedOn === null) {
              {
                var nativeEvent = queuedEvent.nativeEvent;
                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                setReplayingEvent(nativeEventClone);
                nativeEvent.target.dispatchEvent(nativeEventClone);
                resetReplayingEvent();
              }
            } else {
              var _fiber3 = getInstanceFromNode(nextBlockedOn);
              if (_fiber3 !== null) {
                attemptContinuousHydration(_fiber3);
              }
              queuedEvent.blockedOn = nextBlockedOn;
              return false;
            }
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key57, map5) {
          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
            map5.delete(key57);
          }
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
            queuedFocus = null;
          }
          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
            queuedDrag = null;
          }
          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
            queuedMouse = null;
          }
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          if (queuedEvent.blockedOn === unblocked) {
            queuedEvent.blockedOn = null;
            if (!hasScheduledReplayAttempt) {
              hasScheduledReplayAttempt = true;
              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
            }
          }
        }
        function retryIfBlockedOn(unblocked) {
          if (queuedDiscreteEvents.length > 0) {
            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
            for (var i2 = 1; i2 < queuedDiscreteEvents.length; i2++) {
              var queuedEvent = queuedDiscreteEvents[i2];
              if (queuedEvent.blockedOn === unblocked) {
                queuedEvent.blockedOn = null;
              }
            }
          }
          if (queuedFocus !== null) {
            scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          }
          if (queuedDrag !== null) {
            scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          }
          if (queuedMouse !== null) {
            scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          }
          var unblock = function(queuedEvent2) {
            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
          };
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
            var queuedTarget = queuedExplicitHydrationTargets[_i];
            if (queuedTarget.blockedOn === unblocked) {
              queuedTarget.blockedOn = null;
            }
          }
          while (queuedExplicitHydrationTargets.length > 0) {
            var nextExplicitTarget = queuedExplicitHydrationTargets[0];
            if (nextExplicitTarget.blockedOn !== null) {
              break;
            } else {
              attemptExplicitHydrationTarget(nextExplicitTarget);
              if (nextExplicitTarget.blockedOn === null) {
                queuedExplicitHydrationTargets.shift();
              }
            }
          }
        }
        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
        var _enabled = true;
        function setEnabled(enabled) {
          _enabled = !!enabled;
        }
        function isEnabled() {
          return _enabled;
        }
        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
          var eventPriority = getEventPriority(domEventName);
          var listenerWrapper;
          switch (eventPriority) {
            case DiscreteEventPriority:
              listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            case DefaultEventPriority:
            default:
              listenerWrapper = dispatchEvent;
              break;
          }
          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(DiscreteEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = null;
          try {
            setCurrentUpdatePriority(ContinuousEventPriority);
            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig.transition = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (!_enabled) {
            return;
          }
          {
            dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          }
        }
        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn === null) {
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            clearIfContinuousEvent(domEventName, nativeEvent);
            return;
          }
          if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
            nativeEvent.stopPropagation();
            return;
          }
          clearIfContinuousEvent(domEventName, nativeEvent);
          if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
            while (blockedOn !== null) {
              var fiber = getInstanceFromNode(blockedOn);
              if (fiber !== null) {
                attemptSynchronousHydration(fiber);
              }
              var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (nextBlockedOn === null) {
                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              }
              if (nextBlockedOn === blockedOn) {
                break;
              }
              blockedOn = nextBlockedOn;
            }
            if (blockedOn !== null) {
              nativeEvent.stopPropagation();
            }
            return;
          }
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
        }
        var return_targetInst = null;
        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          return_targetInst = null;
          var nativeEventTarget = getEventTarget(nativeEvent);
          var targetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (targetInst !== null) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (nearestMounted === null) {
              targetInst = null;
            } else {
              var tag = nearestMounted.tag;
              if (tag === SuspenseComponent) {
                var instance = getSuspenseInstanceFromFiber(nearestMounted);
                if (instance !== null) {
                  return instance;
                }
                targetInst = null;
              } else if (tag === HostRoot) {
                var root2 = nearestMounted.stateNode;
                if (isRootDehydrated(root2)) {
                  return getContainerFromFiber(nearestMounted);
                }
                targetInst = null;
              } else if (nearestMounted !== targetInst) {
                targetInst = null;
              }
            }
          }
          return_targetInst = targetInst;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "toggle":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message": {
              var schedulerPriority = getCurrentPriorityLevel();
              switch (schedulerPriority) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            }
            default:
              return DefaultEventPriority;
          }
        }
        function addEventBubbleListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, false);
          return listener;
        }
        function addEventCaptureListener(target, eventType, listener) {
          target.addEventListener(eventType, listener, true);
          return listener;
        }
        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            capture: true,
            passive
          });
          return listener;
        }
        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
          target.addEventListener(eventType, listener, {
            passive
          });
          return listener;
        }
        var root = null;
        var startText = null;
        var fallbackText = null;
        function initialize(nativeEventTarget) {
          root = nativeEventTarget;
          startText = getText();
          return true;
        }
        function reset() {
          root = null;
          startText = null;
          fallbackText = null;
        }
        function getData() {
          if (fallbackText) {
            return fallbackText;
          }
          var start;
          var startValue = startText;
          var startLength = startValue.length;
          var end;
          var endValue = getText();
          var endLength = endValue.length;
          for (start = 0; start < startLength; start++) {
            if (startValue[start] !== endValue[start]) {
              break;
            }
          }
          var minEnd = startLength - start;
          for (end = 1; end <= minEnd; end++) {
            if (startValue[startLength - end] !== endValue[endLength - end]) {
              break;
            }
          }
          var sliceTail = end > 1 ? 1 - end : void 0;
          fallbackText = endValue.slice(start, sliceTail);
          return fallbackText;
        }
        function getText() {
          if ("value" in root) {
            return root.value;
          }
          return root.textContent;
        }
        function getEventCharCode(nativeEvent) {
          var charCode;
          var keyCode = nativeEvent.keyCode;
          if ("charCode" in nativeEvent) {
            charCode = nativeEvent.charCode;
            if (charCode === 0 && keyCode === 13) {
              charCode = 13;
            }
          } else {
            charCode = keyCode;
          }
          if (charCode === 10) {
            charCode = 13;
          }
          if (charCode >= 32 || charCode === 13) {
            return charCode;
          }
          return 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var _propName in Interface) {
              if (!Interface.hasOwnProperty(_propName)) {
                continue;
              }
              var normalize3 = Interface[_propName];
              if (normalize3) {
                this[_propName] = normalize3(nativeEvent);
              } else {
                this[_propName] = nativeEvent[_propName];
              }
            }
            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
            if (defaultPrevented) {
              this.isDefaultPrevented = functionThatReturnsTrue;
            } else {
              this.isDefaultPrevented = functionThatReturnsFalse;
            }
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign2(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.preventDefault) {
                event.preventDefault();
              } else if (typeof event.returnValue !== "unknown") {
                event.returnValue = false;
              }
              this.isDefaultPrevented = functionThatReturnsTrue;
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              if (!event) {
                return;
              }
              if (event.stopPropagation) {
                event.stopPropagation();
              } else if (typeof event.cancelBubble !== "unknown") {
                event.cancelBubble = true;
              }
              this.isPropagationStopped = functionThatReturnsTrue;
            },
            /**
             * We release all dispatched `SyntheticEvent`s after each event loop, adding
             * them back into the pool. This allows a way to hold onto a reference that
             * won't be added back into the pool.
             */
            persist: function() {
            },
            /**
             * Checks if this event should be released back into the pool.
             *
             * @return {boolean} True if this should not be released, false otherwise.
             */
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        var EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        };
        var SyntheticEvent = createSyntheticEvent(EventInterface);
        var UIEventInterface = assign2({}, EventInterface, {
          view: 0,
          detail: 0
        });
        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
        var lastMovementX;
        var lastMovementY;
        var lastMouseEvent;
        function updateMouseMovementPolyfillState(event) {
          if (event !== lastMouseEvent) {
            if (lastMouseEvent && event.type === "mousemove") {
              lastMovementX = event.screenX - lastMouseEvent.screenX;
              lastMovementY = event.screenY - lastMouseEvent.screenY;
            } else {
              lastMovementX = 0;
              lastMovementY = 0;
            }
            lastMouseEvent = event;
          }
        }
        var MouseEventInterface = assign2({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            if (event.relatedTarget === void 0) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
            return event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) {
              return event.movementX;
            }
            updateMouseMovementPolyfillState(event);
            return lastMovementX;
          },
          movementY: function(event) {
            if ("movementY" in event) {
              return event.movementY;
            }
            return lastMovementY;
          }
        });
        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
        var DragEventInterface = assign2({}, MouseEventInterface, {
          dataTransfer: 0
        });
        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
        var FocusEventInterface = assign2({}, UIEventInterface, {
          relatedTarget: 0
        });
        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
        var AnimationEventInterface = assign2({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
        var ClipboardEventInterface = assign2({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        });
        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
        var CompositionEventInterface = assign2({}, EventInterface, {
          data: 0
        });
        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
        var SyntheticInputEvent = SyntheticCompositionEvent;
        var normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        };
        var translateToKey = {
          "8": "Backspace",
          "9": "Tab",
          "12": "Clear",
          "13": "Enter",
          "16": "Shift",
          "17": "Control",
          "18": "Alt",
          "19": "Pause",
          "20": "CapsLock",
          "27": "Escape",
          "32": " ",
          "33": "PageUp",
          "34": "PageDown",
          "35": "End",
          "36": "Home",
          "37": "ArrowLeft",
          "38": "ArrowUp",
          "39": "ArrowRight",
          "40": "ArrowDown",
          "45": "Insert",
          "46": "Delete",
          "112": "F1",
          "113": "F2",
          "114": "F3",
          "115": "F4",
          "116": "F5",
          "117": "F6",
          "118": "F7",
          "119": "F8",
          "120": "F9",
          "121": "F10",
          "122": "F11",
          "123": "F12",
          "144": "NumLock",
          "145": "ScrollLock",
          "224": "Meta"
        };
        function getEventKey(nativeEvent) {
          if (nativeEvent.key) {
            var key57 = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if (key57 !== "Unidentified") {
              return key57;
            }
          }
          if (nativeEvent.type === "keypress") {
            var charCode = getEventCharCode(nativeEvent);
            return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
          }
          if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
            return translateToKey[nativeEvent.keyCode] || "Unidentified";
          }
          return "";
        }
        var modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        };
        function modifierStateGetter(keyArg) {
          var syntheticEvent = this;
          var nativeEvent = syntheticEvent.nativeEvent;
          if (nativeEvent.getModifierState) {
            return nativeEvent.getModifierState(keyArg);
          }
          var keyProp = modifierKeyToProp[keyArg];
          return keyProp ? !!nativeEvent[keyProp] : false;
        }
        function getEventModifierState(nativeEvent) {
          return modifierStateGetter;
        }
        var KeyboardEventInterface = assign2({}, UIEventInterface, {
          key: getEventKey,
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          // Legacy Interface
          charCode: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            return 0;
          },
          keyCode: function(event) {
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          },
          which: function(event) {
            if (event.type === "keypress") {
              return getEventCharCode(event);
            }
            if (event.type === "keydown" || event.type === "keyup") {
              return event.keyCode;
            }
            return 0;
          }
        });
        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
        var PointerEventInterface = assign2({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        });
        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
        var TouchEventInterface = assign2({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        });
        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
        var TransitionEventInterface = assign2({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        });
        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
        var WheelEventInterface = assign2({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : (
              // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
              "wheelDeltaX" in event ? -event.wheelDeltaX : 0
            );
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : (
              // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
              "wheelDeltaY" in event ? -event.wheelDeltaY : (
                // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                "wheelDelta" in event ? -event.wheelDelta : 0
              )
            );
          },
          deltaZ: 0,
          // Browsers without "deltaMode" is reporting in raw wheel delta where one
          // notch on the scroll is always +/- 120, roughly equivalent to pixels.
          // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
          // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
          deltaMode: 0
        });
        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
        var END_KEYCODES = [9, 13, 27, 32];
        var START_KEYCODE = 229;
        var canUseCompositionEvent = canUseDOM2 && "CompositionEvent" in window;
        var documentMode = null;
        if (canUseDOM2 && "documentMode" in document) {
          documentMode = document.documentMode;
        }
        var canUseTextInputEvent = canUseDOM2 && "TextEvent" in window && !documentMode;
        var useFallbackCompositionData = canUseDOM2 && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
        var SPACEBAR_CODE = 32;
        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
        function registerEvents() {
          registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
          registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        }
        var hasSpaceKeypress = false;
        function isKeypressCommand(nativeEvent) {
          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
          !(nativeEvent.ctrlKey && nativeEvent.altKey);
        }
        function getCompositionEventType(domEventName) {
          switch (domEventName) {
            case "compositionstart":
              return "onCompositionStart";
            case "compositionend":
              return "onCompositionEnd";
            case "compositionupdate":
              return "onCompositionUpdate";
          }
        }
        function isFallbackCompositionStart(domEventName, nativeEvent) {
          return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          var detail = nativeEvent.detail;
          if (typeof detail === "object" && "data" in detail) {
            return detail.data;
          }
          return null;
        }
        function isUsingKoreanIME(nativeEvent) {
          return nativeEvent.locale === "ko";
        }
        var isComposing = false;
        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var eventType;
          var fallbackData;
          if (canUseCompositionEvent) {
            eventType = getCompositionEventType(domEventName);
          } else if (!isComposing) {
            if (isFallbackCompositionStart(domEventName, nativeEvent)) {
              eventType = "onCompositionStart";
            }
          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
            eventType = "onCompositionEnd";
          }
          if (!eventType) {
            return null;
          }
          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
            if (!isComposing && eventType === "onCompositionStart") {
              isComposing = initialize(nativeEventTarget);
            } else if (eventType === "onCompositionEnd") {
              if (isComposing) {
                fallbackData = getData();
              }
            }
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
          if (listeners.length > 0) {
            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            if (fallbackData) {
              event.data = fallbackData;
            } else {
              var customData = getDataFromCustomEvent(nativeEvent);
              if (customData !== null) {
                event.data = customData;
              }
            }
          }
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              var which = nativeEvent.which;
              if (which !== SPACEBAR_CODE) {
                return null;
              }
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              var chars = nativeEvent.data;
              if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                return null;
              }
              return chars;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing) {
            if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
              var chars = getData();
              reset();
              isComposing = false;
              return chars;
            }
            return null;
          }
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!isKeypressCommand(nativeEvent)) {
                if (nativeEvent.char && nativeEvent.char.length > 1) {
                  return nativeEvent.char;
                } else if (nativeEvent.which) {
                  return String.fromCharCode(nativeEvent.which);
                }
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
          var chars;
          if (canUseTextInputEvent) {
            chars = getNativeBeforeInputChars(domEventName, nativeEvent);
          } else {
            chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
          }
          if (!chars) {
            return null;
          }
          var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
          if (listeners.length > 0) {
            var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.data = chars;
          }
        }
        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
        var supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        };
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          if (nodeName === "input") {
            return !!supportedInputTypes[elem.type];
          }
          if (nodeName === "textarea") {
            return true;
          }
          return false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM2) {
            return false;
          }
          var eventName = "on" + eventNameSuffix;
          var isSupported = eventName in document;
          if (!isSupported) {
            var element = document.createElement("div");
            element.setAttribute(eventName, "return;");
            isSupported = typeof element[eventName] === "function";
          }
          return isSupported;
        }
        function registerEvents$1() {
          registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          enqueueStateRestore(target);
          var listeners = accumulateTwoPhaseListeners(inst, "onChange");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        var activeElement = null;
        var activeElementInst = null;
        function shouldUseChangeEvent(elem) {
          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName === "select" || nodeName === "input" && elem.type === "file";
        }
        function manualDispatchChangeEvent(nativeEvent) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
          batchedUpdates(runEventInBatch, dispatchQueue);
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) {
            return targetInst;
          }
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if (domEventName === "change") {
            return targetInst;
          }
        }
        var isInputEventSupported = false;
        if (canUseDOM2) {
          isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
        }
        function startWatchingForValueChange(target, targetInst) {
          activeElement = target;
          activeElementInst = targetInst;
          activeElement.attachEvent("onpropertychange", handlePropertyChange);
        }
        function stopWatchingForValueChange() {
          if (!activeElement) {
            return;
          }
          activeElement.detachEvent("onpropertychange", handlePropertyChange);
          activeElement = null;
          activeElementInst = null;
        }
        function handlePropertyChange(nativeEvent) {
          if (nativeEvent.propertyName !== "value") {
            return;
          }
          if (getInstIfValueChanged(activeElementInst)) {
            manualDispatchChangeEvent(nativeEvent);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          if (domEventName === "focusin") {
            stopWatchingForValueChange();
            startWatchingForValueChange(target, targetInst);
          } else if (domEventName === "focusout") {
            stopWatchingForValueChange();
          }
        }
        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
          if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
            return getInstIfValueChanged(activeElementInst);
          }
        }
        function shouldUseClickEvent(elem) {
          var nodeName = elem.nodeName;
          return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if (domEventName === "click") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if (domEventName === "input" || domEventName === "change") {
            return getInstIfValueChanged(targetInst);
          }
        }
        function handleControlledInputBlur(node) {
          var state2 = node._wrapperState;
          if (!state2 || !state2.controlled || node.type !== "number") {
            return;
          }
          {
            setDefaultValue(node, "number", node.value);
          }
        }
        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          var getTargetInstFunc, handleEventFunc;
          if (shouldUseChangeEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForChangeEvent;
          } else if (isTextInputElement(targetNode)) {
            if (isInputEventSupported) {
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            } else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else if (shouldUseClickEvent(targetNode)) {
            getTargetInstFunc = getTargetInstForClickEvent;
          }
          if (getTargetInstFunc) {
            var inst = getTargetInstFunc(domEventName, targetInst);
            if (inst) {
              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
              return;
            }
          }
          if (handleEventFunc) {
            handleEventFunc(domEventName, targetNode, targetInst);
          }
          if (domEventName === "focusout") {
            handleControlledInputBlur(targetNode);
          }
        }
        function registerEvents$2() {
          registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
          registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
          registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
          registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        }
        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
          var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
          if (isOverEvent && !isReplayingEvent(nativeEvent)) {
            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
            if (related) {
              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                return;
              }
            }
          }
          if (!isOutEvent && !isOverEvent) {
            return;
          }
          var win;
          if (nativeEventTarget.window === nativeEventTarget) {
            win = nativeEventTarget;
          } else {
            var doc = nativeEventTarget.ownerDocument;
            if (doc) {
              win = doc.defaultView || doc.parentWindow;
            } else {
              win = window;
            }
          }
          var from2;
          var to2;
          if (isOutEvent) {
            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
            from2 = targetInst;
            to2 = _related ? getClosestInstanceFromNode(_related) : null;
            if (to2 !== null) {
              var nearestMounted = getNearestMountedFiber(to2);
              if (to2 !== nearestMounted || to2.tag !== HostComponent && to2.tag !== HostText) {
                to2 = null;
              }
            }
          } else {
            from2 = null;
            to2 = targetInst;
          }
          if (from2 === to2) {
            return;
          }
          var SyntheticEventCtor = SyntheticMouseEvent;
          var leaveEventType = "onMouseLeave";
          var enterEventType = "onMouseEnter";
          var eventTypePrefix = "mouse";
          if (domEventName === "pointerout" || domEventName === "pointerover") {
            SyntheticEventCtor = SyntheticPointerEvent;
            leaveEventType = "onPointerLeave";
            enterEventType = "onPointerEnter";
            eventTypePrefix = "pointer";
          }
          var fromNode = from2 == null ? win : getNodeFromInstance(from2);
          var toNode = to2 == null ? win : getNodeFromInstance(to2);
          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from2, nativeEvent, nativeEventTarget);
          leave.target = fromNode;
          leave.relatedTarget = toNode;
          var enter = null;
          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to2, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode;
            enterEvent.relatedTarget = fromNode;
            enter = enterEvent;
          }
          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from2, to2);
        }
        function is6(x2, y2) {
          return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is6;
        function shallowEqual2(objA, objB) {
          if (objectIs(objA, objB)) {
            return true;
          }
          if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
            return false;
          }
          var keysA = Object.keys(objA);
          var keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) {
            return false;
          }
          for (var i2 = 0; i2 < keysA.length; i2++) {
            var currentKey = keysA[i2];
            if (!hasOwnProperty3.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
              return false;
            }
          }
          return true;
        }
        function getLeafNode(node) {
          while (node && node.firstChild) {
            node = node.firstChild;
          }
          return node;
        }
        function getSiblingNode(node) {
          while (node) {
            if (node.nextSibling) {
              return node.nextSibling;
            }
            node = node.parentNode;
          }
        }
        function getNodeForCharacterOffset(root2, offset) {
          var node = getLeafNode(root2);
          var nodeStart = 0;
          var nodeEnd = 0;
          while (node) {
            if (node.nodeType === TEXT_NODE) {
              nodeEnd = nodeStart + node.textContent.length;
              if (nodeStart <= offset && nodeEnd >= offset) {
                return {
                  node,
                  offset: offset - nodeStart
                };
              }
              nodeStart = nodeEnd;
            }
            node = getLeafNode(getSiblingNode(node));
          }
        }
        function getOffsets(outerNode) {
          var ownerDocument = outerNode.ownerDocument;
          var win = ownerDocument && ownerDocument.defaultView || window;
          var selection = win.getSelection && win.getSelection();
          if (!selection || selection.rangeCount === 0) {
            return null;
          }
          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
          try {
            anchorNode.nodeType;
            focusNode.nodeType;
          } catch (e2) {
            return null;
          }
          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
        }
        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
          var length3 = 0;
          var start = -1;
          var end = -1;
          var indexWithinAnchor = 0;
          var indexWithinFocus = 0;
          var node = outerNode;
          var parentNode = null;
          outer: while (true) {
            var next = null;
            while (true) {
              if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                start = length3 + anchorOffset;
              }
              if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                end = length3 + focusOffset;
              }
              if (node.nodeType === TEXT_NODE) {
                length3 += node.nodeValue.length;
              }
              if ((next = node.firstChild) === null) {
                break;
              }
              parentNode = node;
              node = next;
            }
            while (true) {
              if (node === outerNode) {
                break outer;
              }
              if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                start = length3;
              }
              if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                end = length3;
              }
              if ((next = node.nextSibling) !== null) {
                break;
              }
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          if (start === -1 || end === -1) {
            return null;
          }
          return {
            start,
            end
          };
        }
        function setOffsets(node, offsets) {
          var doc = node.ownerDocument || document;
          var win = doc && doc.defaultView || window;
          if (!win.getSelection) {
            return;
          }
          var selection = win.getSelection();
          var length3 = node.textContent.length;
          var start = Math.min(offsets.start, length3);
          var end = offsets.end === void 0 ? start : Math.min(offsets.end, length3);
          if (!selection.extend && start > end) {
            var temp = end;
            end = start;
            start = temp;
          }
          var startMarker = getNodeForCharacterOffset(node, start);
          var endMarker = getNodeForCharacterOffset(node, end);
          if (startMarker && endMarker) {
            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
              return;
            }
            var range3 = doc.createRange();
            range3.setStart(startMarker.node, startMarker.offset);
            selection.removeAllRanges();
            if (start > end) {
              selection.addRange(range3);
              selection.extend(endMarker.node, endMarker.offset);
            } else {
              range3.setEnd(endMarker.node, endMarker.offset);
              selection.addRange(range3);
            }
          }
        }
        function isTextNode(node) {
          return node && node.nodeType === TEXT_NODE;
        }
        function containsNode(outerNode, innerNode) {
          if (!outerNode || !innerNode) {
            return false;
          } else if (outerNode === innerNode) {
            return true;
          } else if (isTextNode(outerNode)) {
            return false;
          } else if (isTextNode(innerNode)) {
            return containsNode(outerNode, innerNode.parentNode);
          } else if ("contains" in outerNode) {
            return outerNode.contains(innerNode);
          } else if (outerNode.compareDocumentPosition) {
            return !!(outerNode.compareDocumentPosition(innerNode) & 16);
          } else {
            return false;
          }
        }
        function isInDocument(node) {
          return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
        }
        function isSameOriginFrame(iframe) {
          try {
            return typeof iframe.contentWindow.location.href === "string";
          } catch (err2) {
            return false;
          }
        }
        function getActiveElementDeep() {
          var win = window;
          var element = getActiveElement();
          while (element instanceof win.HTMLIFrameElement) {
            if (isSameOriginFrame(element)) {
              win = element.contentWindow;
            } else {
              return element;
            }
            element = getActiveElement(win.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
        }
        function getSelectionInformation() {
          var focusedElem = getActiveElementDeep();
          return {
            focusedElem,
            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
          };
        }
        function restoreSelection(priorSelectionInformation) {
          var curFocusedElem = getActiveElementDeep();
          var priorFocusedElem = priorSelectionInformation.focusedElem;
          var priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
              setSelection(priorFocusedElem, priorSelectionRange);
            }
            var ancestors = [];
            var ancestor = priorFocusedElem;
            while (ancestor = ancestor.parentNode) {
              if (ancestor.nodeType === ELEMENT_NODE) {
                ancestors.push({
                  element: ancestor,
                  left: ancestor.scrollLeft,
                  top: ancestor.scrollTop
                });
              }
            }
            if (typeof priorFocusedElem.focus === "function") {
              priorFocusedElem.focus();
            }
            for (var i2 = 0; i2 < ancestors.length; i2++) {
              var info = ancestors[i2];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
        }
        function getSelection(input) {
          var selection;
          if ("selectionStart" in input) {
            selection = {
              start: input.selectionStart,
              end: input.selectionEnd
            };
          } else {
            selection = getOffsets(input);
          }
          return selection || {
            start: 0,
            end: 0
          };
        }
        function setSelection(input, offsets) {
          var start = offsets.start;
          var end = offsets.end;
          if (end === void 0) {
            end = start;
          }
          if ("selectionStart" in input) {
            input.selectionStart = start;
            input.selectionEnd = Math.min(end, input.value.length);
          } else {
            setOffsets(input, offsets);
          }
        }
        var skipSelectionChangeEvent = canUseDOM2 && "documentMode" in document && document.documentMode <= 11;
        function registerEvents$3() {
          registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
        }
        var activeElement$1 = null;
        var activeElementInst$1 = null;
        var lastSelection = null;
        var mouseDown = false;
        function getSelection$1(node) {
          if ("selectionStart" in node && hasSelectionCapabilities(node)) {
            return {
              start: node.selectionStart,
              end: node.selectionEnd
            };
          } else {
            var win = node.ownerDocument && node.ownerDocument.defaultView || window;
            var selection = win.getSelection();
            return {
              anchorNode: selection.anchorNode,
              anchorOffset: selection.anchorOffset,
              focusNode: selection.focusNode,
              focusOffset: selection.focusOffset
            };
          }
        }
        function getEventTargetDocument(eventTarget) {
          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = getEventTargetDocument(nativeEventTarget);
          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
            return;
          }
          var currentSelection = getSelection$1(activeElement$1);
          if (!lastSelection || !shallowEqual2(lastSelection, currentSelection)) {
            lastSelection = currentSelection;
            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.target = activeElement$1;
            }
          }
        }
        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                activeElement$1 = targetNode;
                activeElementInst$1 = targetInst;
                lastSelection = null;
              }
              break;
            case "focusout":
              activeElement$1 = null;
              activeElementInst$1 = null;
              lastSelection = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) {
                break;
              }
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes2 = {};
          prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes2["Webkit" + styleProp] = "webkit" + eventName;
          prefixes2["Moz" + styleProp] = "moz" + eventName;
          return prefixes2;
        }
        var vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        var prefixedEventNames = {};
        var style = {};
        if (canUseDOM2) {
          style = document.createElement("div").style;
          if (!("AnimationEvent" in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
          }
          if (!("TransitionEvent" in window)) {
            delete vendorPrefixes.transitionend.transition;
          }
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
          } else if (!vendorPrefixes[eventName]) {
            return eventName;
          }
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
              return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
          }
          return eventName;
        }
        var ANIMATION_END = getVendorPrefixedEventName("animationend");
        var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
        var ANIMATION_START = getVendorPrefixedEventName("animationstart");
        var TRANSITION_END = getVendorPrefixedEventName("transitionend");
        var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
        var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function registerSimpleEvents() {
          for (var i2 = 0; i2 < simpleEventPluginEvents.length; i2++) {
            var eventName = simpleEventPluginEvents[i2];
            var domEventName = eventName.toLowerCase();
            var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + capitalizedEvent);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        }
        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (reactName === void 0) {
            return;
          }
          var SyntheticEventCtor = SyntheticEvent;
          var reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (getEventCharCode(nativeEvent) === 0) {
                return;
              }
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (nativeEvent.button === 2) {
                return;
              }
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
          }
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          {
            var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
            // nonDelegatedEvents list in DOMPluginEventSystem.
            // Then we can remove this special list.
            // This is a breaking change that can wait until React 18.
            domEventName === "scroll";
            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
            if (_listeners.length > 0) {
              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event: _event,
                listeners: _listeners
              });
            }
          }
        }
        registerSimpleEvents();
        registerEvents$2();
        registerEvents$1();
        registerEvents$3();
        registerEvents();
        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
          if (shouldProcessPolyfillPlugins) {
            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
        }
        var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
        var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
        function executeDispatch(event, listener, currentTarget) {
          var type5 = event.type || "unknown-event";
          event.currentTarget = currentTarget;
          invokeGuardedCallbackAndCatchFirstError(type5, listener, void 0, event);
          event.currentTarget = null;
        }
        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
          var previousInstance;
          if (inCapturePhase) {
            for (var i2 = dispatchListeners.length - 1; i2 >= 0; i2--) {
              var _dispatchListeners$i = dispatchListeners[i2], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, listener, currentTarget);
              previousInstance = instance;
            }
          } else {
            for (var _i = 0; _i < dispatchListeners.length; _i++) {
              var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
              if (_instance !== previousInstance && event.isPropagationStopped()) {
                return;
              }
              executeDispatch(event, _listener, _currentTarget);
              previousInstance = _instance;
            }
          }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
          for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
            var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
          }
          rethrowCaughtError();
        }
        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var nativeEventTarget = getEventTarget(nativeEvent);
          var dispatchQueue = [];
          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          {
            if (!nonDelegatedEvents.has(domEventName)) {
              error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var isCapturePhaseListener = false;
          var listenerSet = getEventListenerSet(targetElement);
          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
          if (!listenerSet.has(listenerSetKey)) {
            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
            listenerSet.add(listenerSetKey);
          }
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          {
            if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
              error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
            }
          }
          var eventSystemFlags = 0;
          if (isCapturePhaseListener) {
            eventSystemFlags |= IS_CAPTURE_PHASE;
          }
          addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
        }
        var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              if (domEventName !== "selectionchange") {
                if (!nonDelegatedEvents.has(domEventName)) {
                  listenToNativeEvent(domEventName, false, rootContainerElement);
                }
                listenToNativeEvent(domEventName, true, rootContainerElement);
              }
            });
            var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
            if (ownerDocument !== null) {
              if (!ownerDocument[listeningMarker]) {
                ownerDocument[listeningMarker] = true;
                listenToNativeEvent("selectionchange", false, ownerDocument);
              }
            }
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
          var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
          var isPassiveListener = void 0;
          if (passiveBrowserEventsSupported) {
            if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
              isPassiveListener = true;
            }
          }
          targetContainer = targetContainer;
          var unsubscribeListener;
          if (isCapturePhaseListener) {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
            }
          } else {
            if (isPassiveListener !== void 0) {
              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
            } else {
              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
            }
          }
        }
        function isMatchingRootContainer(grandContainer, targetContainer) {
          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
          var ancestorInst = targetInst;
          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
            var targetContainerNode = targetContainer;
            if (targetInst !== null) {
              var node = targetInst;
              mainLoop: while (true) {
                if (node === null) {
                  return;
                }
                var nodeTag = node.tag;
                if (nodeTag === HostRoot || nodeTag === HostPortal) {
                  var container = node.stateNode.containerInfo;
                  if (isMatchingRootContainer(container, targetContainerNode)) {
                    break;
                  }
                  if (nodeTag === HostPortal) {
                    var grandNode = node.return;
                    while (grandNode !== null) {
                      var grandTag = grandNode.tag;
                      if (grandTag === HostRoot || grandTag === HostPortal) {
                        var grandContainer = grandNode.stateNode.containerInfo;
                        if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                          return;
                        }
                      }
                      grandNode = grandNode.return;
                    }
                  }
                  while (container !== null) {
                    var parentNode = getClosestInstanceFromNode(container);
                    if (parentNode === null) {
                      return;
                    }
                    var parentTag = parentNode.tag;
                    if (parentTag === HostComponent || parentTag === HostText) {
                      node = ancestorInst = parentNode;
                      continue mainLoop;
                    }
                    container = container.parentNode;
                  }
                }
                node = node.return;
              }
            }
          }
          batchedUpdates(function() {
            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
          });
        }
        function createDispatchListener(instance, listener, currentTarget) {
          return {
            instance,
            listener,
            currentTarget
          };
        }
        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
          var captureName = reactName !== null ? reactName + "Capture" : null;
          var reactEventName = inCapturePhase ? captureName : reactName;
          var listeners = [];
          var instance = targetFiber;
          var lastHostComponent = null;
          while (instance !== null) {
            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
            if (tag === HostComponent && stateNode !== null) {
              lastHostComponent = stateNode;
              if (reactEventName !== null) {
                var listener = getListener(instance, reactEventName);
                if (listener != null) {
                  listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                }
              }
            }
            if (accumulateTargetOnly) {
              break;
            }
            instance = instance.return;
          }
          return listeners;
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          var captureName = reactName + "Capture";
          var listeners = [];
          var instance = targetFiber;
          while (instance !== null) {
            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              var captureListener = getListener(instance, captureName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
              }
              var bubbleListener = getListener(instance, reactName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
              }
            }
            instance = instance.return;
          }
          return listeners;
        }
        function getParent(inst) {
          if (inst === null) {
            return null;
          }
          do {
            inst = inst.return;
          } while (inst && inst.tag !== HostComponent);
          if (inst) {
            return inst;
          }
          return null;
        }
        function getLowestCommonAncestor(instA, instB) {
          var nodeA = instA;
          var nodeB = instB;
          var depthA = 0;
          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
            depthA++;
          }
          var depthB = 0;
          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
            depthB++;
          }
          while (depthA - depthB > 0) {
            nodeA = getParent(nodeA);
            depthA--;
          }
          while (depthB - depthA > 0) {
            nodeB = getParent(nodeB);
            depthB--;
          }
          var depth = depthA;
          while (depth--) {
            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
              return nodeA;
            }
            nodeA = getParent(nodeA);
            nodeB = getParent(nodeB);
          }
          return null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common2, inCapturePhase) {
          var registrationName = event._reactName;
          var listeners = [];
          var instance = target;
          while (instance !== null) {
            if (instance === common2) {
              break;
            }
            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
            if (alternate !== null && alternate === common2) {
              break;
            }
            if (tag === HostComponent && stateNode !== null) {
              var currentTarget = stateNode;
              if (inCapturePhase) {
                var captureListener = getListener(instance, registrationName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
              } else if (!inCapturePhase) {
                var bubbleListener = getListener(instance, registrationName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
            }
            instance = instance.return;
          }
          if (listeners.length !== 0) {
            dispatchQueue.push({
              event,
              listeners
            });
          }
        }
        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from2, to2) {
          var common2 = from2 && to2 ? getLowestCommonAncestor(from2, to2) : null;
          if (from2 !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from2, common2, false);
          }
          if (to2 !== null && enterEvent !== null) {
            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to2, common2, true);
          }
        }
        function getListenerSetKey(domEventName, capture) {
          return domEventName + "__" + (capture ? "capture" : "bubble");
        }
        var didWarnInvalidHydration = false;
        var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
        var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
        var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
        var AUTOFOCUS = "autoFocus";
        var CHILDREN = "children";
        var STYLE = "style";
        var HTML$1 = "__html";
        var warnedUnknownTags;
        var validatePropertiesInDevelopment;
        var warnForPropDifference;
        var warnForExtraAttributes;
        var warnForInvalidEventListener;
        var canDiffStyleForHydrationWarning;
        var normalizeHTML;
        {
          warnedUnknownTags = {
            // There are working polyfills for <dialog>. Let people use it.
            dialog: true,
            // Electron ships a custom <webview> tag to display external web content in
            // an isolated frame and process.
            // This tag is not present in non Electron environments such as JSDom which
            // is often used for testing purposes.
            // @see https://electronjs.org/docs/api/webview-tag
            webview: true
          };
          validatePropertiesInDevelopment = function(type5, props3) {
            validateProperties(type5, props3);
            validateProperties$1(type5, props3);
            validateProperties$2(type5, props3, {
              registrationNameDependencies,
              possibleRegistrationNames
            });
          };
          canDiffStyleForHydrationWarning = canUseDOM2 && !document.documentMode;
          warnForPropDifference = function(propName, serverValue, clientValue) {
            if (didWarnInvalidHydration) {
              return;
            }
            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
            if (normalizedServerValue === normalizedClientValue) {
              return;
            }
            didWarnInvalidHydration = true;
            error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
          };
          warnForExtraAttributes = function(attributeNames) {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            var names = [];
            attributeNames.forEach(function(name2) {
              names.push(name2);
            });
            error("Extra attributes from the server: %s", names);
          };
          warnForInvalidEventListener = function(registrationName, listener) {
            if (listener === false) {
              error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
            } else {
              error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
            }
          };
          normalizeHTML = function(parent, html2) {
            var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
            testElement.innerHTML = html2;
            return testElement.innerHTML;
          };
        }
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
        function normalizeMarkupForTextOrAttribute(markup) {
          {
            checkHtmlStringCoercion(markup);
          }
          var markupString = typeof markup === "string" ? markup : "" + markup;
          return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
          var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
          var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
          if (normalizedServerText === normalizedClientText) {
            return;
          }
          if (shouldWarnDev) {
            {
              if (!didWarnInvalidHydration) {
                didWarnInvalidHydration = true;
                error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
              }
            }
          }
          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
            throw new Error("Text content does not match server-rendered HTML.");
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function noop3() {
        }
        function trapClickOnNonInteractiveElement(node) {
          node.onclick = noop3;
        }
        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
          for (var propKey in nextProps) {
            if (!nextProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = nextProps[propKey];
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              setValueForStyles(domElement, nextProp);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              if (nextHtml != null) {
                setInnerHTML(domElement, nextHtml);
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                var canSetTextContent = tag !== "textarea" || nextProp !== "";
                if (canSetTextContent) {
                  setTextContent(domElement, nextProp);
                }
              } else if (typeof nextProp === "number") {
                setTextContent(domElement, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (propKey === AUTOFOCUS) ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (nextProp != null) {
              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
            }
          }
        }
        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
          for (var i2 = 0; i2 < updatePayload.length; i2 += 2) {
            var propKey = updatePayload[i2];
            var propValue = updatePayload[i2 + 1];
            if (propKey === STYLE) {
              setValueForStyles(domElement, propValue);
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              setInnerHTML(domElement, propValue);
            } else if (propKey === CHILDREN) {
              setTextContent(domElement, propValue);
            } else {
              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
            }
          }
        }
        function createElement3(type5, props3, rootContainerElement, parentNamespace) {
          var isCustomComponentTag;
          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
          var domElement;
          var namespaceURI = parentNamespace;
          if (namespaceURI === HTML_NAMESPACE) {
            namespaceURI = getIntrinsicNamespace(type5);
          }
          if (namespaceURI === HTML_NAMESPACE) {
            {
              isCustomComponentTag = isCustomComponent(type5, props3);
              if (!isCustomComponentTag && type5 !== type5.toLowerCase()) {
                error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type5);
              }
            }
            if (type5 === "script") {
              var div = ownerDocument.createElement("div");
              div.innerHTML = "<script><\/script>";
              var firstChild = div.firstChild;
              domElement = div.removeChild(firstChild);
            } else if (typeof props3.is === "string") {
              domElement = ownerDocument.createElement(type5, {
                is: props3.is
              });
            } else {
              domElement = ownerDocument.createElement(type5);
              if (type5 === "select") {
                var node = domElement;
                if (props3.multiple) {
                  node.multiple = true;
                } else if (props3.size) {
                  node.size = props3.size;
                }
              }
            }
          } else {
            domElement = ownerDocument.createElementNS(namespaceURI, type5);
          }
          {
            if (namespaceURI === HTML_NAMESPACE) {
              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty3.call(warnedUnknownTags, type5)) {
                warnedUnknownTags[type5] = true;
                error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type5);
              }
            }
          }
          return domElement;
        }
        function createTextNode(text3, rootContainerElement) {
          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text3);
        }
        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
          var isCustomComponentTag = isCustomComponent(tag, rawProps);
          {
            validatePropertiesInDevelopment(tag, rawProps);
          }
          var props3;
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              props3 = rawProps;
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              props3 = rawProps;
              break;
            case "video":
            case "audio":
              for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
                listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
              }
              props3 = rawProps;
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              props3 = rawProps;
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              props3 = rawProps;
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              props3 = rawProps;
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              props3 = getHostProps(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              props3 = rawProps;
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              props3 = getHostProps$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              props3 = getHostProps$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            default:
              props3 = rawProps;
          }
          assertValidProps(tag, props3);
          setInitialDOMProperties(tag, domElement, rootContainerElement, props3, isCustomComponentTag);
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, false);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "option":
              postMountWrapper$1(domElement, rawProps);
              break;
            case "select":
              postMountWrapper$2(domElement, rawProps);
              break;
            default:
              if (typeof props3.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
        }
        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
          {
            validatePropertiesInDevelopment(tag, nextRawProps);
          }
          var updatePayload = null;
          var lastProps;
          var nextProps;
          switch (tag) {
            case "input":
              lastProps = getHostProps(domElement, lastRawProps);
              nextProps = getHostProps(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "select":
              lastProps = getHostProps$1(domElement, lastRawProps);
              nextProps = getHostProps$1(domElement, nextRawProps);
              updatePayload = [];
              break;
            case "textarea":
              lastProps = getHostProps$2(domElement, lastRawProps);
              nextProps = getHostProps$2(domElement, nextRawProps);
              updatePayload = [];
              break;
            default:
              lastProps = lastRawProps;
              nextProps = nextRawProps;
              if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          assertValidProps(tag, nextProps);
          var propKey;
          var styleName;
          var styleUpdates = null;
          for (propKey in lastProps) {
            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
              continue;
            }
            if (propKey === STYLE) {
              var lastStyle = lastProps[propKey];
              for (styleName in lastStyle) {
                if (lastStyle.hasOwnProperty(styleName)) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (propKey === AUTOFOCUS) ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (!updatePayload) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, null);
            }
          }
          for (propKey in nextProps) {
            var nextProp = nextProps[propKey];
            var lastProp = lastProps != null ? lastProps[propKey] : void 0;
            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
              continue;
            }
            if (propKey === STYLE) {
              {
                if (nextProp) {
                  Object.freeze(nextProp);
                }
              }
              if (lastProp) {
                for (styleName in lastProp) {
                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
                for (styleName in nextProp) {
                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = nextProp[styleName];
                  }
                }
              } else {
                if (!styleUpdates) {
                  if (!updatePayload) {
                    updatePayload = [];
                  }
                  updatePayload.push(propKey, styleUpdates);
                }
                styleUpdates = nextProp;
              }
            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
              if (nextHtml != null) {
                if (lastHtml !== nextHtml) {
                  (updatePayload = updatePayload || []).push(propKey, nextHtml);
                }
              }
            } else if (propKey === CHILDREN) {
              if (typeof nextProp === "string" || typeof nextProp === "number") {
                (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
              }
            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;
            else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
              if (!updatePayload && lastProp !== nextProp) {
                updatePayload = [];
              }
            } else {
              (updatePayload = updatePayload || []).push(propKey, nextProp);
            }
          }
          if (styleUpdates) {
            {
              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
            }
            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
          }
          return updatePayload;
        }
        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
          if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
            updateChecked(domElement, nextRawProps);
          }
          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
          switch (tag) {
            case "input":
              updateWrapper(domElement, nextRawProps);
              break;
            case "textarea":
              updateWrapper$1(domElement, nextRawProps);
              break;
            case "select":
              postUpdateWrapper(domElement, nextRawProps);
              break;
          }
        }
        function getPossibleStandardName(propName) {
          {
            var lowerCasedName = propName.toLowerCase();
            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              return null;
            }
            return possibleStandardNames[lowerCasedName] || null;
          }
        }
        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
          var isCustomComponentTag;
          var extraAttributeNames;
          {
            isCustomComponentTag = isCustomComponent(tag, rawProps);
            validatePropertiesInDevelopment(tag, rawProps);
          }
          switch (tag) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
                listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
              }
              break;
            case "source":
              listenToNonDelegatedEvent("error", domElement);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "input":
              initWrapperState(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "option":
              validateProps(domElement, rawProps);
              break;
            case "select":
              initWrapperState$1(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
            case "textarea":
              initWrapperState$2(domElement, rawProps);
              listenToNonDelegatedEvent("invalid", domElement);
              break;
          }
          assertValidProps(tag, rawProps);
          {
            extraAttributeNames = /* @__PURE__ */ new Set();
            var attributes = domElement.attributes;
            for (var _i = 0; _i < attributes.length; _i++) {
              var name2 = attributes[_i].name.toLowerCase();
              switch (name2) {
                case "value":
                  break;
                case "checked":
                  break;
                case "selected":
                  break;
                default:
                  extraAttributeNames.add(attributes[_i].name);
              }
            }
          }
          var updatePayload = null;
          for (var propKey in rawProps) {
            if (!rawProps.hasOwnProperty(propKey)) {
              continue;
            }
            var nextProp = rawProps[propKey];
            if (propKey === CHILDREN) {
              if (typeof nextProp === "string") {
                if (domElement.textContent !== nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, nextProp];
                }
              } else if (typeof nextProp === "number") {
                if (domElement.textContent !== "" + nextProp) {
                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                  }
                  updatePayload = [CHILDREN, "" + nextProp];
                }
              }
            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
              if (nextProp != null) {
                if (typeof nextProp !== "function") {
                  warnForInvalidEventListener(propKey, nextProp);
                }
                if (propKey === "onScroll") {
                  listenToNonDelegatedEvent("scroll", domElement);
                }
              }
            } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
            typeof isCustomComponentTag === "boolean") {
              var serverValue = void 0;
              var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
              if (rawProps[SUPPRESS_HYDRATION_WARNING] === true) ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              propKey === "value" || propKey === "checked" || propKey === "selected") ;
              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var serverHTML = domElement.innerHTML;
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  var expectedHTML = normalizeHTML(domElement, nextHtml);
                  if (expectedHTML !== serverHTML) {
                    warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                }
              } else if (propKey === STYLE) {
                extraAttributeNames.delete(propKey);
                if (canDiffStyleForHydrationWarning) {
                  var expectedStyle = createDangerousStringForStyles(nextProp);
                  serverValue = domElement.getAttribute("style");
                  if (expectedStyle !== serverValue) {
                    warnForPropDifference(propKey, serverValue, expectedStyle);
                  }
                }
              } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                extraAttributeNames.delete(propKey.toLowerCase());
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
                if (nextProp !== serverValue) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                var isMismatchDueToBadCasing = false;
                if (propertyInfo !== null) {
                  extraAttributeNames.delete(propertyInfo.attributeName);
                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                } else {
                  var ownNamespace = parentNamespace;
                  if (ownNamespace === HTML_NAMESPACE) {
                    ownNamespace = getIntrinsicNamespace(tag);
                  }
                  if (ownNamespace === HTML_NAMESPACE) {
                    extraAttributeNames.delete(propKey.toLowerCase());
                  } else {
                    var standardName = getPossibleStandardName(propKey);
                    if (standardName !== null && standardName !== propKey) {
                      isMismatchDueToBadCasing = true;
                      extraAttributeNames.delete(standardName);
                    }
                    extraAttributeNames.delete(propKey);
                  }
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                }
                var dontWarnCustomElement = enableCustomElementPropertySupport;
                if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                  warnForPropDifference(propKey, serverValue, nextProp);
                }
              }
            }
          }
          {
            if (shouldWarnDev) {
              if (
                // $FlowFixMe - Should be inferred as not undefined.
                extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
              ) {
                warnForExtraAttributes(extraAttributeNames);
              }
            }
          }
          switch (tag) {
            case "input":
              track(domElement);
              postMountWrapper(domElement, rawProps, true);
              break;
            case "textarea":
              track(domElement);
              postMountWrapper$3(domElement);
              break;
            case "select":
            case "option":
              break;
            default:
              if (typeof rawProps.onClick === "function") {
                trapClickOnNonInteractiveElement(domElement);
              }
              break;
          }
          return updatePayload;
        }
        function diffHydratedText(textNode, text3, isConcurrentMode) {
          var isDifferent = textNode.nodeValue !== text3;
          return isDifferent;
        }
        function warnForDeletedHydratableElement(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
          }
        }
        function warnForDeletedHydratableText(parentNode, child) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedElement(parentNode, tag, props3) {
          {
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
          }
        }
        function warnForInsertedHydratedText(parentNode, text3) {
          {
            if (text3 === "") {
              return;
            }
            if (didWarnInvalidHydration) {
              return;
            }
            didWarnInvalidHydration = true;
            error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text3, parentNode.nodeName.toLowerCase());
          }
        }
        function restoreControlledState$3(domElement, tag, props3) {
          switch (tag) {
            case "input":
              restoreControlledState(domElement, props3);
              return;
            case "textarea":
              restoreControlledState$2(domElement, props3);
              return;
            case "select":
              restoreControlledState$1(domElement, props3);
              return;
          }
        }
        var validateDOMNesting = function() {
        };
        var updatedAncestorInfo = function() {
        };
        {
          var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
          var inScopeTags = [
            "applet",
            "caption",
            "html",
            "table",
            "td",
            "th",
            "marquee",
            "object",
            "template",
            // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
            // TODO: Distinguish by namespace here -- for <title>, including it here
            // errs on the side of fewer warnings
            "foreignObject",
            "desc",
            "title"
          ];
          var buttonScopeTags = inScopeTags.concat(["button"]);
          var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
          var emptyAncestorInfo = {
            current: null,
            formTag: null,
            aTagInScope: null,
            buttonTagInScope: null,
            nobrTagInScope: null,
            pTagInButtonScope: null,
            listItemTagAutoclosing: null,
            dlItemTagAutoclosing: null
          };
          updatedAncestorInfo = function(oldInfo, tag) {
            var ancestorInfo = assign2({}, oldInfo || emptyAncestorInfo);
            var info = {
              tag
            };
            if (inScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.aTagInScope = null;
              ancestorInfo.buttonTagInScope = null;
              ancestorInfo.nobrTagInScope = null;
            }
            if (buttonScopeTags.indexOf(tag) !== -1) {
              ancestorInfo.pTagInButtonScope = null;
            }
            if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
              ancestorInfo.listItemTagAutoclosing = null;
              ancestorInfo.dlItemTagAutoclosing = null;
            }
            ancestorInfo.current = info;
            if (tag === "form") {
              ancestorInfo.formTag = info;
            }
            if (tag === "a") {
              ancestorInfo.aTagInScope = info;
            }
            if (tag === "button") {
              ancestorInfo.buttonTagInScope = info;
            }
            if (tag === "nobr") {
              ancestorInfo.nobrTagInScope = info;
            }
            if (tag === "p") {
              ancestorInfo.pTagInButtonScope = info;
            }
            if (tag === "li") {
              ancestorInfo.listItemTagAutoclosing = info;
            }
            if (tag === "dd" || tag === "dt") {
              ancestorInfo.dlItemTagAutoclosing = info;
            }
            return ancestorInfo;
          };
          var isTagValidWithParent = function(tag, parentTag) {
            switch (parentTag) {
              case "select":
                return tag === "option" || tag === "optgroup" || tag === "#text";
              case "optgroup":
                return tag === "option" || tag === "#text";
              case "option":
                return tag === "#text";
              case "tr":
                return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
              case "tbody":
              case "thead":
              case "tfoot":
                return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
              case "colgroup":
                return tag === "col" || tag === "template";
              case "table":
                return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
              case "head":
                return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
              case "html":
                return tag === "head" || tag === "body" || tag === "frameset";
              case "frameset":
                return tag === "frame";
              case "#document":
                return tag === "html";
            }
            switch (tag) {
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
              case "rp":
              case "rt":
                return impliedEndTags.indexOf(parentTag) === -1;
              case "body":
              case "caption":
              case "col":
              case "colgroup":
              case "frameset":
              case "frame":
              case "head":
              case "html":
              case "tbody":
              case "td":
              case "tfoot":
              case "th":
              case "thead":
              case "tr":
                return parentTag == null;
            }
            return true;
          };
          var findInvalidAncestorForTag = function(tag, ancestorInfo) {
            switch (tag) {
              case "address":
              case "article":
              case "aside":
              case "blockquote":
              case "center":
              case "details":
              case "dialog":
              case "dir":
              case "div":
              case "dl":
              case "fieldset":
              case "figcaption":
              case "figure":
              case "footer":
              case "header":
              case "hgroup":
              case "main":
              case "menu":
              case "nav":
              case "ol":
              case "p":
              case "section":
              case "summary":
              case "ul":
              case "pre":
              case "listing":
              case "table":
              case "hr":
              case "xmp":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                return ancestorInfo.pTagInButtonScope;
              case "form":
                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
              case "li":
                return ancestorInfo.listItemTagAutoclosing;
              case "dd":
              case "dt":
                return ancestorInfo.dlItemTagAutoclosing;
              case "button":
                return ancestorInfo.buttonTagInScope;
              case "a":
                return ancestorInfo.aTagInScope;
              case "nobr":
                return ancestorInfo.nobrTagInScope;
            }
            return null;
          };
          var didWarn$1 = {};
          validateDOMNesting = function(childTag, childText, ancestorInfo) {
            ancestorInfo = ancestorInfo || emptyAncestorInfo;
            var parentInfo = ancestorInfo.current;
            var parentTag = parentInfo && parentInfo.tag;
            if (childText != null) {
              if (childTag != null) {
                error("validateDOMNesting: when childText is passed, childTag should be null");
              }
              childTag = "#text";
            }
            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
            var invalidParentOrAncestor = invalidParent || invalidAncestor;
            if (!invalidParentOrAncestor) {
              return;
            }
            var ancestorTag = invalidParentOrAncestor.tag;
            var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
            if (didWarn$1[warnKey]) {
              return;
            }
            didWarn$1[warnKey] = true;
            var tagDisplayName = childTag;
            var whitespaceInfo = "";
            if (childTag === "#text") {
              if (/\S/.test(childText)) {
                tagDisplayName = "Text nodes";
              } else {
                tagDisplayName = "Whitespace text nodes";
                whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
              }
            } else {
              tagDisplayName = "<" + childTag + ">";
            }
            if (invalidParent) {
              var info = "";
              if (ancestorTag === "table" && childTag === "tr") {
                info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
              }
              error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
            } else {
              error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
            }
          };
        }
        var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
        var SUSPENSE_START_DATA = "$";
        var SUSPENSE_END_DATA = "/$";
        var SUSPENSE_PENDING_START_DATA = "$?";
        var SUSPENSE_FALLBACK_START_DATA = "$!";
        var STYLE$1 = "style";
        var eventsEnabled = null;
        var selectionInformation = null;
        function getRootHostContext(rootContainerInstance) {
          var type5;
          var namespace2;
          var nodeType = rootContainerInstance.nodeType;
          switch (nodeType) {
            case DOCUMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE: {
              type5 = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
              var root2 = rootContainerInstance.documentElement;
              namespace2 = root2 ? root2.namespaceURI : getChildNamespace(null, "");
              break;
            }
            default: {
              var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
              var ownNamespace = container.namespaceURI || null;
              type5 = container.tagName;
              namespace2 = getChildNamespace(ownNamespace, type5);
              break;
            }
          }
          {
            var validatedTag = type5.toLowerCase();
            var ancestorInfo = updatedAncestorInfo(null, validatedTag);
            return {
              namespace: namespace2,
              ancestorInfo
            };
          }
        }
        function getChildHostContext(parentHostContext, type5, rootContainerInstance) {
          {
            var parentHostContextDev = parentHostContext;
            var namespace2 = getChildNamespace(parentHostContextDev.namespace, type5);
            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type5);
            return {
              namespace: namespace2,
              ancestorInfo
            };
          }
        }
        function getPublicInstance(instance) {
          return instance;
        }
        function prepareForCommit(containerInfo) {
          eventsEnabled = isEnabled();
          selectionInformation = getSelectionInformation();
          var activeInstance = null;
          setEnabled(false);
          return activeInstance;
        }
        function resetAfterCommit(containerInfo) {
          restoreSelection(selectionInformation);
          setEnabled(eventsEnabled);
          eventsEnabled = null;
          selectionInformation = null;
        }
        function createInstance(type5, props3, rootContainerInstance, hostContext, internalInstanceHandle) {
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            validateDOMNesting(type5, null, hostContextDev.ancestorInfo);
            if (typeof props3.children === "string" || typeof props3.children === "number") {
              var string = "" + props3.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type5);
              validateDOMNesting(null, string, ownAncestorInfo);
            }
            parentNamespace = hostContextDev.namespace;
          }
          var domElement = createElement3(type5, props3, rootContainerInstance, parentNamespace);
          precacheFiberNode(internalInstanceHandle, domElement);
          updateFiberProps(domElement, props3);
          return domElement;
        }
        function appendInitialChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function finalizeInitialChildren(domElement, type5, props3, rootContainerInstance, hostContext) {
          setInitialProperties(domElement, type5, props3, rootContainerInstance);
          switch (type5) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              return !!props3.autoFocus;
            case "img":
              return true;
            default:
              return false;
          }
        }
        function prepareUpdate(domElement, type5, oldProps, newProps, rootContainerInstance, hostContext) {
          {
            var hostContextDev = hostContext;
            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
              var string = "" + newProps.children;
              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type5);
              validateDOMNesting(null, string, ownAncestorInfo);
            }
          }
          return diffProperties(domElement, type5, oldProps, newProps);
        }
        function shouldSetTextContent(type5, props3) {
          return type5 === "textarea" || type5 === "noscript" || typeof props3.children === "string" || typeof props3.children === "number" || typeof props3.dangerouslySetInnerHTML === "object" && props3.dangerouslySetInnerHTML !== null && props3.dangerouslySetInnerHTML.__html != null;
        }
        function createTextInstance(text3, rootContainerInstance, hostContext, internalInstanceHandle) {
          {
            var hostContextDev = hostContext;
            validateDOMNesting(null, text3, hostContextDev.ancestorInfo);
          }
          var textNode = createTextNode(text3, rootContainerInstance);
          precacheFiberNode(internalInstanceHandle, textNode);
          return textNode;
        }
        function getCurrentEventPriority() {
          var currentEvent = window.event;
          if (currentEvent === void 0) {
            return DefaultEventPriority;
          }
          return getEventPriority(currentEvent.type);
        }
        var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
        var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
        var noTimeout = -1;
        var localPromise = typeof Promise === "function" ? Promise : void 0;
        var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
        } : scheduleTimeout;
        function handleErrorInNextTick(error2) {
          setTimeout(function() {
            throw error2;
          });
        }
        function commitMount(domElement, type5, newProps, internalInstanceHandle) {
          switch (type5) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              if (newProps.autoFocus) {
                domElement.focus();
              }
              return;
            case "img": {
              if (newProps.src) {
                domElement.src = newProps.src;
              }
              return;
            }
          }
        }
        function commitUpdate(domElement, updatePayload, type5, oldProps, newProps, internalInstanceHandle) {
          updateProperties(domElement, updatePayload, type5, oldProps, newProps);
          updateFiberProps(domElement, newProps);
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function appendChild(parentInstance, child) {
          parentInstance.appendChild(child);
        }
        function appendChildToContainer(container, child) {
          var parentNode;
          if (container.nodeType === COMMENT_NODE) {
            parentNode = container.parentNode;
            parentNode.insertBefore(child, container);
          } else {
            parentNode = container;
            parentNode.appendChild(child);
          }
          var reactRootContainer = container._reactRootContainer;
          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
            trapClickOnNonInteractiveElement(parentNode);
          }
        }
        function insertBefore(parentInstance, child, beforeChild) {
          parentInstance.insertBefore(child, beforeChild);
        }
        function insertInContainerBefore(container, child, beforeChild) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.insertBefore(child, beforeChild);
          } else {
            container.insertBefore(child, beforeChild);
          }
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          if (container.nodeType === COMMENT_NODE) {
            container.parentNode.removeChild(child);
          } else {
            container.removeChild(child);
          }
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node = suspenseInstance;
          var depth = 0;
          do {
            var nextNode = node.nextSibling;
            parentInstance.removeChild(node);
            if (nextNode && nextNode.nodeType === COMMENT_NODE) {
              var data = nextNode.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                depth++;
              }
            }
            node = nextNode;
          } while (node);
          retryIfBlockedOn(suspenseInstance);
        }
        function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
          if (container.nodeType === COMMENT_NODE) {
            clearSuspenseBoundary(container.parentNode, suspenseInstance);
          } else if (container.nodeType === ELEMENT_NODE) {
            clearSuspenseBoundary(container, suspenseInstance);
          }
          retryIfBlockedOn(container);
        }
        function hideInstance(instance) {
          instance = instance;
          var style2 = instance.style;
          if (typeof style2.setProperty === "function") {
            style2.setProperty("display", "none", "important");
          } else {
            style2.display = "none";
          }
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props3) {
          instance = instance;
          var styleProp = props3[STYLE$1];
          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
          instance.style.display = dangerousStyleValue("display", display);
        }
        function unhideTextInstance(textInstance, text3) {
          textInstance.nodeValue = text3;
        }
        function clearContainer(container) {
          if (container.nodeType === ELEMENT_NODE) {
            container.textContent = "";
          } else if (container.nodeType === DOCUMENT_NODE) {
            if (container.documentElement) {
              container.removeChild(container.documentElement);
            }
          }
        }
        function canHydrateInstance(instance, type5, props3) {
          if (instance.nodeType !== ELEMENT_NODE || type5.toLowerCase() !== instance.nodeName.toLowerCase()) {
            return null;
          }
          return instance;
        }
        function canHydrateTextInstance(instance, text3) {
          if (text3 === "" || instance.nodeType !== TEXT_NODE) {
            return null;
          }
          return instance;
        }
        function canHydrateSuspenseInstance(instance) {
          if (instance.nodeType !== COMMENT_NODE) {
            return null;
          }
          return instance;
        }
        function isSuspenseInstancePending(instance) {
          return instance.data === SUSPENSE_PENDING_START_DATA;
        }
        function isSuspenseInstanceFallback(instance) {
          return instance.data === SUSPENSE_FALLBACK_START_DATA;
        }
        function getSuspenseInstanceFallbackErrorDetails(instance) {
          var dataset = instance.nextSibling && instance.nextSibling.dataset;
          var digest, message, stack;
          if (dataset) {
            digest = dataset.dgst;
            {
              message = dataset.msg;
              stack = dataset.stck;
            }
          }
          {
            return {
              message,
              digest,
              stack
            };
          }
        }
        function registerSuspenseInstanceRetry(instance, callback) {
          instance._reactRetry = callback;
        }
        function getNextHydratable(node) {
          for (; node != null; node = node.nextSibling) {
            var nodeType = node.nodeType;
            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
              break;
            }
            if (nodeType === COMMENT_NODE) {
              var nodeData = node.data;
              if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                break;
              }
              if (nodeData === SUSPENSE_END_DATA) {
                return null;
              }
            }
          }
          return node;
        }
        function getNextHydratableSibling(instance) {
          return getNextHydratable(instance.nextSibling);
        }
        function getFirstHydratableChild(parentInstance) {
          return getNextHydratable(parentInstance.firstChild);
        }
        function getFirstHydratableChildWithinContainer(parentContainer) {
          return getNextHydratable(parentContainer.firstChild);
        }
        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
          return getNextHydratable(parentInstance.nextSibling);
        }
        function hydrateInstance(instance, type5, props3, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, instance);
          updateFiberProps(instance, props3);
          var parentNamespace;
          {
            var hostContextDev = hostContext;
            parentNamespace = hostContextDev.namespace;
          }
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedProperties(instance, type5, props3, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
        }
        function hydrateTextInstance(textInstance, text3, internalInstanceHandle, shouldWarnDev) {
          precacheFiberNode(internalInstanceHandle, textInstance);
          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
          return diffHydratedText(textInstance, text3);
        }
        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
          precacheFiberNode(internalInstanceHandle, suspenseInstance);
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          var node = suspenseInstance.nextSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_END_DATA) {
                if (depth === 0) {
                  return getNextHydratableSibling(node);
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                depth++;
              }
            }
            node = node.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          var node = targetInstance.previousSibling;
          var depth = 0;
          while (node) {
            if (node.nodeType === COMMENT_NODE) {
              var data = node.data;
              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                if (depth === 0) {
                  return node;
                } else {
                  depth--;
                }
              } else if (data === SUSPENSE_END_DATA) {
                depth++;
              }
            }
            node = node.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function shouldDeleteUnhydratedTailInstances(parentType) {
          return parentType !== "head" && parentType !== "body";
        }
        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text3, isConcurrentMode) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text3, isConcurrentMode, shouldWarnDev);
        }
        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text3, isConcurrentMode) {
          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text3, isConcurrentMode, shouldWarnDev);
          }
        }
        function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
          {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentContainer, instance);
            } else if (instance.nodeType === COMMENT_NODE) ;
            else {
              warnForDeletedHydratableText(parentContainer, instance);
            }
          }
        }
        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentNode, instance);
              } else if (instance.nodeType === COMMENT_NODE) ;
              else {
                warnForDeletedHydratableText(parentNode, instance);
              }
            }
          }
        }
        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentInstance, instance);
              } else if (instance.nodeType === COMMENT_NODE) ;
              else {
                warnForDeletedHydratableText(parentInstance, instance);
              }
            }
          }
        }
        function didNotFindHydratableInstanceWithinContainer(parentContainer, type5, props3) {
          {
            warnForInsertedHydratedElement(parentContainer, type5);
          }
        }
        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text3) {
          {
            warnForInsertedHydratedText(parentContainer, text3);
          }
        }
        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type5, props3) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type5);
          }
        }
        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text3) {
          {
            var parentNode = parentInstance.parentNode;
            if (parentNode !== null) warnForInsertedHydratedText(parentNode, text3);
          }
        }
        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type5, props3, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedElement(parentInstance, type5);
            }
          }
        }
        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text3, isConcurrentMode) {
          {
            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              warnForInsertedHydratedText(parentInstance, text3);
            }
          }
        }
        function errorHydratingContainer(parentContainer) {
          {
            error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
          }
        }
        function preparePortalMount(portalInstance) {
          listenToAllSupportedEvents(portalInstance);
        }
        var randomKey = Math.random().toString(36).slice(2);
        var internalInstanceKey = "__reactFiber$" + randomKey;
        var internalPropsKey = "__reactProps$" + randomKey;
        var internalContainerInstanceKey = "__reactContainer$" + randomKey;
        var internalEventHandlersKey = "__reactEvents$" + randomKey;
        var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
        var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
        function detachDeletedInstance(node) {
          delete node[internalInstanceKey];
          delete node[internalPropsKey];
          delete node[internalEventHandlersKey];
          delete node[internalEventHandlerListenersKey];
          delete node[internalEventHandlesSetKey];
        }
        function precacheFiberNode(hostInst, node) {
          node[internalInstanceKey] = hostInst;
        }
        function markContainerAsRoot(hostRoot, node) {
          node[internalContainerInstanceKey] = hostRoot;
        }
        function unmarkContainerAsRoot(node) {
          node[internalContainerInstanceKey] = null;
        }
        function isContainerMarkedAsRoot(node) {
          return !!node[internalContainerInstanceKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) {
            return targetInst;
          }
          var parentNode = targetNode.parentNode;
          while (parentNode) {
            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
            if (targetInst) {
              var alternate = targetInst.alternate;
              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                var suspenseInstance = getParentSuspenseInstance(targetNode);
                while (suspenseInstance !== null) {
                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                  if (targetSuspenseInst) {
                    return targetSuspenseInst;
                  }
                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                }
              }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node) {
          var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
          if (inst) {
            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
              return inst;
            } else {
              return null;
            }
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          if (inst.tag === HostComponent || inst.tag === HostText) {
            return inst.stateNode;
          }
          throw new Error("getNodeFromInstance: Invalid argument.");
        }
        function getFiberCurrentPropsFromNode(node) {
          return node[internalPropsKey] || null;
        }
        function updateFiberProps(node, props3) {
          node[internalPropsKey] = props3;
        }
        function getEventListenerSet(node) {
          var elementListenerSet = node[internalEventHandlersKey];
          if (elementListenerSet === void 0) {
            elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
          }
          return elementListenerSet;
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values3, location, componentName, element) {
          {
            var has5 = Function.call.bind(hasOwnProperty3);
            for (var typeSpecName in typeSpecs) {
              if (has5(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err2 = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err2.name = "Invariant Violation";
                    throw err2;
                  }
                  error$1 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var valueStack = [];
        var fiberStack;
        {
          fiberStack = [];
        }
        var index = -1;
        function createCursor(defaultValue) {
          return {
            current: defaultValue
          };
        }
        function pop(cursor, fiber) {
          if (index < 0) {
            {
              error("Unexpected pop.");
            }
            return;
          }
          {
            if (fiber !== fiberStack[index]) {
              error("Unexpected Fiber popped.");
            }
          }
          cursor.current = valueStack[index];
          valueStack[index] = null;
          {
            fiberStack[index] = null;
          }
          index--;
        }
        function push(cursor, value, fiber) {
          index++;
          valueStack[index] = cursor.current;
          {
            fiberStack[index] = fiber;
          }
          cursor.current = value;
        }
        var warnedAboutMissingGetChildContext;
        {
          warnedAboutMissingGetChildContext = {};
        }
        var emptyContextObject = {};
        {
          Object.freeze(emptyContextObject);
        }
        var contextStackCursor = createCursor(emptyContextObject);
        var didPerformWorkStackCursor = createCursor(false);
        var previousContext = emptyContextObject;
        function getUnmaskedContext(workInProgress2, Component2, didPushOwnContextIfProvider) {
          {
            if (didPushOwnContextIfProvider && isContextProvider(Component2)) {
              return previousContext;
            }
            return contextStackCursor.current;
          }
        }
        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
          {
            var instance = workInProgress2.stateNode;
            instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
            instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
          }
        }
        function getMaskedContext(workInProgress2, unmaskedContext) {
          {
            var type5 = workInProgress2.type;
            var contextTypes = type5.contextTypes;
            if (!contextTypes) {
              return emptyContextObject;
            }
            var instance = workInProgress2.stateNode;
            if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
              return instance.__reactInternalMemoizedMaskedChildContext;
            }
            var context2 = {};
            for (var key57 in contextTypes) {
              context2[key57] = unmaskedContext[key57];
            }
            {
              var name2 = getComponentNameFromFiber(workInProgress2) || "Unknown";
              checkPropTypes(contextTypes, context2, "context", name2);
            }
            if (instance) {
              cacheContext(workInProgress2, unmaskedContext, context2);
            }
            return context2;
          }
        }
        function hasContextChanged() {
          {
            return didPerformWorkStackCursor.current;
          }
        }
        function isContextProvider(type5) {
          {
            var childContextTypes = type5.childContextTypes;
            return childContextTypes !== null && childContextTypes !== void 0;
          }
        }
        function popContext(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function popTopLevelContextObject(fiber) {
          {
            pop(didPerformWorkStackCursor, fiber);
            pop(contextStackCursor, fiber);
          }
        }
        function pushTopLevelContextObject(fiber, context2, didChange) {
          {
            if (contextStackCursor.current !== emptyContextObject) {
              throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
            }
            push(contextStackCursor, context2, fiber);
            push(didPerformWorkStackCursor, didChange, fiber);
          }
        }
        function processChildContext(fiber, type5, parentContext) {
          {
            var instance = fiber.stateNode;
            var childContextTypes = type5.childContextTypes;
            if (typeof instance.getChildContext !== "function") {
              {
                var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                if (!warnedAboutMissingGetChildContext[componentName]) {
                  warnedAboutMissingGetChildContext[componentName] = true;
                  error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                }
              }
              return parentContext;
            }
            var childContext = instance.getChildContext();
            for (var contextKey in childContext) {
              if (!(contextKey in childContextTypes)) {
                throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
              }
            }
            {
              var name2 = getComponentNameFromFiber(fiber) || "Unknown";
              checkPropTypes(childContextTypes, childContext, "child context", name2);
            }
            return assign2({}, parentContext, childContext);
          }
        }
        function pushContextProvider(workInProgress2) {
          {
            var instance = workInProgress2.stateNode;
            var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
            previousContext = contextStackCursor.current;
            push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
            push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
            return true;
          }
        }
        function invalidateContextProvider(workInProgress2, type5, didChange) {
          {
            var instance = workInProgress2.stateNode;
            if (!instance) {
              throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
            }
            if (didChange) {
              var mergedContext = processChildContext(workInProgress2, type5, previousContext);
              instance.__reactInternalMemoizedMergedChildContext = mergedContext;
              pop(didPerformWorkStackCursor, workInProgress2);
              pop(contextStackCursor, workInProgress2);
              push(contextStackCursor, mergedContext, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            } else {
              pop(didPerformWorkStackCursor, workInProgress2);
              push(didPerformWorkStackCursor, didChange, workInProgress2);
            }
          }
        }
        function findCurrentUnmaskedContext(fiber) {
          {
            if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
              throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
            }
            var node = fiber;
            do {
              switch (node.tag) {
                case HostRoot:
                  return node.stateNode.context;
                case ClassComponent: {
                  var Component2 = node.type;
                  if (isContextProvider(Component2)) {
                    return node.stateNode.__reactInternalMemoizedMergedChildContext;
                  }
                  break;
                }
              }
              node = node.return;
            } while (node !== null);
            throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        var LegacyRoot = 0;
        var ConcurrentRoot = 1;
        var syncQueue = null;
        var includesLegacySyncCallbacks = false;
        var isFlushingSyncQueue = false;
        function scheduleSyncCallback(callback) {
          if (syncQueue === null) {
            syncQueue = [callback];
          } else {
            syncQueue.push(callback);
          }
        }
        function scheduleLegacySyncCallback(callback) {
          includesLegacySyncCallbacks = true;
          scheduleSyncCallback(callback);
        }
        function flushSyncCallbacksOnlyInLegacyMode() {
          if (includesLegacySyncCallbacks) {
            flushSyncCallbacks();
          }
        }
        function flushSyncCallbacks() {
          if (!isFlushingSyncQueue && syncQueue !== null) {
            isFlushingSyncQueue = true;
            var i2 = 0;
            var previousUpdatePriority = getCurrentUpdatePriority();
            try {
              var isSync = true;
              var queue = syncQueue;
              setCurrentUpdatePriority(DiscreteEventPriority);
              for (; i2 < queue.length; i2++) {
                var callback = queue[i2];
                do {
                  callback = callback(isSync);
                } while (callback !== null);
              }
              syncQueue = null;
              includesLegacySyncCallbacks = false;
            } catch (error2) {
              if (syncQueue !== null) {
                syncQueue = syncQueue.slice(i2 + 1);
              }
              scheduleCallback(ImmediatePriority, flushSyncCallbacks);
              throw error2;
            } finally {
              setCurrentUpdatePriority(previousUpdatePriority);
              isFlushingSyncQueue = false;
            }
          }
          return null;
        }
        var forkStack = [];
        var forkStackIndex = 0;
        var treeForkProvider = null;
        var treeForkCount = 0;
        var idStack = [];
        var idStackIndex = 0;
        var treeContextProvider = null;
        var treeContextId = 1;
        var treeContextOverflow = "";
        function isForkedChild(workInProgress2) {
          warnIfNotHydrating();
          return (workInProgress2.flags & Forked) !== NoFlags;
        }
        function getForksAtLevel(workInProgress2) {
          warnIfNotHydrating();
          return treeForkCount;
        }
        function getTreeId() {
          var overflow = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
          return id.toString(32) + overflow;
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index2) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          var baseOverflow = treeContextOverflow;
          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
          var slot = index2 + 1;
          var length3 = getBitLength(totalChildren) + baseLength;
          if (length3 > 30) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            var newOverflowBits = (1 << numberOfOverflowBits) - 1;
            var newOverflow = (baseId & newOverflowBits).toString(32);
            var restOfBaseId = baseId >> numberOfOverflowBits;
            var restOfBaseLength = baseLength - numberOfOverflowBits;
            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
            var restOfNewBits = slot << restOfBaseLength;
            var id = restOfNewBits | restOfBaseId;
            var overflow = newOverflow + baseOverflow;
            treeContextId = 1 << restOfLength | id;
            treeContextOverflow = overflow;
          } else {
            var newBits = slot << baseLength;
            var _id = newBits | baseId;
            var _overflow = baseOverflow;
            treeContextId = 1 << length3 | _id;
            treeContextOverflow = _overflow;
          }
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          var returnFiber = workInProgress2.return;
          if (returnFiber !== null) {
            var numberOfForks = 1;
            var slotIndex = 0;
            pushTreeFork(workInProgress2, numberOfForks);
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        function getBitLength(number) {
          return 32 - clz32(number);
        }
        function getLeadingBit(id) {
          return 1 << getBitLength(id) - 1;
        }
        function popTreeContext(workInProgress2) {
          while (workInProgress2 === treeForkProvider) {
            treeForkProvider = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
            treeForkCount = forkStack[--forkStackIndex];
            forkStack[forkStackIndex] = null;
          }
          while (workInProgress2 === treeContextProvider) {
            treeContextProvider = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextOverflow = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
            treeContextId = idStack[--idStackIndex];
            idStack[idStackIndex] = null;
          }
        }
        function getSuspendedTreeContext() {
          warnIfNotHydrating();
          if (treeContextProvider !== null) {
            return {
              id: treeContextId,
              overflow: treeContextOverflow
            };
          } else {
            return null;
          }
        }
        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextId = suspendedContext.id;
          treeContextOverflow = suspendedContext.overflow;
          treeContextProvider = workInProgress2;
        }
        function warnIfNotHydrating() {
          {
            if (!getIsHydrating()) {
              error("Expected to be hydrating. This is a bug in React. Please file an issue.");
            }
          }
        }
        var hydrationParentFiber = null;
        var nextHydratableInstance = null;
        var isHydrating = false;
        var didSuspendOrErrorDEV = false;
        var hydrationErrors = null;
        function warnIfHydrating() {
          {
            if (isHydrating) {
              error("We should not be hydrating here. This is a bug in React. Please file a bug.");
            }
          }
        }
        function markDidThrowWhileHydratingDEV() {
          {
            didSuspendOrErrorDEV = true;
          }
        }
        function didSuspendOrErrorWhileHydratingDEV() {
          {
            return didSuspendOrErrorDEV;
          }
        }
        function enterHydrationState(fiber) {
          var parentInstance = fiber.stateNode.containerInfo;
          nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          return true;
        }
        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
          nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
          hydrationParentFiber = fiber;
          isHydrating = true;
          hydrationErrors = null;
          didSuspendOrErrorDEV = false;
          if (treeContext !== null) {
            restoreSuspendedTreeContext(fiber, treeContext);
          }
          return true;
        }
        function warnUnhydratedInstance(returnFiber, instance) {
          {
            switch (returnFiber.tag) {
              case HostRoot: {
                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                break;
              }
              case HostComponent: {
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotHydrateInstance(
                  returnFiber.type,
                  returnFiber.memoizedProps,
                  returnFiber.stateNode,
                  instance,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                break;
              }
            }
          }
        }
        function deleteHydratableInstance(returnFiber, instance) {
          warnUnhydratedInstance(returnFiber, instance);
          var childToDelete = createFiberFromHostInstanceForDeletion();
          childToDelete.stateNode = instance;
          childToDelete.return = returnFiber;
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function warnNonhydratedInstance(returnFiber, fiber) {
          {
            if (didSuspendOrErrorDEV) {
              return;
            }
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                switch (fiber.tag) {
                  case HostComponent:
                    var type5 = fiber.type;
                    var props3 = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinContainer(parentContainer, type5);
                    break;
                  case HostText:
                    var text3 = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text3);
                    break;
                }
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                switch (fiber.tag) {
                  case HostComponent: {
                    var _type = fiber.type;
                    var _props = fiber.pendingProps;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _type,
                      _props,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostText: {
                    var _text = fiber.pendingProps;
                    var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotFindHydratableTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      _text,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode
                    );
                    break;
                  }
                }
                break;
              }
              case SuspenseComponent: {
                var suspenseState = returnFiber.memoizedState;
                var _parentInstance = suspenseState.dehydrated;
                if (_parentInstance !== null) switch (fiber.tag) {
                  case HostComponent:
                    var _type2 = fiber.type;
                    var _props2 = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                    break;
                  case HostText:
                    var _text2 = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                    break;
                }
                break;
              }
              default:
                return;
            }
          }
        }
        function insertNonHydratedInstance(returnFiber, fiber) {
          fiber.flags = fiber.flags & ~Hydrating | Placement;
          warnNonhydratedInstance(returnFiber, fiber);
        }
        function tryHydrate(fiber, nextInstance) {
          switch (fiber.tag) {
            case HostComponent: {
              var type5 = fiber.type;
              var props3 = fiber.pendingProps;
              var instance = canHydrateInstance(nextInstance, type5);
              if (instance !== null) {
                fiber.stateNode = instance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = getFirstHydratableChild(instance);
                return true;
              }
              return false;
            }
            case HostText: {
              var text3 = fiber.pendingProps;
              var textInstance = canHydrateTextInstance(nextInstance, text3);
              if (textInstance !== null) {
                fiber.stateNode = textInstance;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            case SuspenseComponent: {
              var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
              if (suspenseInstance !== null) {
                var suspenseState = {
                  dehydrated: suspenseInstance,
                  treeContext: getSuspendedTreeContext(),
                  retryLane: OffscreenLane
                };
                fiber.memoizedState = suspenseState;
                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                dehydratedFragment.return = fiber;
                fiber.child = dehydratedFragment;
                hydrationParentFiber = fiber;
                nextHydratableInstance = null;
                return true;
              }
              return false;
            }
            default:
              return false;
          }
        }
        function shouldClientRenderOnMismatch(fiber) {
          return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
        }
        function throwOnHydrationMismatch(fiber) {
          throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
        }
        function tryToClaimNextHydratableInstance(fiber) {
          if (!isHydrating) {
            return;
          }
          var nextInstance = nextHydratableInstance;
          if (!nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          var firstAttemptedInstance = nextInstance;
          if (!tryHydrate(fiber, nextInstance)) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnNonhydratedInstance(hydrationParentFiber, fiber);
              throwOnHydrationMismatch();
            }
            nextInstance = getNextHydratableSibling(firstAttemptedInstance);
            var prevHydrationParentFiber = hydrationParentFiber;
            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
          }
        }
        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
          var instance = fiber.stateNode;
          var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
          var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
          fiber.updateQueue = updatePayload;
          if (updatePayload !== null) {
            return true;
          }
          return false;
        }
        function prepareToHydrateHostTextInstance(fiber) {
          var textInstance = fiber.stateNode;
          var textContent = fiber.memoizedProps;
          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
          if (shouldUpdate) {
            var returnFiber = hydrationParentFiber;
            if (returnFiber !== null) {
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedContainerTextInstance(
                    parentContainer,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotMatchHydratedTextInstance(
                    parentType,
                    parentProps,
                    parentInstance,
                    textInstance,
                    textContent,
                    // TODO: Delete this argument when we remove the legacy root API.
                    _isConcurrentMode2
                  );
                  break;
                }
              }
            }
          }
          return shouldUpdate;
        }
        function prepareToHydrateHostSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          hydrateSuspenseInstance(suspenseInstance, fiber);
        }
        function skipPastDehydratedSuspenseInstance(fiber) {
          var suspenseState = fiber.memoizedState;
          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
          if (!suspenseInstance) {
            throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
          }
          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
        }
        function popToNextHostParent(fiber) {
          var parent = fiber.return;
          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
            parent = parent.return;
          }
          hydrationParentFiber = parent;
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) {
            return false;
          }
          if (!isHydrating) {
            popToNextHostParent(fiber);
            isHydrating = true;
            return false;
          }
          if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
            var nextInstance = nextHydratableInstance;
            if (nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnIfUnhydratedTailNodes(fiber);
                throwOnHydrationMismatch();
              } else {
                while (nextInstance) {
                  deleteHydratableInstance(fiber, nextInstance);
                  nextInstance = getNextHydratableSibling(nextInstance);
                }
              }
            }
          }
          popToNextHostParent(fiber);
          if (fiber.tag === SuspenseComponent) {
            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
          } else {
            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
          }
          return true;
        }
        function hasUnhydratedTailNodes() {
          return isHydrating && nextHydratableInstance !== null;
        }
        function warnIfUnhydratedTailNodes(fiber) {
          var nextInstance = nextHydratableInstance;
          while (nextInstance) {
            warnUnhydratedInstance(fiber, nextInstance);
            nextInstance = getNextHydratableSibling(nextInstance);
          }
        }
        function resetHydrationState() {
          hydrationParentFiber = null;
          nextHydratableInstance = null;
          isHydrating = false;
          didSuspendOrErrorDEV = false;
        }
        function upgradeHydrationErrorsToRecoverable() {
          if (hydrationErrors !== null) {
            queueRecoverableErrors(hydrationErrors);
            hydrationErrors = null;
          }
        }
        function getIsHydrating() {
          return isHydrating;
        }
        function queueHydrationError(error2) {
          if (hydrationErrors === null) {
            hydrationErrors = [error2];
          } else {
            hydrationErrors.push(error2);
          }
        }
        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
        var NoTransition = null;
        function requestCurrentTransition() {
          return ReactCurrentBatchConfig$1.transition;
        }
        var ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function(fiber, instance) {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function(fiber, instance) {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        };
        {
          var findStrictRoot = function(fiber) {
            var maybeStrictRoot = null;
            var node = fiber;
            while (node !== null) {
              if (node.mode & StrictLegacyMode) {
                maybeStrictRoot = node;
              }
              node = node.return;
            }
            return maybeStrictRoot;
          };
          var setToSortedString = function(set5) {
            var array2 = [];
            set5.forEach(function(value) {
              array2.push(value);
            });
            return array2.sort().join(", ");
          };
          var pendingComponentWillMountWarnings = [];
          var pendingUNSAFE_ComponentWillMountWarnings = [];
          var pendingComponentWillReceivePropsWarnings = [];
          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          var pendingComponentWillUpdateWarnings = [];
          var pendingUNSAFE_ComponentWillUpdateWarnings = [];
          var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
              return;
            }
            if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
            instance.componentWillMount.__suppressDeprecationWarning !== true) {
              pendingComponentWillMountWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              pendingComponentWillReceivePropsWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              pendingComponentWillUpdateWarnings.push(fiber);
            }
            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillMountWarnings.length > 0) {
              pendingComponentWillMountWarnings.forEach(function(fiber) {
                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillMountWarnings = [];
            }
            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillMountWarnings = [];
            }
            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillReceivePropsWarnings.length > 0) {
              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillReceivePropsWarnings = [];
            }
            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            }
            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingComponentWillUpdateWarnings.length > 0) {
              pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingComponentWillUpdateWarnings = [];
            }
            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutUnsafeLifecycles.add(fiber.type);
              });
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
            }
            if (UNSAFE_componentWillMountUniqueNames.size > 0) {
              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
              error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
            }
            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
              error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
            }
            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
              error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
            }
            if (componentWillMountUniqueNames.size > 0) {
              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
              warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
            }
            if (componentWillReceivePropsUniqueNames.size > 0) {
              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
              warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
            }
            if (componentWillUpdateUniqueNames.size > 0) {
              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
              warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
            }
          };
          var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
            var strictRoot = findStrictRoot(fiber);
            if (strictRoot === null) {
              error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
              return;
            }
            if (didWarnAboutLegacyContext.has(fiber.type)) {
              return;
            }
            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
              if (warningsForRoot === void 0) {
                warningsForRoot = [];
                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
              }
              warningsForRoot.push(fiber);
            }
          };
          ReactStrictModeWarnings.flushLegacyContextWarning = function() {
            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
              if (fiberArray.length === 0) {
                return;
              }
              var firstFiber = fiberArray[0];
              var uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              try {
                setCurrentFiber(firstFiber);
                error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
              } finally {
                resetCurrentFiber();
              }
            });
          };
          ReactStrictModeWarnings.discardPendingWarnings = function() {
            pendingComponentWillMountWarnings = [];
            pendingUNSAFE_ComponentWillMountWarnings = [];
            pendingComponentWillReceivePropsWarnings = [];
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            pendingComponentWillUpdateWarnings = [];
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
            pendingLegacyContextWarning = /* @__PURE__ */ new Map();
          };
        }
        var didWarnAboutMaps;
        var didWarnAboutGenerators;
        var didWarnAboutStringRefs;
        var ownerHasKeyUseWarning;
        var ownerHasFunctionTypeWarning;
        var warnForMissingKey = function(child, returnFiber) {
        };
        {
          didWarnAboutMaps = false;
          didWarnAboutGenerators = false;
          didWarnAboutStringRefs = {};
          ownerHasKeyUseWarning = {};
          ownerHasFunctionTypeWarning = {};
          warnForMissingKey = function(child, returnFiber) {
            if (child === null || typeof child !== "object") {
              return;
            }
            if (!child._store || child._store.validated || child.key != null) {
              return;
            }
            if (typeof child._store !== "object") {
              throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
            }
            child._store.validated = true;
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasKeyUseWarning[componentName]) {
              return;
            }
            ownerHasKeyUseWarning[componentName] = true;
            error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
          };
        }
        function isReactClass(type5) {
          return type5.prototype && type5.prototype.isReactComponent;
        }
        function coerceRef(returnFiber, current3, element) {
          var mixedRef = element.ref;
          if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
            {
              if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
              // because these cannot be automatically converted to an arrow function
              // using a codemod. Therefore, we don't have to warn about string refs again.
              !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
              !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
              !(typeof element.type === "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
              element._owner) {
                var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                if (!didWarnAboutStringRefs[componentName]) {
                  {
                    error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);
                  }
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
            if (element._owner) {
              var owner = element._owner;
              var inst;
              if (owner) {
                var ownerFiber = owner;
                if (ownerFiber.tag !== ClassComponent) {
                  throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                }
                inst = ownerFiber.stateNode;
              }
              if (!inst) {
                throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
              }
              var resolvedInst = inst;
              {
                checkPropStringCoercion(mixedRef, "ref");
              }
              var stringRef = "" + mixedRef;
              if (current3 !== null && current3.ref !== null && typeof current3.ref === "function" && current3.ref._stringRef === stringRef) {
                return current3.ref;
              }
              var ref = function(value) {
                var refs = resolvedInst.refs;
                if (value === null) {
                  delete refs[stringRef];
                } else {
                  refs[stringRef] = value;
                }
              };
              ref._stringRef = stringRef;
              return ref;
            } else {
              if (typeof mixedRef !== "string") {
                throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
              }
              if (!element._owner) {
                throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
              }
            }
          }
          return mixedRef;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          var childString = Object.prototype.toString.call(newChild);
          throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
        }
        function warnOnFunctionType(returnFiber) {
          {
            var componentName = getComponentNameFromFiber(returnFiber) || "Component";
            if (ownerHasFunctionTypeWarning[componentName]) {
              return;
            }
            ownerHasFunctionTypeWarning[componentName] = true;
            error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
          }
        }
        function resolveLazy(lazyType) {
          var payload = lazyType._payload;
          var init2 = lazyType._init;
          return init2(payload);
        }
        function ChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (!shouldTrackSideEffects) {
              return;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) {
              return null;
            }
            var childToDelete = currentFirstChild;
            while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
            }
            return null;
          }
          function mapRemainingChildren(returnFiber, currentFirstChild) {
            var existingChildren = /* @__PURE__ */ new Map();
            var existingChild = currentFirstChild;
            while (existingChild !== null) {
              if (existingChild.key !== null) {
                existingChildren.set(existingChild.key, existingChild);
              } else {
                existingChildren.set(existingChild.index, existingChild);
              }
              existingChild = existingChild.sibling;
            }
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            var clone4 = createWorkInProgress(fiber, pendingProps);
            clone4.index = 0;
            clone4.sibling = null;
            return clone4;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects) {
              newFiber.flags |= Forked;
              return lastPlacedIndex;
            }
            var current3 = newFiber.alternate;
            if (current3 !== null) {
              var oldIndex = current3.index;
              if (oldIndex < lastPlacedIndex) {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              } else {
                return oldIndex;
              }
            } else {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            }
          }
          function placeSingleChild(newFiber) {
            if (shouldTrackSideEffects && newFiber.alternate === null) {
              newFiber.flags |= Placement;
            }
            return newFiber;
          }
          function updateTextNode(returnFiber, current3, textContent, lanes) {
            if (current3 === null || current3.tag !== HostText) {
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current3, textContent);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateElement(returnFiber, current3, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE2) {
              return updateFragment2(returnFiber, current3, element.props.children, lanes, element.key);
            }
            if (current3 !== null) {
              if (current3.elementType === elementType || // Keep this check inline so it only runs on the false path:
              isCompatibleFamilyForHotReloading(current3, element) || // Lazy types should reconcile their resolved type.
              // We need to do this after the Hot Reloading check above,
              // because hot reloading has different semantics than prod because
              // it doesn't resuspend. So we can't let the call below suspend.
              typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE2 && resolveLazy(elementType) === current3.type) {
                var existing = useFiber(current3, element.props);
                existing.ref = coerceRef(returnFiber, current3, element);
                existing.return = returnFiber;
                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }
                return existing;
              }
            }
            var created = createFiberFromElement(element, returnFiber.mode, lanes);
            created.ref = coerceRef(returnFiber, current3, element);
            created.return = returnFiber;
            return created;
          }
          function updatePortal(returnFiber, current3, portal, lanes) {
            if (current3 === null || current3.tag !== HostPortal || current3.stateNode.containerInfo !== portal.containerInfo || current3.stateNode.implementation !== portal.implementation) {
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current3, portal.children || []);
              existing.return = returnFiber;
              return existing;
            }
          }
          function updateFragment2(returnFiber, current3, fragment2, lanes, key57) {
            if (current3 === null || current3.tag !== Fragment) {
              var created = createFiberFromFragment(fragment2, returnFiber.mode, lanes, key57);
              created.return = returnFiber;
              return created;
            } else {
              var existing = useFiber(current3, fragment2);
              existing.return = returnFiber;
              return existing;
            }
          }
          function createChild(returnFiber, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE2: {
                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                  _created.ref = coerceRef(returnFiber, null, newChild);
                  _created.return = returnFiber;
                  return _created;
                }
                case REACT_PORTAL_TYPE2: {
                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  _created2.return = returnFiber;
                  return _created2;
                }
                case REACT_LAZY_TYPE2: {
                  var payload = newChild._payload;
                  var init2 = newChild._init;
                  return createChild(returnFiber, init2(payload), lanes);
                }
              }
              if (isArray4(newChild) || getIteratorFn(newChild)) {
                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                _created3.return = returnFiber;
                return _created3;
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key57 = oldFiber !== null ? oldFiber.key : null;
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              if (key57 !== null) {
                return null;
              }
              return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE2: {
                  if (newChild.key === key57) {
                    return updateElement(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_PORTAL_TYPE2: {
                  if (newChild.key === key57) {
                    return updatePortal(returnFiber, oldFiber, newChild, lanes);
                  } else {
                    return null;
                  }
                }
                case REACT_LAZY_TYPE2: {
                  var payload = newChild._payload;
                  var init2 = newChild._init;
                  return updateSlot(returnFiber, oldFiber, init2(payload), lanes);
                }
              }
              if (isArray4(newChild) || getIteratorFn(newChild)) {
                if (key57 !== null) {
                  return null;
                }
                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              var matchedFiber = existingChildren.get(newIdx) || null;
              return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE2: {
                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                }
                case REACT_PORTAL_TYPE2: {
                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                }
                case REACT_LAZY_TYPE2:
                  var payload = newChild._payload;
                  var init2 = newChild._init;
                  return updateFromMap(existingChildren, returnFiber, newIdx, init2(payload), lanes);
              }
              if (isArray4(newChild) || getIteratorFn(newChild)) {
                var _matchedFiber3 = existingChildren.get(newIdx) || null;
                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return null;
          }
          function warnOnInvalidKey(child, knownKeys, returnFiber) {
            {
              if (typeof child !== "object" || child === null) {
                return knownKeys;
              }
              switch (child.$$typeof) {
                case REACT_ELEMENT_TYPE2:
                case REACT_PORTAL_TYPE2:
                  warnForMissingKey(child, returnFiber);
                  var key57 = child.key;
                  if (typeof key57 !== "string") {
                    break;
                  }
                  if (knownKeys === null) {
                    knownKeys = /* @__PURE__ */ new Set();
                    knownKeys.add(key57);
                    break;
                  }
                  if (!knownKeys.has(key57)) {
                    knownKeys.add(key57);
                    break;
                  }
                  error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.", key57);
                  break;
                case REACT_LAZY_TYPE2:
                  var payload = child._payload;
                  var init2 = child._init;
                  warnOnInvalidKey(init2(payload), knownKeys, returnFiber);
                  break;
              }
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            {
              var knownKeys = null;
              for (var i2 = 0; i2 < newChildren.length; i2++) {
                var child = newChildren[i2];
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                if (_newFiber === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber;
                } else {
                  previousNewFiber.sibling = _newFiber;
                }
                previousNewFiber = _newFiber;
              }
              if (getIsHydrating()) {
                var _numberOfForks = newIdx;
                pushTreeFork(returnFiber, _numberOfForks);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; newIdx < newChildren.length; newIdx++) {
              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
              if (_newFiber2 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber2.alternate !== null) {
                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber2;
                } else {
                  previousNewFiber.sibling = _newFiber2;
                }
                previousNewFiber = _newFiber2;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks2 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks2);
            }
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
            var iteratorFn2 = getIteratorFn(newChildrenIterable);
            if (typeof iteratorFn2 !== "function") {
              throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
              newChildrenIterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (newChildrenIterable.entries === iteratorFn2) {
                if (!didWarnAboutMaps) {
                  error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
              var _newChildren = iteratorFn2.call(newChildrenIterable);
              if (_newChildren) {
                var knownKeys = null;
                var _step = _newChildren.next();
                for (; !_step.done; _step = _newChildren.next()) {
                  var child = _step.value;
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
            }
            var newChildren = iteratorFn2.call(newChildrenIterable);
            if (newChildren == null) {
              throw new Error("An iterable object provided no iterator.");
            }
            var resultingFirstChild = null;
            var previousNewFiber = null;
            var oldFiber = currentFirstChild;
            var lastPlacedIndex = 0;
            var newIdx = 0;
            var nextOldFiber = null;
            var step = newChildren.next();
            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
              if (oldFiber.index > newIdx) {
                nextOldFiber = oldFiber;
                oldFiber = null;
              } else {
                nextOldFiber = oldFiber.sibling;
              }
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (newFiber === null) {
                if (oldFiber === null) {
                  oldFiber = nextOldFiber;
                }
                break;
              }
              if (shouldTrackSideEffects) {
                if (oldFiber && newFiber.alternate === null) {
                  deleteChild(returnFiber, oldFiber);
                }
              }
              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = newFiber;
              } else {
                previousNewFiber.sibling = newFiber;
              }
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done) {
              deleteRemainingChildren(returnFiber, oldFiber);
              if (getIsHydrating()) {
                var numberOfForks = newIdx;
                pushTreeFork(returnFiber, numberOfForks);
              }
              return resultingFirstChild;
            }
            if (oldFiber === null) {
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber3 = createChild(returnFiber, step.value, lanes);
                if (_newFiber3 === null) {
                  continue;
                }
                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber3;
                } else {
                  previousNewFiber.sibling = _newFiber3;
                }
                previousNewFiber = _newFiber3;
              }
              if (getIsHydrating()) {
                var _numberOfForks3 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks3);
              }
              return resultingFirstChild;
            }
            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
            for (; !step.done; newIdx++, step = newChildren.next()) {
              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
              if (_newFiber4 !== null) {
                if (shouldTrackSideEffects) {
                  if (_newFiber4.alternate !== null) {
                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                  }
                }
                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = _newFiber4;
                } else {
                  previousNewFiber.sibling = _newFiber4;
                }
                previousNewFiber = _newFiber4;
              }
            }
            if (shouldTrackSideEffects) {
              existingChildren.forEach(function(child2) {
                return deleteChild(returnFiber, child2);
              });
            }
            if (getIsHydrating()) {
              var _numberOfForks4 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks4);
            }
            return resultingFirstChild;
          }
          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
              var existing = useFiber(currentFirstChild, textContent);
              existing.return = returnFiber;
              return existing;
            }
            deleteRemainingChildren(returnFiber, currentFirstChild);
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
            var key57 = element.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key57) {
                var elementType = element.type;
                if (elementType === REACT_FRAGMENT_TYPE2) {
                  if (child.tag === Fragment) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, element.props.children);
                    existing.return = returnFiber;
                    {
                      existing._debugSource = element._source;
                      existing._debugOwner = element._owner;
                    }
                    return existing;
                  }
                } else {
                  if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                  isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                  // We need to do this after the Hot Reloading check above,
                  // because hot reloading has different semantics than prod because
                  // it doesn't resuspend. So we can't let the call below suspend.
                  typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE2 && resolveLazy(elementType) === child.type) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var _existing = useFiber(child, element.props);
                    _existing.ref = coerceRef(returnFiber, child, element);
                    _existing.return = returnFiber;
                    {
                      _existing._debugSource = element._source;
                      _existing._debugOwner = element._owner;
                    }
                    return _existing;
                  }
                }
                deleteRemainingChildren(returnFiber, child);
                break;
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            if (element.type === REACT_FRAGMENT_TYPE2) {
              var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
              created.return = returnFiber;
              return created;
            } else {
              var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
              _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
              _created4.return = returnFiber;
              return _created4;
            }
          }
          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
            var key57 = portal.key;
            var child = currentFirstChild;
            while (child !== null) {
              if (child.key === key57) {
                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, portal.children || []);
                  existing.return = returnFiber;
                  return existing;
                } else {
                  deleteRemainingChildren(returnFiber, child);
                  break;
                }
              } else {
                deleteChild(returnFiber, child);
              }
              child = child.sibling;
            }
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
            var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE2 && newChild.key === null;
            if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children;
            }
            if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE2:
                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_PORTAL_TYPE2:
                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                case REACT_LAZY_TYPE2:
                  var payload = newChild._payload;
                  var init2 = newChild._init;
                  return reconcileChildFibers2(returnFiber, currentFirstChild, init2(payload), lanes);
              }
              if (isArray4(newChild)) {
                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
              }
              if (getIteratorFn(newChild)) {
                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
              }
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
            }
            {
              if (typeof newChild === "function") {
                warnOnFunctionType(returnFiber);
              }
            }
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return reconcileChildFibers2;
        }
        var reconcileChildFibers = ChildReconciler(true);
        var mountChildFibers = ChildReconciler(false);
        function cloneChildFibers(current3, workInProgress2) {
          if (current3 !== null && workInProgress2.child !== current3.child) {
            throw new Error("Resuming work not yet implemented.");
          }
          if (workInProgress2.child === null) {
            return;
          }
          var currentChild = workInProgress2.child;
          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
          workInProgress2.child = newChild;
          newChild.return = workInProgress2;
          while (currentChild.sibling !== null) {
            currentChild = currentChild.sibling;
            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
            newChild.return = workInProgress2;
          }
          newChild.sibling = null;
        }
        function resetChildFibers(workInProgress2, lanes) {
          var child = workInProgress2.child;
          while (child !== null) {
            resetWorkInProgress(child, lanes);
            child = child.sibling;
          }
        }
        var valueCursor = createCursor(null);
        var rendererSigil;
        {
          rendererSigil = {};
        }
        var currentlyRenderingFiber = null;
        var lastContextDependency = null;
        var lastFullyObservedContext = null;
        var isDisallowedContextReadInDEV = false;
        function resetContextDependencies() {
          currentlyRenderingFiber = null;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function enterDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = true;
          }
        }
        function exitDisallowedContextReadInDEV() {
          {
            isDisallowedContextReadInDEV = false;
          }
        }
        function pushProvider(providerFiber, context2, nextValue) {
          {
            push(valueCursor, context2._currentValue, providerFiber);
            context2._currentValue = nextValue;
            {
              if (context2._currentRenderer !== void 0 && context2._currentRenderer !== null && context2._currentRenderer !== rendererSigil) {
                error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              }
              context2._currentRenderer = rendererSigil;
            }
          }
        }
        function popProvider(context2, providerFiber) {
          var currentValue = valueCursor.current;
          pop(valueCursor, providerFiber);
          {
            {
              context2._currentValue = currentValue;
            }
          }
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          var node = parent;
          while (node !== null) {
            var alternate = node.alternate;
            if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
              node.childLanes = mergeLanes(node.childLanes, renderLanes2);
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
            if (node === propagationRoot) {
              break;
            }
            node = node.return;
          }
          {
            if (node !== propagationRoot) {
              error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
        }
        function propagateContextChange(workInProgress2, context2, renderLanes2) {
          {
            propagateContextChange_eager(workInProgress2, context2, renderLanes2);
          }
        }
        function propagateContextChange_eager(workInProgress2, context2, renderLanes2) {
          var fiber = workInProgress2.child;
          if (fiber !== null) {
            fiber.return = workInProgress2;
          }
          while (fiber !== null) {
            var nextFiber = void 0;
            var list4 = fiber.dependencies;
            if (list4 !== null) {
              nextFiber = fiber.child;
              var dependency = list4.firstContext;
              while (dependency !== null) {
                if (dependency.context === context2) {
                  if (fiber.tag === ClassComponent) {
                    var lane = pickArbitraryLane(renderLanes2);
                    var update4 = createUpdate(NoTimestamp, lane);
                    update4.tag = ForceUpdate;
                    var updateQueue = fiber.updateQueue;
                    if (updateQueue === null) ;
                    else {
                      var sharedQueue = updateQueue.shared;
                      var pending = sharedQueue.pending;
                      if (pending === null) {
                        update4.next = update4;
                      } else {
                        update4.next = pending.next;
                        pending.next = update4;
                      }
                      sharedQueue.pending = update4;
                    }
                  }
                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                  var alternate = fiber.alternate;
                  if (alternate !== null) {
                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                  }
                  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                  list4.lanes = mergeLanes(list4.lanes, renderLanes2);
                  break;
                }
                dependency = dependency.next;
              }
            } else if (fiber.tag === ContextProvider) {
              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
            } else if (fiber.tag === DehydratedFragment) {
              var parentSuspense = fiber.return;
              if (parentSuspense === null) {
                throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
              }
              parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
              var _alternate = parentSuspense.alternate;
              if (_alternate !== null) {
                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
              }
              scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
              nextFiber = fiber.sibling;
            } else {
              nextFiber = fiber.child;
            }
            if (nextFiber !== null) {
              nextFiber.return = fiber;
            } else {
              nextFiber = fiber;
              while (nextFiber !== null) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                var sibling = nextFiber.sibling;
                if (sibling !== null) {
                  sibling.return = nextFiber.return;
                  nextFiber = sibling;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            }
            fiber = nextFiber;
          }
        }
        function prepareToReadContext(workInProgress2, renderLanes2) {
          currentlyRenderingFiber = workInProgress2;
          lastContextDependency = null;
          lastFullyObservedContext = null;
          var dependencies = workInProgress2.dependencies;
          if (dependencies !== null) {
            {
              var firstContext = dependencies.firstContext;
              if (firstContext !== null) {
                if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                  markWorkInProgressReceivedUpdate();
                }
                dependencies.firstContext = null;
              }
            }
          }
        }
        function readContext(context2) {
          {
            if (isDisallowedContextReadInDEV) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          var value = context2._currentValue;
          if (lastFullyObservedContext === context2) ;
          else {
            var contextItem = {
              context: context2,
              memoizedValue: value,
              next: null
            };
            if (lastContextDependency === null) {
              if (currentlyRenderingFiber === null) {
                throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
              lastContextDependency = contextItem;
              currentlyRenderingFiber.dependencies = {
                lanes: NoLanes,
                firstContext: contextItem
              };
            } else {
              lastContextDependency = lastContextDependency.next = contextItem;
            }
          }
          return value;
        }
        var concurrentQueues = null;
        function pushConcurrentUpdateQueue(queue) {
          if (concurrentQueues === null) {
            concurrentQueues = [queue];
          } else {
            concurrentQueues.push(queue);
          }
        }
        function finishQueueingConcurrentUpdates() {
          if (concurrentQueues !== null) {
            for (var i2 = 0; i2 < concurrentQueues.length; i2++) {
              var queue = concurrentQueues[i2];
              var lastInterleavedUpdate = queue.interleaved;
              if (lastInterleavedUpdate !== null) {
                queue.interleaved = null;
                var firstInterleavedUpdate = lastInterleavedUpdate.next;
                var lastPendingUpdate = queue.pending;
                if (lastPendingUpdate !== null) {
                  var firstPendingUpdate = lastPendingUpdate.next;
                  lastPendingUpdate.next = firstInterleavedUpdate;
                  lastInterleavedUpdate.next = firstPendingUpdate;
                }
                queue.pending = lastInterleavedUpdate;
              }
            }
            concurrentQueues = null;
          }
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update4, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update4.next = update4;
            pushConcurrentUpdateQueue(queue);
          } else {
            update4.next = interleaved.next;
            interleaved.next = update4;
          }
          queue.interleaved = update4;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update4, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update4.next = update4;
            pushConcurrentUpdateQueue(queue);
          } else {
            update4.next = interleaved.next;
            interleaved.next = update4;
          }
          queue.interleaved = update4;
        }
        function enqueueConcurrentClassUpdate(fiber, queue, update4, lane) {
          var interleaved = queue.interleaved;
          if (interleaved === null) {
            update4.next = update4;
            pushConcurrentUpdateQueue(queue);
          } else {
            update4.next = interleaved.next;
            interleaved.next = update4;
          }
          queue.interleaved = update4;
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          return markUpdateLaneFromFiberToRoot(fiber, lane);
        }
        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
          var alternate = sourceFiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, lane);
          }
          {
            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
            }
          }
          var node = sourceFiber;
          var parent = sourceFiber.return;
          while (parent !== null) {
            parent.childLanes = mergeLanes(parent.childLanes, lane);
            alternate = parent.alternate;
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, lane);
            } else {
              {
                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                }
              }
            }
            node = parent;
            parent = parent.return;
          }
          if (node.tag === HostRoot) {
            var root2 = node.stateNode;
            return root2;
          } else {
            return null;
          }
        }
        var UpdateState = 0;
        var ReplaceState = 1;
        var ForceUpdate = 2;
        var CaptureUpdate = 3;
        var hasForceUpdate = false;
        var didWarnUpdateInsideUpdate;
        var currentlyProcessingQueue;
        {
          didWarnUpdateInsideUpdate = false;
          currentlyProcessingQueue = null;
        }
        function initializeUpdateQueue(fiber) {
          var queue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
              pending: null,
              interleaved: null,
              lanes: NoLanes
            },
            effects: null
          };
          fiber.updateQueue = queue;
        }
        function cloneUpdateQueue(current3, workInProgress2) {
          var queue = workInProgress2.updateQueue;
          var currentQueue = current3.updateQueue;
          if (queue === currentQueue) {
            var clone4 = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: currentQueue.firstBaseUpdate,
              lastBaseUpdate: currentQueue.lastBaseUpdate,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = clone4;
          }
        }
        function createUpdate(eventTime, lane) {
          var update4 = {
            eventTime,
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
          return update4;
        }
        function enqueueUpdate(fiber, update4, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return null;
          }
          var sharedQueue = updateQueue.shared;
          {
            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
              error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
              didWarnUpdateInsideUpdate = true;
            }
          }
          if (isUnsafeClassRenderPhaseUpdate()) {
            var pending = sharedQueue.pending;
            if (pending === null) {
              update4.next = update4;
            } else {
              update4.next = pending.next;
              pending.next = update4;
            }
            sharedQueue.pending = update4;
            return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
          } else {
            return enqueueConcurrentClassUpdate(fiber, sharedQueue, update4, lane);
          }
        }
        function entangleTransitions(root2, fiber, lane) {
          var updateQueue = fiber.updateQueue;
          if (updateQueue === null) {
            return;
          }
          var sharedQueue = updateQueue.shared;
          if (isTransitionLane(lane)) {
            var queueLanes = sharedQueue.lanes;
            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            sharedQueue.lanes = newQueueLanes;
            markRootEntangled(root2, newQueueLanes);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue;
          var current3 = workInProgress2.alternate;
          if (current3 !== null) {
            var currentQueue = current3.updateQueue;
            if (queue === currentQueue) {
              var newFirst = null;
              var newLast = null;
              var firstBaseUpdate = queue.firstBaseUpdate;
              if (firstBaseUpdate !== null) {
                var update4 = firstBaseUpdate;
                do {
                  var clone4 = {
                    eventTime: update4.eventTime,
                    lane: update4.lane,
                    tag: update4.tag,
                    payload: update4.payload,
                    callback: update4.callback,
                    next: null
                  };
                  if (newLast === null) {
                    newFirst = newLast = clone4;
                  } else {
                    newLast.next = clone4;
                    newLast = clone4;
                  }
                  update4 = update4.next;
                } while (update4 !== null);
                if (newLast === null) {
                  newFirst = newLast = capturedUpdate;
                } else {
                  newLast.next = capturedUpdate;
                  newLast = capturedUpdate;
                }
              } else {
                newFirst = newLast = capturedUpdate;
              }
              queue = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: newFirst,
                lastBaseUpdate: newLast,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = queue;
              return;
            }
          }
          var lastBaseUpdate = queue.lastBaseUpdate;
          if (lastBaseUpdate === null) {
            queue.firstBaseUpdate = capturedUpdate;
          } else {
            lastBaseUpdate.next = capturedUpdate;
          }
          queue.lastBaseUpdate = capturedUpdate;
        }
        function getStateFromUpdate(workInProgress2, queue, update4, prevState, nextProps, instance) {
          switch (update4.tag) {
            case ReplaceState: {
              var payload = update4.payload;
              if (typeof payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                var nextState = payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
                return nextState;
              }
              return payload;
            }
            case CaptureUpdate: {
              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
            }
            case UpdateState: {
              var _payload = update4.payload;
              var partialState;
              if (typeof _payload === "function") {
                {
                  enterDisallowedContextReadInDEV();
                }
                partialState = _payload.call(instance, prevState, nextProps);
                {
                  if (workInProgress2.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(true);
                    try {
                      _payload.call(instance, prevState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(false);
                    }
                  }
                  exitDisallowedContextReadInDEV();
                }
              } else {
                partialState = _payload;
              }
              if (partialState === null || partialState === void 0) {
                return prevState;
              }
              return assign2({}, prevState, partialState);
            }
            case ForceUpdate: {
              hasForceUpdate = true;
              return prevState;
            }
          }
          return prevState;
        }
        function processUpdateQueue(workInProgress2, props3, instance, renderLanes2) {
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          {
            currentlyProcessingQueue = queue.shared;
          }
          var firstBaseUpdate = queue.firstBaseUpdate;
          var lastBaseUpdate = queue.lastBaseUpdate;
          var pendingQueue = queue.shared.pending;
          if (pendingQueue !== null) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue;
            var firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            if (lastBaseUpdate === null) {
              firstBaseUpdate = firstPendingUpdate;
            } else {
              lastBaseUpdate.next = firstPendingUpdate;
            }
            lastBaseUpdate = lastPendingUpdate;
            var current3 = workInProgress2.alternate;
            if (current3 !== null) {
              var currentQueue = current3.updateQueue;
              var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
              if (currentLastBaseUpdate !== lastBaseUpdate) {
                if (currentLastBaseUpdate === null) {
                  currentQueue.firstBaseUpdate = firstPendingUpdate;
                } else {
                  currentLastBaseUpdate.next = firstPendingUpdate;
                }
                currentQueue.lastBaseUpdate = lastPendingUpdate;
              }
            }
          }
          if (firstBaseUpdate !== null) {
            var newState = queue.baseState;
            var newLanes = NoLanes;
            var newBaseState = null;
            var newFirstBaseUpdate = null;
            var newLastBaseUpdate = null;
            var update4 = firstBaseUpdate;
            do {
              var updateLane = update4.lane;
              var updateEventTime = update4.eventTime;
              if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                var clone4 = {
                  eventTime: updateEventTime,
                  lane: updateLane,
                  tag: update4.tag,
                  payload: update4.payload,
                  callback: update4.callback,
                  next: null
                };
                if (newLastBaseUpdate === null) {
                  newFirstBaseUpdate = newLastBaseUpdate = clone4;
                  newBaseState = newState;
                } else {
                  newLastBaseUpdate = newLastBaseUpdate.next = clone4;
                }
                newLanes = mergeLanes(newLanes, updateLane);
              } else {
                if (newLastBaseUpdate !== null) {
                  var _clone2 = {
                    eventTime: updateEventTime,
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    tag: update4.tag,
                    payload: update4.payload,
                    callback: update4.callback,
                    next: null
                  };
                  newLastBaseUpdate = newLastBaseUpdate.next = _clone2;
                }
                newState = getStateFromUpdate(workInProgress2, queue, update4, newState, props3, instance);
                var callback = update4.callback;
                if (callback !== null && // If the update was already committed, we should not queue its
                // callback again.
                update4.lane !== NoLane) {
                  workInProgress2.flags |= Callback3;
                  var effects = queue.effects;
                  if (effects === null) {
                    queue.effects = [update4];
                  } else {
                    effects.push(update4);
                  }
                }
              }
              update4 = update4.next;
              if (update4 === null) {
                pendingQueue = queue.shared.pending;
                if (pendingQueue === null) {
                  break;
                } else {
                  var _lastPendingUpdate = pendingQueue;
                  var _firstPendingUpdate = _lastPendingUpdate.next;
                  _lastPendingUpdate.next = null;
                  update4 = _firstPendingUpdate;
                  queue.lastBaseUpdate = _lastPendingUpdate;
                  queue.shared.pending = null;
                }
              }
            } while (true);
            if (newLastBaseUpdate === null) {
              newBaseState = newState;
            }
            queue.baseState = newBaseState;
            queue.firstBaseUpdate = newFirstBaseUpdate;
            queue.lastBaseUpdate = newLastBaseUpdate;
            var lastInterleaved = queue.shared.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                newLanes = mergeLanes(newLanes, interleaved.lane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (firstBaseUpdate === null) {
              queue.shared.lanes = NoLanes;
            }
            markSkippedUpdateLanes(newLanes);
            workInProgress2.lanes = newLanes;
            workInProgress2.memoizedState = newState;
          }
          {
            currentlyProcessingQueue = null;
          }
        }
        function callCallback(callback, context2) {
          if (typeof callback !== "function") {
            throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
          }
          callback.call(context2);
        }
        function resetHasForceUpdateBeforeProcessing() {
          hasForceUpdate = false;
        }
        function checkHasForceUpdateAfterProcessing() {
          return hasForceUpdate;
        }
        function commitUpdateQueue(finishedWork, finishedQueue, instance) {
          var effects = finishedQueue.effects;
          finishedQueue.effects = null;
          if (effects !== null) {
            for (var i2 = 0; i2 < effects.length; i2++) {
              var effect = effects[i2];
              var callback = effect.callback;
              if (callback !== null) {
                effect.callback = null;
                callCallback(callback, instance);
              }
            }
          }
        }
        var NO_CONTEXT = {};
        var contextStackCursor$1 = createCursor(NO_CONTEXT);
        var contextFiberStackCursor = createCursor(NO_CONTEXT);
        var rootInstanceStackCursor = createCursor(NO_CONTEXT);
        function requiredContext(c2) {
          if (c2 === NO_CONTEXT) {
            throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
          }
          return c2;
        }
        function getRootHostContainer() {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          return rootInstance;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, NO_CONTEXT, fiber);
          var nextRootContext = getRootHostContext(nextRootInstance);
          pop(contextStackCursor$1, fiber);
          push(contextStackCursor$1, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          var context2 = requiredContext(contextStackCursor$1.current);
          return context2;
        }
        function pushHostContext(fiber) {
          var rootInstance = requiredContext(rootInstanceStackCursor.current);
          var context2 = requiredContext(contextStackCursor$1.current);
          var nextContext = getChildHostContext(context2, fiber.type);
          if (context2 === nextContext) {
            return;
          }
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor$1, nextContext, fiber);
        }
        function popHostContext(fiber) {
          if (contextFiberStackCursor.current !== fiber) {
            return;
          }
          pop(contextStackCursor$1, fiber);
          pop(contextFiberStackCursor, fiber);
        }
        var DefaultSuspenseContext = 0;
        var SubtreeSuspenseContextMask = 1;
        var InvisibleParentSuspenseContext = 1;
        var ForceSuspenseFallback = 2;
        var suspenseStackCursor = createCursor(DefaultSuspenseContext);
        function hasSuspenseContext(parentContext, flag) {
          return (parentContext & flag) !== 0;
        }
        function setDefaultShallowSuspenseContext(parentContext) {
          return parentContext & SubtreeSuspenseContextMask;
        }
        function setShallowSuspenseContext(parentContext, shallowContext) {
          return parentContext & SubtreeSuspenseContextMask | shallowContext;
        }
        function addSubtreeSuspenseContext(parentContext, subtreeContext) {
          return parentContext | subtreeContext;
        }
        function pushSuspenseContext(fiber, newContext) {
          push(suspenseStackCursor, newContext, fiber);
        }
        function popSuspenseContext(fiber) {
          pop(suspenseStackCursor, fiber);
        }
        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
          var nextState = workInProgress2.memoizedState;
          if (nextState !== null) {
            if (nextState.dehydrated !== null) {
              return true;
            }
            return false;
          }
          var props3 = workInProgress2.memoizedProps;
          {
            return true;
          }
        }
        function findFirstSuspended(row) {
          var node = row;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state2 = node.memoizedState;
              if (state2 !== null) {
                var dehydrated = state2.dehydrated;
                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                  return node;
                }
              }
            } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
            // keep track of whether it suspended or not.
            node.memoizedProps.revealOrder !== void 0) {
              var didSuspend = (node.flags & DidCapture) !== NoFlags;
              if (didSuspend) {
                return node;
              }
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === row) {
              return null;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === row) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return null;
        }
        var NoFlags$1 = (
          /*   */
          0
        );
        var HasEffect = (
          /* */
          1
        );
        var Insertion = (
          /*  */
          2
        );
        var Layout = (
          /*    */
          4
        );
        var Passive$1 = (
          /*   */
          8
        );
        var workInProgressSources = [];
        function resetWorkInProgressVersions() {
          for (var i2 = 0; i2 < workInProgressSources.length; i2++) {
            var mutableSource = workInProgressSources[i2];
            {
              mutableSource._workInProgressVersionPrimary = null;
            }
          }
          workInProgressSources.length = 0;
        }
        function registerMutableSourceForHydration(root2, mutableSource) {
          var getVersion = mutableSource._getVersion;
          var version2 = getVersion(mutableSource._source);
          if (root2.mutableSourceEagerHydrationData == null) {
            root2.mutableSourceEagerHydrationData = [mutableSource, version2];
          } else {
            root2.mutableSourceEagerHydrationData.push(mutableSource, version2);
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
        var didWarnAboutMismatchedHooksForComponent;
        var didWarnUncachedGetSnapshot;
        {
          didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        }
        var renderLanes = NoLanes;
        var currentlyRenderingFiber$1 = null;
        var currentHook = null;
        var workInProgressHook = null;
        var didScheduleRenderPhaseUpdate = false;
        var didScheduleRenderPhaseUpdateDuringThisPass = false;
        var localIdCounter = 0;
        var globalClientIdCounter = 0;
        var RE_RENDER_LIMIT = 25;
        var currentHookNameInDev = null;
        var hookTypesDev = null;
        var hookTypesUpdateIndexDev = -1;
        var ignorePreviousDependencies = false;
        function mountHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev === null) {
              hookTypesDev = [hookName];
            } else {
              hookTypesDev.push(hookName);
            }
          }
        }
        function updateHookTypesDev() {
          {
            var hookName = currentHookNameInDev;
            if (hookTypesDev !== null) {
              hookTypesUpdateIndexDev++;
              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                warnOnHookMismatchInDev(hookName);
              }
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          {
            if (deps !== void 0 && deps !== null && !isArray4(deps)) {
              error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
            }
          }
        }
        function warnOnHookMismatchInDev(currentHookName) {
          {
            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
              didWarnAboutMismatchedHooksForComponent.add(componentName);
              if (hookTypesDev !== null) {
                var table2 = "";
                var secondColumnStart = 30;
                for (var i2 = 0; i2 <= hookTypesUpdateIndexDev; i2++) {
                  var oldHookName = hookTypesDev[i2];
                  var newHookName = i2 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                  var row = i2 + 1 + ". " + oldHookName;
                  while (row.length < secondColumnStart) {
                    row += " ";
                  }
                  row += newHookName + "\n";
                  table2 += row;
                }
                error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table2);
              }
            }
          }
        }
        function throwInvalidHookError() {
          throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          {
            if (ignorePreviousDependencies) {
              return false;
            }
          }
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
            }
          }
          for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
            if (objectIs(nextDeps[i2], prevDeps[i2])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function renderWithHooks(current3, workInProgress2, Component2, props3, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber$1 = workInProgress2;
          {
            hookTypesDev = current3 !== null ? current3._debugHookTypes : null;
            hookTypesUpdateIndexDev = -1;
            ignorePreviousDependencies = current3 !== null && current3.type !== workInProgress2.type;
          }
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = NoLanes;
          {
            if (current3 !== null && current3.memoizedState !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
            } else if (hookTypesDev !== null) {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
            } else {
              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
            }
          }
          var children = Component2(props3, secondArg);
          if (didScheduleRenderPhaseUpdateDuringThisPass) {
            var numberOfReRenders = 0;
            do {
              didScheduleRenderPhaseUpdateDuringThisPass = false;
              localIdCounter = 0;
              if (numberOfReRenders >= RE_RENDER_LIMIT) {
                throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
              }
              numberOfReRenders += 1;
              {
                ignorePreviousDependencies = false;
              }
              currentHook = null;
              workInProgressHook = null;
              workInProgress2.updateQueue = null;
              {
                hookTypesUpdateIndexDev = -1;
              }
              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
              children = Component2(props3, secondArg);
            } while (didScheduleRenderPhaseUpdateDuringThisPass);
          }
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          {
            workInProgress2._debugHookTypes = hookTypesDev;
          }
          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            currentHookNameInDev = null;
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            if (current3 !== null && (current3.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
            // and creates false positives. To make this work in legacy mode, we'd
            // need to mark fibers that commit in an incomplete state, somehow. For
            // now I'll disable the warning that most of the bugs that would trigger
            // it are either exclusive to concurrent mode or exist in both.
            (current3.mode & ConcurrentMode) !== NoMode) {
              error("Internal React error: Expected static flag was missing. Please notify the React team.");
            }
          }
          didScheduleRenderPhaseUpdate = false;
          if (didRenderTooFewHooks) {
            throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
          }
          return children;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = localIdCounter !== 0;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current3, workInProgress2, lanes) {
          workInProgress2.updateQueue = current3.updateQueue;
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
          } else {
            workInProgress2.flags &= ~(Passive | Update);
          }
          current3.lanes = removeLanes(current3.lanes, lanes);
        }
        function resetHooksAfterThrow() {
          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
          if (didScheduleRenderPhaseUpdate) {
            var hook = currentlyRenderingFiber$1.memoizedState;
            while (hook !== null) {
              var queue = hook.queue;
              if (queue !== null) {
                queue.pending = null;
              }
              hook = hook.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = NoLanes;
          currentlyRenderingFiber$1 = null;
          currentHook = null;
          workInProgressHook = null;
          {
            hookTypesDev = null;
            hookTypesUpdateIndexDev = -1;
            currentHookNameInDev = null;
            isUpdatingOpaqueValueInRenderPhase = false;
          }
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          localIdCounter = 0;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
          } else {
            workInProgressHook = workInProgressHook.next = hook;
          }
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          var nextCurrentHook;
          if (currentHook === null) {
            var current3 = currentlyRenderingFiber$1.alternate;
            if (current3 !== null) {
              nextCurrentHook = current3.memoizedState;
            } else {
              nextCurrentHook = null;
            }
          } else {
            nextCurrentHook = currentHook.next;
          }
          var nextWorkInProgressHook;
          if (workInProgressHook === null) {
            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
          } else {
            nextWorkInProgressHook = workInProgressHook.next;
          }
          if (nextWorkInProgressHook !== null) {
            workInProgressHook = nextWorkInProgressHook;
            nextWorkInProgressHook = workInProgressHook.next;
            currentHook = nextCurrentHook;
          } else {
            if (nextCurrentHook === null) {
              throw new Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            var newHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
            } else {
              workInProgressHook = workInProgressHook.next = newHook;
            }
          }
          return workInProgressHook;
        }
        function createFunctionComponentUpdateQueue() {
          return {
            lastEffect: null,
            stores: null
          };
        }
        function basicStateReducer(state2, action) {
          return typeof action === "function" ? action(state2) : action;
        }
        function mountReducer(reducer, initialArg, init2) {
          var hook = mountWorkInProgressHook();
          var initialState;
          if (init2 !== void 0) {
            initialState = init2(initialArg);
          } else {
            initialState = initialArg;
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch2 = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch2];
        }
        function updateReducer(reducer, initialArg, init2) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer;
          var current3 = currentHook;
          var baseQueue = current3.baseQueue;
          var pendingQueue = queue.pending;
          if (pendingQueue !== null) {
            if (baseQueue !== null) {
              var baseFirst = baseQueue.next;
              var pendingFirst = pendingQueue.next;
              baseQueue.next = pendingFirst;
              pendingQueue.next = baseFirst;
            }
            {
              if (current3.baseQueue !== baseQueue) {
                error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
              }
            }
            current3.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          if (baseQueue !== null) {
            var first = baseQueue.next;
            var newState = current3.baseState;
            var newBaseState = null;
            var newBaseQueueFirst = null;
            var newBaseQueueLast = null;
            var update4 = first;
            do {
              var updateLane = update4.lane;
              if (!isSubsetOfLanes(renderLanes, updateLane)) {
                var clone4 = {
                  lane: updateLane,
                  action: update4.action,
                  hasEagerState: update4.hasEagerState,
                  eagerState: update4.eagerState,
                  next: null
                };
                if (newBaseQueueLast === null) {
                  newBaseQueueFirst = newBaseQueueLast = clone4;
                  newBaseState = newState;
                } else {
                  newBaseQueueLast = newBaseQueueLast.next = clone4;
                }
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                markSkippedUpdateLanes(updateLane);
              } else {
                if (newBaseQueueLast !== null) {
                  var _clone2 = {
                    // This update is going to be committed so we never want uncommit
                    // it. Using NoLane works because 0 is a subset of all bitmasks, so
                    // this will never be skipped by the check above.
                    lane: NoLane,
                    action: update4.action,
                    hasEagerState: update4.hasEagerState,
                    eagerState: update4.eagerState,
                    next: null
                  };
                  newBaseQueueLast = newBaseQueueLast.next = _clone2;
                }
                if (update4.hasEagerState) {
                  newState = update4.eagerState;
                } else {
                  var action = update4.action;
                  newState = reducer(newState, action);
                }
              }
              update4 = update4.next;
            } while (update4 !== null && update4 !== first);
            if (newBaseQueueLast === null) {
              newBaseState = newState;
            } else {
              newBaseQueueLast.next = newBaseQueueFirst;
            }
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            hook.baseState = newBaseState;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = newState;
          }
          var lastInterleaved = queue.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              var interleavedLane = interleaved.lane;
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
              markSkippedUpdateLanes(interleavedLane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (baseQueue === null) {
            queue.lanes = NoLanes;
          }
          var dispatch2 = queue.dispatch;
          return [hook.memoizedState, dispatch2];
        }
        function rerenderReducer(reducer, initialArg, init2) {
          var hook = updateWorkInProgressHook();
          var queue = hook.queue;
          if (queue === null) {
            throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
          }
          queue.lastRenderedReducer = reducer;
          var dispatch2 = queue.dispatch;
          var lastRenderPhaseUpdate = queue.pending;
          var newState = hook.memoizedState;
          if (lastRenderPhaseUpdate !== null) {
            queue.pending = null;
            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            var update4 = firstRenderPhaseUpdate;
            do {
              var action = update4.action;
              newState = reducer(newState, action);
              update4 = update4.next;
            } while (update4 !== firstRenderPhaseUpdate);
            if (!objectIs(newState, hook.memoizedState)) {
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = newState;
            if (hook.baseQueue === null) {
              hook.baseState = newState;
            }
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch2];
        }
        function mountMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function updateMutableSource(source, getSnapshot, subscribe) {
          {
            return void 0;
          }
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = mountWorkInProgressHook();
          var nextSnapshot;
          var isHydrating2 = getIsHydrating();
          if (isHydrating2) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            nextSnapshot = getServerSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                if (nextSnapshot !== getServerSnapshot()) {
                  error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
          } else {
            nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var root2 = getWorkInProgressRoot();
            if (root2 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root2, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          hook.memoizedState = nextSnapshot;
          var inst = {
            value: nextSnapshot,
            getSnapshot
          };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1;
          var hook = updateWorkInProgressHook();
          var nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var prevSnapshot = hook.memoizedState;
          var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
          if (snapshotChanged) {
            hook.memoizedState = nextSnapshot;
            markWorkInProgressReceivedUpdate();
          }
          var inst = hook.queue;
          updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
          if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
          // checking whether we scheduled a subscription effect above.
          workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            var root2 = getWorkInProgressRoot();
            if (root2 === null) {
              throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
            }
            if (!includesBlockingLane(root2, renderLanes)) {
              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
            }
          }
          return nextSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= StoreConsistency;
          var check2 = {
            getSnapshot,
            value: renderedSnapshot
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.stores = [check2];
          } else {
            var stores = componentUpdateQueue.stores;
            if (stores === null) {
              componentUpdateQueue.stores = [check2];
            } else {
              stores.push(check2);
            }
          }
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        }
        function subscribeToStore(fiber, inst, subscribe) {
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          };
          return subscribe(handleStoreChange);
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        }
        function mountState(initialState) {
          var hook = mountWorkInProgressHook();
          if (typeof initialState === "function") {
            initialState = initialState();
          }
          hook.memoizedState = hook.baseState = initialState;
          var queue = {
            pending: null,
            interleaved: null,
            lanes: NoLanes,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState
          };
          hook.queue = queue;
          var dispatch2 = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
          return [hook.memoizedState, dispatch2];
        }
        function updateState(initialState) {
          return updateReducer(basicStateReducer);
        }
        function rerenderState(initialState) {
          return rerenderReducer(basicStateReducer);
        }
        function pushEffect(tag, create2, destroy, deps) {
          var effect = {
            tag,
            create: create2,
            destroy,
            deps,
            // Circular
            next: null
          };
          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
          if (componentUpdateQueue === null) {
            componentUpdateQueue = createFunctionComponentUpdateQueue();
            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var lastEffect = componentUpdateQueue.lastEffect;
            if (lastEffect === null) {
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              componentUpdateQueue.lastEffect = effect;
            }
          }
          return effect;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          {
            var _ref2 = {
              current: initialValue
            };
            hook.memoizedState = _ref2;
            return _ref2;
          }
        }
        function updateRef(initialValue) {
          var hook = updateWorkInProgressHook();
          return hook.memoizedState;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, void 0, nextDeps);
        }
        function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var destroy = void 0;
          if (currentHook !== null) {
            var prevEffect = currentHook.memoizedState;
            destroy = prevEffect.destroy;
            if (nextDeps !== null) {
              var prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                hook.memoizedState = pushEffect(hookFlags, create2, destroy, nextDeps);
                return;
              }
            }
          }
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, destroy, nextDeps);
        }
        function mountEffect(create2, deps) {
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create2, deps);
          } else {
            return mountEffectImpl(Passive | PassiveStatic, Passive$1, create2, deps);
          }
        }
        function updateEffect(create2, deps) {
          return updateEffectImpl(Passive, Passive$1, create2, deps);
        }
        function mountInsertionEffect(create2, deps) {
          return mountEffectImpl(Update, Insertion, create2, deps);
        }
        function updateInsertionEffect(create2, deps) {
          return updateEffectImpl(Update, Insertion, create2, deps);
        }
        function mountLayoutEffect(create2, deps) {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, create2, deps);
        }
        function updateLayoutEffect(create2, deps) {
          return updateEffectImpl(Update, Layout, create2, deps);
        }
        function imperativeHandleEffect(create2, ref) {
          if (typeof ref === "function") {
            var refCallback = ref;
            var _inst = create2();
            refCallback(_inst);
            return function() {
              refCallback(null);
            };
          } else if (ref !== null && ref !== void 0) {
            var refObject = ref;
            {
              if (!refObject.hasOwnProperty("current")) {
                error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
              }
            }
            var _inst2 = create2();
            refObject.current = _inst2;
            return function() {
              refObject.current = null;
            };
          }
        }
        function mountImperativeHandle(ref, create2, deps) {
          {
            if (typeof create2 !== "function") {
              error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
        }
        function updateImperativeHandle(ref, create2, deps) {
          {
            if (typeof create2 !== "function") {
              error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
            }
          }
          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
          return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
        }
        function mountDebugValue(value, formatterFn) {
        }
        var updateDebugValue = mountDebugValue;
        function mountCallback(callback, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function updateCallback(callback, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          hook.memoizedState = [callback, nextDeps];
          return callback;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          var prevState = hook.memoizedState;
          if (prevState !== null) {
            if (nextDeps !== null) {
              var prevDeps = prevState[1];
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                return prevState[0];
              }
            }
          }
          var nextValue = nextCreate();
          hook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function mountDeferredValue(value) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = value;
          return value;
        }
        function updateDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          var resolvedCurrentHook = currentHook;
          var prevValue = resolvedCurrentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value);
        }
        function rerenderDeferredValue(value) {
          var hook = updateWorkInProgressHook();
          if (currentHook === null) {
            hook.memoizedState = value;
            return value;
          } else {
            var prevValue = currentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
        }
        function updateDeferredValueImpl(hook, prevValue, value) {
          var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
          if (shouldDeferValue) {
            if (!objectIs(value, prevValue)) {
              var deferredLane = claimNextTransitionLane();
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
              markSkippedUpdateLanes(deferredLane);
              hook.baseState = true;
            }
            return prevValue;
          } else {
            if (hook.baseState) {
              hook.baseState = false;
              markWorkInProgressReceivedUpdate();
            }
            hook.memoizedState = value;
            return value;
          }
        }
        function startTransition(setPending, callback, options2) {
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
          setPending(true);
          var prevTransition = ReactCurrentBatchConfig$2.transition;
          ReactCurrentBatchConfig$2.transition = {};
          var currentTransition = ReactCurrentBatchConfig$2.transition;
          {
            ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            setPending(false);
            callback();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$2.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        function mountTransition() {
          var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
          var start = startTransition.bind(null, setPending);
          var hook = mountWorkInProgressHook();
          hook.memoizedState = start;
          return [isPending, start];
        }
        function updateTransition() {
          var _updateState = updateState(), isPending = _updateState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        function rerenderTransition() {
          var _rerenderState = rerenderState(), isPending = _rerenderState[0];
          var hook = updateWorkInProgressHook();
          var start = hook.memoizedState;
          return [isPending, start];
        }
        var isUpdatingOpaqueValueInRenderPhase = false;
        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
          {
            return isUpdatingOpaqueValueInRenderPhase;
          }
        }
        function mountId() {
          var hook = mountWorkInProgressHook();
          var root2 = getWorkInProgressRoot();
          var identifierPrefix = root2.identifierPrefix;
          var id;
          if (getIsHydrating()) {
            var treeId = getTreeId();
            id = ":" + identifierPrefix + "R" + treeId;
            var localId = localIdCounter++;
            if (localId > 0) {
              id += "H" + localId.toString(32);
            }
            id += ":";
          } else {
            var globalClientId = globalClientIdCounter++;
            id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
          }
          hook.memoizedState = id;
          return id;
        }
        function updateId() {
          var hook = updateWorkInProgressHook();
          var id = hook.memoizedState;
          return id;
        }
        function dispatchReducerAction(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update4 = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update4);
          } else {
            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update4, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitionUpdate(root2, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function dispatchSetState(fiber, queue, action) {
          {
            if (typeof arguments[3] === "function") {
              error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
            }
          }
          var lane = requestUpdateLane(fiber);
          var update4 = {
            lane,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            enqueueRenderPhaseUpdate(queue, update4);
          } else {
            var alternate = fiber.alternate;
            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
              var lastRenderedReducer = queue.lastRenderedReducer;
              if (lastRenderedReducer !== null) {
                var prevDispatcher;
                {
                  prevDispatcher = ReactCurrentDispatcher$1.current;
                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                }
                try {
                  var currentState = queue.lastRenderedState;
                  var eagerState = lastRenderedReducer(currentState, action);
                  update4.hasEagerState = true;
                  update4.eagerState = eagerState;
                  if (objectIs(eagerState, currentState)) {
                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update4, lane);
                    return;
                  }
                } catch (error2) {
                } finally {
                  {
                    ReactCurrentDispatcher$1.current = prevDispatcher;
                  }
                }
              }
            }
            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update4, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitionUpdate(root2, queue, lane);
            }
          }
          markUpdateInDevTools(fiber, lane);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue, update4) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          if (pending === null) {
            update4.next = update4;
          } else {
            update4.next = pending.next;
            pending.next = update4;
          }
          queue.pending = update4;
        }
        function entangleTransitionUpdate(root2, queue, lane) {
          if (isTransitionLane(lane)) {
            var queueLanes = queue.lanes;
            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
            var newQueueLanes = mergeLanes(queueLanes, lane);
            queue.lanes = newQueueLanes;
            markRootEntangled(root2, newQueueLanes);
          }
        }
        function markUpdateInDevTools(fiber, lane, action) {
          {
            markStateUpdateScheduled(fiber, lane);
          }
        }
        var ContextOnlyDispatcher = {
          readContext,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useMutableSource: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError,
          unstable_isNewReconciler: enableNewReconciler
        };
        var HooksDispatcherOnMountInDEV = null;
        var HooksDispatcherOnMountWithHookTypesInDEV = null;
        var HooksDispatcherOnUpdateInDEV = null;
        var HooksDispatcherOnRerenderInDEV = null;
        var InvalidNestedHooksDispatcherOnMountInDEV = null;
        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        {
          var warnInvalidContextAccess = function() {
            error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          };
          var warnInvalidHookAccess = function() {
            error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
          };
          HooksDispatcherOnMountInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              mountHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              return mountLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              mountHookTypesDev();
              checkDepsAreArrayDev(deps);
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnMountWithHookTypesInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return mountEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return mountImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return mountInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return mountLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnUpdateInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          HooksDispatcherOnRerenderInDEV = {
            readContext: function(context2) {
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              updateHookTypesDev();
              return updateEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              updateHookTypesDev();
              return updateImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              updateHookTypesDev();
              return updateInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              updateHookTypesDev();
              return updateLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return updateMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnMountInDEV = {
            readContext: function(context2) {
              warnInvalidContextAccess();
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountReducer(reducer, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountRef(initialValue);
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              mountHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
              try {
                return mountState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              mountHookTypesDev();
              return mountId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnUpdateInDEV = {
            readContext: function(context2) {
              warnInvalidContextAccess();
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateReducer(reducer, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
          InvalidNestedHooksDispatcherOnRerenderInDEV = {
            readContext: function(context2) {
              warnInvalidContextAccess();
              return readContext(context2);
            },
            useCallback: function(callback, deps) {
              currentHookNameInDev = "useCallback";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateCallback(callback, deps);
            },
            useContext: function(context2) {
              currentHookNameInDev = "useContext";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return readContext(context2);
            },
            useEffect: function(create2, deps) {
              currentHookNameInDev = "useEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateEffect(create2, deps);
            },
            useImperativeHandle: function(ref, create2, deps) {
              currentHookNameInDev = "useImperativeHandle";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateImperativeHandle(ref, create2, deps);
            },
            useInsertionEffect: function(create2, deps) {
              currentHookNameInDev = "useInsertionEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateInsertionEffect(create2, deps);
            },
            useLayoutEffect: function(create2, deps) {
              currentHookNameInDev = "useLayoutEffect";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateLayoutEffect(create2, deps);
            },
            useMemo: function(create2, deps) {
              currentHookNameInDev = "useMemo";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return updateMemo(create2, deps);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useReducer: function(reducer, initialArg, init2) {
              currentHookNameInDev = "useReducer";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderReducer(reducer, initialArg, init2);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useRef: function(initialValue) {
              currentHookNameInDev = "useRef";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateRef();
            },
            useState: function(initialState) {
              currentHookNameInDev = "useState";
              warnInvalidHookAccess();
              updateHookTypesDev();
              var prevDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                return rerenderState(initialState);
              } finally {
                ReactCurrentDispatcher$1.current = prevDispatcher;
              }
            },
            useDebugValue: function(value, formatterFn) {
              currentHookNameInDev = "useDebugValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateDebugValue();
            },
            useDeferredValue: function(value) {
              currentHookNameInDev = "useDeferredValue";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderDeferredValue(value);
            },
            useTransition: function() {
              currentHookNameInDev = "useTransition";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return rerenderTransition();
            },
            useMutableSource: function(source, getSnapshot, subscribe) {
              currentHookNameInDev = "useMutableSource";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateMutableSource();
            },
            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
              currentHookNameInDev = "useSyncExternalStore";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateSyncExternalStore(subscribe, getSnapshot);
            },
            useId: function() {
              currentHookNameInDev = "useId";
              warnInvalidHookAccess();
              updateHookTypesDev();
              return updateId();
            },
            unstable_isNewReconciler: enableNewReconciler
          };
        }
        var now$1 = Scheduler.unstable_now;
        var commitTime = 0;
        var layoutEffectStartTime = -1;
        var profilerStartTime = -1;
        var passiveEffectStartTime = -1;
        var currentUpdateIsNested = false;
        var nestedUpdateScheduled = false;
        function isCurrentUpdateNested() {
          return currentUpdateIsNested;
        }
        function markNestedUpdateScheduled() {
          {
            nestedUpdateScheduled = true;
          }
        }
        function resetNestedUpdateFlag() {
          {
            currentUpdateIsNested = false;
            nestedUpdateScheduled = false;
          }
        }
        function syncNestedUpdateFlag() {
          {
            currentUpdateIsNested = nestedUpdateScheduled;
            nestedUpdateScheduled = false;
          }
        }
        function getCommitTime() {
          return commitTime;
        }
        function recordCommitTime() {
          commitTime = now$1();
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now$1();
          if (fiber.actualStartTime < 0) {
            fiber.actualStartTime = now$1();
          }
        }
        function stopProfilerTimerIfRunning(fiber) {
          profilerStartTime = -1;
        }
        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
          if (profilerStartTime >= 0) {
            var elapsedTime = now$1() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            if (overrideBaseTime) {
              fiber.selfBaseDuration = elapsedTime;
            }
            profilerStartTime = -1;
          }
        }
        function recordLayoutEffectDuration(fiber) {
          if (layoutEffectStartTime >= 0) {
            var elapsedTime = now$1() - layoutEffectStartTime;
            layoutEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root2 = parentFiber.stateNode;
                  root2.effectDuration += elapsedTime;
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  parentStateNode.effectDuration += elapsedTime;
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function recordPassiveEffectDuration(fiber) {
          if (passiveEffectStartTime >= 0) {
            var elapsedTime = now$1() - passiveEffectStartTime;
            passiveEffectStartTime = -1;
            var parentFiber = fiber.return;
            while (parentFiber !== null) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root2 = parentFiber.stateNode;
                  if (root2 !== null) {
                    root2.passiveEffectDuration += elapsedTime;
                  }
                  return;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  if (parentStateNode !== null) {
                    parentStateNode.passiveEffectDuration += elapsedTime;
                  }
                  return;
              }
              parentFiber = parentFiber.return;
            }
          }
        }
        function startLayoutEffectTimer() {
          layoutEffectStartTime = now$1();
        }
        function startPassiveEffectTimer() {
          passiveEffectStartTime = now$1();
        }
        function transferActualDuration(fiber) {
          var child = fiber.child;
          while (child) {
            fiber.actualDuration += child.actualDuration;
            child = child.sibling;
          }
        }
        function resolveDefaultProps(Component2, baseProps) {
          if (Component2 && Component2.defaultProps) {
            var props3 = assign2({}, baseProps);
            var defaultProps = Component2.defaultProps;
            for (var propName in defaultProps) {
              if (props3[propName] === void 0) {
                props3[propName] = defaultProps[propName];
              }
            }
            return props3;
          }
          return baseProps;
        }
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent;
        var didWarnAboutUninitializedState;
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
        var didWarnAboutLegacyLifecyclesAndDerivedState;
        var didWarnAboutUndefinedDerivedState;
        var warnOnUndefinedDerivedState;
        var warnOnInvalidCallback;
        var didWarnAboutDirectlyAssigningPropsToState;
        var didWarnAboutContextTypeAndContextTypes;
        var didWarnAboutInvalidateContextType;
        var didWarnAboutLegacyContext$1;
        {
          didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
          didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
          warnOnInvalidCallback = function(callback, callerName) {
            if (callback === null || typeof callback === "function") {
              return;
            }
            var key57 = callerName + "_" + callback;
            if (!didWarnOnInvalidCallback.has(key57)) {
              didWarnOnInvalidCallback.add(key57);
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          };
          warnOnUndefinedDerivedState = function(type5, partialState) {
            if (partialState === void 0) {
              var componentName = getComponentNameFromType(type5) || "Component";
              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                didWarnAboutUndefinedDerivedState.add(componentName);
                error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
              }
            }
          };
          Object.defineProperty(fakeInternalInstance, "_processChildContext", {
            enumerable: false,
            value: function() {
              throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
            }
          });
          Object.freeze(fakeInternalInstance);
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState;
          var partialState = getDerivedStateFromProps(nextProps, prevState);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                partialState = getDerivedStateFromProps(nextProps, prevState);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            warnOnUndefinedDerivedState(ctor, partialState);
          }
          var memoizedState = partialState === null || partialState === void 0 ? prevState : assign2({}, prevState, partialState);
          workInProgress2.memoizedState = memoizedState;
          if (workInProgress2.lanes === NoLanes) {
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = memoizedState;
          }
        }
        var classComponentUpdater = {
          isMounted,
          enqueueSetState: function(inst, payload, callback) {
            var fiber = get3(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update4 = createUpdate(eventTime, lane);
            update4.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "setState");
              }
              update4.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update4, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueReplaceState: function(inst, payload, callback) {
            var fiber = get3(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update4 = createUpdate(eventTime, lane);
            update4.tag = ReplaceState;
            update4.payload = payload;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "replaceState");
              }
              update4.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update4, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markStateUpdateScheduled(fiber, lane);
            }
          },
          enqueueForceUpdate: function(inst, callback) {
            var fiber = get3(inst);
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(fiber);
            var update4 = createUpdate(eventTime, lane);
            update4.tag = ForceUpdate;
            if (callback !== void 0 && callback !== null) {
              {
                warnOnInvalidCallback(callback, "forceUpdate");
              }
              update4.callback = callback;
            }
            var root2 = enqueueUpdate(fiber, update4, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
              entangleTransitions(root2, fiber, lane);
            }
            {
              markForceUpdateScheduled(fiber, lane);
            }
          }
        };
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if (typeof instance.shouldComponentUpdate === "function") {
            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              if (shouldUpdate === void 0) {
                error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
              }
            }
            return shouldUpdate;
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent) {
            return !shallowEqual2(oldProps, newProps) || !shallowEqual2(oldState, newState);
          }
          return true;
        }
        function checkClassInstance(workInProgress2, ctor, newProps) {
          var instance = workInProgress2.stateNode;
          {
            var name2 = getComponentNameFromType(ctor) || "Component";
            var renderPresent = instance.render;
            if (!renderPresent) {
              if (ctor.prototype && typeof ctor.prototype.render === "function") {
                error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2);
              } else {
                error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2);
              }
            }
            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
              error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
            }
            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
            }
            if (instance.propTypes) {
              error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2);
            }
            if (instance.contextType) {
              error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
            }
            {
              if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
              // this one.
              (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                didWarnAboutLegacyContext$1.add(ctor);
                error("%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead\n\n.Learn more about this warning here: https://reactjs.org/link/legacy-context", name2);
              }
              if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
              // this one.
              (workInProgress2.mode & StrictLegacyMode) === NoMode) {
                didWarnAboutLegacyContext$1.add(ctor);
                error("%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", name2);
              }
              if (instance.contextTypes) {
                error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2);
              }
              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                didWarnAboutContextTypeAndContextTypes.add(ctor);
                error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2);
              }
            }
            if (typeof instance.componentShouldUpdate === "function") {
              error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
              error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
            }
            if (typeof instance.componentDidUnmount === "function") {
              error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
            }
            if (typeof instance.componentDidReceiveProps === "function") {
              error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
            }
            if (typeof instance.componentWillRecieveProps === "function") {
              error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
            }
            if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
              error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
            }
            var hasMutatedProps = instance.props !== newProps;
            if (instance.props !== void 0 && hasMutatedProps) {
              error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2);
            }
            if (instance.defaultProps) {
              error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
              error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
            }
            if (typeof instance.getDerivedStateFromProps === "function") {
              error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
            }
            if (typeof instance.getDerivedStateFromError === "function") {
              error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
            }
            if (typeof ctor.getSnapshotBeforeUpdate === "function") {
              error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
            }
            var _state = instance.state;
            if (_state && (typeof _state !== "object" || isArray4(_state))) {
              error("%s.state: must be set to an object or null", name2);
            }
            if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
              error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
            }
          }
        }
        function adoptClassInstance(workInProgress2, instance) {
          instance.updater = classComponentUpdater;
          workInProgress2.stateNode = instance;
          set4(instance, workInProgress2);
          {
            instance._reactInternalInstance = fakeInternalInstance;
          }
        }
        function constructClassInstance(workInProgress2, ctor, props3) {
          var isLegacyContextConsumer = false;
          var unmaskedContext = emptyContextObject;
          var context2 = emptyContextObject;
          var contextType = ctor.contextType;
          {
            if ("contextType" in ctor) {
              var isValid = (
                // Allow null for conditional declaration
                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE2 && contextType._context === void 0
              );
              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                didWarnAboutInvalidateContextType.add(ctor);
                var addendum = "";
                if (contextType === void 0) {
                  addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                } else if (typeof contextType !== "object") {
                  addendum = " However, it is set to a " + typeof contextType + ".";
                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE2) {
                  addendum = " Did you accidentally pass the Context.Provider instead?";
                } else if (contextType._context !== void 0) {
                  addendum = " Did you accidentally pass the Context.Consumer instead?";
                } else {
                  addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                }
                error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
              }
            }
          }
          if (typeof contextType === "object" && contextType !== null) {
            context2 = readContext(contextType);
          } else {
            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            var contextTypes = ctor.contextTypes;
            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
            context2 = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
          }
          var instance = new ctor(props3, context2);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance = new ctor(props3, context2);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          var state2 = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
          adoptClassInstance(workInProgress2, instance);
          {
            if (typeof ctor.getDerivedStateFromProps === "function" && state2 === null) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutUninitializedState.has(componentName)) {
                didWarnAboutUninitializedState.add(componentName);
                error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
              }
            }
            if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
              var foundWillMountName = null;
              var foundWillReceivePropsName = null;
              var foundWillUpdateName = null;
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                foundWillMountName = "componentWillMount";
              } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                foundWillMountName = "UNSAFE_componentWillMount";
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                foundWillReceivePropsName = "componentWillReceiveProps";
              } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                foundWillUpdateName = "componentWillUpdate";
              } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                foundWillUpdateName = "UNSAFE_componentWillUpdate";
              }
              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                var _componentName = getComponentNameFromType(ctor) || "Component";
                var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                  error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                }
              }
            }
          }
          if (isLegacyContextConsumer) {
            cacheContext(workInProgress2, unmaskedContext, context2);
          }
          return instance;
        }
        function callComponentWillMount(workInProgress2, instance) {
          var oldState = instance.state;
          if (typeof instance.componentWillMount === "function") {
            instance.componentWillMount();
          }
          if (typeof instance.UNSAFE_componentWillMount === "function") {
            instance.UNSAFE_componentWillMount();
          }
          if (oldState !== instance.state) {
            {
              error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          if (typeof instance.componentWillReceiveProps === "function") {
            instance.componentWillReceiveProps(newProps, nextContext);
          }
          if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          }
          if (instance.state !== oldState) {
            {
              var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                didWarnAboutStateAssignmentForComponent.add(componentName);
                error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
              }
            }
            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
          }
        }
        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          {
            checkClassInstance(workInProgress2, ctor, newProps);
          }
          var instance = workInProgress2.stateNode;
          instance.props = newProps;
          instance.state = workInProgress2.memoizedState;
          instance.refs = {};
          initializeUpdateQueue(workInProgress2);
          var contextType = ctor.contextType;
          if (typeof contextType === "object" && contextType !== null) {
            instance.context = readContext(contextType);
          } else {
            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            instance.context = getMaskedContext(workInProgress2, unmaskedContext);
          }
          {
            if (instance.state === newProps) {
              var componentName = getComponentNameFromType(ctor) || "Component";
              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
            }
            {
              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
            }
          }
          instance.state = workInProgress2.memoizedState;
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            callComponentWillMount(workInProgress2, instance);
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            instance.state = workInProgress2.memoizedState;
          }
          if (typeof instance.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
        }
        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          var oldProps = workInProgress2.memoizedProps;
          instance.props = oldProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (oldProps !== newProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              if (typeof instance.componentWillMount === "function") {
                instance.componentWillMount();
              }
              if (typeof instance.UNSAFE_componentWillMount === "function") {
                instance.UNSAFE_componentWillMount();
              }
            }
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags = Update;
              {
                _fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags;
            }
          } else {
            if (typeof instance.componentDidMount === "function") {
              var _fiberFlags2 = Update;
              {
                _fiberFlags2 |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                _fiberFlags2 |= MountLayoutDev;
              }
              workInProgress2.flags |= _fiberFlags2;
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        function updateClassInstance(current3, workInProgress2, ctor, newProps, renderLanes2) {
          var instance = workInProgress2.stateNode;
          cloneUpdateQueue(current3, workInProgress2);
          var unresolvedOldProps = workInProgress2.memoizedProps;
          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
          instance.props = oldProps;
          var unresolvedNewProps = workInProgress2.pendingProps;
          var oldContext = instance.context;
          var contextType = ctor.contextType;
          var nextContext = emptyContextObject;
          if (typeof contextType === "object" && contextType !== null) {
            nextContext = readContext(contextType);
          } else {
            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
          }
          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
          var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
            }
          }
          resetHasForceUpdateBeforeProcessing();
          var oldState = workInProgress2.memoizedState;
          var newState = instance.state = oldState;
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          newState = workInProgress2.memoizedState;
          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            return false;
          }
          if (typeof getDerivedStateFromProps === "function") {
            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
            newState = workInProgress2.memoizedState;
          }
          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
          // both before and after `shouldComponentUpdate` has been called. Not ideal,
          // but I'm loath to refactor this function. This only happens for memoized
          // components so it's not that common.
          enableLazyContextPropagation;
          if (shouldUpdate) {
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
              if (typeof instance.componentWillUpdate === "function") {
                instance.componentWillUpdate(newProps, newState, nextContext);
              }
              if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
              }
            }
            if (typeof instance.componentDidUpdate === "function") {
              workInProgress2.flags |= Update;
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              workInProgress2.flags |= Snapshot;
            }
          } else {
            if (typeof instance.componentDidUpdate === "function") {
              if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) {
                workInProgress2.flags |= Update;
              }
            }
            if (typeof instance.getSnapshotBeforeUpdate === "function") {
              if (unresolvedOldProps !== current3.memoizedProps || oldState !== current3.memoizedState) {
                workInProgress2.flags |= Snapshot;
              }
            }
            workInProgress2.memoizedProps = newProps;
            workInProgress2.memoizedState = newState;
          }
          instance.props = newProps;
          instance.state = newState;
          instance.context = nextContext;
          return shouldUpdate;
        }
        function createCapturedValueAtFiber(value, source) {
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source),
            digest: null
          };
        }
        function createCapturedValue(value, digest, stack) {
          return {
            value,
            source: null,
            stack: stack != null ? stack : null,
            digest: digest != null ? digest : null
          };
        }
        function showErrorDialog(boundary, errorInfo) {
          return true;
        }
        function logCapturedError(boundary, errorInfo) {
          try {
            var logError = showErrorDialog(boundary, errorInfo);
            if (logError === false) {
              return;
            }
            var error2 = errorInfo.value;
            if (true) {
              var source = errorInfo.source;
              var stack = errorInfo.stack;
              var componentStack = stack !== null ? stack : "";
              if (error2 != null && error2._suppressLogging) {
                if (boundary.tag === ClassComponent) {
                  return;
                }
                console["error"](error2);
              }
              var componentName = source ? getComponentNameFromFiber(source) : null;
              var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
              var errorBoundaryMessage;
              if (boundary.tag === HostRoot) {
                errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
              } else {
                var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
              }
              var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
              console["error"](combinedMessage);
            } else {
              console["error"](error2);
            }
          } catch (e2) {
            setTimeout(function() {
              throw e2;
            });
          }
        }
        var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
        function createRootErrorUpdate(fiber, errorInfo, lane) {
          var update4 = createUpdate(NoTimestamp, lane);
          update4.tag = CaptureUpdate;
          update4.payload = {
            element: null
          };
          var error2 = errorInfo.value;
          update4.callback = function() {
            onUncaughtError(error2);
            logCapturedError(fiber, errorInfo);
          };
          return update4;
        }
        function createClassErrorUpdate(fiber, errorInfo, lane) {
          var update4 = createUpdate(NoTimestamp, lane);
          update4.tag = CaptureUpdate;
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if (typeof getDerivedStateFromError === "function") {
            var error$1 = errorInfo.value;
            update4.payload = function() {
              return getDerivedStateFromError(error$1);
            };
            update4.callback = function() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
            };
          }
          var inst = fiber.stateNode;
          if (inst !== null && typeof inst.componentDidCatch === "function") {
            update4.callback = function callback() {
              {
                markFailedErrorBoundaryForHotReloading(fiber);
              }
              logCapturedError(fiber, errorInfo);
              if (typeof getDerivedStateFromError !== "function") {
                markLegacyErrorBoundaryAsFailed(this);
              }
              var error$12 = errorInfo.value;
              var stack = errorInfo.stack;
              this.componentDidCatch(error$12, {
                componentStack: stack !== null ? stack : ""
              });
              {
                if (typeof getDerivedStateFromError !== "function") {
                  if (!includesSomeLane(fiber.lanes, SyncLane)) {
                    error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                  }
                }
              }
            };
          }
          return update4;
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          var threadIDs;
          if (pingCache === null) {
            pingCache = root2.pingCache = new PossiblyWeakMap$1();
            threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else {
            threadIDs = pingCache.get(wakeable);
            if (threadIDs === void 0) {
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            }
          }
          if (!threadIDs.has(lanes)) {
            threadIDs.add(lanes);
            var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root2, lanes);
              }
            }
            wakeable.then(ping, ping);
          }
        }
        function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
          var wakeables = suspenseBoundary.updateQueue;
          if (wakeables === null) {
            var updateQueue = /* @__PURE__ */ new Set();
            updateQueue.add(wakeable);
            suspenseBoundary.updateQueue = updateQueue;
          } else {
            wakeables.add(wakeable);
          }
        }
        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
          var tag = sourceFiber.tag;
          if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef2 || tag === SimpleMemoComponent)) {
            var currentSource = sourceFiber.alternate;
            if (currentSource) {
              sourceFiber.updateQueue = currentSource.updateQueue;
              sourceFiber.memoizedState = currentSource.memoizedState;
              sourceFiber.lanes = currentSource.lanes;
            } else {
              sourceFiber.updateQueue = null;
              sourceFiber.memoizedState = null;
            }
          }
        }
        function getNearestSuspenseBoundaryToCapture(returnFiber) {
          var node = returnFiber;
          do {
            if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
              return node;
            }
            node = node.return;
          } while (node !== null);
          return null;
        }
        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
          if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
            if (suspenseBoundary === returnFiber) {
              suspenseBoundary.flags |= ShouldCapture;
            } else {
              suspenseBoundary.flags |= DidCapture;
              sourceFiber.flags |= ForceUpdateForLegacySuspense;
              sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
              if (sourceFiber.tag === ClassComponent) {
                var currentSourceFiber = sourceFiber.alternate;
                if (currentSourceFiber === null) {
                  sourceFiber.tag = IncompleteClassComponent;
                } else {
                  var update4 = createUpdate(NoTimestamp, SyncLane);
                  update4.tag = ForceUpdate;
                  enqueueUpdate(sourceFiber, update4, SyncLane);
                }
              }
              sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
            }
            return suspenseBoundary;
          }
          suspenseBoundary.flags |= ShouldCapture;
          suspenseBoundary.lanes = rootRenderLanes;
          return suspenseBoundary;
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= Incomplete;
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root2, rootRenderLanes);
            }
          }
          if (value !== null && typeof value === "object" && typeof value.then === "function") {
            var wakeable = value;
            resetSuspendedComponent(sourceFiber);
            {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
              }
            }
            var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (suspenseBoundary !== null) {
              suspenseBoundary.flags &= ~ForceClientRender;
              markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
              if (suspenseBoundary.mode & ConcurrentMode) {
                attachPingListener(root2, wakeable, rootRenderLanes);
              }
              attachRetryListener(suspenseBoundary, root2, wakeable);
              return;
            } else {
              if (!includesSyncLane(rootRenderLanes)) {
                attachPingListener(root2, wakeable, rootRenderLanes);
                renderDidSuspendDelayIfPossible();
                return;
              }
              var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
              value = uncaughtSuspenseError;
            }
          } else {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
              var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (_suspenseBoundary !== null) {
                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                  _suspenseBoundary.flags |= ForceClientRender;
                }
                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                return;
              }
            }
          }
          value = createCapturedValueAtFiber(value, sourceFiber);
          renderDidError(value);
          var workInProgress2 = returnFiber;
          do {
            switch (workInProgress2.tag) {
              case HostRoot: {
                var _errorInfo = value;
                workInProgress2.flags |= ShouldCapture;
                var lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update4 = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                enqueueCapturedUpdate(workInProgress2, update4);
                return;
              }
              case ClassComponent:
                var errorInfo = value;
                var ctor = workInProgress2.type;
                var instance = workInProgress2.stateNode;
                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                  workInProgress2.flags |= ShouldCapture;
                  var _lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                  var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                  enqueueCapturedUpdate(workInProgress2, _update);
                  return;
                }
                break;
            }
            workInProgress2 = workInProgress2.return;
          } while (workInProgress2 !== null);
        }
        function getSuspendedCache() {
          {
            return null;
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var didReceiveUpdate = false;
        var didWarnAboutBadClass;
        var didWarnAboutModulePatternComponent;
        var didWarnAboutContextTypeOnFunctionComponent;
        var didWarnAboutGetDerivedStateOnFunctionComponent;
        var didWarnAboutFunctionRefs;
        var didWarnAboutReassigningProps;
        var didWarnAboutRevealOrder;
        var didWarnAboutTailOptions;
        var didWarnAboutDefaultPropsOnFunctionComponent;
        {
          didWarnAboutBadClass = {};
          didWarnAboutModulePatternComponent = {};
          didWarnAboutContextTypeOnFunctionComponent = {};
          didWarnAboutGetDerivedStateOnFunctionComponent = {};
          didWarnAboutFunctionRefs = {};
          didWarnAboutReassigningProps = false;
          didWarnAboutRevealOrder = {};
          didWarnAboutTailOptions = {};
          didWarnAboutDefaultPropsOnFunctionComponent = {};
        }
        function reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2) {
          if (current3 === null) {
            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current3.child, nextChildren, renderLanes2);
          }
        }
        function forceUnmountCurrentAndReconcile(current3, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current3.child, null, renderLanes2);
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        }
        function updateForwardRef(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component2.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component2)
                );
              }
            }
          }
          var render3 = Component2.render;
          var ref = workInProgress2.ref;
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current3, workInProgress2, render3, nextProps, ref, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current3, workInProgress2, render3, nextProps, ref, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current3 !== null && !didReceiveUpdate) {
            bailoutHooks(current3, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          if (current3 === null) {
            var type5 = Component2.type;
            if (isSimpleFunctionComponent(type5) && Component2.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
            Component2.defaultProps === void 0) {
              var resolvedType = type5;
              {
                resolvedType = resolveFunctionForHotReloading(type5);
              }
              workInProgress2.tag = SimpleMemoComponent;
              workInProgress2.type = resolvedType;
              {
                validateFunctionComponentInDev(workInProgress2, type5);
              }
              return updateSimpleMemoComponent(current3, workInProgress2, resolvedType, nextProps, renderLanes2);
            }
            {
              var innerPropTypes = type5.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(type5)
                );
              }
              if (Component2.defaultProps !== void 0) {
                var componentName = getComponentNameFromType(type5) || "Unknown";
                if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                  error("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName);
                  didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
                }
              }
            }
            var child = createFiberFromTypeAndProps(Component2.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
            child.ref = workInProgress2.ref;
            child.return = workInProgress2;
            workInProgress2.child = child;
            return child;
          }
          {
            var _type = Component2.type;
            var _innerPropTypes = _type.propTypes;
            if (_innerPropTypes) {
              checkPropTypes(
                _innerPropTypes,
                nextProps,
                // Resolved props
                "prop",
                getComponentNameFromType(_type)
              );
            }
          }
          var currentChild = current3.child;
          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current3, renderLanes2);
          if (!hasScheduledUpdateOrContext) {
            var prevProps = currentChild.memoizedProps;
            var compare2 = Component2.compare;
            compare2 = compare2 !== null ? compare2 : shallowEqual2;
            if (compare2(prevProps, nextProps) && current3.ref === workInProgress2.ref) {
              return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
            }
          }
          workInProgress2.flags |= PerformedWork;
          var newChild = createWorkInProgress(currentChild, nextProps);
          newChild.ref = workInProgress2.ref;
          newChild.return = workInProgress2;
          workInProgress2.child = newChild;
          return newChild;
        }
        function updateSimpleMemoComponent(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var outerMemoType = workInProgress2.elementType;
              if (outerMemoType.$$typeof === REACT_LAZY_TYPE2) {
                var lazyComponent = outerMemoType;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  outerMemoType = init2(payload);
                } catch (x2) {
                  outerMemoType = null;
                }
                var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(
                    outerPropTypes,
                    nextProps,
                    // Resolved (SimpleMemoComponent has no defaultProps)
                    "prop",
                    getComponentNameFromType(outerMemoType)
                  );
                }
              }
            }
          }
          if (current3 !== null) {
            var prevProps = current3.memoizedProps;
            if (shallowEqual2(prevProps, nextProps) && current3.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
            workInProgress2.type === current3.type) {
              didReceiveUpdate = false;
              workInProgress2.pendingProps = nextProps = prevProps;
              if (!checkScheduledUpdateOrContext(current3, renderLanes2)) {
                workInProgress2.lanes = current3.lanes;
                return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
              } else if ((current3.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              }
            }
          }
          return updateFunctionComponent(current3, workInProgress2, Component2, nextProps, renderLanes2);
        }
        function updateOffscreenComponent(current3, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          var prevState = current3 !== null ? current3.memoizedState : null;
          if (nextProps.mode === "hidden" || enableLegacyHidden) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              var nextState = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = nextState;
              pushRenderLanes(workInProgress2, renderLanes2);
            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
              var spawnedCachePool = null;
              var nextBaseLanes;
              if (prevState !== null) {
                var prevBaseLanes = prevState.baseLanes;
                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
              } else {
                nextBaseLanes = renderLanes2;
              }
              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
              var _nextState = {
                baseLanes: nextBaseLanes,
                cachePool: spawnedCachePool,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState;
              workInProgress2.updateQueue = null;
              pushRenderLanes(workInProgress2, nextBaseLanes);
              return null;
            } else {
              var _nextState2 = {
                baseLanes: NoLanes,
                cachePool: null,
                transitions: null
              };
              workInProgress2.memoizedState = _nextState2;
              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
              pushRenderLanes(workInProgress2, subtreeRenderLanes2);
            }
          } else {
            var _subtreeRenderLanes;
            if (prevState !== null) {
              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
              workInProgress2.memoizedState = null;
            } else {
              _subtreeRenderLanes = renderLanes2;
            }
            pushRenderLanes(workInProgress2, _subtreeRenderLanes);
          }
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateFragment(current3, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateMode(current3, workInProgress2, renderLanes2) {
          var nextChildren = workInProgress2.pendingProps.children;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateProfiler(current3, workInProgress2, renderLanes2) {
          {
            workInProgress2.flags |= Update;
            {
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
          }
          var nextProps = workInProgress2.pendingProps;
          var nextChildren = nextProps.children;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markRef(current3, workInProgress2) {
          var ref = workInProgress2.ref;
          if (current3 === null && ref !== null || current3 !== null && current3.ref !== ref) {
            workInProgress2.flags |= Ref2;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
        }
        function updateFunctionComponent(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          {
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component2.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component2)
                );
              }
            }
          }
          var context2;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, true);
            context2 = getMaskedContext(workInProgress2, unmaskedContext);
          }
          var nextChildren;
          var hasId;
          prepareToReadContext(workInProgress2, renderLanes2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            nextChildren = renderWithHooks(current3, workInProgress2, Component2, nextProps, context2, renderLanes2);
            hasId = checkDidRenderIdHook();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                nextChildren = renderWithHooks(current3, workInProgress2, Component2, nextProps, context2, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          if (current3 !== null && !didReceiveUpdate) {
            bailoutHooks(current3, workInProgress2, renderLanes2);
            return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current3, workInProgress2, Component2, nextProps, renderLanes2) {
          {
            switch (shouldError(workInProgress2)) {
              case false: {
                var _instance = workInProgress2.stateNode;
                var ctor = workInProgress2.type;
                var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                var state2 = tempInstance.state;
                _instance.updater.enqueueSetState(_instance, state2, null);
                break;
              }
              case true: {
                workInProgress2.flags |= DidCapture;
                workInProgress2.flags |= ShouldCapture;
                var error$1 = new Error("Simulated error coming from DevTools");
                var lane = pickArbitraryLane(renderLanes2);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                var update4 = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                enqueueCapturedUpdate(workInProgress2, update4);
                break;
              }
            }
            if (workInProgress2.type !== workInProgress2.elementType) {
              var innerPropTypes = Component2.propTypes;
              if (innerPropTypes) {
                checkPropTypes(
                  innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(Component2)
                );
              }
            }
          }
          var hasContext;
          if (isContextProvider(Component2)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var instance = workInProgress2.stateNode;
          var shouldUpdate;
          if (instance === null) {
            resetSuspendedCurrentOnMountInLegacyMode(current3, workInProgress2);
            constructClassInstance(workInProgress2, Component2, nextProps);
            mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            shouldUpdate = true;
          } else if (current3 === null) {
            shouldUpdate = resumeMountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
          } else {
            shouldUpdate = updateClassInstance(current3, workInProgress2, Component2, nextProps, renderLanes2);
          }
          var nextUnitOfWork = finishClassComponent(current3, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2);
          {
            var inst = workInProgress2.stateNode;
            if (shouldUpdate && inst.props !== nextProps) {
              if (!didWarnAboutReassigningProps) {
                error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
              }
              didWarnAboutReassigningProps = true;
            }
          }
          return nextUnitOfWork;
        }
        function finishClassComponent(current3, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2) {
          markRef(current3, workInProgress2);
          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (!shouldUpdate && !didCaptureError) {
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component2, false);
            }
            return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          }
          var instance = workInProgress2.stateNode;
          ReactCurrentOwner$1.current = workInProgress2;
          var nextChildren;
          if (didCaptureError && typeof Component2.getDerivedStateFromError !== "function") {
            nextChildren = null;
            {
              stopProfilerTimerIfRunning();
            }
          } else {
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              setIsRendering(true);
              nextChildren = instance.render();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance.render();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
          }
          workInProgress2.flags |= PerformedWork;
          if (current3 !== null && didCaptureError) {
            forceUnmountCurrentAndReconcile(current3, workInProgress2, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          }
          workInProgress2.memoizedState = instance.state;
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component2, true);
          }
          return workInProgress2.child;
        }
        function pushHostRootContext(workInProgress2) {
          var root2 = workInProgress2.stateNode;
          if (root2.pendingContext) {
            pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
          } else if (root2.context) {
            pushTopLevelContextObject(workInProgress2, root2.context, false);
          }
          pushHostContainer(workInProgress2, root2.containerInfo);
        }
        function updateHostRoot(current3, workInProgress2, renderLanes2) {
          pushHostRootContext(workInProgress2);
          if (current3 === null) {
            throw new Error("Should have a current fiber. This is a bug in React.");
          }
          var nextProps = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          var prevChildren = prevState.element;
          cloneUpdateQueue(current3, workInProgress2);
          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          var root2 = workInProgress2.stateNode;
          var nextChildren = nextState.element;
          if (prevState.isDehydrated) {
            var overrideState = {
              element: nextChildren,
              isDehydrated: false,
              cache: nextState.cache,
              pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
              transitions: nextState.transitions
            };
            var updateQueue = workInProgress2.updateQueue;
            updateQueue.baseState = overrideState;
            workInProgress2.memoizedState = overrideState;
            if (workInProgress2.flags & ForceClientRender) {
              var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current3, workInProgress2, nextChildren, renderLanes2, recoverableError);
            } else if (nextChildren !== prevChildren) {
              var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
              return mountHostRootWithoutHydrating(current3, workInProgress2, nextChildren, renderLanes2, _recoverableError);
            } else {
              enterHydrationState(workInProgress2);
              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
              workInProgress2.child = child;
              var node = child;
              while (node) {
                node.flags = node.flags & ~Placement | Hydrating;
                node = node.sibling;
              }
            }
          } else {
            resetHydrationState();
            if (nextChildren === prevChildren) {
              return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
            }
            reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        function mountHostRootWithoutHydrating(current3, workInProgress2, nextChildren, renderLanes2, recoverableError) {
          resetHydrationState();
          queueHydrationError(recoverableError);
          workInProgress2.flags |= ForceClientRender;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostComponent(current3, workInProgress2, renderLanes2) {
          pushHostContext(workInProgress2);
          if (current3 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          var type5 = workInProgress2.type;
          var nextProps = workInProgress2.pendingProps;
          var prevProps = current3 !== null ? current3.memoizedProps : null;
          var nextChildren = nextProps.children;
          var isDirectTextChild = shouldSetTextContent(type5, nextProps);
          if (isDirectTextChild) {
            nextChildren = null;
          } else if (prevProps !== null && shouldSetTextContent(type5, prevProps)) {
            workInProgress2.flags |= ContentReset;
          }
          markRef(current3, workInProgress2);
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function updateHostText(current3, workInProgress2) {
          if (current3 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
          }
          return null;
        }
        function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props3 = workInProgress2.pendingProps;
          var lazyComponent = elementType;
          var payload = lazyComponent._payload;
          var init2 = lazyComponent._init;
          var Component2 = init2(payload);
          workInProgress2.type = Component2;
          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component2);
          var resolvedProps = resolveDefaultProps(Component2, props3);
          var child;
          switch (resolvedTag) {
            case FunctionComponent: {
              {
                validateFunctionComponentInDev(workInProgress2, Component2);
                workInProgress2.type = Component2 = resolveFunctionForHotReloading(Component2);
              }
              child = updateFunctionComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
              return child;
            }
            case ClassComponent: {
              {
                workInProgress2.type = Component2 = resolveClassForHotReloading(Component2);
              }
              child = updateClassComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
              return child;
            }
            case ForwardRef2: {
              {
                workInProgress2.type = Component2 = resolveForwardRefForHotReloading(Component2);
              }
              child = updateForwardRef(null, workInProgress2, Component2, resolvedProps, renderLanes2);
              return child;
            }
            case MemoComponent: {
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = Component2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      resolvedProps,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(Component2)
                    );
                  }
                }
              }
              child = updateMemoComponent(
                null,
                workInProgress2,
                Component2,
                resolveDefaultProps(Component2.type, resolvedProps),
                // The inner type can have defaults too
                renderLanes2
              );
              return child;
            }
          }
          var hint = "";
          {
            if (Component2 !== null && typeof Component2 === "object" && Component2.$$typeof === REACT_LAZY_TYPE2) {
              hint = " Did you wrap a component in React.lazy() more than once?";
            }
          }
          throw new Error("Element type is invalid. Received a promise that resolves to: " + Component2 + ". " + ("Lazy element type must resolve to a class or function." + hint));
        }
        function mountIncompleteClassComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          workInProgress2.tag = ClassComponent;
          var hasContext;
          if (isContextProvider(Component2)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          constructClassInstance(workInProgress2, Component2, nextProps);
          mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
        }
        function mountIndeterminateComponent(_current, workInProgress2, Component2, renderLanes2) {
          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
          var props3 = workInProgress2.pendingProps;
          var context2;
          {
            var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, false);
            context2 = getMaskedContext(workInProgress2, unmaskedContext);
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var value;
          var hasId;
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            if (Component2.prototype && typeof Component2.prototype.render === "function") {
              var componentName = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutBadClass[componentName]) {
                error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                didWarnAboutBadClass[componentName] = true;
              }
            }
            if (workInProgress2.mode & StrictLegacyMode) {
              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
            }
            setIsRendering(true);
            ReactCurrentOwner$1.current = workInProgress2;
            value = renderWithHooks(null, workInProgress2, Component2, props3, context2, renderLanes2);
            hasId = checkDidRenderIdHook();
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          {
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              var _componentName = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                didWarnAboutModulePatternComponent[_componentName] = true;
              }
            }
          }
          if (
            // Run these checks in production only if the flag is off.
            // Eventually we'll delete this branch altogether.
            typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
          ) {
            {
              var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutModulePatternComponent[_componentName2]) {
                error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                didWarnAboutModulePatternComponent[_componentName2] = true;
              }
            }
            workInProgress2.tag = ClassComponent;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            var hasContext = false;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
            initializeUpdateQueue(workInProgress2);
            adoptClassInstance(workInProgress2, value);
            mountClassInstance(workInProgress2, Component2, props3, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
          } else {
            workInProgress2.tag = FunctionComponent;
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  value = renderWithHooks(null, workInProgress2, Component2, props3, context2, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            reconcileChildren(null, workInProgress2, value, renderLanes2);
            {
              validateFunctionComponentInDev(workInProgress2, Component2);
            }
            return workInProgress2.child;
          }
        }
        function validateFunctionComponentInDev(workInProgress2, Component2) {
          {
            if (Component2) {
              if (Component2.childContextTypes) {
                error("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
              }
            }
            if (workInProgress2.ref !== null) {
              var info = "";
              var ownerName = getCurrentFiberOwnerNameInDevOrNull();
              if (ownerName) {
                info += "\n\nCheck the render method of `" + ownerName + "`.";
              }
              var warningKey = ownerName || "";
              var debugSource = workInProgress2._debugSource;
              if (debugSource) {
                warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
              }
              if (!didWarnAboutFunctionRefs[warningKey]) {
                didWarnAboutFunctionRefs[warningKey] = true;
                error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
              }
            }
            if (Component2.defaultProps !== void 0) {
              var componentName = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
              }
            }
            if (typeof Component2.getDerivedStateFromProps === "function") {
              var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
              }
            }
            if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
              var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                error("%s: Function components do not support contextType.", _componentName4);
                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
              }
            }
          }
        }
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: NoLane
        };
        function mountSuspenseOffscreenState(renderLanes2) {
          return {
            baseLanes: renderLanes2,
            cachePool: getSuspendedCache(),
            transitions: null
          };
        }
        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
          var cachePool = null;
          return {
            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
            cachePool,
            transitions: prevOffscreenState.transitions
          };
        }
        function shouldRemainOnFallback(suspenseContext, current3, workInProgress2, renderLanes2) {
          if (current3 !== null) {
            var suspenseState = current3.memoizedState;
            if (suspenseState === null) {
              return false;
            }
          }
          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        }
        function getRemainingWorkInPrimaryTree(current3, renderLanes2) {
          return removeLanes(current3.childLanes, renderLanes2);
        }
        function updateSuspenseComponent(current3, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          {
            if (shouldSuspend(workInProgress2)) {
              workInProgress2.flags |= DidCapture;
            }
          }
          var suspenseContext = suspenseStackCursor.current;
          var showFallback = false;
          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
          if (didSuspend || shouldRemainOnFallback(suspenseContext, current3)) {
            showFallback = true;
            workInProgress2.flags &= ~DidCapture;
          } else {
            if (current3 === null || current3.memoizedState !== null) {
              {
                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
              }
            }
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          pushSuspenseContext(workInProgress2, suspenseContext);
          if (current3 === null) {
            tryToClaimNextHydratableInstance(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null) {
              var dehydrated = suspenseState.dehydrated;
              if (dehydrated !== null) {
                return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
              }
            }
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            if (showFallback) {
              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackFragment;
            } else {
              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
            }
          } else {
            var prevState = current3.memoizedState;
            if (prevState !== null) {
              var _dehydrated = prevState.dehydrated;
              if (_dehydrated !== null) {
                return updateDehydratedSuspenseComponent(current3, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
              }
            }
            if (showFallback) {
              var _nextFallbackChildren = nextProps.fallback;
              var _nextPrimaryChildren = nextProps.children;
              var fallbackChildFragment = updateSuspenseFallbackChildren(current3, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
              var _primaryChildFragment2 = workInProgress2.child;
              var prevOffscreenState = current3.child.memoizedState;
              _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
              _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current3, renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            } else {
              var _nextPrimaryChildren2 = nextProps.children;
              var _primaryChildFragment3 = updateSuspensePrimaryChildren(current3, workInProgress2, _nextPrimaryChildren2, renderLanes2);
              workInProgress2.memoizedState = null;
              return _primaryChildFragment3;
            }
          }
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          primaryChildFragment.return = workInProgress2;
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var progressedPrimaryFragment = workInProgress2.child;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          var fallbackChildFragment;
          if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = 0;
              primaryChildFragment.treeBaseDuration = 0;
            }
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          } else {
            primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          }
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
          return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
        }
        function updateWorkInProgressOffscreenFiber(current3, offscreenProps) {
          return createWorkInProgress(current3, offscreenProps);
        }
        function updateSuspensePrimaryChildren(current3, workInProgress2, primaryChildren, renderLanes2) {
          var currentPrimaryChildFragment = current3.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
            mode: "visible",
            children: primaryChildren
          });
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            primaryChildFragment.lanes = renderLanes2;
          }
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = null;
          if (currentFallbackChildFragment !== null) {
            var deletions = workInProgress2.deletions;
            if (deletions === null) {
              workInProgress2.deletions = [currentFallbackChildFragment];
              workInProgress2.flags |= ChildDeletion;
            } else {
              deletions.push(currentFallbackChildFragment);
            }
          }
          workInProgress2.child = primaryChildFragment;
          return primaryChildFragment;
        }
        function updateSuspenseFallbackChildren(current3, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var mode = workInProgress2.mode;
          var currentPrimaryChildFragment = current3.child;
          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
          var primaryChildProps = {
            mode: "hidden",
            children: primaryChildren
          };
          var primaryChildFragment;
          if (
            // In legacy mode, we commit the primary tree as if it successfully
            // completed, even though it's in an inconsistent state.
            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
            // already cloned. In legacy mode, the only case where this isn't true is
            // when DevTools forces us to display a fallback; we skip the first render
            // pass entirely and go straight to rendering the fallback. (In Concurrent
            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
            // only codepath.)
            workInProgress2.child !== currentPrimaryChildFragment
          ) {
            var progressedPrimaryFragment = workInProgress2.child;
            primaryChildFragment = progressedPrimaryFragment;
            primaryChildFragment.childLanes = NoLanes;
            primaryChildFragment.pendingProps = primaryChildProps;
            if (workInProgress2.mode & ProfileMode) {
              primaryChildFragment.actualDuration = 0;
              primaryChildFragment.actualStartTime = -1;
              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
            }
            workInProgress2.deletions = null;
          } else {
            primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
            primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
          }
          var fallbackChildFragment;
          if (currentFallbackChildFragment !== null) {
            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
          } else {
            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
          }
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          return fallbackChildFragment;
        }
        function retrySuspenseComponentWithoutHydrating(current3, workInProgress2, renderLanes2, recoverableError) {
          if (recoverableError !== null) {
            queueHydrationError(recoverableError);
          }
          reconcileChildFibers(workInProgress2, current3.child, null, renderLanes2);
          var nextProps = workInProgress2.pendingProps;
          var primaryChildren = nextProps.children;
          var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
          primaryChildFragment.flags |= Placement;
          workInProgress2.memoizedState = null;
          return primaryChildFragment;
        }
        function mountSuspenseFallbackAfterRetryWithoutHydrating(current3, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
          var fiberMode = workInProgress2.mode;
          var primaryChildProps = {
            mode: "visible",
            children: primaryChildren
          };
          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
          var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
          primaryChildFragment.return = workInProgress2;
          fallbackChildFragment.return = workInProgress2;
          primaryChildFragment.sibling = fallbackChildFragment;
          workInProgress2.child = primaryChildFragment;
          if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
            reconcileChildFibers(workInProgress2, current3.child, null, renderLanes2);
          }
          return fallbackChildFragment;
        }
        function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            {
              error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
            }
            workInProgress2.lanes = laneToLanes(SyncLane);
          } else if (isSuspenseInstanceFallback(suspenseInstance)) {
            workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
          } else {
            workInProgress2.lanes = laneToLanes(OffscreenLane);
          }
          return null;
        }
        function updateDehydratedSuspenseComponent(current3, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
          if (!didSuspend) {
            warnIfHydrating();
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              return retrySuspenseComponentWithoutHydrating(
                current3,
                workInProgress2,
                renderLanes2,
                // TODO: When we delete legacy mode, we should make this error argument
                // required  every concurrent mode path that causes hydration to
                // de-opt to client rendering should have an error message.
                null
              );
            }
            if (isSuspenseInstanceFallback(suspenseInstance)) {
              var digest, message, stack;
              {
                var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                digest = _getSuspenseInstanceF.digest;
                message = _getSuspenseInstanceF.message;
                stack = _getSuspenseInstanceF.stack;
              }
              var error2;
              if (message) {
                error2 = new Error(message);
              } else {
                error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
              }
              var capturedValue = createCapturedValue(error2, digest, stack);
              return retrySuspenseComponentWithoutHydrating(current3, workInProgress2, renderLanes2, capturedValue);
            }
            var hasContextChanged2 = includesSomeLane(renderLanes2, current3.childLanes);
            if (didReceiveUpdate || hasContextChanged2) {
              var root2 = getWorkInProgressRoot();
              if (root2 !== null) {
                var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
                if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                  suspenseState.retryLane = attemptHydrationAtLane;
                  var eventTime = NoTimestamp;
                  enqueueConcurrentRenderForLane(current3, attemptHydrationAtLane);
                  scheduleUpdateOnFiber(root2, current3, attemptHydrationAtLane, eventTime);
                }
              }
              renderDidSuspendDelayIfPossible();
              var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
              return retrySuspenseComponentWithoutHydrating(current3, workInProgress2, renderLanes2, _capturedValue);
            } else if (isSuspenseInstancePending(suspenseInstance)) {
              workInProgress2.flags |= DidCapture;
              workInProgress2.child = current3.child;
              var retry = retryDehydratedSuspenseBoundary.bind(null, current3);
              registerSuspenseInstanceRetry(suspenseInstance, retry);
              return null;
            } else {
              reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
              var primaryChildren = nextProps.children;
              var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
              primaryChildFragment.flags |= Hydrating;
              return primaryChildFragment;
            }
          } else {
            if (workInProgress2.flags & ForceClientRender) {
              workInProgress2.flags &= ~ForceClientRender;
              var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
              return retrySuspenseComponentWithoutHydrating(current3, workInProgress2, renderLanes2, _capturedValue2);
            } else if (workInProgress2.memoizedState !== null) {
              workInProgress2.child = current3.child;
              workInProgress2.flags |= DidCapture;
              return null;
            } else {
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current3, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
              var _primaryChildFragment4 = workInProgress2.child;
              _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
              workInProgress2.memoizedState = SUSPENDED_MARKER;
              return fallbackChildFragment;
            }
          }
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
          }
          scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
        }
        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
          var node = firstChild;
          while (node !== null) {
            if (node.tag === SuspenseComponent) {
              var state2 = node.memoizedState;
              if (state2 !== null) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              }
            } else if (node.tag === SuspenseListComponent) {
              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        function findLastContentRow(firstChild) {
          var row = firstChild;
          var lastContentRow = null;
          while (row !== null) {
            var currentRow = row.alternate;
            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              lastContentRow = row;
            }
            row = row.sibling;
          }
          return lastContentRow;
        }
        function validateRevealOrder(revealOrder) {
          {
            if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
              didWarnAboutRevealOrder[revealOrder] = true;
              if (typeof revealOrder === "string") {
                switch (revealOrder.toLowerCase()) {
                  case "together":
                  case "forwards":
                  case "backwards": {
                    error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  case "forward":
                  case "backward": {
                    error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                    break;
                  }
                  default:
                    error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                    break;
                }
              } else {
                error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
              }
            }
          }
        }
        function validateTailOptions(tailMode, revealOrder) {
          {
            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
              if (tailMode !== "collapsed" && tailMode !== "hidden") {
                didWarnAboutTailOptions[tailMode] = true;
                error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
              } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                didWarnAboutTailOptions[tailMode] = true;
                error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
              }
            }
          }
        }
        function validateSuspenseListNestedChild(childSlot, index2) {
          {
            var isAnArray = isArray4(childSlot);
            var isIterable2 = !isAnArray && typeof getIteratorFn(childSlot) === "function";
            if (isAnArray || isIterable2) {
              var type5 = isAnArray ? "array" : "iterable";
              error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type5, index2, type5);
              return false;
            }
          }
          return true;
        }
        function validateSuspenseListChildren(children, revealOrder) {
          {
            if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
              if (isArray4(children)) {
                for (var i2 = 0; i2 < children.length; i2++) {
                  if (!validateSuspenseListNestedChild(children[i2], i2)) {
                    return;
                  }
                }
              } else {
                var iteratorFn2 = getIteratorFn(children);
                if (typeof iteratorFn2 === "function") {
                  var childrenIterator = iteratorFn2.call(children);
                  if (childrenIterator) {
                    var step = childrenIterator.next();
                    var _i = 0;
                    for (; !step.done; step = childrenIterator.next()) {
                      if (!validateSuspenseListNestedChild(step.value, _i)) {
                        return;
                      }
                      _i++;
                    }
                  }
                } else {
                  error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                }
              }
            }
          }
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail2, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          if (renderState === null) {
            workInProgress2.memoizedState = {
              isBackwards,
              rendering: null,
              renderingStartTime: 0,
              last: lastContentRow,
              tail: tail2,
              tailMode
            };
          } else {
            renderState.isBackwards = isBackwards;
            renderState.rendering = null;
            renderState.renderingStartTime = 0;
            renderState.last = lastContentRow;
            renderState.tail = tail2;
            renderState.tailMode = tailMode;
          }
        }
        function updateSuspenseListComponent(current3, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps;
          var revealOrder = nextProps.revealOrder;
          var tailMode = nextProps.tail;
          var newChildren = nextProps.children;
          validateRevealOrder(revealOrder);
          validateTailOptions(tailMode, revealOrder);
          validateSuspenseListChildren(newChildren, revealOrder);
          reconcileChildren(current3, workInProgress2, newChildren, renderLanes2);
          var suspenseContext = suspenseStackCursor.current;
          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          if (shouldForceFallback) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
            workInProgress2.flags |= DidCapture;
          } else {
            var didSuspendBefore = current3 !== null && (current3.flags & DidCapture) !== NoFlags;
            if (didSuspendBefore) {
              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }
          pushSuspenseContext(workInProgress2, suspenseContext);
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            workInProgress2.memoizedState = null;
          } else {
            switch (revealOrder) {
              case "forwards": {
                var lastContentRow = findLastContentRow(workInProgress2.child);
                var tail2;
                if (lastContentRow === null) {
                  tail2 = workInProgress2.child;
                  workInProgress2.child = null;
                } else {
                  tail2 = lastContentRow.sibling;
                  lastContentRow.sibling = null;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  tail2,
                  lastContentRow,
                  tailMode
                );
                break;
              }
              case "backwards": {
                var _tail = null;
                var row = workInProgress2.child;
                workInProgress2.child = null;
                while (row !== null) {
                  var currentRow = row.alternate;
                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                    workInProgress2.child = row;
                    break;
                  }
                  var nextRow = row.sibling;
                  row.sibling = _tail;
                  _tail = row;
                  row = nextRow;
                }
                initSuspenseListRenderState(
                  workInProgress2,
                  true,
                  // isBackwards
                  _tail,
                  null,
                  // last
                  tailMode
                );
                break;
              }
              case "together": {
                initSuspenseListRenderState(
                  workInProgress2,
                  false,
                  // isBackwards
                  null,
                  // tail
                  null,
                  // last
                  void 0
                );
                break;
              }
              default: {
                workInProgress2.memoizedState = null;
              }
            }
          }
          return workInProgress2.child;
        }
        function updatePortalComponent(current3, workInProgress2, renderLanes2) {
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          var nextChildren = workInProgress2.pendingProps;
          if (current3 === null) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          } else {
            reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          }
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
        function updateContextProvider(current3, workInProgress2, renderLanes2) {
          var providerType = workInProgress2.type;
          var context2 = providerType._context;
          var newProps = workInProgress2.pendingProps;
          var oldProps = workInProgress2.memoizedProps;
          var newValue = newProps.value;
          {
            if (!("value" in newProps)) {
              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
              }
            }
            var providerPropTypes = workInProgress2.type.propTypes;
            if (providerPropTypes) {
              checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
            }
          }
          pushProvider(workInProgress2, context2, newValue);
          {
            if (oldProps !== null) {
              var oldValue = oldProps.value;
              if (objectIs(oldValue, newValue)) {
                if (oldProps.children === newProps.children && !hasContextChanged()) {
                  return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
                }
              } else {
                propagateContextChange(workInProgress2, context2, renderLanes2);
              }
            }
          }
          var newChildren = newProps.children;
          reconcileChildren(current3, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        var hasWarnedAboutUsingContextAsConsumer = false;
        function updateContextConsumer(current3, workInProgress2, renderLanes2) {
          var context2 = workInProgress2.type;
          {
            if (context2._context === void 0) {
              if (context2 !== context2.Consumer) {
                if (!hasWarnedAboutUsingContextAsConsumer) {
                  hasWarnedAboutUsingContextAsConsumer = true;
                  error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                }
              }
            } else {
              context2 = context2._context;
            }
          }
          var newProps = workInProgress2.pendingProps;
          var render3 = newProps.children;
          {
            if (typeof render3 !== "function") {
              error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
            }
          }
          prepareToReadContext(workInProgress2, renderLanes2);
          var newValue = readContext(context2);
          {
            markComponentRenderStarted(workInProgress2);
          }
          var newChildren;
          {
            ReactCurrentOwner$1.current = workInProgress2;
            setIsRendering(true);
            newChildren = render3(newValue);
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
          workInProgress2.flags |= PerformedWork;
          reconcileChildren(current3, workInProgress2, newChildren, renderLanes2);
          return workInProgress2.child;
        }
        function markWorkInProgressReceivedUpdate() {
          didReceiveUpdate = true;
        }
        function resetSuspendedCurrentOnMountInLegacyMode(current3, workInProgress2) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            if (current3 !== null) {
              current3.alternate = null;
              workInProgress2.alternate = null;
              workInProgress2.flags |= Placement;
            }
          }
        }
        function bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2) {
          if (current3 !== null) {
            workInProgress2.dependencies = current3.dependencies;
          }
          {
            stopProfilerTimerIfRunning();
          }
          markSkippedUpdateLanes(workInProgress2.lanes);
          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
            {
              return null;
            }
          }
          cloneChildFibers(current3, workInProgress2);
          return workInProgress2.child;
        }
        function remountFiber(current3, oldWorkInProgress, newWorkInProgress) {
          {
            var returnFiber = oldWorkInProgress.return;
            if (returnFiber === null) {
              throw new Error("Cannot swap the root fiber.");
            }
            current3.alternate = null;
            oldWorkInProgress.alternate = null;
            newWorkInProgress.index = oldWorkInProgress.index;
            newWorkInProgress.sibling = oldWorkInProgress.sibling;
            newWorkInProgress.return = oldWorkInProgress.return;
            newWorkInProgress.ref = oldWorkInProgress.ref;
            if (oldWorkInProgress === returnFiber.child) {
              returnFiber.child = newWorkInProgress;
            } else {
              var prevSibling = returnFiber.child;
              if (prevSibling === null) {
                throw new Error("Expected parent to have a child.");
              }
              while (prevSibling.sibling !== oldWorkInProgress) {
                prevSibling = prevSibling.sibling;
                if (prevSibling === null) {
                  throw new Error("Expected to find the previous sibling.");
                }
              }
              prevSibling.sibling = newWorkInProgress;
            }
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [current3];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(current3);
            }
            newWorkInProgress.flags |= Placement;
            return newWorkInProgress;
          }
        }
        function checkScheduledUpdateOrContext(current3, renderLanes2) {
          var updateLanes = current3.lanes;
          if (includesSomeLane(updateLanes, renderLanes2)) {
            return true;
          }
          return false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current3, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case HostRoot:
              pushHostRootContext(workInProgress2);
              var root2 = workInProgress2.stateNode;
              resetHydrationState();
              break;
            case HostComponent:
              pushHostContext(workInProgress2);
              break;
            case ClassComponent: {
              var Component2 = workInProgress2.type;
              if (isContextProvider(Component2)) {
                pushContextProvider(workInProgress2);
              }
              break;
            }
            case HostPortal:
              pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
              break;
            case ContextProvider: {
              var newValue = workInProgress2.memoizedProps.value;
              var context2 = workInProgress2.type._context;
              pushProvider(workInProgress2, context2, newValue);
              break;
            }
            case Profiler:
              {
                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (hasChildWork) {
                  workInProgress2.flags |= Update;
                }
                {
                  var stateNode = workInProgress2.stateNode;
                  stateNode.effectDuration = 0;
                  stateNode.passiveEffectDuration = 0;
                }
              }
              break;
            case SuspenseComponent: {
              var state2 = workInProgress2.memoizedState;
              if (state2 !== null) {
                if (state2.dehydrated !== null) {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  workInProgress2.flags |= DidCapture;
                  return null;
                }
                var primaryChildFragment = workInProgress2.child;
                var primaryChildLanes = primaryChildFragment.childLanes;
                if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                  return updateSuspenseComponent(current3, workInProgress2, renderLanes2);
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                  var child = bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
                  if (child !== null) {
                    return child.sibling;
                  } else {
                    return null;
                  }
                }
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
              }
              break;
            }
            case SuspenseListComponent: {
              var didSuspendBefore = (current3.flags & DidCapture) !== NoFlags;
              var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (didSuspendBefore) {
                if (_hasChildWork) {
                  return updateSuspenseListComponent(current3, workInProgress2, renderLanes2);
                }
                workInProgress2.flags |= DidCapture;
              }
              var renderState = workInProgress2.memoizedState;
              if (renderState !== null) {
                renderState.rendering = null;
                renderState.tail = null;
                renderState.lastEffect = null;
              }
              pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
              if (_hasChildWork) {
                break;
              } else {
                return null;
              }
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              workInProgress2.lanes = NoLanes;
              return updateOffscreenComponent(current3, workInProgress2, renderLanes2);
            }
          }
          return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
        }
        function beginWork(current3, workInProgress2, renderLanes2) {
          {
            if (workInProgress2._debugNeedsRemount && current3 !== null) {
              return remountFiber(current3, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
            }
          }
          if (current3 !== null) {
            var oldProps = current3.memoizedProps;
            var newProps = workInProgress2.pendingProps;
            if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
            workInProgress2.type !== current3.type) {
              didReceiveUpdate = true;
            } else {
              var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current3, renderLanes2);
              if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
              // may not be work scheduled on `current`, so we check for this flag.
              (workInProgress2.flags & DidCapture) === NoFlags) {
                didReceiveUpdate = false;
                return attemptEarlyBailoutIfNoScheduledUpdate(current3, workInProgress2, renderLanes2);
              }
              if ((current3.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                didReceiveUpdate = true;
              } else {
                didReceiveUpdate = false;
              }
            }
          } else {
            didReceiveUpdate = false;
            if (getIsHydrating() && isForkedChild(workInProgress2)) {
              var slotIndex = workInProgress2.index;
              var numberOfForks = getForksAtLevel();
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          workInProgress2.lanes = NoLanes;
          switch (workInProgress2.tag) {
            case IndeterminateComponent: {
              return mountIndeterminateComponent(current3, workInProgress2, workInProgress2.type, renderLanes2);
            }
            case LazyComponent: {
              var elementType = workInProgress2.elementType;
              return mountLazyComponent(current3, workInProgress2, elementType, renderLanes2);
            }
            case FunctionComponent: {
              var Component2 = workInProgress2.type;
              var unresolvedProps = workInProgress2.pendingProps;
              var resolvedProps = workInProgress2.elementType === Component2 ? unresolvedProps : resolveDefaultProps(Component2, unresolvedProps);
              return updateFunctionComponent(current3, workInProgress2, Component2, resolvedProps, renderLanes2);
            }
            case ClassComponent: {
              var _Component = workInProgress2.type;
              var _unresolvedProps = workInProgress2.pendingProps;
              var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
              return updateClassComponent(current3, workInProgress2, _Component, _resolvedProps, renderLanes2);
            }
            case HostRoot:
              return updateHostRoot(current3, workInProgress2, renderLanes2);
            case HostComponent:
              return updateHostComponent(current3, workInProgress2, renderLanes2);
            case HostText:
              return updateHostText(current3, workInProgress2);
            case SuspenseComponent:
              return updateSuspenseComponent(current3, workInProgress2, renderLanes2);
            case HostPortal:
              return updatePortalComponent(current3, workInProgress2, renderLanes2);
            case ForwardRef2: {
              var type5 = workInProgress2.type;
              var _unresolvedProps2 = workInProgress2.pendingProps;
              var _resolvedProps2 = workInProgress2.elementType === type5 ? _unresolvedProps2 : resolveDefaultProps(type5, _unresolvedProps2);
              return updateForwardRef(current3, workInProgress2, type5, _resolvedProps2, renderLanes2);
            }
            case Fragment:
              return updateFragment(current3, workInProgress2, renderLanes2);
            case Mode:
              return updateMode(current3, workInProgress2, renderLanes2);
            case Profiler:
              return updateProfiler(current3, workInProgress2, renderLanes2);
            case ContextProvider:
              return updateContextProvider(current3, workInProgress2, renderLanes2);
            case ContextConsumer:
              return updateContextConsumer(current3, workInProgress2, renderLanes2);
            case MemoComponent: {
              var _type2 = workInProgress2.type;
              var _unresolvedProps3 = workInProgress2.pendingProps;
              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
              {
                if (workInProgress2.type !== workInProgress2.elementType) {
                  var outerPropTypes = _type2.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      _resolvedProps3,
                      // Resolved for outer only
                      "prop",
                      getComponentNameFromType(_type2)
                    );
                  }
                }
              }
              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
              return updateMemoComponent(current3, workInProgress2, _type2, _resolvedProps3, renderLanes2);
            }
            case SimpleMemoComponent: {
              return updateSimpleMemoComponent(current3, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
            }
            case IncompleteClassComponent: {
              var _Component2 = workInProgress2.type;
              var _unresolvedProps4 = workInProgress2.pendingProps;
              var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
              return mountIncompleteClassComponent(current3, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
            }
            case SuspenseListComponent: {
              return updateSuspenseListComponent(current3, workInProgress2, renderLanes2);
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent: {
              return updateOffscreenComponent(current3, workInProgress2, renderLanes2);
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= Update;
        }
        function markRef$1(workInProgress2) {
          workInProgress2.flags |= Ref2;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
        var appendAllChildren;
        var updateHostContainer;
        var updateHostComponent$1;
        var updateHostText$1;
        {
          appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
            var node = workInProgress2.child;
            while (node !== null) {
              if (node.tag === HostComponent || node.tag === HostText) {
                appendInitialChild(parent, node.stateNode);
              } else if (node.tag === HostPortal) ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          };
          updateHostContainer = function(current3, workInProgress2) {
          };
          updateHostComponent$1 = function(current3, workInProgress2, type5, newProps, rootContainerInstance) {
            var oldProps = current3.memoizedProps;
            if (oldProps === newProps) {
              return;
            }
            var instance = workInProgress2.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type5, oldProps, newProps, rootContainerInstance, currentHostContext);
            workInProgress2.updateQueue = updatePayload;
            if (updatePayload) {
              markUpdate(workInProgress2);
            }
          };
          updateHostText$1 = function(current3, workInProgress2, oldText, newText) {
            if (oldText !== newText) {
              markUpdate(workInProgress2);
            }
          };
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (getIsHydrating()) {
            return;
          }
          switch (renderState.tailMode) {
            case "hidden": {
              var tailNode = renderState.tail;
              var lastTailNode = null;
              while (tailNode !== null) {
                if (tailNode.alternate !== null) {
                  lastTailNode = tailNode;
                }
                tailNode = tailNode.sibling;
              }
              if (lastTailNode === null) {
                renderState.tail = null;
              } else {
                lastTailNode.sibling = null;
              }
              break;
            }
            case "collapsed": {
              var _tailNode = renderState.tail;
              var _lastTailNode = null;
              while (_tailNode !== null) {
                if (_tailNode.alternate !== null) {
                  _lastTailNode = _tailNode;
                }
                _tailNode = _tailNode.sibling;
              }
              if (_lastTailNode === null) {
                if (!hasRenderedATailFallback && renderState.tail !== null) {
                  renderState.tail.sibling = null;
                } else {
                  renderState.tail = null;
                }
              } else {
                _lastTailNode.sibling = null;
              }
              break;
            }
          }
        }
        function bubbleProperties(completedWork) {
          var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
          var newChildLanes = NoLanes;
          var subtreeFlags = NoFlags;
          if (!didBailout) {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var actualDuration = completedWork.actualDuration;
              var treeBaseDuration = completedWork.selfBaseDuration;
              var child = completedWork.child;
              while (child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                subtreeFlags |= child.subtreeFlags;
                subtreeFlags |= child.flags;
                actualDuration += child.actualDuration;
                treeBaseDuration += child.treeBaseDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
              completedWork.treeBaseDuration = treeBaseDuration;
            } else {
              var _child = completedWork.child;
              while (_child !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                subtreeFlags |= _child.subtreeFlags;
                subtreeFlags |= _child.flags;
                _child.return = completedWork;
                _child = _child.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          } else {
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              var _treeBaseDuration = completedWork.selfBaseDuration;
              var _child2 = completedWork.child;
              while (_child2 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                subtreeFlags |= _child2.subtreeFlags & StaticMask;
                subtreeFlags |= _child2.flags & StaticMask;
                _treeBaseDuration += _child2.treeBaseDuration;
                _child2 = _child2.sibling;
              }
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else {
              var _child3 = completedWork.child;
              while (_child3 !== null) {
                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                subtreeFlags |= _child3.subtreeFlags & StaticMask;
                subtreeFlags |= _child3.flags & StaticMask;
                _child3.return = completedWork;
                _child3 = _child3.sibling;
              }
            }
            completedWork.subtreeFlags |= subtreeFlags;
          }
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeDehydratedSuspenseBoundary(current3, workInProgress2, nextState) {
          if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
            warnIfUnhydratedTailNodes(workInProgress2);
            resetHydrationState();
            workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
            return false;
          }
          var wasHydrated = popHydrationState(workInProgress2);
          if (nextState !== null && nextState.dehydrated !== null) {
            if (current3 === null) {
              if (!wasHydrated) {
                throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
              }
              prepareToHydrateHostSuspenseInstance(workInProgress2);
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var isTimedOutSuspense = nextState !== null;
                  if (isTimedOutSuspense) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            } else {
              resetHydrationState();
              if ((workInProgress2.flags & DidCapture) === NoFlags) {
                workInProgress2.memoizedState = null;
              }
              workInProgress2.flags |= Update;
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  var _isTimedOutSuspense = nextState !== null;
                  if (_isTimedOutSuspense) {
                    var _primaryChildFragment = workInProgress2.child;
                    if (_primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return false;
            }
          } else {
            upgradeHydrationErrorsToRecoverable();
            return true;
          }
        }
        function completeWork(current3, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case LazyComponent:
            case SimpleMemoComponent:
            case FunctionComponent:
            case ForwardRef2:
            case Fragment:
            case Mode:
            case Profiler:
            case ContextConsumer:
            case MemoComponent:
              bubbleProperties(workInProgress2);
              return null;
            case ClassComponent: {
              var Component2 = workInProgress2.type;
              if (isContextProvider(Component2)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostRoot: {
              var fiberRoot = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              if (fiberRoot.pendingContext) {
                fiberRoot.context = fiberRoot.pendingContext;
                fiberRoot.pendingContext = null;
              }
              if (current3 === null || current3.child === null) {
                var wasHydrated = popHydrationState(workInProgress2);
                if (wasHydrated) {
                  markUpdate(workInProgress2);
                } else {
                  if (current3 !== null) {
                    var prevState = current3.memoizedState;
                    if (
                      // Check if this is a client root
                      !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                      (workInProgress2.flags & ForceClientRender) !== NoFlags
                    ) {
                      workInProgress2.flags |= Snapshot;
                      upgradeHydrationErrorsToRecoverable();
                    }
                  }
                }
              }
              updateHostContainer(current3, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              var rootContainerInstance = getRootHostContainer();
              var type5 = workInProgress2.type;
              if (current3 !== null && workInProgress2.stateNode != null) {
                updateHostComponent$1(current3, workInProgress2, type5, newProps, rootContainerInstance);
                if (current3.ref !== workInProgress2.ref) {
                  markRef$1(workInProgress2);
                }
              } else {
                if (!newProps) {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var currentHostContext = getHostContext();
                var _wasHydrated = popHydrationState(workInProgress2);
                if (_wasHydrated) {
                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  var instance = createInstance(type5, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                  appendAllChildren(instance, workInProgress2, false, false);
                  workInProgress2.stateNode = instance;
                  if (finalizeInitialChildren(instance, type5, newProps, rootContainerInstance)) {
                    markUpdate(workInProgress2);
                  }
                }
                if (workInProgress2.ref !== null) {
                  markRef$1(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case HostText: {
              var newText = newProps;
              if (current3 && workInProgress2.stateNode != null) {
                var oldText = current3.memoizedProps;
                updateHostText$1(current3, workInProgress2, oldText, newText);
              } else {
                if (typeof newText !== "string") {
                  if (workInProgress2.stateNode === null) {
                    throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                  }
                }
                var _rootContainerInstance = getRootHostContainer();
                var _currentHostContext = getHostContext();
                var _wasHydrated2 = popHydrationState(workInProgress2);
                if (_wasHydrated2) {
                  if (prepareToHydrateHostTextInstance(workInProgress2)) {
                    markUpdate(workInProgress2);
                  }
                } else {
                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var nextState = workInProgress2.memoizedState;
              if (current3 === null || current3.memoizedState !== null && current3.memoizedState.dehydrated !== null) {
                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current3, workInProgress2, nextState);
                if (!fallthroughToNormalSuspensePath) {
                  if (workInProgress2.flags & ShouldCapture) {
                    return workInProgress2;
                  } else {
                    return null;
                  }
                }
              }
              if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                workInProgress2.lanes = renderLanes2;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              var nextDidTimeout = nextState !== null;
              var prevDidTimeout = current3 !== null && current3.memoizedState !== null;
              if (nextDidTimeout !== prevDidTimeout) {
                if (nextDidTimeout) {
                  var _offscreenFiber2 = workInProgress2.child;
                  _offscreenFiber2.flags |= Visibility;
                  if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                    var hasInvisibleChildContext = current3 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                      renderDidSuspend();
                    } else {
                      renderDidSuspendDelayIfPossible();
                    }
                  }
                }
              }
              var wakeables = workInProgress2.updateQueue;
              if (wakeables !== null) {
                workInProgress2.flags |= Update;
              }
              bubbleProperties(workInProgress2);
              {
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  if (nextDidTimeout) {
                    var primaryChildFragment = workInProgress2.child;
                    if (primaryChildFragment !== null) {
                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                    }
                  }
                }
              }
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              updateHostContainer(current3, workInProgress2);
              if (current3 === null) {
                preparePortalMount(workInProgress2.stateNode.containerInfo);
              }
              bubbleProperties(workInProgress2);
              return null;
            case ContextProvider:
              var context2 = workInProgress2.type._context;
              popProvider(context2, workInProgress2);
              bubbleProperties(workInProgress2);
              return null;
            case IncompleteClassComponent: {
              var _Component = workInProgress2.type;
              if (isContextProvider(_Component)) {
                popContext(workInProgress2);
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              var renderState = workInProgress2.memoizedState;
              if (renderState === null) {
                bubbleProperties(workInProgress2);
                return null;
              }
              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
              var renderedTail = renderState.rendering;
              if (renderedTail === null) {
                if (!didSuspendAlready) {
                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current3 === null || (current3.flags & DidCapture) === NoFlags);
                  if (!cannotBeSuspended) {
                    var row = workInProgress2.child;
                    while (row !== null) {
                      var suspended = findFirstSuspended(row);
                      if (suspended !== null) {
                        didSuspendAlready = true;
                        workInProgress2.flags |= DidCapture;
                        cutOffTailIfNeeded(renderState, false);
                        var newThenables = suspended.updateQueue;
                        if (newThenables !== null) {
                          workInProgress2.updateQueue = newThenables;
                          workInProgress2.flags |= Update;
                        }
                        workInProgress2.subtreeFlags = NoFlags;
                        resetChildFibers(workInProgress2, renderLanes2);
                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                        return workInProgress2.child;
                      }
                      row = row.sibling;
                    }
                  }
                  if (renderState.tail !== null && now() > getRenderTargetTime()) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                } else {
                  cutOffTailIfNeeded(renderState, false);
                }
              } else {
                if (!didSuspendAlready) {
                  var _suspended = findFirstSuspended(renderedTail);
                  if (_suspended !== null) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    var _newThenables = _suspended.updateQueue;
                    if (_newThenables !== null) {
                      workInProgress2.updateQueue = _newThenables;
                      workInProgress2.flags |= Update;
                    }
                    cutOffTailIfNeeded(renderState, true);
                    if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                      bubbleProperties(workInProgress2);
                      return null;
                    }
                  } else if (
                    // The time it took to render last row is greater than the remaining
                    // time we have to render. So rendering one more row would likely
                    // exceed it.
                    now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                  ) {
                    workInProgress2.flags |= DidCapture;
                    didSuspendAlready = true;
                    cutOffTailIfNeeded(renderState, false);
                    workInProgress2.lanes = SomeRetryLane;
                  }
                }
                if (renderState.isBackwards) {
                  renderedTail.sibling = workInProgress2.child;
                  workInProgress2.child = renderedTail;
                } else {
                  var previousSibling = renderState.last;
                  if (previousSibling !== null) {
                    previousSibling.sibling = renderedTail;
                  } else {
                    workInProgress2.child = renderedTail;
                  }
                  renderState.last = renderedTail;
                }
              }
              if (renderState.tail !== null) {
                var next = renderState.tail;
                renderState.rendering = next;
                renderState.tail = next.sibling;
                renderState.renderingStartTime = now();
                next.sibling = null;
                var suspenseContext = suspenseStackCursor.current;
                if (didSuspendAlready) {
                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                } else {
                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                }
                pushSuspenseContext(workInProgress2, suspenseContext);
                return next;
              }
              bubbleProperties(workInProgress2);
              return null;
            }
            case ScopeComponent: {
              break;
            }
            case OffscreenComponent:
            case LegacyHiddenComponent: {
              popRenderLanes(workInProgress2);
              var _nextState = workInProgress2.memoizedState;
              var nextIsHidden = _nextState !== null;
              if (current3 !== null) {
                var _prevState = current3.memoizedState;
                var prevIsHidden = _prevState !== null;
                if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.
                !enableLegacyHidden) {
                  workInProgress2.flags |= Visibility;
                }
              }
              if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                bubbleProperties(workInProgress2);
              } else {
                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                  bubbleProperties(workInProgress2);
                  {
                    if (workInProgress2.subtreeFlags & (Placement | Update)) {
                      workInProgress2.flags |= Visibility;
                    }
                  }
                }
              }
              return null;
            }
            case CacheComponent: {
              return null;
            }
            case TracingMarkerComponent: {
              return null;
            }
          }
          throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
        }
        function unwindWork(current3, workInProgress2, renderLanes2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case ClassComponent: {
              var Component2 = workInProgress2.type;
              if (isContextProvider(Component2)) {
                popContext(workInProgress2);
              }
              var flags = workInProgress2.flags;
              if (flags & ShouldCapture) {
                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case HostRoot: {
              var root2 = workInProgress2.stateNode;
              popHostContainer(workInProgress2);
              popTopLevelContextObject(workInProgress2);
              resetWorkInProgressVersions();
              var _flags = workInProgress2.flags;
              if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                return workInProgress2;
              }
              return null;
            }
            case HostComponent: {
              popHostContext(workInProgress2);
              return null;
            }
            case SuspenseComponent: {
              popSuspenseContext(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null && suspenseState.dehydrated !== null) {
                if (workInProgress2.alternate === null) {
                  throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                }
                resetHydrationState();
              }
              var _flags2 = workInProgress2.flags;
              if (_flags2 & ShouldCapture) {
                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                  transferActualDuration(workInProgress2);
                }
                return workInProgress2;
              }
              return null;
            }
            case SuspenseListComponent: {
              popSuspenseContext(workInProgress2);
              return null;
            }
            case HostPortal:
              popHostContainer(workInProgress2);
              return null;
            case ContextProvider:
              var context2 = workInProgress2.type._context;
              popProvider(context2, workInProgress2);
              return null;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(workInProgress2);
              return null;
            case CacheComponent:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current3, interruptedWork, renderLanes2) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case ClassComponent: {
              var childContextTypes = interruptedWork.type.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                popContext(interruptedWork);
              }
              break;
            }
            case HostRoot: {
              var root2 = interruptedWork.stateNode;
              popHostContainer(interruptedWork);
              popTopLevelContextObject(interruptedWork);
              resetWorkInProgressVersions();
              break;
            }
            case HostComponent: {
              popHostContext(interruptedWork);
              break;
            }
            case HostPortal:
              popHostContainer(interruptedWork);
              break;
            case SuspenseComponent:
              popSuspenseContext(interruptedWork);
              break;
            case SuspenseListComponent:
              popSuspenseContext(interruptedWork);
              break;
            case ContextProvider:
              var context2 = interruptedWork.type._context;
              popProvider(context2, interruptedWork);
              break;
            case OffscreenComponent:
            case LegacyHiddenComponent:
              popRenderLanes(interruptedWork);
              break;
          }
        }
        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        {
          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        }
        var offscreenSubtreeIsHidden = false;
        var offscreenSubtreeWasHidden = false;
        var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
        var nextEffect = null;
        var inProgressLanes = null;
        var inProgressRoot = null;
        function reportUncaughtErrorInDEV(error2) {
          {
            invokeGuardedCallback(null, function() {
              throw error2;
            });
            clearCaughtError();
          }
        }
        var callComponentWillUnmountWithTimer = function(current3, instance) {
          instance.props = current3.memoizedProps;
          instance.state = current3.memoizedState;
          if (current3.mode & ProfileMode) {
            try {
              startLayoutEffectTimer();
              instance.componentWillUnmount();
            } finally {
              recordLayoutEffectDuration(current3);
            }
          } else {
            instance.componentWillUnmount();
          }
        };
        function safelyCallCommitHookLayoutEffectListMount(current3, nearestMountedAncestor) {
          try {
            commitHookEffectListMount(Layout, current3);
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        function safelyCallComponentWillUnmount(current3, nearestMountedAncestor, instance) {
          try {
            callComponentWillUnmountWithTimer(current3, instance);
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        function safelyCallComponentDidMount(current3, nearestMountedAncestor, instance) {
          try {
            instance.componentDidMount();
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        function safelyAttachRef(current3, nearestMountedAncestor) {
          try {
            commitAttachRef(current3);
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        function safelyDetachRef(current3, nearestMountedAncestor) {
          var ref = current3.ref;
          if (ref !== null) {
            if (typeof ref === "function") {
              var retVal;
              try {
                if (enableProfilerTimer && enableProfilerCommitHooks && current3.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(null);
                  } finally {
                    recordLayoutEffectDuration(current3);
                  }
                } else {
                  retVal = ref(null);
                }
              } catch (error2) {
                captureCommitPhaseError(current3, nearestMountedAncestor, error2);
              }
              {
                if (typeof retVal === "function") {
                  error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current3));
                }
              }
            } else {
              ref.current = null;
            }
          }
        }
        function safelyCallDestroy(current3, nearestMountedAncestor, destroy) {
          try {
            destroy();
          } catch (error2) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error2);
          }
        }
        var focusedInstanceHandle = null;
        var shouldFireAfterActiveInstanceBlur = false;
        function commitBeforeMutationEffects(root2, firstChild) {
          focusedInstanceHandle = prepareForCommit(root2.containerInfo);
          nextEffect = firstChild;
          commitBeforeMutationEffects_begin();
          var shouldFire = shouldFireAfterActiveInstanceBlur;
          shouldFireAfterActiveInstanceBlur = false;
          focusedInstanceHandle = null;
          return shouldFire;
        }
        function commitBeforeMutationEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitBeforeMutationEffects_complete();
            }
          }
        }
        function commitBeforeMutationEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              commitBeforeMutationEffectsOnFiber(fiber);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitBeforeMutationEffectsOnFiber(finishedWork) {
          var current3 = finishedWork.alternate;
          var flags = finishedWork.flags;
          if ((flags & Snapshot) !== NoFlags) {
            setCurrentFiber(finishedWork);
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case SimpleMemoComponent: {
                break;
              }
              case ClassComponent: {
                if (current3 !== null) {
                  var prevProps = current3.memoizedProps;
                  var prevState = current3.memoizedState;
                  var instance = finishedWork.stateNode;
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                  {
                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                      didWarnSet.add(finishedWork.type);
                      error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                    }
                  }
                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                }
                break;
              }
              case HostRoot: {
                {
                  var root2 = finishedWork.stateNode;
                  clearContainer(root2.containerInfo);
                }
                break;
              }
              case HostComponent:
              case HostText:
              case HostPortal:
              case IncompleteClassComponent:
                break;
              default: {
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            resetCurrentFiber();
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                var destroy = effect.destroy;
                effect.destroy = void 0;
                if (destroy !== void 0) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStarted(finishedWork);
                    }
                  }
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectUnmountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectUnmountStopped();
                    }
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitHookEffectListMount(flags, finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;
            do {
              if ((effect.tag & flags) === flags) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStarted(finishedWork);
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStarted(finishedWork);
                  }
                }
                var create2 = effect.create;
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                effect.destroy = create2();
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectMountStopped();
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectMountStopped();
                  }
                }
                {
                  var destroy = effect.destroy;
                  if (destroy !== void 0 && typeof destroy !== "function") {
                    var hookName = void 0;
                    if ((effect.tag & Layout) !== NoFlags) {
                      hookName = "useLayoutEffect";
                    } else if ((effect.tag & Insertion) !== NoFlags) {
                      hookName = "useInsertionEffect";
                    } else {
                      hookName = "useEffect";
                    }
                    var addendum = void 0;
                    if (destroy === null) {
                      addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                    } else if (typeof destroy.then === "function") {
                      addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                    } else {
                      addendum = " You returned: " + destroy;
                    }
                    error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                  }
                }
              }
              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }
        function commitPassiveEffectDurations(finishedRoot, finishedWork) {
          {
            if ((finishedWork.flags & Update) !== NoFlags) {
              switch (finishedWork.tag) {
                case Profiler: {
                  var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                  var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                  var commitTime2 = getCommitTime();
                  var phase = finishedWork.alternate === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onPostCommit === "function") {
                    onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                  }
                  var parentFiber = finishedWork.return;
                  outer: while (parentFiber !== null) {
                    switch (parentFiber.tag) {
                      case HostRoot:
                        var root2 = parentFiber.stateNode;
                        root2.passiveEffectDuration += passiveEffectDuration;
                        break outer;
                      case Profiler:
                        var parentStateNode = parentFiber.stateNode;
                        parentStateNode.passiveEffectDuration += passiveEffectDuration;
                        break outer;
                    }
                    parentFiber = parentFiber.return;
                  }
                  break;
                }
              }
            }
          }
        }
        function commitLayoutEffectOnFiber(finishedRoot, current3, finishedWork, committedLanes) {
          if ((finishedWork.flags & LayoutMask) !== NoFlags) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    } finally {
                      recordLayoutEffectDuration(finishedWork);
                    }
                  } else {
                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  }
                }
                break;
              }
              case ClassComponent: {
                var instance = finishedWork.stateNode;
                if (finishedWork.flags & Update) {
                  if (!offscreenSubtreeWasHidden) {
                    if (current3 === null) {
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidMount();
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidMount();
                      }
                    } else {
                      var prevProps = finishedWork.elementType === finishedWork.type ? current3.memoizedProps : resolveDefaultProps(finishedWork.type, current3.memoizedProps);
                      var prevState = current3.memoizedState;
                      {
                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                          if (instance.props !== finishedWork.memoizedProps) {
                            error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                          if (instance.state !== finishedWork.memoizedState) {
                            error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                          }
                        }
                      }
                      if (finishedWork.mode & ProfileMode) {
                        try {
                          startLayoutEffectTimer();
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        } finally {
                          recordLayoutEffectDuration(finishedWork);
                        }
                      } else {
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                      }
                    }
                  }
                }
                var updateQueue = finishedWork.updateQueue;
                if (updateQueue !== null) {
                  {
                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                      if (instance.props !== finishedWork.memoizedProps) {
                        error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                      if (instance.state !== finishedWork.memoizedState) {
                        error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                      }
                    }
                  }
                  commitUpdateQueue(finishedWork, updateQueue, instance);
                }
                break;
              }
              case HostRoot: {
                var _updateQueue = finishedWork.updateQueue;
                if (_updateQueue !== null) {
                  var _instance = null;
                  if (finishedWork.child !== null) {
                    switch (finishedWork.child.tag) {
                      case HostComponent:
                        _instance = getPublicInstance(finishedWork.child.stateNode);
                        break;
                      case ClassComponent:
                        _instance = finishedWork.child.stateNode;
                        break;
                    }
                  }
                  commitUpdateQueue(finishedWork, _updateQueue, _instance);
                }
                break;
              }
              case HostComponent: {
                var _instance2 = finishedWork.stateNode;
                if (current3 === null && finishedWork.flags & Update) {
                  var type5 = finishedWork.type;
                  var props3 = finishedWork.memoizedProps;
                  commitMount(_instance2, type5, props3);
                }
                break;
              }
              case HostText: {
                break;
              }
              case HostPortal: {
                break;
              }
              case Profiler: {
                {
                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                  var effectDuration = finishedWork.stateNode.effectDuration;
                  var commitTime2 = getCommitTime();
                  var phase = current3 === null ? "mount" : "update";
                  {
                    if (isCurrentUpdateNested()) {
                      phase = "nested-update";
                    }
                  }
                  if (typeof onRender === "function") {
                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                  }
                  {
                    if (typeof onCommit === "function") {
                      onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                    }
                    enqueuePendingPassiveProfilerEffect(finishedWork);
                    var parentFiber = finishedWork.return;
                    outer: while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root2 = parentFiber.stateNode;
                          root2.effectDuration += effectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.effectDuration += effectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                  }
                }
                break;
              }
              case SuspenseComponent: {
                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                break;
              }
              case SuspenseListComponent:
              case IncompleteClassComponent:
              case ScopeComponent:
              case OffscreenComponent:
              case LegacyHiddenComponent:
              case TracingMarkerComponent: {
                break;
              }
              default:
                throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          if (!offscreenSubtreeWasHidden) {
            {
              if (finishedWork.flags & Ref2) {
                commitAttachRef(finishedWork);
              }
            }
          }
        }
        function reappearLayoutEffectsOnFiber(node) {
          switch (node.tag) {
            case FunctionComponent:
            case ForwardRef2:
            case SimpleMemoComponent: {
              if (node.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                } finally {
                  recordLayoutEffectDuration(node);
                }
              } else {
                safelyCallCommitHookLayoutEffectListMount(node, node.return);
              }
              break;
            }
            case ClassComponent: {
              var instance = node.stateNode;
              if (typeof instance.componentDidMount === "function") {
                safelyCallComponentDidMount(node, node.return, instance);
              }
              safelyAttachRef(node, node.return);
              break;
            }
            case HostComponent: {
              safelyAttachRef(node, node.return);
              break;
            }
          }
        }
        function hideOrUnhideAllChildren(finishedWork, isHidden) {
          var hostSubtreeRoot = null;
          {
            var node = finishedWork;
            while (true) {
              if (node.tag === HostComponent) {
                if (hostSubtreeRoot === null) {
                  hostSubtreeRoot = node;
                  try {
                    var instance = node.stateNode;
                    if (isHidden) {
                      hideInstance(instance);
                    } else {
                      unhideInstance(node.stateNode, node.memoizedProps);
                    }
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
              } else if (node.tag === HostText) {
                if (hostSubtreeRoot === null) {
                  try {
                    var _instance3 = node.stateNode;
                    if (isHidden) {
                      hideTextInstance(_instance3);
                    } else {
                      unhideTextInstance(_instance3, node.memoizedProps);
                    }
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
              } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;
              else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === finishedWork) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node = node.return;
              }
              if (hostSubtreeRoot === node) {
                hostSubtreeRoot = null;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (ref !== null) {
            var instance = finishedWork.stateNode;
            var instanceToUse;
            switch (finishedWork.tag) {
              case HostComponent:
                instanceToUse = getPublicInstance(instance);
                break;
              default:
                instanceToUse = instance;
            }
            if (typeof ref === "function") {
              var retVal;
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref(instanceToUse);
                } finally {
                  recordLayoutEffectDuration(finishedWork);
                }
              } else {
                retVal = ref(instanceToUse);
              }
              {
                if (typeof retVal === "function") {
                  error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                }
              }
            } else {
              {
                if (!ref.hasOwnProperty("current")) {
                  error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                }
              }
              ref.current = instanceToUse;
            }
          }
        }
        function detachFiberMutation(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.return = null;
          }
          fiber.return = null;
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          if (alternate !== null) {
            fiber.alternate = null;
            detachFiberAfterEffects(alternate);
          }
          {
            fiber.child = null;
            fiber.deletions = null;
            fiber.sibling = null;
            if (fiber.tag === HostComponent) {
              var hostInstance = fiber.stateNode;
              if (hostInstance !== null) {
                detachDeletedInstance(hostInstance);
              }
            }
            fiber.stateNode = null;
            {
              fiber._debugOwner = null;
            }
            {
              fiber.return = null;
              fiber.dependencies = null;
              fiber.memoizedProps = null;
              fiber.memoizedState = null;
              fiber.pendingProps = null;
              fiber.stateNode = null;
              fiber.updateQueue = null;
            }
          }
        }
        function getHostParentFiber(fiber) {
          var parent = fiber.return;
          while (parent !== null) {
            if (isHostParent(parent)) {
              return parent;
            }
            parent = parent.return;
          }
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        }
        function isHostParent(fiber) {
          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
        }
        function getHostSibling(fiber) {
          var node = fiber;
          siblings: while (true) {
            while (node.sibling === null) {
              if (node.return === null || isHostParent(node.return)) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
            while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
              if (node.flags & Placement) {
                continue siblings;
              }
              if (node.child === null || node.tag === HostPortal) {
                continue siblings;
              } else {
                node.child.return = node;
                node = node.child;
              }
            }
            if (!(node.flags & Placement)) {
              return node.stateNode;
            }
          }
        }
        function commitPlacement(finishedWork) {
          var parentFiber = getHostParentFiber(finishedWork);
          switch (parentFiber.tag) {
            case HostComponent: {
              var parent = parentFiber.stateNode;
              if (parentFiber.flags & ContentReset) {
                resetTextContent(parent);
                parentFiber.flags &= ~ContentReset;
              }
              var before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            }
            case HostRoot:
            case HostPortal: {
              var _parent = parentFiber.stateNode.containerInfo;
              var _before = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
              break;
            }
            default:
              throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertInContainerBefore(parent, stateNode, before);
            } else {
              appendChildToContainer(parent, stateNode);
            }
          } else if (tag === HostPortal) ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNodeIntoContainer(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        function insertOrAppendPlacementNode(node, before, parent) {
          var tag = node.tag;
          var isHost = tag === HostComponent || tag === HostText;
          if (isHost) {
            var stateNode = node.stateNode;
            if (before) {
              insertBefore(parent, stateNode, before);
            } else {
              appendChild(parent, stateNode);
            }
          } else if (tag === HostPortal) ;
          else {
            var child = node.child;
            if (child !== null) {
              insertOrAppendPlacementNode(child, before, parent);
              var sibling = child.sibling;
              while (sibling !== null) {
                insertOrAppendPlacementNode(sibling, before, parent);
                sibling = sibling.sibling;
              }
            }
          }
        }
        var hostParent = null;
        var hostParentIsContainer = false;
        function commitDeletionEffects(root2, returnFiber, deletedFiber) {
          {
            var parent = returnFiber;
            findParent: while (parent !== null) {
              switch (parent.tag) {
                case HostComponent: {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break findParent;
                }
                case HostRoot: {
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break findParent;
                }
                case HostPortal: {
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break findParent;
                }
              }
              parent = parent.return;
            }
            if (hostParent === null) {
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            }
            commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
            hostParent = null;
            hostParentIsContainer = false;
          }
          detachFiberMutation(deletedFiber);
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          var child = parent.child;
          while (child !== null) {
            commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
            child = child.sibling;
          }
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          onCommitUnmount(deletedFiber);
          switch (deletedFiber.tag) {
            case HostComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
              }
            }
            case HostText: {
              {
                var prevHostParent = hostParent;
                var prevHostParentIsContainer = hostParentIsContainer;
                hostParent = null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = prevHostParent;
                hostParentIsContainer = prevHostParentIsContainer;
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    removeChildFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    removeChild(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case DehydratedFragment: {
              {
                if (hostParent !== null) {
                  if (hostParentIsContainer) {
                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                  } else {
                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                  }
                }
              }
              return;
            }
            case HostPortal: {
              {
                var _prevHostParent = hostParent;
                var _prevHostParentIsContainer = hostParentIsContainer;
                hostParent = deletedFiber.stateNode.containerInfo;
                hostParentIsContainer = true;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                hostParent = _prevHostParent;
                hostParentIsContainer = _prevHostParentIsContainer;
              }
              return;
            }
            case FunctionComponent:
            case ForwardRef2:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                var updateQueue = deletedFiber.updateQueue;
                if (updateQueue !== null) {
                  var lastEffect = updateQueue.lastEffect;
                  if (lastEffect !== null) {
                    var firstEffect = lastEffect.next;
                    var effect = firstEffect;
                    do {
                      var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                      if (destroy !== void 0) {
                        if ((tag & Insertion) !== NoFlags$1) {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        } else if ((tag & Layout) !== NoFlags$1) {
                          {
                            markComponentLayoutEffectUnmountStarted(deletedFiber);
                          }
                          if (deletedFiber.mode & ProfileMode) {
                            startLayoutEffectTimer();
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            recordLayoutEffectDuration(deletedFiber);
                          } else {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          }
                          {
                            markComponentLayoutEffectUnmountStopped();
                          }
                        }
                      }
                      effect = effect.next;
                    } while (effect !== firstEffect);
                  }
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ClassComponent: {
              if (!offscreenSubtreeWasHidden) {
                safelyDetachRef(deletedFiber, nearestMountedAncestor);
                var instance = deletedFiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                }
              }
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case ScopeComponent: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
            case OffscreenComponent: {
              if (
                // TODO: Remove this dead flag
                deletedFiber.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              }
              break;
            }
            default: {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              return;
            }
          }
        }
        function commitSuspenseCallback(finishedWork) {
          var newState = finishedWork.memoizedState;
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          var newState = finishedWork.memoizedState;
          if (newState === null) {
            var current3 = finishedWork.alternate;
            if (current3 !== null) {
              var prevState = current3.memoizedState;
              if (prevState !== null) {
                var suspenseInstance = prevState.dehydrated;
                if (suspenseInstance !== null) {
                  commitHydratedSuspenseInstance(suspenseInstance);
                }
              }
            }
          }
        }
        function attachSuspenseRetryListeners(finishedWork) {
          var wakeables = finishedWork.updateQueue;
          if (wakeables !== null) {
            finishedWork.updateQueue = null;
            var retryCache = finishedWork.stateNode;
            if (retryCache === null) {
              retryCache = finishedWork.stateNode = new PossiblyWeakSet();
            }
            wakeables.forEach(function(wakeable) {
              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
              if (!retryCache.has(wakeable)) {
                retryCache.add(wakeable);
                {
                  if (isDevToolsPresent) {
                    if (inProgressLanes !== null && inProgressRoot !== null) {
                      restorePendingUpdaters(inProgressRoot, inProgressLanes);
                    } else {
                      throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                    }
                  }
                }
                wakeable.then(retry, retry);
              }
            });
          }
        }
        function commitMutationEffects(root2, finishedWork, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          setCurrentFiber(finishedWork);
          commitMutationEffectsOnFiber(finishedWork, root2);
          setCurrentFiber(finishedWork);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
          var deletions = parentFiber.deletions;
          if (deletions !== null) {
            for (var i2 = 0; i2 < deletions.length; i2++) {
              var childToDelete = deletions[i2];
              try {
                commitDeletionEffects(root2, parentFiber, childToDelete);
              } catch (error2) {
                captureCommitPhaseError(childToDelete, parentFiber, error2);
              }
            }
          }
          var prevDebugFiber = getCurrentFiber();
          if (parentFiber.subtreeFlags & MutationMask) {
            var child = parentFiber.child;
            while (child !== null) {
              setCurrentFiber(child);
              commitMutationEffectsOnFiber(child, root2);
              child = child.sibling;
            }
          }
          setCurrentFiber(prevDebugFiber);
        }
        function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
          var current3 = finishedWork.alternate;
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef2:
            case MemoComponent:
            case SimpleMemoComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                try {
                  commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                  commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  recordLayoutEffectDuration(finishedWork);
                } else {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
              }
              return;
            }
            case ClassComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref2) {
                if (current3 !== null) {
                  safelyDetachRef(current3, current3.return);
                }
              }
              return;
            }
            case HostComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Ref2) {
                if (current3 !== null) {
                  safelyDetachRef(current3, current3.return);
                }
              }
              {
                if (finishedWork.flags & ContentReset) {
                  var instance = finishedWork.stateNode;
                  try {
                    resetTextContent(instance);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
                if (flags & Update) {
                  var _instance4 = finishedWork.stateNode;
                  if (_instance4 != null) {
                    var newProps = finishedWork.memoizedProps;
                    var oldProps = current3 !== null ? current3.memoizedProps : newProps;
                    var type5 = finishedWork.type;
                    var updatePayload = finishedWork.updateQueue;
                    finishedWork.updateQueue = null;
                    if (updatePayload !== null) {
                      try {
                        commitUpdate(_instance4, updatePayload, type5, oldProps, newProps, finishedWork);
                      } catch (error2) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostText: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (finishedWork.stateNode === null) {
                    throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                  }
                  var textInstance = finishedWork.stateNode;
                  var newText = finishedWork.memoizedProps;
                  var oldText = current3 !== null ? current3.memoizedProps : newText;
                  try {
                    commitTextUpdate(textInstance, oldText, newText);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                }
              }
              return;
            }
            case HostRoot: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                {
                  if (current3 !== null) {
                    var prevRootState = current3.memoizedState;
                    if (prevRootState.isDehydrated) {
                      try {
                        commitHydratedContainer(root2.containerInfo);
                      } catch (error2) {
                        captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                      }
                    }
                  }
                }
              }
              return;
            }
            case HostPortal: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
            case SuspenseComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              var offscreenFiber = finishedWork.child;
              if (offscreenFiber.flags & Visibility) {
                var offscreenInstance = offscreenFiber.stateNode;
                var newState = offscreenFiber.memoizedState;
                var isHidden = newState !== null;
                offscreenInstance.isHidden = isHidden;
                if (isHidden) {
                  var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                  if (!wasHidden) {
                    markCommitTimeOfFallback();
                  }
                }
              }
              if (flags & Update) {
                try {
                  commitSuspenseCallback(finishedWork);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case OffscreenComponent: {
              var _wasHidden = current3 !== null && current3.memoizedState !== null;
              if (
                // TODO: Remove this dead flag
                finishedWork.mode & ConcurrentMode
              ) {
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                recursivelyTraverseMutationEffects(root2, finishedWork);
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              } else {
                recursivelyTraverseMutationEffects(root2, finishedWork);
              }
              commitReconciliationEffects(finishedWork);
              if (flags & Visibility) {
                var _offscreenInstance = finishedWork.stateNode;
                var _newState = finishedWork.memoizedState;
                var _isHidden = _newState !== null;
                var offscreenBoundary = finishedWork;
                _offscreenInstance.isHidden = _isHidden;
                {
                  if (_isHidden) {
                    if (!_wasHidden) {
                      if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                        nextEffect = offscreenBoundary;
                        var offscreenChild = offscreenBoundary.child;
                        while (offscreenChild !== null) {
                          nextEffect = offscreenChild;
                          disappearLayoutEffects_begin(offscreenChild);
                          offscreenChild = offscreenChild.sibling;
                        }
                      }
                    }
                  }
                }
                {
                  hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                }
              }
              return;
            }
            case SuspenseListComponent: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & Update) {
                attachSuspenseRetryListeners(finishedWork);
              }
              return;
            }
            case ScopeComponent: {
              return;
            }
            default: {
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              return;
            }
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & Placement) {
            try {
              commitPlacement(finishedWork);
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
            finishedWork.flags &= ~Placement;
          }
          if (flags & Hydrating) {
            finishedWork.flags &= ~Hydrating;
          }
        }
        function commitLayoutEffects(finishedWork, root2, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          nextEffect = finishedWork;
          commitLayoutEffects_begin(finishedWork, root2, committedLanes);
          inProgressLanes = null;
          inProgressRoot = null;
        }
        function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
          var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent && isModernRoot) {
              var isHidden = fiber.memoizedState !== null;
              var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
              if (newOffscreenSubtreeIsHidden) {
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                continue;
              } else {
                var current3 = fiber.alternate;
                var wasHidden = current3 !== null && current3.memoizedState !== null;
                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                  nextEffect = fiber;
                  reappearLayoutEffects_begin(fiber);
                }
                var child = firstChild;
                while (child !== null) {
                  nextEffect = child;
                  commitLayoutEffects_begin(
                    child,
                    // New root; bubble back up to here and stop.
                    root2,
                    committedLanes
                  );
                  child = child.sibling;
                }
                nextEffect = fiber;
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                continue;
              }
            }
            if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
            }
          }
        }
        function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & LayoutMask) !== NoFlags) {
              var current3 = fiber.alternate;
              setCurrentFiber(fiber);
              try {
                commitLayoutEffectOnFiber(root2, current3, fiber, committedLanes);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function disappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (fiber.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  } finally {
                    recordLayoutEffectDuration(fiber);
                  }
                } else {
                  commitHookEffectListUnmount(Layout, fiber, fiber.return);
                }
                break;
              }
              case ClassComponent: {
                safelyDetachRef(fiber, fiber.return);
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
              case HostComponent: {
                safelyDetachRef(fiber, fiber.return);
                break;
              }
              case OffscreenComponent: {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  disappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
                break;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              disappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function disappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function reappearLayoutEffects_begin(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if (fiber.tag === OffscreenComponent) {
              var isHidden = fiber.memoizedState !== null;
              if (isHidden) {
                reappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
            }
            if (firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              reappearLayoutEffects_complete(subtreeRoot);
            }
          }
        }
        function reappearLayoutEffects_complete(subtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            try {
              reappearLayoutEffectsOnFiber(fiber);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
          nextEffect = finishedWork;
          commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
        }
        function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var firstChild = fiber.child;
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
              firstChild.return = fiber;
              nextEffect = firstChild;
            } else {
              commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
            }
          }
        }
        function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              try {
                commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
            }
            if (fiber === subtreeRoot) {
              nextEffect = null;
              return;
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef2:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                } finally {
                  recordPassiveEffectDuration(finishedWork);
                }
              } else {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffects(firstChild) {
          nextEffect = firstChild;
          commitPassiveUnmountEffects_begin();
        }
        function commitPassiveUnmountEffects_begin() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var child = fiber.child;
            if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
              var deletions = fiber.deletions;
              if (deletions !== null) {
                for (var i2 = 0; i2 < deletions.length; i2++) {
                  var fiberToDelete = deletions[i2];
                  nextEffect = fiberToDelete;
                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                }
                {
                  var previousFiber = fiber.alternate;
                  if (previousFiber !== null) {
                    var detachedChild = previousFiber.child;
                    if (detachedChild !== null) {
                      previousFiber.child = null;
                      do {
                        var detachedSibling = detachedChild.sibling;
                        detachedChild.sibling = null;
                        detachedChild = detachedSibling;
                      } while (detachedChild !== null);
                    }
                  }
                }
                nextEffect = fiber;
              }
            }
            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffects_complete();
            }
          }
        }
        function commitPassiveUnmountEffects_complete() {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            if ((fiber.flags & Passive) !== NoFlags) {
              setCurrentFiber(fiber);
              commitPassiveUnmountOnFiber(fiber);
              resetCurrentFiber();
            }
            var sibling = fiber.sibling;
            if (sibling !== null) {
              sibling.return = fiber.return;
              nextEffect = sibling;
              return;
            }
            nextEffect = fiber.return;
          }
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef2:
            case SimpleMemoComponent: {
              if (finishedWork.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                recordPassiveEffectDuration(finishedWork);
              } else {
                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              }
              break;
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            setCurrentFiber(fiber);
            commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
            resetCurrentFiber();
            var child = fiber.child;
            if (child !== null) {
              child.return = fiber;
              nextEffect = child;
            } else {
              commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
            }
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
          while (nextEffect !== null) {
            var fiber = nextEffect;
            var sibling = fiber.sibling;
            var returnFiber = fiber.return;
            {
              detachFiberAfterEffects(fiber);
              if (fiber === deletedSubtreeRoot) {
                nextEffect = null;
                return;
              }
            }
            if (sibling !== null) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              return;
            }
            nextEffect = returnFiber;
          }
        }
        function commitPassiveUnmountInsideDeletedTreeOnFiber(current3, nearestMountedAncestor) {
          switch (current3.tag) {
            case FunctionComponent:
            case ForwardRef2:
            case SimpleMemoComponent: {
              if (current3.mode & ProfileMode) {
                startPassiveEffectTimer();
                commitHookEffectListUnmount(Passive$1, current3, nearestMountedAncestor);
                recordPassiveEffectDuration(current3);
              } else {
                commitHookEffectListUnmount(Passive$1, current3, nearestMountedAncestor);
              }
              break;
            }
          }
        }
        function invokeLayoutEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Layout | HasEffect, fiber);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                try {
                  instance.componentDidMount();
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectMountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                break;
              }
            }
          }
        }
        function invokeLayoutEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                break;
              }
              case ClassComponent: {
                var instance = fiber.stateNode;
                if (typeof instance.componentWillUnmount === "function") {
                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                }
                break;
              }
            }
          }
        }
        function invokePassiveEffectUnmountInDEV(fiber) {
          {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef2:
              case SimpleMemoComponent: {
                try {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
              }
            }
          }
        }
        var COMPONENT_TYPE = 0;
        var HAS_PSEUDO_CLASS_TYPE = 1;
        var ROLE_TYPE = 2;
        var TEST_NAME_TYPE = 3;
        var TEXT_TYPE = 4;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          COMPONENT_TYPE = symbolFor("selector.component");
          HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
          ROLE_TYPE = symbolFor("selector.role");
          TEST_NAME_TYPE = symbolFor("selector.test_id");
          TEXT_TYPE = symbolFor("selector.text");
        }
        var commitHooks = [];
        function onCommitRoot$1() {
          {
            commitHooks.forEach(function(commitHook) {
              return commitHook();
            });
          }
        }
        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
        function isLegacyActEnvironment(fiber) {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            var jestIsDefined = typeof jest !== "undefined";
            return jestIsDefined && isReactActEnvironmentGlobal !== false;
          }
        }
        function isConcurrentActEnvironment() {
          {
            var isReactActEnvironmentGlobal = (
              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
              typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
            );
            if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
              error("The current testing environment is not configured to support act(...)");
            }
            return isReactActEnvironmentGlobal;
          }
        }
        var ceil2 = Math.ceil;
        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
        var NoContext = (
          /*             */
          0
        );
        var BatchedContext = (
          /*               */
          1
        );
        var RenderContext = (
          /*                */
          2
        );
        var CommitContext = (
          /*                */
          4
        );
        var RootInProgress = 0;
        var RootFatalErrored = 1;
        var RootErrored = 2;
        var RootSuspended = 3;
        var RootSuspendedWithDelay = 4;
        var RootCompleted = 5;
        var RootDidNotComplete = 6;
        var executionContext = NoContext;
        var workInProgressRoot = null;
        var workInProgress = null;
        var workInProgressRootRenderLanes = NoLanes;
        var subtreeRenderLanes = NoLanes;
        var subtreeRenderLanesCursor = createCursor(NoLanes);
        var workInProgressRootExitStatus = RootInProgress;
        var workInProgressRootFatalError = null;
        var workInProgressRootIncludedLanes = NoLanes;
        var workInProgressRootSkippedLanes = NoLanes;
        var workInProgressRootInterleavedUpdatedLanes = NoLanes;
        var workInProgressRootPingedLanes = NoLanes;
        var workInProgressRootConcurrentErrors = null;
        var workInProgressRootRecoverableErrors = null;
        var globalMostRecentFallbackTime = 0;
        var FALLBACK_THROTTLE_MS = 500;
        var workInProgressRootRenderTargetTime = Infinity;
        var RENDER_TIMEOUT_MS = 500;
        var workInProgressTransitions = null;
        function resetRenderTimer() {
          workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
        }
        function getRenderTargetTime() {
          return workInProgressRootRenderTargetTime;
        }
        var hasUncaughtError = false;
        var firstUncaughtError = null;
        var legacyErrorBoundariesThatAlreadyFailed = null;
        var rootDoesHavePassiveEffects = false;
        var rootWithPendingPassiveEffects = null;
        var pendingPassiveEffectsLanes = NoLanes;
        var pendingPassiveProfilerEffects = [];
        var pendingPassiveTransitions = null;
        var NESTED_UPDATE_LIMIT = 50;
        var nestedUpdateCount = 0;
        var rootWithNestedUpdates = null;
        var isFlushingPassiveEffects = false;
        var didScheduleUpdateDuringPassiveEffects = false;
        var NESTED_PASSIVE_UPDATE_LIMIT = 50;
        var nestedPassiveUpdateCount = 0;
        var rootWithPassiveNestedUpdates = null;
        var currentEventTime = NoTimestamp;
        var currentEventTransitionLane = NoLanes;
        var isRunningInsertionEffect = false;
        function getWorkInProgressRoot() {
          return workInProgressRoot;
        }
        function requestEventTime() {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            return now();
          }
          if (currentEventTime !== NoTimestamp) {
            return currentEventTime;
          }
          currentEventTime = now();
          return currentEventTime;
        }
        function requestUpdateLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
            return pickArbitraryLane(workInProgressRootRenderLanes);
          }
          var isTransition = requestCurrentTransition() !== NoTransition;
          if (isTransition) {
            if (ReactCurrentBatchConfig$3.transition !== null) {
              var transition = ReactCurrentBatchConfig$3.transition;
              if (!transition._updatedFibers) {
                transition._updatedFibers = /* @__PURE__ */ new Set();
              }
              transition._updatedFibers.add(fiber);
            }
            if (currentEventTransitionLane === NoLane) {
              currentEventTransitionLane = claimNextTransitionLane();
            }
            return currentEventTransitionLane;
          }
          var updateLane = getCurrentUpdatePriority();
          if (updateLane !== NoLane) {
            return updateLane;
          }
          var eventLane = getCurrentEventPriority();
          return eventLane;
        }
        function requestRetryLane(fiber) {
          var mode = fiber.mode;
          if ((mode & ConcurrentMode) === NoMode) {
            return SyncLane;
          }
          return claimNextRetryLane();
        }
        function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
          checkForNestedUpdates();
          {
            if (isRunningInsertionEffect) {
              error("useInsertionEffect must not schedule updates.");
            }
          }
          {
            if (isFlushingPassiveEffects) {
              didScheduleUpdateDuringPassiveEffects = true;
            }
          }
          markRootUpdated(root2, lane, eventTime);
          if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
            warnAboutRenderPhaseUpdatesInDEV(fiber);
          } else {
            {
              if (isDevToolsPresent) {
                addFiberToLanesMap(root2, fiber, lane);
              }
            }
            warnIfUpdatesNotWrappedWithActDEV(fiber);
            if (root2 === workInProgressRoot) {
              if ((executionContext & RenderContext) === NoContext) {
                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
              }
              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                markRootSuspended$1(root2, workInProgressRootRenderLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
            if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
          var current3 = root2.current;
          current3.lanes = lane;
          markRootUpdated(root2, lane, eventTime);
          ensureRootIsScheduled(root2, eventTime);
        }
        function isUnsafeClassRenderPhaseUpdate(fiber) {
          return (
            // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
            // decided not to enable it.
            (executionContext & RenderContext) !== NoContext
          );
        }
        function ensureRootIsScheduled(root2, currentTime) {
          var existingCallbackNode = root2.callbackNode;
          markStarvedLanesAsExpired(root2, currentTime);
          var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (nextLanes === NoLanes) {
            if (existingCallbackNode !== null) {
              cancelCallback$1(existingCallbackNode);
            }
            root2.callbackNode = null;
            root2.callbackPriority = NoLane;
            return;
          }
          var newCallbackPriority = getHighestPriorityLane(nextLanes);
          var existingCallbackPriority = root2.callbackPriority;
          if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
          // Scheduler task, rather than an `act` task, cancel it and re-scheduled
          // on the `act` queue.
          !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
            {
              if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            return;
          }
          if (existingCallbackNode != null) {
            cancelCallback$1(existingCallbackNode);
          }
          var newCallbackNode;
          if (newCallbackPriority === SyncLane) {
            if (root2.tag === LegacyRoot) {
              if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
              }
              scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
            } else {
              scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
            }
            {
              if (ReactCurrentActQueue$1.current !== null) {
                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
              } else {
                scheduleMicrotask(function() {
                  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                    flushSyncCallbacks();
                  }
                });
              }
            }
            newCallbackNode = null;
          } else {
            var schedulerPriorityLevel;
            switch (lanesToEventPriority(nextLanes)) {
              case DiscreteEventPriority:
                schedulerPriorityLevel = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriorityLevel = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriorityLevel = NormalPriority;
                break;
              case IdleEventPriority:
                schedulerPriorityLevel = IdlePriority;
                break;
              default:
                schedulerPriorityLevel = NormalPriority;
                break;
            }
            newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
          }
          root2.callbackPriority = newCallbackPriority;
          root2.callbackNode = newCallbackNode;
        }
        function performConcurrentWorkOnRoot(root2, didTimeout) {
          {
            resetNestedUpdateFlag();
          }
          currentEventTime = NoTimestamp;
          currentEventTransitionLane = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var originalCallbackNode = root2.callbackNode;
          var didFlushPassiveEffects = flushPassiveEffects();
          if (didFlushPassiveEffects) {
            if (root2.callbackNode !== originalCallbackNode) {
              return null;
            }
          }
          var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
          if (lanes === NoLanes) {
            return null;
          }
          var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
          var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
          if (exitStatus !== RootInProgress) {
            if (exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              markRootSuspended$1(root2, lanes);
            } else {
              var renderWasConcurrent = !includesBlockingLane(root2, lanes);
              var finishedWork = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                exitStatus = renderRootSync(root2, lanes);
                if (exitStatus === RootErrored) {
                  var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                  if (_errorRetryLanes !== NoLanes) {
                    lanes = _errorRetryLanes;
                    exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                  }
                }
                if (exitStatus === RootFatalErrored) {
                  var _fatalError = workInProgressRootFatalError;
                  prepareFreshStack(root2, NoLanes);
                  markRootSuspended$1(root2, lanes);
                  ensureRootIsScheduled(root2, now());
                  throw _fatalError;
                }
              }
              root2.finishedWork = finishedWork;
              root2.finishedLanes = lanes;
              finishConcurrentRender(root2, exitStatus, lanes);
            }
          }
          ensureRootIsScheduled(root2, now());
          if (root2.callbackNode === originalCallbackNode) {
            return performConcurrentWorkOnRoot.bind(null, root2);
          }
          return null;
        }
        function recoverFromConcurrentError(root2, errorRetryLanes) {
          var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
          if (isRootDehydrated(root2)) {
            var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
            rootWorkInProgress.flags |= ForceClientRender;
            {
              errorHydratingContainer(root2.containerInfo);
            }
          }
          var exitStatus = renderRootSync(root2, errorRetryLanes);
          if (exitStatus !== RootErrored) {
            var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
            workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
            if (errorsFromSecondAttempt !== null) {
              queueRecoverableErrors(errorsFromSecondAttempt);
            }
          }
          return exitStatus;
        }
        function queueRecoverableErrors(errors) {
          if (workInProgressRootRecoverableErrors === null) {
            workInProgressRootRecoverableErrors = errors;
          } else {
            workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
          }
        }
        function finishConcurrentRender(root2, exitStatus, lanes) {
          switch (exitStatus) {
            case RootInProgress:
            case RootFatalErrored: {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            case RootErrored: {
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspended: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
              !shouldForceFlushFallbacksInDEV()) {
                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
                if (msUntilTimeout > 10) {
                  var nextLanes = getNextLanes(root2, NoLanes);
                  if (nextLanes !== NoLanes) {
                    break;
                  }
                  var suspendedLanes = root2.suspendedLanes;
                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                    var eventTime = requestEventTime();
                    markRootPinged(root2, suspendedLanes);
                    break;
                  }
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootSuspendedWithDelay: {
              markRootSuspended$1(root2, lanes);
              if (includesOnlyTransitions(lanes)) {
                break;
              }
              if (!shouldForceFlushFallbacksInDEV()) {
                var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                var eventTimeMs = mostRecentEventTime;
                var timeElapsedMs = now() - eventTimeMs;
                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                if (_msUntilTimeout > 10) {
                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                  break;
                }
              }
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            case RootCompleted: {
              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
              break;
            }
            default: {
              throw new Error("Unknown root exit status.");
            }
          }
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          var node = finishedWork;
          while (true) {
            if (node.flags & StoreConsistency) {
              var updateQueue = node.updateQueue;
              if (updateQueue !== null) {
                var checks = updateQueue.stores;
                if (checks !== null) {
                  for (var i2 = 0; i2 < checks.length; i2++) {
                    var check2 = checks[i2];
                    var getSnapshot = check2.getSnapshot;
                    var renderedValue = check2.value;
                    try {
                      if (!objectIs(getSnapshot(), renderedValue)) {
                        return false;
                      }
                    } catch (error2) {
                      return false;
                    }
                  }
                }
              }
            }
            var child = node.child;
            if (node.subtreeFlags & StoreConsistency && child !== null) {
              child.return = node;
              node = child;
              continue;
            }
            if (node === finishedWork) {
              return true;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return true;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
          return true;
        }
        function markRootSuspended$1(root2, suspendedLanes) {
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
          markRootSuspended(root2, suspendedLanes);
        }
        function performSyncWorkOnRoot(root2) {
          {
            syncNestedUpdateFlag();
          }
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          flushPassiveEffects();
          var lanes = getNextLanes(root2, NoLanes);
          if (!includesSomeLane(lanes, SyncLane)) {
            ensureRootIsScheduled(root2, now());
            return null;
          }
          var exitStatus = renderRootSync(root2, lanes);
          if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root2, NoLanes);
            markRootSuspended$1(root2, lanes);
            ensureRootIsScheduled(root2, now());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          var finishedWork = root2.current.alternate;
          root2.finishedWork = finishedWork;
          root2.finishedLanes = lanes;
          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
          ensureRootIsScheduled(root2, now());
          return null;
        }
        function flushRoot(root2, lanes) {
          if (lanes !== NoLanes) {
            markRootEntangled(root2, mergeLanes(lanes, SyncLane));
            ensureRootIsScheduled(root2, now());
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              resetRenderTimer();
              flushSyncCallbacks();
            }
          }
        }
        function batchedUpdates$1(fn2, a2) {
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          try {
            return fn2(a2);
          } finally {
            executionContext = prevExecutionContext;
            if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
            !ReactCurrentActQueue$1.isBatchingLegacy) {
              resetRenderTimer();
              flushSyncCallbacksOnlyInLegacyMode();
            }
          }
        }
        function discreteUpdates(fn2, a2, b, c2, d2) {
          var previousPriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            return fn2(a2, b, c2, d2);
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            if (executionContext === NoContext) {
              resetRenderTimer();
            }
          }
        }
        function flushSync(fn2) {
          if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushPassiveEffects();
          }
          var prevExecutionContext = executionContext;
          executionContext |= BatchedContext;
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            if (fn2) {
              return fn2();
            } else {
              return void 0;
            }
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
            executionContext = prevExecutionContext;
            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushSyncCallbacks();
            }
          }
        }
        function isAlreadyRendering() {
          return (executionContext & (RenderContext | CommitContext)) !== NoContext;
        }
        function pushRenderLanes(fiber, lanes) {
          push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
        }
        function popRenderLanes(fiber) {
          subtreeRenderLanes = subtreeRenderLanesCursor.current;
          pop(subtreeRenderLanesCursor, fiber);
        }
        function prepareFreshStack(root2, lanes) {
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          var timeoutHandle = root2.timeoutHandle;
          if (timeoutHandle !== noTimeout) {
            root2.timeoutHandle = noTimeout;
            cancelTimeout(timeoutHandle);
          }
          if (workInProgress !== null) {
            var interruptedWork = workInProgress.return;
            while (interruptedWork !== null) {
              var current3 = interruptedWork.alternate;
              unwindInterruptedWork(current3, interruptedWork);
              interruptedWork = interruptedWork.return;
            }
          }
          workInProgressRoot = root2;
          var rootWorkInProgress = createWorkInProgress(root2.current, null);
          workInProgress = rootWorkInProgress;
          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressRootFatalError = null;
          workInProgressRootSkippedLanes = NoLanes;
          workInProgressRootInterleavedUpdatedLanes = NoLanes;
          workInProgressRootPingedLanes = NoLanes;
          workInProgressRootConcurrentErrors = null;
          workInProgressRootRecoverableErrors = null;
          finishQueueingConcurrentUpdates();
          {
            ReactStrictModeWarnings.discardPendingWarnings();
          }
          return rootWorkInProgress;
        }
        function handleError(root2, thrownValue) {
          do {
            var erroredWork = workInProgress;
            try {
              resetContextDependencies();
              resetHooksAfterThrow();
              resetCurrentFiber();
              ReactCurrentOwner$2.current = null;
              if (erroredWork === null || erroredWork.return === null) {
                workInProgressRootExitStatus = RootFatalErrored;
                workInProgressRootFatalError = thrownValue;
                workInProgress = null;
                return;
              }
              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
              }
              if (enableSchedulingProfiler) {
                markComponentRenderStopped();
                if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                  var wakeable = thrownValue;
                  markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                } else {
                  markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                }
              }
              throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
              completeUnitOfWork(erroredWork);
            } catch (yetAnotherThrownValue) {
              thrownValue = yetAnotherThrownValue;
              if (workInProgress === erroredWork && erroredWork !== null) {
                erroredWork = erroredWork.return;
                workInProgress = erroredWork;
              } else {
                erroredWork = workInProgress;
              }
              continue;
            }
            return;
          } while (true);
        }
        function pushDispatcher() {
          var prevDispatcher = ReactCurrentDispatcher$2.current;
          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
          if (prevDispatcher === null) {
            return ContextOnlyDispatcher;
          } else {
            return prevDispatcher;
          }
        }
        function popDispatcher(prevDispatcher) {
          ReactCurrentDispatcher$2.current = prevDispatcher;
        }
        function markCommitTimeOfFallback() {
          globalMostRecentFallbackTime = now();
        }
        function markSkippedUpdateLanes(lane) {
          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
        }
        function renderDidSuspend() {
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootSuspended;
          }
        }
        function renderDidSuspendDelayIfPossible() {
          if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
            workInProgressRootExitStatus = RootSuspendedWithDelay;
          }
          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
          }
        }
        function renderDidError(error2) {
          if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
            workInProgressRootExitStatus = RootErrored;
          }
          if (workInProgressRootConcurrentErrors === null) {
            workInProgressRootConcurrentErrors = [error2];
          } else {
            workInProgressRootConcurrentErrors.push(error2);
          }
        }
        function renderHasNotSuspendedYet() {
          return workInProgressRootExitStatus === RootInProgress;
        }
        function renderRootSync(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root2, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            prepareFreshStack(root2, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopSync();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          executionContext = prevExecutionContext;
          popDispatcher(prevDispatcher);
          if (workInProgress !== null) {
            throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
          }
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
        function workLoopSync() {
          while (workInProgress !== null) {
            performUnitOfWork(workInProgress);
          }
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                if (memoizedUpdaters.size > 0) {
                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                  memoizedUpdaters.clear();
                }
                movePendingFibersToMemoized(root2, lanes);
              }
            }
            workInProgressTransitions = getTransitionsForLanes();
            resetRenderTimer();
            prepareFreshStack(root2, lanes);
          }
          {
            markRenderStarted(lanes);
          }
          do {
            try {
              workLoopConcurrent();
              break;
            } catch (thrownValue) {
              handleError(root2, thrownValue);
            }
          } while (true);
          resetContextDependencies();
          popDispatcher(prevDispatcher);
          executionContext = prevExecutionContext;
          if (workInProgress !== null) {
            {
              markRenderYielded();
            }
            return RootInProgress;
          } else {
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
        }
        function workLoopConcurrent() {
          while (workInProgress !== null && !shouldYield()) {
            performUnitOfWork(workInProgress);
          }
        }
        function performUnitOfWork(unitOfWork) {
          var current3 = unitOfWork.alternate;
          setCurrentFiber(unitOfWork);
          var next;
          if ((unitOfWork.mode & ProfileMode) !== NoMode) {
            startProfilerTimer(unitOfWork);
            next = beginWork$1(current3, unitOfWork, subtreeRenderLanes);
            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
          } else {
            next = beginWork$1(current3, unitOfWork, subtreeRenderLanes);
          }
          resetCurrentFiber();
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          if (next === null) {
            completeUnitOfWork(unitOfWork);
          } else {
            workInProgress = next;
          }
          ReactCurrentOwner$2.current = null;
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            var current3 = completedWork.alternate;
            var returnFiber = completedWork.return;
            if ((completedWork.flags & Incomplete) === NoFlags) {
              setCurrentFiber(completedWork);
              var next = void 0;
              if ((completedWork.mode & ProfileMode) === NoMode) {
                next = completeWork(current3, completedWork, subtreeRenderLanes);
              } else {
                startProfilerTimer(completedWork);
                next = completeWork(current3, completedWork, subtreeRenderLanes);
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              }
              resetCurrentFiber();
              if (next !== null) {
                workInProgress = next;
                return;
              }
            } else {
              var _next = unwindWork(current3, completedWork);
              if (_next !== null) {
                _next.flags &= HostEffectMask;
                workInProgress = _next;
                return;
              }
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                var actualDuration = completedWork.actualDuration;
                var child = completedWork.child;
                while (child !== null) {
                  actualDuration += child.actualDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
              }
              if (returnFiber !== null) {
                returnFiber.flags |= Incomplete;
                returnFiber.subtreeFlags = NoFlags;
                returnFiber.deletions = null;
              } else {
                workInProgressRootExitStatus = RootDidNotComplete;
                workInProgress = null;
                return;
              }
            }
            var siblingFiber = completedWork.sibling;
            if (siblingFiber !== null) {
              workInProgress = siblingFiber;
              return;
            }
            completedWork = returnFiber;
            workInProgress = completedWork;
          } while (completedWork !== null);
          if (workInProgressRootExitStatus === RootInProgress) {
            workInProgressRootExitStatus = RootCompleted;
          }
        }
        function commitRoot(root2, recoverableErrors, transitions) {
          var previousUpdateLanePriority = getCurrentUpdatePriority();
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(DiscreteEventPriority);
            commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
          } finally {
            ReactCurrentBatchConfig$3.transition = prevTransition;
            setCurrentUpdatePriority(previousUpdateLanePriority);
          }
          return null;
        }
        function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
          do {
            flushPassiveEffects();
          } while (rootWithPendingPassiveEffects !== null);
          flushRenderPhaseStrictModeWarningsInDEV();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Should not already be working.");
          }
          var finishedWork = root2.finishedWork;
          var lanes = root2.finishedLanes;
          {
            markCommitStarted(lanes);
          }
          if (finishedWork === null) {
            {
              markCommitStopped();
            }
            return null;
          } else {
            {
              if (lanes === NoLanes) {
                error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
              }
            }
          }
          root2.finishedWork = null;
          root2.finishedLanes = NoLanes;
          if (finishedWork === root2.current) {
            throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
          }
          root2.callbackNode = null;
          root2.callbackPriority = NoLane;
          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
          markRootFinished(root2, remainingLanes);
          if (root2 === workInProgressRoot) {
            workInProgressRoot = null;
            workInProgress = null;
            workInProgressRootRenderLanes = NoLanes;
          }
          if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              pendingPassiveTransitions = transitions;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
          var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
          if (subtreeHasEffects || rootHasEffect) {
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            ReactCurrentBatchConfig$3.transition = null;
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(DiscreteEventPriority);
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            ReactCurrentOwner$2.current = null;
            var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);
            {
              recordCommitTime();
            }
            commitMutationEffects(root2, finishedWork, lanes);
            resetAfterCommit(root2.containerInfo);
            root2.current = finishedWork;
            {
              markLayoutEffectsStarted(lanes);
            }
            commitLayoutEffects(finishedWork, root2, lanes);
            {
              markLayoutEffectsStopped();
            }
            requestPaint();
            executionContext = prevExecutionContext;
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          } else {
            root2.current = finishedWork;
            {
              recordCommitTime();
            }
          }
          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
          if (rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = false;
            rootWithPendingPassiveEffects = root2;
            pendingPassiveEffectsLanes = lanes;
          } else {
            {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
            }
          }
          remainingLanes = root2.pendingLanes;
          if (remainingLanes === NoLanes) {
            legacyErrorBoundariesThatAlreadyFailed = null;
          }
          {
            if (!rootDidHavePassiveEffects) {
              commitDoubleInvokeEffectsInDEV(root2.current, false);
            }
          }
          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
          {
            if (isDevToolsPresent) {
              root2.memoizedUpdaters.clear();
            }
          }
          {
            onCommitRoot$1();
          }
          ensureRootIsScheduled(root2, now());
          if (recoverableErrors !== null) {
            var onRecoverableError = root2.onRecoverableError;
            for (var i2 = 0; i2 < recoverableErrors.length; i2++) {
              var recoverableError = recoverableErrors[i2];
              var componentStack = recoverableError.stack;
              var digest = recoverableError.digest;
              onRecoverableError(recoverableError.value, {
                componentStack,
                digest
              });
            }
          }
          if (hasUncaughtError) {
            hasUncaughtError = false;
            var error$1 = firstUncaughtError;
            firstUncaughtError = null;
            throw error$1;
          }
          if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
            flushPassiveEffects();
          }
          remainingLanes = root2.pendingLanes;
          if (includesSomeLane(remainingLanes, SyncLane)) {
            {
              markNestedUpdateScheduled();
            }
            if (root2 === rootWithNestedUpdates) {
              nestedUpdateCount++;
            } else {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = root2;
            }
          } else {
            nestedUpdateCount = 0;
          }
          flushSyncCallbacks();
          {
            markCommitStopped();
          }
          return null;
        }
        function flushPassiveEffects() {
          if (rootWithPendingPassiveEffects !== null) {
            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
            var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(priority);
              return flushPassiveEffectsImpl();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            }
          }
          return false;
        }
        function enqueuePendingPassiveProfilerEffect(fiber) {
          {
            pendingPassiveProfilerEffects.push(fiber);
            if (!rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = true;
              scheduleCallback$1(NormalPriority, function() {
                flushPassiveEffects();
                return null;
              });
            }
          }
        }
        function flushPassiveEffectsImpl() {
          if (rootWithPendingPassiveEffects === null) {
            return false;
          }
          var transitions = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root2 = rootWithPendingPassiveEffects;
          var lanes = pendingPassiveEffectsLanes;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = NoLanes;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
            throw new Error("Cannot flush passive effects while already rendering.");
          }
          {
            isFlushingPassiveEffects = true;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          {
            markPassiveEffectsStarted(lanes);
          }
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          commitPassiveUnmountEffects(root2.current);
          commitPassiveMountEffects(root2, root2.current, lanes, transitions);
          {
            var profilerEffects = pendingPassiveProfilerEffects;
            pendingPassiveProfilerEffects = [];
            for (var i2 = 0; i2 < profilerEffects.length; i2++) {
              var _fiber = profilerEffects[i2];
              commitPassiveEffectDurations(root2, _fiber);
            }
          }
          {
            markPassiveEffectsStopped();
          }
          {
            commitDoubleInvokeEffectsInDEV(root2.current, true);
          }
          executionContext = prevExecutionContext;
          flushSyncCallbacks();
          {
            if (didScheduleUpdateDuringPassiveEffects) {
              if (root2 === rootWithPassiveNestedUpdates) {
                nestedPassiveUpdateCount++;
              } else {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = root2;
              }
            } else {
              nestedPassiveUpdateCount = 0;
            }
            isFlushingPassiveEffects = false;
            didScheduleUpdateDuringPassiveEffects = false;
          }
          onPostCommitRoot(root2);
          {
            var stateNode = root2.current.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
          return true;
        }
        function isAlreadyFailedLegacyErrorBoundary(instance) {
          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
        }
        function markLegacyErrorBoundaryAsFailed(instance) {
          if (legacyErrorBoundariesThatAlreadyFailed === null) {
            legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
          } else {
            legacyErrorBoundariesThatAlreadyFailed.add(instance);
          }
        }
        function prepareToThrowUncaughtError(error2) {
          if (!hasUncaughtError) {
            hasUncaughtError = true;
            firstUncaughtError = error2;
          }
        }
        var onUncaughtError = prepareToThrowUncaughtError;
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
          var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
          var update4 = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
          var root2 = enqueueUpdate(rootFiber, update4, SyncLane);
          var eventTime = requestEventTime();
          if (root2 !== null) {
            markRootUpdated(root2, SyncLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
          {
            reportUncaughtErrorInDEV(error$1);
            setIsRunningInsertionEffect(false);
          }
          if (sourceFiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
            return;
          }
          var fiber = null;
          {
            fiber = nearestMountedAncestor;
          }
          while (fiber !== null) {
            if (fiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
              return;
            } else if (fiber.tag === ClassComponent) {
              var ctor = fiber.type;
              var instance = fiber.stateNode;
              if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                var update4 = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                var root2 = enqueueUpdate(fiber, update4, SyncLane);
                var eventTime = requestEventTime();
                if (root2 !== null) {
                  markRootUpdated(root2, SyncLane, eventTime);
                  ensureRootIsScheduled(root2, eventTime);
                }
                return;
              }
            }
            fiber = fiber.return;
          }
          {
            error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
          }
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          if (pingCache !== null) {
            pingCache.delete(wakeable);
          }
          var eventTime = requestEventTime();
          markRootPinged(root2, pingedLanes);
          warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
          if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
              prepareFreshStack(root2, NoLanes);
            } else {
              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
            }
          }
          ensureRootIsScheduled(root2, eventTime);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          if (retryLane === NoLane) {
            retryLane = requestRetryLane(boundaryFiber);
          }
          var eventTime = requestEventTime();
          var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          if (root2 !== null) {
            markRootUpdated(root2, retryLane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState;
          var retryLane = NoLane;
          if (suspenseState !== null) {
            retryLane = suspenseState.retryLane;
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = NoLane;
          var retryCache;
          switch (boundaryFiber.tag) {
            case SuspenseComponent:
              retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              if (suspenseState !== null) {
                retryLane = suspenseState.retryLane;
              }
              break;
            case SuspenseListComponent:
              retryCache = boundaryFiber.stateNode;
              break;
            default:
              throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
          }
          if (retryCache !== null) {
            retryCache.delete(wakeable);
          }
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function jnd(timeElapsed) {
          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil2(timeElapsed / 1960) * 1960;
        }
        function checkForNestedUpdates() {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = null;
            throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
          }
          {
            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = null;
              error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
            }
          }
        }
        function flushRenderPhaseStrictModeWarningsInDEV() {
          {
            ReactStrictModeWarnings.flushLegacyContextWarning();
            {
              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
            }
          }
        }
        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
          {
            setCurrentFiber(fiber);
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
            }
            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
            if (hasPassiveEffects) {
              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
            }
            resetCurrentFiber();
          }
        }
        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
          {
            var current3 = firstChild;
            var subtreeRoot = null;
            while (current3 !== null) {
              var primarySubtreeFlag = current3.subtreeFlags & fiberFlags;
              if (current3 !== subtreeRoot && current3.child !== null && primarySubtreeFlag !== NoFlags) {
                current3 = current3.child;
              } else {
                if ((current3.flags & fiberFlags) !== NoFlags) {
                  invokeEffectFn(current3);
                }
                if (current3.sibling !== null) {
                  current3 = current3.sibling;
                } else {
                  current3 = subtreeRoot = current3.return;
                }
              }
            }
          }
        }
        var didWarnStateUpdateForNotYetMountedComponent = null;
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          {
            if ((executionContext & RenderContext) !== NoContext) {
              return;
            }
            if (!(fiber.mode & ConcurrentMode)) {
              return;
            }
            var tag = fiber.tag;
            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef2 && tag !== MemoComponent && tag !== SimpleMemoComponent) {
              return;
            }
            var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
            if (didWarnStateUpdateForNotYetMountedComponent !== null) {
              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                return;
              }
              didWarnStateUpdateForNotYetMountedComponent.add(componentName);
            } else {
              didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
            }
            var previousFiber = current2;
            try {
              setCurrentFiber(fiber);
              error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
        var beginWork$1;
        {
          var dummyFiber = null;
          beginWork$1 = function(current3, unitOfWork, lanes) {
            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
            try {
              return beginWork(current3, unitOfWork, lanes);
            } catch (originalError) {
              if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                throw originalError;
              }
              resetContextDependencies();
              resetHooksAfterThrow();
              unwindInterruptedWork(current3, unitOfWork);
              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
              if (unitOfWork.mode & ProfileMode) {
                startProfilerTimer(unitOfWork);
              }
              invokeGuardedCallback(null, beginWork, null, current3, unitOfWork, lanes);
              if (hasCaughtError()) {
                var replayError = clearCaughtError();
                if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                  originalError._suppressLogging = true;
                }
              }
              throw originalError;
            }
          };
        }
        var didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent;
        {
          didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        }
        function warnAboutRenderPhaseUpdatesInDEV(fiber) {
          {
            if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef2:
                case SimpleMemoComponent: {
                  var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  var dedupeKey = renderingComponentName;
                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                    var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                    error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                  }
                  break;
                }
                case ClassComponent: {
                  if (!didWarnAboutUpdateInRender) {
                    error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                    didWarnAboutUpdateInRender = true;
                  }
                  break;
                }
              }
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              memoizedUpdaters.forEach(function(schedulingFiber) {
                addFiberToLanesMap(root2, schedulingFiber, lanes);
              });
            }
          }
        }
        var fakeActCallbackNode = {};
        function scheduleCallback$1(priorityLevel, callback) {
          {
            var actQueue = ReactCurrentActQueue$1.current;
            if (actQueue !== null) {
              actQueue.push(callback);
              return fakeActCallbackNode;
            } else {
              return scheduleCallback(priorityLevel, callback);
            }
          }
        }
        function cancelCallback$1(callbackNode) {
          if (callbackNode === fakeActCallbackNode) {
            return;
          }
          return cancelCallback(callbackNode);
        }
        function shouldForceFlushFallbacksInDEV() {
          return ReactCurrentActQueue$1.current !== null;
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          {
            if (fiber.mode & ConcurrentMode) {
              if (!isConcurrentActEnvironment()) {
                return;
              }
            } else {
              if (!isLegacyActEnvironment()) {
                return;
              }
              if (executionContext !== NoContext) {
                return;
              }
              if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef2 && fiber.tag !== SimpleMemoComponent) {
                return;
              }
            }
            if (ReactCurrentActQueue$1.current === null) {
              var previousFiber = current2;
              try {
                setCurrentFiber(fiber);
                error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
        }
        function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
          {
            if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
              error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
            }
          }
        }
        function setIsRunningInsertionEffect(isRunning) {
          {
            isRunningInsertionEffect = isRunning;
          }
        }
        var resolveFamily = null;
        var failedBoundaries = null;
        var setRefreshHandler = function(handler) {
          {
            resolveFamily = handler;
          }
        };
        function resolveFunctionForHotReloading(type5) {
          {
            if (resolveFamily === null) {
              return type5;
            }
            var family = resolveFamily(type5);
            if (family === void 0) {
              return type5;
            }
            return family.current;
          }
        }
        function resolveClassForHotReloading(type5) {
          return resolveFunctionForHotReloading(type5);
        }
        function resolveForwardRefForHotReloading(type5) {
          {
            if (resolveFamily === null) {
              return type5;
            }
            var family = resolveFamily(type5);
            if (family === void 0) {
              if (type5 !== null && type5 !== void 0 && typeof type5.render === "function") {
                var currentRender = resolveFunctionForHotReloading(type5.render);
                if (type5.render !== currentRender) {
                  var syntheticType = {
                    $$typeof: REACT_FORWARD_REF_TYPE2,
                    render: currentRender
                  };
                  if (type5.displayName !== void 0) {
                    syntheticType.displayName = type5.displayName;
                  }
                  return syntheticType;
                }
              }
              return type5;
            }
            return family.current;
          }
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          {
            if (resolveFamily === null) {
              return false;
            }
            var prevType = fiber.elementType;
            var nextType = element.type;
            var needsCompareFamilies = false;
            var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
            switch (fiber.tag) {
              case ClassComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                }
                break;
              }
              case FunctionComponent: {
                if (typeof nextType === "function") {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE2) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case ForwardRef2: {
                if ($$typeofNextType === REACT_FORWARD_REF_TYPE2) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE2) {
                  needsCompareFamilies = true;
                }
                break;
              }
              case MemoComponent:
              case SimpleMemoComponent: {
                if ($$typeofNextType === REACT_MEMO_TYPE2) {
                  needsCompareFamilies = true;
                } else if ($$typeofNextType === REACT_LAZY_TYPE2) {
                  needsCompareFamilies = true;
                }
                break;
              }
              default:
                return false;
            }
            if (needsCompareFamilies) {
              var prevFamily = resolveFamily(prevType);
              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                return true;
              }
            }
            return false;
          }
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          {
            if (resolveFamily === null) {
              return;
            }
            if (typeof WeakSet !== "function") {
              return;
            }
            if (failedBoundaries === null) {
              failedBoundaries = /* @__PURE__ */ new WeakSet();
            }
            failedBoundaries.add(fiber);
          }
        }
        var scheduleRefresh = function(root2, update4) {
          {
            if (resolveFamily === null) {
              return;
            }
            var staleFamilies = update4.staleFamilies, updatedFamilies = update4.updatedFamilies;
            flushPassiveEffects();
            flushSync(function() {
              scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
            });
          }
        };
        var scheduleRoot = function(root2, element) {
          {
            if (root2.context !== emptyContextObject) {
              return;
            }
            flushPassiveEffects();
            flushSync(function() {
              updateContainer(element, root2, null, null);
            });
          }
        };
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          {
            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type5 = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type5;
                break;
              case ForwardRef2:
                candidateType = type5.render;
                break;
            }
            if (resolveFamily === null) {
              throw new Error("Expected resolveFamily to be set during hot reload.");
            }
            var needsRender = false;
            var needsRemount = false;
            if (candidateType !== null) {
              var family = resolveFamily(candidateType);
              if (family !== void 0) {
                if (staleFamilies.has(family)) {
                  needsRemount = true;
                } else if (updatedFamilies.has(family)) {
                  if (tag === ClassComponent) {
                    needsRemount = true;
                  } else {
                    needsRender = true;
                  }
                }
              }
            }
            if (failedBoundaries !== null) {
              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                needsRemount = true;
              }
            }
            if (needsRemount) {
              fiber._debugNeedsRemount = true;
            }
            if (needsRemount || needsRender) {
              var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (_root !== null) {
                scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
              }
            }
            if (child !== null && !needsRemount) {
              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
            }
            if (sibling !== null) {
              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
            }
          }
        }
        var findHostInstancesForRefresh = function(root2, families) {
          {
            var hostInstances = /* @__PURE__ */ new Set();
            var types2 = new Set(families.map(function(family) {
              return family.current;
            }));
            findHostInstancesForMatchingFibersRecursively(root2.current, types2, hostInstances);
            return hostInstances;
          }
        };
        function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
          {
            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type5 = fiber.type;
            var candidateType = null;
            switch (tag) {
              case FunctionComponent:
              case SimpleMemoComponent:
              case ClassComponent:
                candidateType = type5;
                break;
              case ForwardRef2:
                candidateType = type5.render;
                break;
            }
            var didMatch = false;
            if (candidateType !== null) {
              if (types2.has(candidateType)) {
                didMatch = true;
              }
            }
            if (didMatch) {
              findHostInstancesForFiberShallowly(fiber, hostInstances);
            } else {
              if (child !== null) {
                findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances);
              }
            }
            if (sibling !== null) {
              findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
            }
          }
        }
        function findHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
            if (foundHostInstances) {
              return;
            }
            var node = fiber;
            while (true) {
              switch (node.tag) {
                case HostComponent:
                  hostInstances.add(node.stateNode);
                  return;
                case HostPortal:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
                case HostRoot:
                  hostInstances.add(node.stateNode.containerInfo);
                  return;
              }
              if (node.return === null) {
                throw new Error("Expected to reach root first.");
              }
              node = node.return;
            }
          }
        }
        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
          {
            var node = fiber;
            var foundHostInstances = false;
            while (true) {
              if (node.tag === HostComponent) {
                foundHostInstances = true;
                hostInstances.add(node.stateNode);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === fiber) {
                return foundHostInstances;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === fiber) {
                  return foundHostInstances;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          return false;
        }
        var hasBadMapPolyfill;
        {
          hasBadMapPolyfill = false;
          try {
            var nonExtensibleObject = Object.preventExtensions({});
            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
            /* @__PURE__ */ new Set([nonExtensibleObject]);
          } catch (e2) {
            hasBadMapPolyfill = true;
          }
        }
        function FiberNode(tag, pendingProps, key57, mode) {
          this.tag = tag;
          this.key = key57;
          this.elementType = null;
          this.type = null;
          this.stateNode = null;
          this.return = null;
          this.child = null;
          this.sibling = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.updateQueue = null;
          this.memoizedState = null;
          this.dependencies = null;
          this.mode = mode;
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.deletions = null;
          this.lanes = NoLanes;
          this.childLanes = NoLanes;
          this.alternate = null;
          {
            this.actualDuration = Number.NaN;
            this.actualStartTime = Number.NaN;
            this.selfBaseDuration = Number.NaN;
            this.treeBaseDuration = Number.NaN;
            this.actualDuration = 0;
            this.actualStartTime = -1;
            this.selfBaseDuration = 0;
            this.treeBaseDuration = 0;
          }
          {
            this._debugSource = null;
            this._debugOwner = null;
            this._debugNeedsRemount = false;
            this._debugHookTypes = null;
            if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
              Object.preventExtensions(this);
            }
          }
        }
        var createFiber = function(tag, pendingProps, key57, mode) {
          return new FiberNode(tag, pendingProps, key57, mode);
        };
        function shouldConstruct$1(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function isSimpleFunctionComponent(type5) {
          return typeof type5 === "function" && !shouldConstruct$1(type5) && type5.defaultProps === void 0;
        }
        function resolveLazyComponentTag(Component2) {
          if (typeof Component2 === "function") {
            return shouldConstruct$1(Component2) ? ClassComponent : FunctionComponent;
          } else if (Component2 !== void 0 && Component2 !== null) {
            var $$typeof = Component2.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE2) {
              return ForwardRef2;
            }
            if ($$typeof === REACT_MEMO_TYPE2) {
              return MemoComponent;
            }
          }
          return IndeterminateComponent;
        }
        function createWorkInProgress(current3, pendingProps) {
          var workInProgress2 = current3.alternate;
          if (workInProgress2 === null) {
            workInProgress2 = createFiber(current3.tag, pendingProps, current3.key, current3.mode);
            workInProgress2.elementType = current3.elementType;
            workInProgress2.type = current3.type;
            workInProgress2.stateNode = current3.stateNode;
            {
              workInProgress2._debugSource = current3._debugSource;
              workInProgress2._debugOwner = current3._debugOwner;
              workInProgress2._debugHookTypes = current3._debugHookTypes;
            }
            workInProgress2.alternate = current3;
            current3.alternate = workInProgress2;
          } else {
            workInProgress2.pendingProps = pendingProps;
            workInProgress2.type = current3.type;
            workInProgress2.flags = NoFlags;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            {
              workInProgress2.actualDuration = 0;
              workInProgress2.actualStartTime = -1;
            }
          }
          workInProgress2.flags = current3.flags & StaticMask;
          workInProgress2.childLanes = current3.childLanes;
          workInProgress2.lanes = current3.lanes;
          workInProgress2.child = current3.child;
          workInProgress2.memoizedProps = current3.memoizedProps;
          workInProgress2.memoizedState = current3.memoizedState;
          workInProgress2.updateQueue = current3.updateQueue;
          var currentDependencies = current3.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          workInProgress2.sibling = current3.sibling;
          workInProgress2.index = current3.index;
          workInProgress2.ref = current3.ref;
          {
            workInProgress2.selfBaseDuration = current3.selfBaseDuration;
            workInProgress2.treeBaseDuration = current3.treeBaseDuration;
          }
          {
            workInProgress2._debugNeedsRemount = current3._debugNeedsRemount;
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case FunctionComponent:
              case SimpleMemoComponent:
                workInProgress2.type = resolveFunctionForHotReloading(current3.type);
                break;
              case ClassComponent:
                workInProgress2.type = resolveClassForHotReloading(current3.type);
                break;
              case ForwardRef2:
                workInProgress2.type = resolveForwardRefForHotReloading(current3.type);
                break;
            }
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= StaticMask | Placement;
          var current3 = workInProgress2.alternate;
          if (current3 === null) {
            workInProgress2.childLanes = NoLanes;
            workInProgress2.lanes = renderLanes2;
            workInProgress2.child = null;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.memoizedProps = null;
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.dependencies = null;
            workInProgress2.stateNode = null;
            {
              workInProgress2.selfBaseDuration = 0;
              workInProgress2.treeBaseDuration = 0;
            }
          } else {
            workInProgress2.childLanes = current3.childLanes;
            workInProgress2.lanes = current3.lanes;
            workInProgress2.child = current3.child;
            workInProgress2.subtreeFlags = NoFlags;
            workInProgress2.deletions = null;
            workInProgress2.memoizedProps = current3.memoizedProps;
            workInProgress2.memoizedState = current3.memoizedState;
            workInProgress2.updateQueue = current3.updateQueue;
            workInProgress2.type = current3.type;
            var currentDependencies = current3.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            {
              workInProgress2.selfBaseDuration = current3.selfBaseDuration;
              workInProgress2.treeBaseDuration = current3.treeBaseDuration;
            }
          }
          return workInProgress2;
        }
        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
          var mode;
          if (tag === ConcurrentRoot) {
            mode = ConcurrentMode;
            if (isStrictMode === true) {
              mode |= StrictLegacyMode;
              {
                mode |= StrictEffectsMode;
              }
            }
          } else {
            mode = NoMode;
          }
          if (isDevToolsPresent) {
            mode |= ProfileMode;
          }
          return createFiber(HostRoot, null, null, mode);
        }
        function createFiberFromTypeAndProps(type5, key57, pendingProps, owner, mode, lanes) {
          var fiberTag = IndeterminateComponent;
          var resolvedType = type5;
          if (typeof type5 === "function") {
            if (shouldConstruct$1(type5)) {
              fiberTag = ClassComponent;
              {
                resolvedType = resolveClassForHotReloading(resolvedType);
              }
            } else {
              {
                resolvedType = resolveFunctionForHotReloading(resolvedType);
              }
            }
          } else if (typeof type5 === "string") {
            fiberTag = HostComponent;
          } else {
            getTag: switch (type5) {
              case REACT_FRAGMENT_TYPE2:
                return createFiberFromFragment(pendingProps.children, mode, lanes, key57);
              case REACT_STRICT_MODE_TYPE2:
                fiberTag = Mode;
                mode |= StrictLegacyMode;
                if ((mode & ConcurrentMode) !== NoMode) {
                  mode |= StrictEffectsMode;
                }
                break;
              case REACT_PROFILER_TYPE2:
                return createFiberFromProfiler(pendingProps, mode, lanes, key57);
              case REACT_SUSPENSE_TYPE2:
                return createFiberFromSuspense(pendingProps, mode, lanes, key57);
              case REACT_SUSPENSE_LIST_TYPE2:
                return createFiberFromSuspenseList(pendingProps, mode, lanes, key57);
              case REACT_OFFSCREEN_TYPE2:
                return createFiberFromOffscreen(pendingProps, mode, lanes, key57);
              case REACT_LEGACY_HIDDEN_TYPE:
              case REACT_SCOPE_TYPE:
              case REACT_CACHE_TYPE:
              case REACT_TRACING_MARKER_TYPE:
              case REACT_DEBUG_TRACING_MODE_TYPE:
              default: {
                if (typeof type5 === "object" && type5 !== null) {
                  switch (type5.$$typeof) {
                    case REACT_PROVIDER_TYPE2:
                      fiberTag = ContextProvider;
                      break getTag;
                    case REACT_CONTEXT_TYPE2:
                      fiberTag = ContextConsumer;
                      break getTag;
                    case REACT_FORWARD_REF_TYPE2:
                      fiberTag = ForwardRef2;
                      {
                        resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      }
                      break getTag;
                    case REACT_MEMO_TYPE2:
                      fiberTag = MemoComponent;
                      break getTag;
                    case REACT_LAZY_TYPE2:
                      fiberTag = LazyComponent;
                      resolvedType = null;
                      break getTag;
                  }
                }
                var info = "";
                {
                  if (type5 === void 0 || typeof type5 === "object" && type5 !== null && Object.keys(type5).length === 0) {
                    info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                  }
                  var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                  if (ownerName) {
                    info += "\n\nCheck the render method of `" + ownerName + "`.";
                  }
                }
                throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type5 == null ? type5 : typeof type5) + "." + info));
              }
            }
          }
          var fiber = createFiber(fiberTag, pendingProps, key57, mode);
          fiber.elementType = type5;
          fiber.type = resolvedType;
          fiber.lanes = lanes;
          {
            fiber._debugOwner = owner;
          }
          return fiber;
        }
        function createFiberFromElement(element, mode, lanes) {
          var owner = null;
          {
            owner = element._owner;
          }
          var type5 = element.type;
          var key57 = element.key;
          var pendingProps = element.props;
          var fiber = createFiberFromTypeAndProps(type5, key57, pendingProps, owner, mode, lanes);
          {
            fiber._debugSource = element._source;
            fiber._debugOwner = element._owner;
          }
          return fiber;
        }
        function createFiberFromFragment(elements, mode, lanes, key57) {
          var fiber = createFiber(Fragment, elements, key57, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromProfiler(pendingProps, mode, lanes, key57) {
          {
            if (typeof pendingProps.id !== "string") {
              error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
            }
          }
          var fiber = createFiber(Profiler, pendingProps, key57, mode | ProfileMode);
          fiber.elementType = REACT_PROFILER_TYPE2;
          fiber.lanes = lanes;
          {
            fiber.stateNode = {
              effectDuration: 0,
              passiveEffectDuration: 0
            };
          }
          return fiber;
        }
        function createFiberFromSuspense(pendingProps, mode, lanes, key57) {
          var fiber = createFiber(SuspenseComponent, pendingProps, key57, mode);
          fiber.elementType = REACT_SUSPENSE_TYPE2;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromSuspenseList(pendingProps, mode, lanes, key57) {
          var fiber = createFiber(SuspenseListComponent, pendingProps, key57, mode);
          fiber.elementType = REACT_SUSPENSE_LIST_TYPE2;
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key57) {
          var fiber = createFiber(OffscreenComponent, pendingProps, key57, mode);
          fiber.elementType = REACT_OFFSCREEN_TYPE2;
          fiber.lanes = lanes;
          var primaryChildInstance = {
            isHidden: false
          };
          fiber.stateNode = primaryChildInstance;
          return fiber;
        }
        function createFiberFromText(content, mode, lanes) {
          var fiber = createFiber(HostText, content, null, mode);
          fiber.lanes = lanes;
          return fiber;
        }
        function createFiberFromHostInstanceForDeletion() {
          var fiber = createFiber(HostComponent, null, null, NoMode);
          fiber.elementType = "DELETED";
          return fiber;
        }
        function createFiberFromDehydratedFragment(dehydratedNode) {
          var fiber = createFiber(DehydratedFragment, null, null, NoMode);
          fiber.stateNode = dehydratedNode;
          return fiber;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          var pendingProps = portal.children !== null ? portal.children : [];
          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
          fiber.lanes = lanes;
          fiber.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            // Used by persistent updates
            implementation: portal.implementation
          };
          return fiber;
        }
        function assignFiberPropertiesInDEV(target, source) {
          if (target === null) {
            target = createFiber(IndeterminateComponent, null, null, NoMode);
          }
          target.tag = source.tag;
          target.key = source.key;
          target.elementType = source.elementType;
          target.type = source.type;
          target.stateNode = source.stateNode;
          target.return = source.return;
          target.child = source.child;
          target.sibling = source.sibling;
          target.index = source.index;
          target.ref = source.ref;
          target.pendingProps = source.pendingProps;
          target.memoizedProps = source.memoizedProps;
          target.updateQueue = source.updateQueue;
          target.memoizedState = source.memoizedState;
          target.dependencies = source.dependencies;
          target.mode = source.mode;
          target.flags = source.flags;
          target.subtreeFlags = source.subtreeFlags;
          target.deletions = source.deletions;
          target.lanes = source.lanes;
          target.childLanes = source.childLanes;
          target.alternate = source.alternate;
          {
            target.actualDuration = source.actualDuration;
            target.actualStartTime = source.actualStartTime;
            target.selfBaseDuration = source.selfBaseDuration;
            target.treeBaseDuration = source.treeBaseDuration;
          }
          target._debugSource = source._debugSource;
          target._debugOwner = source._debugOwner;
          target._debugNeedsRemount = source._debugNeedsRemount;
          target._debugHookTypes = source._debugHookTypes;
          return target;
        }
        function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
          this.tag = tag;
          this.containerInfo = containerInfo;
          this.pendingChildren = null;
          this.current = null;
          this.pingCache = null;
          this.finishedWork = null;
          this.timeoutHandle = noTimeout;
          this.context = null;
          this.pendingContext = null;
          this.callbackNode = null;
          this.callbackPriority = NoLane;
          this.eventTimes = createLaneMap(NoLanes);
          this.expirationTimes = createLaneMap(NoTimestamp);
          this.pendingLanes = NoLanes;
          this.suspendedLanes = NoLanes;
          this.pingedLanes = NoLanes;
          this.expiredLanes = NoLanes;
          this.mutableReadLanes = NoLanes;
          this.finishedLanes = NoLanes;
          this.entangledLanes = NoLanes;
          this.entanglements = createLaneMap(NoLanes);
          this.identifierPrefix = identifierPrefix;
          this.onRecoverableError = onRecoverableError;
          {
            this.mutableSourceEagerHydrationData = null;
          }
          {
            this.effectDuration = 0;
            this.passiveEffectDuration = 0;
          }
          {
            this.memoizedUpdaters = /* @__PURE__ */ new Set();
            var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
            for (var _i = 0; _i < TotalLanes; _i++) {
              pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
            }
          }
          {
            switch (tag) {
              case ConcurrentRoot:
                this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                break;
              case LegacyRoot:
                this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                break;
            }
          }
        }
        function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
          var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
          root2.current = uninitializedFiber;
          uninitializedFiber.stateNode = root2;
          {
            var _initialState = {
              element: initialChildren,
              isDehydrated: hydrate2,
              cache: null,
              // not enabled yet
              transitions: null,
              pendingSuspenseBoundaries: null
            };
            uninitializedFiber.memoizedState = _initialState;
          }
          initializeUpdateQueue(uninitializedFiber);
          return root2;
        }
        var ReactVersion = "18.3.1";
        function createPortal(children, containerInfo, implementation) {
          var key57 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          {
            checkKeyStringCoercion(key57);
          }
          return {
            // This tag allow us to uniquely identify this as a React Portal
            $$typeof: REACT_PORTAL_TYPE2,
            key: key57 == null ? null : "" + key57,
            children,
            containerInfo,
            implementation
          };
        }
        var didWarnAboutNestedUpdates;
        var didWarnAboutFindNodeInStrictMode;
        {
          didWarnAboutNestedUpdates = false;
          didWarnAboutFindNodeInStrictMode = {};
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) {
            return emptyContextObject;
          }
          var fiber = get3(parentComponent);
          var parentContext = findCurrentUnmaskedContext(fiber);
          if (fiber.tag === ClassComponent) {
            var Component2 = fiber.type;
            if (isContextProvider(Component2)) {
              return processChildContext(fiber, Component2, parentContext);
            }
          }
          return parentContext;
        }
        function findHostInstanceWithWarning(component, methodName) {
          {
            var fiber = get3(component);
            if (fiber === void 0) {
              if (typeof component.render === "function") {
                throw new Error("Unable to find node on an unmounted component.");
              } else {
                var keys4 = Object.keys(component).join(",");
                throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys4);
              }
            }
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            if (hostFiber.mode & StrictLegacyMode) {
              var componentName = getComponentNameFromFiber(fiber) || "Component";
              if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                didWarnAboutFindNodeInStrictMode[componentName] = true;
                var previousFiber = current2;
                try {
                  setCurrentFiber(hostFiber);
                  if (fiber.mode & StrictLegacyMode) {
                    error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  } else {
                    error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                  }
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(previousFiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
            return hostFiber.stateNode;
          }
        }
        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = false;
          var initialChildren = null;
          return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        }
        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
          var hydrate2 = true;
          var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          root2.context = getContextForSubtree(null);
          var current3 = root2.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current3);
          var update4 = createUpdate(eventTime, lane);
          update4.callback = callback !== void 0 && callback !== null ? callback : null;
          enqueueUpdate(current3, update4, lane);
          scheduleInitialHydrationOnRoot(root2, lane, eventTime);
          return root2;
        }
        function updateContainer(element, container, parentComponent, callback) {
          {
            onScheduleRoot(container, element);
          }
          var current$1 = container.current;
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(current$1);
          {
            markRenderScheduled(lane);
          }
          var context2 = getContextForSubtree(parentComponent);
          if (container.context === null) {
            container.context = context2;
          } else {
            container.pendingContext = context2;
          }
          {
            if (isRendering && current2 !== null && !didWarnAboutNestedUpdates) {
              didWarnAboutNestedUpdates = true;
              error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current2) || "Unknown");
            }
          }
          var update4 = createUpdate(eventTime, lane);
          update4.payload = {
            element
          };
          callback = callback === void 0 ? null : callback;
          if (callback !== null) {
            {
              if (typeof callback !== "function") {
                error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
              }
            }
            update4.callback = callback;
          }
          var root2 = enqueueUpdate(current$1, update4, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
            entangleTransitions(root2, current$1, lane);
          }
          return lane;
        }
        function getPublicRootInstance(container) {
          var containerFiber = container.current;
          if (!containerFiber.child) {
            return null;
          }
          switch (containerFiber.child.tag) {
            case HostComponent:
              return getPublicInstance(containerFiber.child.stateNode);
            default:
              return containerFiber.child.stateNode;
          }
        }
        function attemptSynchronousHydration$1(fiber) {
          switch (fiber.tag) {
            case HostRoot: {
              var root2 = fiber.stateNode;
              if (isRootDehydrated(root2)) {
                var lanes = getHighestPriorityPendingLanes(root2);
                flushRoot(root2, lanes);
              }
              break;
            }
            case SuspenseComponent: {
              flushSync(function() {
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  var eventTime = requestEventTime();
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
                }
              });
              var retryLane = SyncLane;
              markRetryLaneIfNotHydrated(fiber, retryLane);
              break;
            }
          }
        }
        function markRetryLaneImpl(fiber, retryLane) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState !== null && suspenseState.dehydrated !== null) {
            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          var alternate = fiber.alternate;
          if (alternate) {
            markRetryLaneImpl(alternate, retryLane);
          }
        }
        function attemptContinuousHydration$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = SelectiveHydrationLane;
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function attemptHydrationAtCurrentPriority$1(fiber) {
          if (fiber.tag !== SuspenseComponent) {
            return;
          }
          var lane = requestUpdateLane(fiber);
          var root2 = enqueueConcurrentRenderForLane(fiber, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
          }
          markRetryLaneIfNotHydrated(fiber, lane);
        }
        function findHostInstanceWithNoPortals(fiber) {
          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        var shouldErrorImpl = function(fiber) {
          return null;
        };
        function shouldError(fiber) {
          return shouldErrorImpl(fiber);
        }
        var shouldSuspendImpl = function(fiber) {
          return false;
        };
        function shouldSuspend(fiber) {
          return shouldSuspendImpl(fiber);
        }
        var overrideHookState = null;
        var overrideHookStateDeletePath = null;
        var overrideHookStateRenamePath = null;
        var overrideProps = null;
        var overridePropsDeletePath = null;
        var overridePropsRenamePath = null;
        var scheduleUpdate = null;
        var setErrorHandler = null;
        var setSuspenseHandler = null;
        {
          var copyWithDeleteImpl = function(obj, path4, index2) {
            var key57 = path4[index2];
            var updated = isArray4(obj) ? obj.slice() : assign2({}, obj);
            if (index2 + 1 === path4.length) {
              if (isArray4(updated)) {
                updated.splice(key57, 1);
              } else {
                delete updated[key57];
              }
              return updated;
            }
            updated[key57] = copyWithDeleteImpl(obj[key57], path4, index2 + 1);
            return updated;
          };
          var copyWithDelete = function(obj, path4) {
            return copyWithDeleteImpl(obj, path4, 0);
          };
          var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
            var oldKey = oldPath[index2];
            var updated = isArray4(obj) ? obj.slice() : assign2({}, obj);
            if (index2 + 1 === oldPath.length) {
              var newKey = newPath[index2];
              updated[newKey] = updated[oldKey];
              if (isArray4(updated)) {
                updated.splice(oldKey, 1);
              } else {
                delete updated[oldKey];
              }
            } else {
              updated[oldKey] = copyWithRenameImpl(
                // $FlowFixMe number or string is fine here
                obj[oldKey],
                oldPath,
                newPath,
                index2 + 1
              );
            }
            return updated;
          };
          var copyWithRename = function(obj, oldPath, newPath) {
            if (oldPath.length !== newPath.length) {
              warn("copyWithRename() expects paths of the same length");
              return;
            } else {
              for (var i2 = 0; i2 < newPath.length - 1; i2++) {
                if (oldPath[i2] !== newPath[i2]) {
                  warn("copyWithRename() expects paths to be the same except for the deepest key");
                  return;
                }
              }
            }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          };
          var copyWithSetImpl = function(obj, path4, index2, value) {
            if (index2 >= path4.length) {
              return value;
            }
            var key57 = path4[index2];
            var updated = isArray4(obj) ? obj.slice() : assign2({}, obj);
            updated[key57] = copyWithSetImpl(obj[key57], path4, index2 + 1, value);
            return updated;
          };
          var copyWithSet = function(obj, path4, value) {
            return copyWithSetImpl(obj, path4, 0, value);
          };
          var findHook = function(fiber, id) {
            var currentHook2 = fiber.memoizedState;
            while (currentHook2 !== null && id > 0) {
              currentHook2 = currentHook2.next;
              id--;
            }
            return currentHook2;
          };
          overrideHookState = function(fiber, id, path4, value) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithSet(hook.memoizedState, path4, value);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign2({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateDeletePath = function(fiber, id, path4) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithDelete(hook.memoizedState, path4);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign2({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
            var hook = findHook(fiber, id);
            if (hook !== null) {
              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
              hook.memoizedState = newState;
              hook.baseState = newState;
              fiber.memoizedProps = assign2({}, fiber.memoizedProps);
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            }
          };
          overrideProps = function(fiber, path4, value) {
            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path4, value);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsDeletePath = function(fiber, path4) {
            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path4);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          overridePropsRenamePath = function(fiber, oldPath, newPath) {
            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
            if (fiber.alternate) {
              fiber.alternate.pendingProps = fiber.pendingProps;
            }
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          scheduleUpdate = function(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          };
          setErrorHandler = function(newShouldErrorImpl) {
            shouldErrorImpl = newShouldErrorImpl;
          };
          setSuspenseHandler = function(newShouldSuspendImpl) {
            shouldSuspendImpl = newShouldSuspendImpl;
          };
        }
        function findHostInstanceByFiber(fiber) {
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          return hostFiber.stateNode;
        }
        function emptyFindFiberByHostInstance(instance) {
          return null;
        }
        function getCurrentFiberForDevTools() {
          return current2;
        }
        function injectIntoDevTools(devToolsConfig) {
          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
          return injectInternals({
            bundleType: devToolsConfig.bundleType,
            version: devToolsConfig.version,
            rendererPackageName: devToolsConfig.rendererPackageName,
            rendererConfig: devToolsConfig.rendererConfig,
            overrideHookState,
            overrideHookStateDeletePath,
            overrideHookStateRenamePath,
            overrideProps,
            overridePropsDeletePath,
            overridePropsRenamePath,
            setErrorHandler,
            setSuspenseHandler,
            scheduleUpdate,
            currentDispatcherRef: ReactCurrentDispatcher2,
            findHostInstanceByFiber,
            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
            // React Refresh
            findHostInstancesForRefresh,
            scheduleRefresh,
            scheduleRoot,
            setRefreshHandler,
            // Enables DevTools to append owner stacks to error messages in DEV mode.
            getCurrentFiber: getCurrentFiberForDevTools,
            // Enables DevTools to detect reconciler version rather than renderer version
            // which may not match for third party renderers.
            reconcilerVersion: ReactVersion
          });
        }
        var defaultOnRecoverableError = typeof reportError === "function" ? (
          // In modern browsers, reportError will dispatch an error event,
          // emulating an uncaught JavaScript error.
          reportError
        ) : function(error2) {
          console["error"](error2);
        };
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
          var root2 = this._internalRoot;
          if (root2 === null) {
            throw new Error("Cannot update an unmounted root.");
          }
          {
            if (typeof arguments[1] === "function") {
              error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            } else if (isValidContainer(arguments[1])) {
              error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
            } else if (typeof arguments[1] !== "undefined") {
              error("You passed a second argument to root.render(...) but it only accepts one argument.");
            }
            var container = root2.containerInfo;
            if (container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(root2.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                }
              }
            }
          }
          updateContainer(children, root2, null, null);
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
          {
            if (typeof arguments[0] === "function") {
              error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
            }
          }
          var root2 = this._internalRoot;
          if (root2 !== null) {
            this._internalRoot = null;
            var container = root2.containerInfo;
            {
              if (isAlreadyRendering()) {
                error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
              }
            }
            flushSync(function() {
              updateContainer(null, root2, null, null);
            });
            unmarkContainerAsRoot(container);
          }
        };
        function createRoot(container, options2) {
          if (!isValidContainer(container)) {
            throw new Error("createRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          var transitionCallbacks = null;
          if (options2 !== null && options2 !== void 0) {
            {
              if (options2.hydrate) {
                warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
              } else {
                if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE2) {
                  error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                }
              }
            }
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
            if (options2.transitionCallbacks !== void 0) {
              transitionCallbacks = options2.transitionCallbacks;
            }
          }
          var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root2.current, container);
          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(rootContainerElement);
          return new ReactDOMRoot(root2);
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function scheduleHydration(target) {
          if (target) {
            queueExplicitHydrationTarget(target);
          }
        }
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
        function hydrateRoot(container, initialChildren, options2) {
          if (!isValidContainer(container)) {
            throw new Error("hydrateRoot(...): Target container is not a DOM element.");
          }
          warnIfReactDOMContainerInDEV(container);
          {
            if (initialChildren === void 0) {
              error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
            }
          }
          var hydrationCallbacks = options2 != null ? options2 : null;
          var mutableSources = options2 != null && options2.hydratedSources || null;
          var isStrictMode = false;
          var concurrentUpdatesByDefaultOverride = false;
          var identifierPrefix = "";
          var onRecoverableError = defaultOnRecoverableError;
          if (options2 !== null && options2 !== void 0) {
            if (options2.unstable_strictMode === true) {
              isStrictMode = true;
            }
            if (options2.identifierPrefix !== void 0) {
              identifierPrefix = options2.identifierPrefix;
            }
            if (options2.onRecoverableError !== void 0) {
              onRecoverableError = options2.onRecoverableError;
            }
          }
          var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          markContainerAsRoot(root2.current, container);
          listenToAllSupportedEvents(container);
          if (mutableSources) {
            for (var i2 = 0; i2 < mutableSources.length; i2++) {
              var mutableSource = mutableSources[i2];
              registerMutableSourceForHydration(root2, mutableSource);
            }
          }
          return new ReactDOMHydrationRoot(root2);
        }
        function isValidContainer(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
        }
        function isValidContainerLegacy(node) {
          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
        }
        function warnIfReactDOMContainerInDEV(container) {
          {
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
            }
            if (isContainerMarkedAsRoot(container)) {
              if (container._reactRootContainer) {
                error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
              } else {
                error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
              }
            }
          }
        }
        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
        var topLevelUpdateWarnings;
        {
          topLevelUpdateWarnings = function(container) {
            if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
              var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
              if (hostInstance) {
                if (hostInstance.parentNode !== container) {
                  error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                }
              }
            }
            var isRootRenderedBySomeReact = !!container._reactRootContainer;
            var rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
              error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
            }
            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
              error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
            }
          };
        }
        function getReactRootElementInContainer(container) {
          if (!container) {
            return null;
          }
          if (container.nodeType === DOCUMENT_NODE) {
            return container.documentElement;
          } else {
            return container.firstChild;
          }
        }
        function noopOnRecoverableError() {
        }
        function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
          if (isHydrationContainer) {
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root2);
                originalCallback.call(instance);
              };
            }
            var root2 = createHydrationContainer(
              initialChildren,
              callback,
              container,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container._reactRootContainer = root2;
            markContainerAsRoot(root2.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            flushSync();
            return root2;
          } else {
            var rootSibling;
            while (rootSibling = container.lastChild) {
              container.removeChild(rootSibling);
            }
            if (typeof callback === "function") {
              var _originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(_root);
                _originalCallback.call(instance);
              };
            }
            var _root = createContainer(
              container,
              LegacyRoot,
              null,
              // hydrationCallbacks
              false,
              // isStrictMode
              false,
              // concurrentUpdatesByDefaultOverride,
              "",
              // identifierPrefix
              noopOnRecoverableError
            );
            container._reactRootContainer = _root;
            markContainerAsRoot(_root.current, container);
            var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(_rootContainerElement);
            flushSync(function() {
              updateContainer(initialChildren, _root, parentComponent, callback);
            });
            return _root;
          }
        }
        function warnOnInvalidCallback$1(callback, callerName) {
          {
            if (callback !== null && typeof callback !== "function") {
              error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
            }
          }
        }
        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
          {
            topLevelUpdateWarnings(container);
            warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
          }
          var maybeRoot = container._reactRootContainer;
          var root2;
          if (!maybeRoot) {
            root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
          } else {
            root2 = maybeRoot;
            if (typeof callback === "function") {
              var originalCallback = callback;
              callback = function() {
                var instance = getPublicRootInstance(root2);
                originalCallback.call(instance);
              };
            }
            updateContainer(children, root2, parentComponent, callback);
          }
          return getPublicRootInstance(root2);
        }
        var didWarnAboutFindDOMNode = false;
        function findDOMNode(componentOrElement) {
          {
            if (!didWarnAboutFindDOMNode) {
              didWarnAboutFindDOMNode = true;
              error("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node");
            }
            var owner = ReactCurrentOwner$3.current;
            if (owner !== null && owner.stateNode !== null) {
              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
              if (!warnedAboutRefsInRender) {
                error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
              }
              owner.stateNode._warnedAboutRefsInRender = true;
            }
          }
          if (componentOrElement == null) {
            return null;
          }
          if (componentOrElement.nodeType === ELEMENT_NODE) {
            return componentOrElement;
          }
          {
            return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
          }
        }
        function hydrate(element, container, callback) {
          {
            error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
        }
        function render2(element, container, callback) {
          {
            error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
            }
          }
          return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
        }
        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          {
            error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
          }
          if (!isValidContainerLegacy(containerNode)) {
            throw new Error("Target container is not a DOM element.");
          }
          if (parentComponent == null || !has4(parentComponent)) {
            throw new Error("parentComponent must be a valid React Component");
          }
          return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
        }
        var didWarnAboutUnmountComponentAtNode = false;
        function unmountComponentAtNode(container) {
          {
            if (!didWarnAboutUnmountComponentAtNode) {
              didWarnAboutUnmountComponentAtNode = true;
              error("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
          }
          if (!isValidContainerLegacy(container)) {
            throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
          }
          {
            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
            if (isModernRoot) {
              error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
            }
          }
          if (container._reactRootContainer) {
            {
              var rootEl = getReactRootElementInContainer(container);
              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
              if (renderedByDifferentReact) {
                error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
              }
            }
            flushSync(function() {
              legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                container._reactRootContainer = null;
                unmarkContainerAsRoot(container);
              });
            });
            return true;
          } else {
            {
              var _rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
              var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
              if (hasNonRootReactChild) {
                error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
              }
            }
            return false;
          }
        }
        setAttemptSynchronousHydration(attemptSynchronousHydration$1);
        setAttemptContinuousHydration(attemptContinuousHydration$1);
        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
        setGetCurrentUpdatePriority(getCurrentUpdatePriority);
        setAttemptHydrationAtPriority(runWithPriority);
        {
          if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
          Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
          Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
            error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          }
        }
        setRestoreImplementation(restoreControlledState$3);
        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
        function createPortal$1(children, container) {
          var key57 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (!isValidContainer(container)) {
            throw new Error("Target container is not a DOM element.");
          }
          return createPortal(children, container, null, key57);
        }
        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
          return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
        }
        var Internals = {
          usingClientEntryPoint: false,
          // Keep in sync with ReactTestUtils.js.
          // This is an array for better minification.
          Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
        };
        function createRoot$1(container, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return createRoot(container, options2);
        }
        function hydrateRoot$1(container, initialChildren, options2) {
          {
            if (!Internals.usingClientEntryPoint && true) {
              error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
            }
          }
          return hydrateRoot(container, initialChildren, options2);
        }
        function flushSync$1(fn2) {
          {
            if (isAlreadyRendering()) {
              error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
            }
          }
          return flushSync(fn2);
        }
        var foundDevTools = injectIntoDevTools({
          findFiberByHostInstance: getClosestInstanceFromNode,
          bundleType: 1,
          version: ReactVersion,
          rendererPackageName: "react-dom"
        });
        {
          if (!foundDevTools && canUseDOM2 && window.top === window.self) {
            if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
              var protocol = window.location.protocol;
              if (/^(https?|file):$/.test(protocol)) {
                console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
              }
            }
          }
        }
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
        exports.createPortal = createPortal$1;
        exports.createRoot = createRoot$1;
        exports.findDOMNode = findDOMNode;
        exports.flushSync = flushSync$1;
        exports.hydrate = hydrate;
        exports.hydrateRoot = hydrateRoot$1;
        exports.render = render2;
        exports.unmountComponentAtNode = unmountComponentAtNode;
        exports.unstable_batchedUpdates = batchedUpdates$1;
        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module) {
    "use strict";
    if (false) {
      checkDCE();
      module.exports = null;
    } else {
      module.exports = require_react_dom_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
var require_use_sync_external_store_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React6 = require_react();
        function is6(x2, y2) {
          return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is6;
        var useSyncExternalStore3 = React6.useSyncExternalStore;
        var useRef2 = React6.useRef, useEffect2 = React6.useEffect, useMemo2 = React6.useMemo, useDebugValue = React6.useDebugValue;
        function useSyncExternalStoreWithSelector3(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef2(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo2(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore3(subscribe, getSelection, getServerSelection);
          useEffect2(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector3;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_with_selector_development();
    }
  }
});

// node_modules/highlight.js/lib/core.js
var require_core = __commonJS({
  "node_modules/highlight.js/lib/core.js"(exports, module) {
    function deepFreeze(obj) {
      if (obj instanceof Map) {
        obj.clear = obj.delete = obj.set = function() {
          throw new Error("map is read-only");
        };
      } else if (obj instanceof Set) {
        obj.add = obj.clear = obj.delete = function() {
          throw new Error("set is read-only");
        };
      }
      Object.freeze(obj);
      Object.getOwnPropertyNames(obj).forEach(function(name2) {
        var prop3 = obj[name2];
        if (typeof prop3 == "object" && !Object.isFrozen(prop3)) {
          deepFreeze(prop3);
        }
      });
      return obj;
    }
    var deepFreezeEs6 = deepFreeze;
    var _default2 = deepFreeze;
    deepFreezeEs6.default = _default2;
    var Response6 = class {
      /**
       * @param {CompiledMode} mode
       */
      constructor(mode) {
        if (mode.data === void 0) mode.data = {};
        this.data = mode.data;
        this.isMatchIgnored = false;
      }
      ignoreMatch() {
        this.isMatchIgnored = true;
      }
    };
    function escapeHTML(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
    }
    function inherit(original, ...objects) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key57 in original) {
        result[key57] = original[key57];
      }
      objects.forEach(function(obj) {
        for (const key57 in obj) {
          result[key57] = obj[key57];
        }
      });
      return (
        /** @type {T} */
        result
      );
    }
    var SPAN_CLOSE = "</span>";
    var emitsWrappingTags = (node) => {
      return !!node.kind;
    };
    var HTMLRenderer = class {
      /**
       * Creates a new HTMLRenderer
       *
       * @param {Tree} parseTree - the parse tree (must support `walk` API)
       * @param {{classPrefix: string}} options
       */
      constructor(parseTree, options) {
        this.buffer = "";
        this.classPrefix = options.classPrefix;
        parseTree.walk(this);
      }
      /**
       * Adds texts to the output stream
       *
       * @param {string} text */
      addText(text3) {
        this.buffer += escapeHTML(text3);
      }
      /**
       * Adds a node open to the output stream (if needed)
       *
       * @param {Node} node */
      openNode(node) {
        if (!emitsWrappingTags(node)) return;
        let className = node.kind;
        if (!node.sublanguage) {
          className = `${this.classPrefix}${className}`;
        }
        this.span(className);
      }
      /**
       * Adds a node close to the output stream (if needed)
       *
       * @param {Node} node */
      closeNode(node) {
        if (!emitsWrappingTags(node)) return;
        this.buffer += SPAN_CLOSE;
      }
      /**
       * returns the accumulated buffer
      */
      value() {
        return this.buffer;
      }
      // helpers
      /**
       * Builds a span element
       *
       * @param {string} className */
      span(className) {
        this.buffer += `<span class="${className}">`;
      }
    };
    var TokenTree = class _TokenTree {
      constructor() {
        this.rootNode = { children: [] };
        this.stack = [this.rootNode];
      }
      get top() {
        return this.stack[this.stack.length - 1];
      }
      get root() {
        return this.rootNode;
      }
      /** @param {Node} node */
      add(node) {
        this.top.children.push(node);
      }
      /** @param {string} kind */
      openNode(kind) {
        const node = { kind, children: [] };
        this.add(node);
        this.stack.push(node);
      }
      closeNode() {
        if (this.stack.length > 1) {
          return this.stack.pop();
        }
        return void 0;
      }
      closeAllNodes() {
        while (this.closeNode()) ;
      }
      toJSON() {
        return JSON.stringify(this.rootNode, null, 4);
      }
      /**
       * @typedef { import("./html_renderer").Renderer } Renderer
       * @param {Renderer} builder
       */
      walk(builder) {
        return this.constructor._walk(builder, this.rootNode);
      }
      /**
       * @param {Renderer} builder
       * @param {Node} node
       */
      static _walk(builder, node) {
        if (typeof node === "string") {
          builder.addText(node);
        } else if (node.children) {
          builder.openNode(node);
          node.children.forEach((child) => this._walk(builder, child));
          builder.closeNode(node);
        }
        return builder;
      }
      /**
       * @param {Node} node
       */
      static _collapse(node) {
        if (typeof node === "string") return;
        if (!node.children) return;
        if (node.children.every((el2) => typeof el2 === "string")) {
          node.children = [node.children.join("")];
        } else {
          node.children.forEach((child) => {
            _TokenTree._collapse(child);
          });
        }
      }
    };
    var TokenTreeEmitter = class extends TokenTree {
      /**
       * @param {*} options
       */
      constructor(options) {
        super();
        this.options = options;
      }
      /**
       * @param {string} text
       * @param {string} kind
       */
      addKeyword(text3, kind) {
        if (text3 === "") {
          return;
        }
        this.openNode(kind);
        this.addText(text3);
        this.closeNode();
      }
      /**
       * @param {string} text
       */
      addText(text3) {
        if (text3 === "") {
          return;
        }
        this.add(text3);
      }
      /**
       * @param {Emitter & {root: DataNode}} emitter
       * @param {string} name
       */
      addSublanguage(emitter, name2) {
        const node = emitter.root;
        node.kind = name2;
        node.sublanguage = true;
        this.add(node);
      }
      toHTML() {
        const renderer = new HTMLRenderer(this, this.options);
        return renderer.value();
      }
      finalize() {
        return true;
      }
    };
    function escape3(value) {
      return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "m");
    }
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;
      return re.source;
    }
    function concat4(...args) {
      const joined = args.map((x2) => source(x2)).join("");
      return joined;
    }
    function either3(...args) {
      const joined = "(" + args.map((x2) => source(x2)).join("|") + ")";
      return joined;
    }
    function countMatchGroups(re) {
      return new RegExp(re.toString() + "|").exec("").length - 1;
    }
    function startsWith2(re, lexeme) {
      const match3 = re && re.exec(lexeme);
      return match3 && match3.index === 0;
    }
    var BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
    function join2(regexps, separator = "|") {
      let numCaptures = 0;
      return regexps.map((regex2) => {
        numCaptures += 1;
        const offset = numCaptures;
        let re = source(regex2);
        let out = "";
        while (re.length > 0) {
          const match3 = BACKREF_RE.exec(re);
          if (!match3) {
            out += re;
            break;
          }
          out += re.substring(0, match3.index);
          re = re.substring(match3.index + match3[0].length);
          if (match3[0][0] === "\\" && match3[1]) {
            out += "\\" + String(Number(match3[1]) + offset);
          } else {
            out += match3[0];
            if (match3[0] === "(") {
              numCaptures++;
            }
          }
        }
        return out;
      }).map((re) => `(${re})`).join(separator);
    }
    var MATCH_NOTHING_RE = /\b\B/;
    var IDENT_RE = "[a-zA-Z]\\w*";
    var UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
    var NUMBER_RE = "\\b\\d+(\\.\\d+)?";
    var C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
    var BINARY_NUMBER_RE = "\\b(0b[01]+)";
    var RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
    var SHEBANG = (opts = {}) => {
      const beginShebang = /^#![ ]*\//;
      if (opts.binary) {
        opts.begin = concat4(
          beginShebang,
          /.*\b/,
          opts.binary,
          /\b.*/
        );
      }
      return inherit({
        className: "meta",
        begin: beginShebang,
        end: /$/,
        relevance: 0,
        /** @type {ModeCallback} */
        "on:begin": (m2, resp) => {
          if (m2.index !== 0) resp.ignoreMatch();
        }
      }, opts);
    };
    var BACKSLASH_ESCAPE = {
      begin: "\\\\[\\s\\S]",
      relevance: 0
    };
    var APOS_STRING_MODE = {
      className: "string",
      begin: "'",
      end: "'",
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    var QUOTE_STRING_MODE = {
      className: "string",
      begin: '"',
      end: '"',
      illegal: "\\n",
      contains: [BACKSLASH_ESCAPE]
    };
    var PHRASAL_WORDS_MODE = {
      begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
    };
    var COMMENT = function(begin, end, modeOptions = {}) {
      const mode = inherit(
        {
          className: "comment",
          begin,
          end,
          contains: []
        },
        modeOptions
      );
      mode.contains.push(PHRASAL_WORDS_MODE);
      mode.contains.push({
        className: "doctag",
        begin: "(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",
        relevance: 0
      });
      return mode;
    };
    var C_LINE_COMMENT_MODE = COMMENT("//", "$");
    var C_BLOCK_COMMENT_MODE = COMMENT("/\\*", "\\*/");
    var HASH_COMMENT_MODE = COMMENT("#", "$");
    var NUMBER_MODE = {
      className: "number",
      begin: NUMBER_RE,
      relevance: 0
    };
    var C_NUMBER_MODE = {
      className: "number",
      begin: C_NUMBER_RE,
      relevance: 0
    };
    var BINARY_NUMBER_MODE = {
      className: "number",
      begin: BINARY_NUMBER_RE,
      relevance: 0
    };
    var CSS_NUMBER_MODE = {
      className: "number",
      begin: NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
      relevance: 0
    };
    var REGEXP_MODE = {
      // this outer rule makes sure we actually have a WHOLE regex and not simply
      // an expression such as:
      //
      //     3 / something
      //
      // (which will then blow up when regex's `illegal` sees the newline)
      begin: /(?=\/[^/\n]*\/)/,
      contains: [{
        className: "regexp",
        begin: /\//,
        end: /\/[gimuy]*/,
        illegal: /\n/,
        contains: [
          BACKSLASH_ESCAPE,
          {
            begin: /\[/,
            end: /\]/,
            relevance: 0,
            contains: [BACKSLASH_ESCAPE]
          }
        ]
      }]
    };
    var TITLE_MODE = {
      className: "title",
      begin: IDENT_RE,
      relevance: 0
    };
    var UNDERSCORE_TITLE_MODE = {
      className: "title",
      begin: UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    var METHOD_GUARD = {
      // excludes method names from keyword processing
      begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
      relevance: 0
    };
    var END_SAME_AS_BEGIN = function(mode) {
      return Object.assign(
        mode,
        {
          /** @type {ModeCallback} */
          "on:begin": (m2, resp) => {
            resp.data._beginMatch = m2[1];
          },
          /** @type {ModeCallback} */
          "on:end": (m2, resp) => {
            if (resp.data._beginMatch !== m2[1]) resp.ignoreMatch();
          }
        }
      );
    };
    var MODES = Object.freeze({
      __proto__: null,
      MATCH_NOTHING_RE,
      IDENT_RE,
      UNDERSCORE_IDENT_RE,
      NUMBER_RE,
      C_NUMBER_RE,
      BINARY_NUMBER_RE,
      RE_STARTERS_RE,
      SHEBANG,
      BACKSLASH_ESCAPE,
      APOS_STRING_MODE,
      QUOTE_STRING_MODE,
      PHRASAL_WORDS_MODE,
      COMMENT,
      C_LINE_COMMENT_MODE,
      C_BLOCK_COMMENT_MODE,
      HASH_COMMENT_MODE,
      NUMBER_MODE,
      C_NUMBER_MODE,
      BINARY_NUMBER_MODE,
      CSS_NUMBER_MODE,
      REGEXP_MODE,
      TITLE_MODE,
      UNDERSCORE_TITLE_MODE,
      METHOD_GUARD,
      END_SAME_AS_BEGIN
    });
    function skipIfhasPrecedingDot(match3, response) {
      const before = match3.input[match3.index - 1];
      if (before === ".") {
        response.ignoreMatch();
      }
    }
    function beginKeywords(mode, parent) {
      if (!parent) return;
      if (!mode.beginKeywords) return;
      mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
      mode.__beforeBegin = skipIfhasPrecedingDot;
      mode.keywords = mode.keywords || mode.beginKeywords;
      delete mode.beginKeywords;
      if (mode.relevance === void 0) mode.relevance = 0;
    }
    function compileIllegal(mode, _parent) {
      if (!Array.isArray(mode.illegal)) return;
      mode.illegal = either3(...mode.illegal);
    }
    function compileMatch(mode, _parent) {
      if (!mode.match) return;
      if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");
      mode.begin = mode.match;
      delete mode.match;
    }
    function compileRelevance(mode, _parent) {
      if (mode.relevance === void 0) mode.relevance = 1;
    }
    var COMMON_KEYWORDS = [
      "of",
      "and",
      "for",
      "in",
      "not",
      "or",
      "if",
      "then",
      "parent",
      // common variable name
      "list",
      // common variable name
      "value"
      // common variable name
    ];
    var DEFAULT_KEYWORD_CLASSNAME = "keyword";
    function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
      const compiledKeywords = {};
      if (typeof rawKeywords === "string") {
        compileList2(className, rawKeywords.split(" "));
      } else if (Array.isArray(rawKeywords)) {
        compileList2(className, rawKeywords);
      } else {
        Object.keys(rawKeywords).forEach(function(className2) {
          Object.assign(
            compiledKeywords,
            compileKeywords(rawKeywords[className2], caseInsensitive, className2)
          );
        });
      }
      return compiledKeywords;
      function compileList2(className2, keywordList) {
        if (caseInsensitive) {
          keywordList = keywordList.map((x2) => x2.toLowerCase());
        }
        keywordList.forEach(function(keyword) {
          const pair3 = keyword.split("|");
          compiledKeywords[pair3[0]] = [className2, scoreForKeyword(pair3[0], pair3[1])];
        });
      }
    }
    function scoreForKeyword(keyword, providedScore) {
      if (providedScore) {
        return Number(providedScore);
      }
      return commonKeyword(keyword) ? 0 : 1;
    }
    function commonKeyword(keyword) {
      return COMMON_KEYWORDS.includes(keyword.toLowerCase());
    }
    function compileLanguage(language, { plugins: plugins2 }) {
      function langRe(value, global2) {
        return new RegExp(
          source(value),
          "m" + (language.case_insensitive ? "i" : "") + (global2 ? "g" : "")
        );
      }
      class MultiRegex {
        constructor() {
          this.matchIndexes = {};
          this.regexes = [];
          this.matchAt = 1;
          this.position = 0;
        }
        // @ts-ignore
        addRule(re, opts) {
          opts.position = this.position++;
          this.matchIndexes[this.matchAt] = opts;
          this.regexes.push([opts, re]);
          this.matchAt += countMatchGroups(re) + 1;
        }
        compile() {
          if (this.regexes.length === 0) {
            this.exec = () => null;
          }
          const terminators = this.regexes.map((el2) => el2[1]);
          this.matcherRe = langRe(join2(terminators), true);
          this.lastIndex = 0;
        }
        /** @param {string} s */
        exec(s2) {
          this.matcherRe.lastIndex = this.lastIndex;
          const match3 = this.matcherRe.exec(s2);
          if (!match3) {
            return null;
          }
          const i2 = match3.findIndex((el2, i3) => i3 > 0 && el2 !== void 0);
          const matchData = this.matchIndexes[i2];
          match3.splice(0, i2);
          return Object.assign(match3, matchData);
        }
      }
      class ResumableMultiRegex {
        constructor() {
          this.rules = [];
          this.multiRegexes = [];
          this.count = 0;
          this.lastIndex = 0;
          this.regexIndex = 0;
        }
        // @ts-ignore
        getMatcher(index) {
          if (this.multiRegexes[index]) return this.multiRegexes[index];
          const matcher = new MultiRegex();
          this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));
          matcher.compile();
          this.multiRegexes[index] = matcher;
          return matcher;
        }
        resumingScanAtSamePosition() {
          return this.regexIndex !== 0;
        }
        considerAll() {
          this.regexIndex = 0;
        }
        // @ts-ignore
        addRule(re, opts) {
          this.rules.push([re, opts]);
          if (opts.type === "begin") this.count++;
        }
        /** @param {string} s */
        exec(s2) {
          const m2 = this.getMatcher(this.regexIndex);
          m2.lastIndex = this.lastIndex;
          let result = m2.exec(s2);
          if (this.resumingScanAtSamePosition()) {
            if (result && result.index === this.lastIndex) ;
            else {
              const m22 = this.getMatcher(0);
              m22.lastIndex = this.lastIndex + 1;
              result = m22.exec(s2);
            }
          }
          if (result) {
            this.regexIndex += result.position + 1;
            if (this.regexIndex === this.count) {
              this.considerAll();
            }
          }
          return result;
        }
      }
      function buildModeRegex(mode) {
        const mm = new ResumableMultiRegex();
        mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
        if (mode.terminatorEnd) {
          mm.addRule(mode.terminatorEnd, { type: "end" });
        }
        if (mode.illegal) {
          mm.addRule(mode.illegal, { type: "illegal" });
        }
        return mm;
      }
      function compileMode(mode, parent) {
        const cmode = (
          /** @type CompiledMode */
          mode
        );
        if (mode.isCompiled) return cmode;
        [
          // do this early so compiler extensions generally don't have to worry about
          // the distinction between match/begin
          compileMatch
        ].forEach((ext) => ext(mode, parent));
        language.compilerExtensions.forEach((ext) => ext(mode, parent));
        mode.__beforeBegin = null;
        [
          beginKeywords,
          // do this later so compiler extensions that come earlier have access to the
          // raw array if they wanted to perhaps manipulate it, etc.
          compileIllegal,
          // default to 1 relevance if not specified
          compileRelevance
        ].forEach((ext) => ext(mode, parent));
        mode.isCompiled = true;
        let keywordPattern = null;
        if (typeof mode.keywords === "object") {
          keywordPattern = mode.keywords.$pattern;
          delete mode.keywords.$pattern;
        }
        if (mode.keywords) {
          mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
        }
        if (mode.lexemes && keywordPattern) {
          throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
        }
        keywordPattern = keywordPattern || mode.lexemes || /\w+/;
        cmode.keywordPatternRe = langRe(keywordPattern, true);
        if (parent) {
          if (!mode.begin) mode.begin = /\B|\b/;
          cmode.beginRe = langRe(mode.begin);
          if (mode.endSameAsBegin) mode.end = mode.begin;
          if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
          if (mode.end) cmode.endRe = langRe(mode.end);
          cmode.terminatorEnd = source(mode.end) || "";
          if (mode.endsWithParent && parent.terminatorEnd) {
            cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
          }
        }
        if (mode.illegal) cmode.illegalRe = langRe(
          /** @type {RegExp | string} */
          mode.illegal
        );
        if (!mode.contains) mode.contains = [];
        mode.contains = [].concat(...mode.contains.map(function(c2) {
          return expandOrCloneMode(c2 === "self" ? mode : c2);
        }));
        mode.contains.forEach(function(c2) {
          compileMode(
            /** @type Mode */
            c2,
            cmode
          );
        });
        if (mode.starts) {
          compileMode(mode.starts, parent);
        }
        cmode.matcher = buildModeRegex(cmode);
        return cmode;
      }
      if (!language.compilerExtensions) language.compilerExtensions = [];
      if (language.contains && language.contains.includes("self")) {
        throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
      }
      language.classNameAliases = inherit(language.classNameAliases || {});
      return compileMode(
        /** @type Mode */
        language
      );
    }
    function dependencyOnParent(mode) {
      if (!mode) return false;
      return mode.endsWithParent || dependencyOnParent(mode.starts);
    }
    function expandOrCloneMode(mode) {
      if (mode.variants && !mode.cachedVariants) {
        mode.cachedVariants = mode.variants.map(function(variant) {
          return inherit(mode, { variants: null }, variant);
        });
      }
      if (mode.cachedVariants) {
        return mode.cachedVariants;
      }
      if (dependencyOnParent(mode)) {
        return inherit(mode, { starts: mode.starts ? inherit(mode.starts) : null });
      }
      if (Object.isFrozen(mode)) {
        return inherit(mode);
      }
      return mode;
    }
    var version2 = "10.7.3";
    function hasValueOrEmptyAttribute(value) {
      return Boolean(value || value === "");
    }
    function BuildVuePlugin(hljs) {
      const Component2 = {
        props: ["language", "code", "autodetect"],
        data: function() {
          return {
            detectedLanguage: "",
            unknownLanguage: false
          };
        },
        computed: {
          className() {
            if (this.unknownLanguage) return "";
            return "hljs " + this.detectedLanguage;
          },
          highlighted() {
            if (!this.autoDetect && !hljs.getLanguage(this.language)) {
              console.warn(`The language "${this.language}" you specified could not be found.`);
              this.unknownLanguage = true;
              return escapeHTML(this.code);
            }
            let result = {};
            if (this.autoDetect) {
              result = hljs.highlightAuto(this.code);
              this.detectedLanguage = result.language;
            } else {
              result = hljs.highlight(this.language, this.code, this.ignoreIllegals);
              this.detectedLanguage = this.language;
            }
            return result.value;
          },
          autoDetect() {
            return !this.language || hasValueOrEmptyAttribute(this.autodetect);
          },
          ignoreIllegals() {
            return true;
          }
        },
        // this avoids needing to use a whole Vue compilation pipeline just
        // to build Highlight.js
        render(createElement3) {
          return createElement3("pre", {}, [
            createElement3("code", {
              class: this.className,
              domProps: { innerHTML: this.highlighted }
            })
          ]);
        }
        // template: `<pre><code :class="className" v-html="highlighted"></code></pre>`
      };
      const VuePlugin = {
        install(Vue) {
          Vue.component("highlightjs", Component2);
        }
      };
      return { Component: Component2, VuePlugin };
    }
    var mergeHTMLPlugin = {
      "after:highlightElement": ({ el: el2, result, text: text3 }) => {
        const originalStream = nodeStream(el2);
        if (!originalStream.length) return;
        const resultNode = document.createElement("div");
        resultNode.innerHTML = result.value;
        result.value = mergeStreams(originalStream, nodeStream(resultNode), text3);
      }
    };
    function tag(node) {
      return node.nodeName.toLowerCase();
    }
    function nodeStream(node) {
      const result = [];
      (function _nodeStream(node2, offset) {
        for (let child = node2.firstChild; child; child = child.nextSibling) {
          if (child.nodeType === 3) {
            offset += child.nodeValue.length;
          } else if (child.nodeType === 1) {
            result.push({
              event: "start",
              offset,
              node: child
            });
            offset = _nodeStream(child, offset);
            if (!tag(child).match(/br|hr|img|input/)) {
              result.push({
                event: "stop",
                offset,
                node: child
              });
            }
          }
        }
        return offset;
      })(node, 0);
      return result;
    }
    function mergeStreams(original, highlighted, value) {
      let processed = 0;
      let result = "";
      const nodeStack = [];
      function selectStream() {
        if (!original.length || !highlighted.length) {
          return original.length ? original : highlighted;
        }
        if (original[0].offset !== highlighted[0].offset) {
          return original[0].offset < highlighted[0].offset ? original : highlighted;
        }
        return highlighted[0].event === "start" ? original : highlighted;
      }
      function open(node) {
        function attributeString(attr) {
          return " " + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
        }
        result += "<" + tag(node) + [].map.call(node.attributes, attributeString).join("") + ">";
      }
      function close(node) {
        result += "</" + tag(node) + ">";
      }
      function render2(event) {
        (event.event === "start" ? open : close)(event.node);
      }
      while (original.length || highlighted.length) {
        let stream = selectStream();
        result += escapeHTML(value.substring(processed, stream[0].offset));
        processed = stream[0].offset;
        if (stream === original) {
          nodeStack.reverse().forEach(close);
          do {
            render2(stream.splice(0, 1)[0]);
            stream = selectStream();
          } while (stream === original && stream.length && stream[0].offset === processed);
          nodeStack.reverse().forEach(open);
        } else {
          if (stream[0].event === "start") {
            nodeStack.push(stream[0].node);
          } else {
            nodeStack.pop();
          }
          render2(stream.splice(0, 1)[0]);
        }
      }
      return result + escapeHTML(value.substr(processed));
    }
    var seenDeprecations = {};
    var error = (message) => {
      console.error(message);
    };
    var warn = (message, ...args) => {
      console.log(`WARN: ${message}`, ...args);
    };
    var deprecated = (version3, message) => {
      if (seenDeprecations[`${version3}/${message}`]) return;
      console.log(`Deprecated as of ${version3}. ${message}`);
      seenDeprecations[`${version3}/${message}`] = true;
    };
    var escape$1 = escapeHTML;
    var inherit$1 = inherit;
    var NO_MATCH = Symbol("nomatch");
    var HLJS = function(hljs) {
      const languages = /* @__PURE__ */ Object.create(null);
      const aliases = /* @__PURE__ */ Object.create(null);
      const plugins2 = [];
      let SAFE_MODE = true;
      const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
      const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
      const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
      let options = {
        noHighlightRe: /^(no-?highlight)$/i,
        languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
        classPrefix: "hljs-",
        tabReplace: null,
        useBR: false,
        languages: null,
        // beta configuration options, subject to change, welcome to discuss
        // https://github.com/highlightjs/highlight.js/issues/1086
        __emitter: TokenTreeEmitter
      };
      function shouldNotHighlight(languageName) {
        return options.noHighlightRe.test(languageName);
      }
      function blockLanguage(block2) {
        let classes = block2.className + " ";
        classes += block2.parentNode ? block2.parentNode.className : "";
        const match3 = options.languageDetectRe.exec(classes);
        if (match3) {
          const language = getLanguage(match3[1]);
          if (!language) {
            warn(LANGUAGE_NOT_FOUND.replace("{}", match3[1]));
            warn("Falling back to no-highlight mode for this block.", block2);
          }
          return language ? match3[1] : "no-highlight";
        }
        return classes.split(/\s+/).find((_class2) => shouldNotHighlight(_class2) || getLanguage(_class2));
      }
      function highlight2(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
        let code2 = "";
        let languageName = "";
        if (typeof optionsOrCode === "object") {
          code2 = codeOrlanguageName;
          ignoreIllegals = optionsOrCode.ignoreIllegals;
          languageName = optionsOrCode.language;
          continuation = void 0;
        } else {
          deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
          deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
          languageName = codeOrlanguageName;
          code2 = optionsOrCode;
        }
        const context2 = {
          code: code2,
          language: languageName
        };
        fire("before:highlight", context2);
        const result = context2.result ? context2.result : _highlight(context2.language, context2.code, ignoreIllegals, continuation);
        result.code = context2.code;
        fire("after:highlight", result);
        return result;
      }
      function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
        function keywordData(mode, match3) {
          const matchText = language.case_insensitive ? match3[0].toLowerCase() : match3[0];
          return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
        }
        function processKeywords() {
          if (!top.keywords) {
            emitter.addText(modeBuffer);
            return;
          }
          let lastIndex = 0;
          top.keywordPatternRe.lastIndex = 0;
          let match3 = top.keywordPatternRe.exec(modeBuffer);
          let buf = "";
          while (match3) {
            buf += modeBuffer.substring(lastIndex, match3.index);
            const data = keywordData(top, match3);
            if (data) {
              const [kind, keywordRelevance] = data;
              emitter.addText(buf);
              buf = "";
              relevance += keywordRelevance;
              if (kind.startsWith("_")) {
                buf += match3[0];
              } else {
                const cssClass = language.classNameAliases[kind] || kind;
                emitter.addKeyword(match3[0], cssClass);
              }
            } else {
              buf += match3[0];
            }
            lastIndex = top.keywordPatternRe.lastIndex;
            match3 = top.keywordPatternRe.exec(modeBuffer);
          }
          buf += modeBuffer.substr(lastIndex);
          emitter.addText(buf);
        }
        function processSubLanguage() {
          if (modeBuffer === "") return;
          let result2 = null;
          if (typeof top.subLanguage === "string") {
            if (!languages[top.subLanguage]) {
              emitter.addText(modeBuffer);
              return;
            }
            result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
            continuations[top.subLanguage] = /** @type {CompiledMode} */
            result2.top;
          } else {
            result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
          }
          if (top.relevance > 0) {
            relevance += result2.relevance;
          }
          emitter.addSublanguage(result2.emitter, result2.language);
        }
        function processBuffer() {
          if (top.subLanguage != null) {
            processSubLanguage();
          } else {
            processKeywords();
          }
          modeBuffer = "";
        }
        function startNewMode(mode) {
          if (mode.className) {
            emitter.openNode(language.classNameAliases[mode.className] || mode.className);
          }
          top = Object.create(mode, { parent: { value: top } });
          return top;
        }
        function endOfMode(mode, match3, matchPlusRemainder) {
          let matched = startsWith2(mode.endRe, matchPlusRemainder);
          if (matched) {
            if (mode["on:end"]) {
              const resp = new Response6(mode);
              mode["on:end"](match3, resp);
              if (resp.isMatchIgnored) matched = false;
            }
            if (matched) {
              while (mode.endsParent && mode.parent) {
                mode = mode.parent;
              }
              return mode;
            }
          }
          if (mode.endsWithParent) {
            return endOfMode(mode.parent, match3, matchPlusRemainder);
          }
        }
        function doIgnore(lexeme) {
          if (top.matcher.regexIndex === 0) {
            modeBuffer += lexeme[0];
            return 1;
          } else {
            resumeScanAtSamePosition = true;
            return 0;
          }
        }
        function doBeginMatch(match3) {
          const lexeme = match3[0];
          const newMode = match3.rule;
          const resp = new Response6(newMode);
          const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
          for (const cb of beforeCallbacks) {
            if (!cb) continue;
            cb(match3, resp);
            if (resp.isMatchIgnored) return doIgnore(lexeme);
          }
          if (newMode && newMode.endSameAsBegin) {
            newMode.endRe = escape3(lexeme);
          }
          if (newMode.skip) {
            modeBuffer += lexeme;
          } else {
            if (newMode.excludeBegin) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (!newMode.returnBegin && !newMode.excludeBegin) {
              modeBuffer = lexeme;
            }
          }
          startNewMode(newMode);
          return newMode.returnBegin ? 0 : lexeme.length;
        }
        function doEndMatch(match3) {
          const lexeme = match3[0];
          const matchPlusRemainder = codeToHighlight.substr(match3.index);
          const endMode = endOfMode(top, match3, matchPlusRemainder);
          if (!endMode) {
            return NO_MATCH;
          }
          const origin = top;
          if (origin.skip) {
            modeBuffer += lexeme;
          } else {
            if (!(origin.returnEnd || origin.excludeEnd)) {
              modeBuffer += lexeme;
            }
            processBuffer();
            if (origin.excludeEnd) {
              modeBuffer = lexeme;
            }
          }
          do {
            if (top.className) {
              emitter.closeNode();
            }
            if (!top.skip && !top.subLanguage) {
              relevance += top.relevance;
            }
            top = top.parent;
          } while (top !== endMode.parent);
          if (endMode.starts) {
            if (endMode.endSameAsBegin) {
              endMode.starts.endRe = endMode.endRe;
            }
            startNewMode(endMode.starts);
          }
          return origin.returnEnd ? 0 : lexeme.length;
        }
        function processContinuations() {
          const list4 = [];
          for (let current2 = top; current2 !== language; current2 = current2.parent) {
            if (current2.className) {
              list4.unshift(current2.className);
            }
          }
          list4.forEach((item) => emitter.openNode(item));
        }
        let lastMatch = {};
        function processLexeme(textBeforeMatch, match3) {
          const lexeme = match3 && match3[0];
          modeBuffer += textBeforeMatch;
          if (lexeme == null) {
            processBuffer();
            return 0;
          }
          if (lastMatch.type === "begin" && match3.type === "end" && lastMatch.index === match3.index && lexeme === "") {
            modeBuffer += codeToHighlight.slice(match3.index, match3.index + 1);
            if (!SAFE_MODE) {
              const err2 = new Error("0 width match regex");
              err2.languageName = languageName;
              err2.badRule = lastMatch.rule;
              throw err2;
            }
            return 1;
          }
          lastMatch = match3;
          if (match3.type === "begin") {
            return doBeginMatch(match3);
          } else if (match3.type === "illegal" && !ignoreIllegals) {
            const err2 = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || "<unnamed>") + '"');
            err2.mode = top;
            throw err2;
          } else if (match3.type === "end") {
            const processed = doEndMatch(match3);
            if (processed !== NO_MATCH) {
              return processed;
            }
          }
          if (match3.type === "illegal" && lexeme === "") {
            return 1;
          }
          if (iterations > 1e5 && iterations > match3.index * 3) {
            const err2 = new Error("potential infinite loop, way more iterations than matches");
            throw err2;
          }
          modeBuffer += lexeme;
          return lexeme.length;
        }
        const language = getLanguage(languageName);
        if (!language) {
          error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
          throw new Error('Unknown language: "' + languageName + '"');
        }
        const md = compileLanguage(language, { plugins: plugins2 });
        let result = "";
        let top = continuation || md;
        const continuations = {};
        const emitter = new options.__emitter(options);
        processContinuations();
        let modeBuffer = "";
        let relevance = 0;
        let index = 0;
        let iterations = 0;
        let resumeScanAtSamePosition = false;
        try {
          top.matcher.considerAll();
          for (; ; ) {
            iterations++;
            if (resumeScanAtSamePosition) {
              resumeScanAtSamePosition = false;
            } else {
              top.matcher.considerAll();
            }
            top.matcher.lastIndex = index;
            const match3 = top.matcher.exec(codeToHighlight);
            if (!match3) break;
            const beforeMatch = codeToHighlight.substring(index, match3.index);
            const processedCount = processLexeme(beforeMatch, match3);
            index = match3.index + processedCount;
          }
          processLexeme(codeToHighlight.substr(index));
          emitter.closeAllNodes();
          emitter.finalize();
          result = emitter.toHTML();
          return {
            // avoid possible breakage with v10 clients expecting
            // this to always be an integer
            relevance: Math.floor(relevance),
            value: result,
            language: languageName,
            illegal: false,
            emitter,
            top
          };
        } catch (err2) {
          if (err2.message && err2.message.includes("Illegal")) {
            return {
              illegal: true,
              illegalBy: {
                msg: err2.message,
                context: codeToHighlight.slice(index - 100, index + 100),
                mode: err2.mode
              },
              sofar: result,
              relevance: 0,
              value: escape$1(codeToHighlight),
              emitter
            };
          } else if (SAFE_MODE) {
            return {
              illegal: false,
              relevance: 0,
              value: escape$1(codeToHighlight),
              emitter,
              language: languageName,
              top,
              errorRaised: err2
            };
          } else {
            throw err2;
          }
        }
      }
      function justTextHighlightResult(code2) {
        const result = {
          relevance: 0,
          emitter: new options.__emitter(options),
          value: escape$1(code2),
          illegal: false,
          top: PLAINTEXT_LANGUAGE
        };
        result.emitter.addText(code2);
        return result;
      }
      function highlightAuto(code2, languageSubset) {
        languageSubset = languageSubset || options.languages || Object.keys(languages);
        const plaintext = justTextHighlightResult(code2);
        const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
          (name2) => _highlight(name2, code2, false)
        );
        results.unshift(plaintext);
        const sorted = results.sort((a2, b) => {
          if (a2.relevance !== b.relevance) return b.relevance - a2.relevance;
          if (a2.language && b.language) {
            if (getLanguage(a2.language).supersetOf === b.language) {
              return 1;
            } else if (getLanguage(b.language).supersetOf === a2.language) {
              return -1;
            }
          }
          return 0;
        });
        const [best, secondBest] = sorted;
        const result = best;
        result.second_best = secondBest;
        return result;
      }
      function fixMarkup(html2) {
        if (!(options.tabReplace || options.useBR)) {
          return html2;
        }
        return html2.replace(fixMarkupRe, (match3) => {
          if (match3 === "\n") {
            return options.useBR ? "<br>" : match3;
          } else if (options.tabReplace) {
            return match3.replace(/\t/g, options.tabReplace);
          }
          return match3;
        });
      }
      function updateClassName(element, currentLang, resultLang) {
        const language = currentLang ? aliases[currentLang] : resultLang;
        element.classList.add("hljs");
        if (language) element.classList.add(language);
      }
      const brPlugin = {
        "before:highlightElement": ({ el: el2 }) => {
          if (options.useBR) {
            el2.innerHTML = el2.innerHTML.replace(/\n/g, "").replace(/<br[ /]*>/g, "\n");
          }
        },
        "after:highlightElement": ({ result }) => {
          if (options.useBR) {
            result.value = result.value.replace(/\n/g, "<br>");
          }
        }
      };
      const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
      const tabReplacePlugin = {
        "after:highlightElement": ({ result }) => {
          if (options.tabReplace) {
            result.value = result.value.replace(
              TAB_REPLACE_RE,
              (m2) => m2.replace(/\t/g, options.tabReplace)
            );
          }
        }
      };
      function highlightElement(element) {
        let node = null;
        const language = blockLanguage(element);
        if (shouldNotHighlight(language)) return;
        fire(
          "before:highlightElement",
          { el: element, language }
        );
        node = element;
        const text3 = node.textContent;
        const result = language ? highlight2(text3, { language, ignoreIllegals: true }) : highlightAuto(text3);
        fire("after:highlightElement", { el: element, result, text: text3 });
        element.innerHTML = result.value;
        updateClassName(element, language, result.language);
        element.result = {
          language: result.language,
          // TODO: remove with version 11.0
          re: result.relevance,
          relavance: result.relevance
        };
        if (result.second_best) {
          element.second_best = {
            language: result.second_best.language,
            // TODO: remove with version 11.0
            re: result.second_best.relevance,
            relavance: result.second_best.relevance
          };
        }
      }
      function configure(userOptions) {
        if (userOptions.useBR) {
          deprecated("10.3.0", "'useBR' will be removed entirely in v11.0");
          deprecated("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
        }
        options = inherit$1(options, userOptions);
      }
      const initHighlighting = () => {
        if (initHighlighting.called) return;
        initHighlighting.called = true;
        deprecated("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");
        const blocks = document.querySelectorAll("pre code");
        blocks.forEach(highlightElement);
      };
      function initHighlightingOnLoad() {
        deprecated("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
        wantsHighlight = true;
      }
      let wantsHighlight = false;
      function highlightAll() {
        if (document.readyState === "loading") {
          wantsHighlight = true;
          return;
        }
        const blocks = document.querySelectorAll("pre code");
        blocks.forEach(highlightElement);
      }
      function boot() {
        if (wantsHighlight) highlightAll();
      }
      if (typeof window !== "undefined" && window.addEventListener) {
        window.addEventListener("DOMContentLoaded", boot, false);
      }
      function registerLanguage(languageName, languageDefinition) {
        let lang = null;
        try {
          lang = languageDefinition(hljs);
        } catch (error$1) {
          error("Language definition for '{}' could not be registered.".replace("{}", languageName));
          if (!SAFE_MODE) {
            throw error$1;
          } else {
            error(error$1);
          }
          lang = PLAINTEXT_LANGUAGE;
        }
        if (!lang.name) lang.name = languageName;
        languages[languageName] = lang;
        lang.rawDefinition = languageDefinition.bind(null, hljs);
        if (lang.aliases) {
          registerAliases(lang.aliases, { languageName });
        }
      }
      function unregisterLanguage(languageName) {
        delete languages[languageName];
        for (const alias of Object.keys(aliases)) {
          if (aliases[alias] === languageName) {
            delete aliases[alias];
          }
        }
      }
      function listLanguages() {
        return Object.keys(languages);
      }
      function requireLanguage(name2) {
        deprecated("10.4.0", "requireLanguage will be removed entirely in v11.");
        deprecated("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");
        const lang = getLanguage(name2);
        if (lang) {
          return lang;
        }
        const err2 = new Error("The '{}' language is required, but not loaded.".replace("{}", name2));
        throw err2;
      }
      function getLanguage(name2) {
        name2 = (name2 || "").toLowerCase();
        return languages[name2] || languages[aliases[name2]];
      }
      function registerAliases(aliasList, { languageName }) {
        if (typeof aliasList === "string") {
          aliasList = [aliasList];
        }
        aliasList.forEach((alias) => {
          aliases[alias.toLowerCase()] = languageName;
        });
      }
      function autoDetection(name2) {
        const lang = getLanguage(name2);
        return lang && !lang.disableAutodetect;
      }
      function upgradePluginAPI(plugin7) {
        if (plugin7["before:highlightBlock"] && !plugin7["before:highlightElement"]) {
          plugin7["before:highlightElement"] = (data) => {
            plugin7["before:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
        if (plugin7["after:highlightBlock"] && !plugin7["after:highlightElement"]) {
          plugin7["after:highlightElement"] = (data) => {
            plugin7["after:highlightBlock"](
              Object.assign({ block: data.el }, data)
            );
          };
        }
      }
      function addPlugin(plugin7) {
        upgradePluginAPI(plugin7);
        plugins2.push(plugin7);
      }
      function fire(event, args) {
        const cb = event;
        plugins2.forEach(function(plugin7) {
          if (plugin7[cb]) {
            plugin7[cb](args);
          }
        });
      }
      function deprecateFixMarkup(arg) {
        deprecated("10.2.0", "fixMarkup will be removed entirely in v11.0");
        deprecated("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");
        return fixMarkup(arg);
      }
      function deprecateHighlightBlock(el2) {
        deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
        deprecated("10.7.0", "Please use highlightElement now.");
        return highlightElement(el2);
      }
      Object.assign(hljs, {
        highlight: highlight2,
        highlightAuto,
        highlightAll,
        fixMarkup: deprecateFixMarkup,
        highlightElement,
        // TODO: Remove with v12 API
        highlightBlock: deprecateHighlightBlock,
        configure,
        initHighlighting,
        initHighlightingOnLoad,
        registerLanguage,
        unregisterLanguage,
        listLanguages,
        getLanguage,
        registerAliases,
        requireLanguage,
        autoDetection,
        inherit: inherit$1,
        addPlugin,
        // plugins for frameworks
        vuePlugin: BuildVuePlugin(hljs).VuePlugin
      });
      hljs.debugMode = function() {
        SAFE_MODE = false;
      };
      hljs.safeMode = function() {
        SAFE_MODE = true;
      };
      hljs.versionString = version2;
      for (const key57 in MODES) {
        if (typeof MODES[key57] === "object") {
          deepFreezeEs6(MODES[key57]);
        }
      }
      Object.assign(hljs, MODES);
      hljs.addPlugin(brPlugin);
      hljs.addPlugin(mergeHTMLPlugin);
      hljs.addPlugin(tabReplacePlugin);
      return hljs;
    };
    var highlight = HLJS({});
    module.exports = highlight;
  }
});

// node_modules/format/format.js
var require_format = __commonJS({
  "node_modules/format/format.js"(exports, module) {
    (function() {
      var namespace2;
      if (typeof module !== "undefined") {
        namespace2 = module.exports = format;
      } else {
        namespace2 = function() {
          return this || (1, eval)("this");
        }();
      }
      namespace2.format = format;
      namespace2.vsprintf = vsprintf;
      if (typeof console !== "undefined" && typeof console.log === "function") {
        namespace2.printf = printf;
      }
      function printf() {
        console.log(format.apply(null, arguments));
      }
      function vsprintf(fmt, replacements) {
        return format.apply(null, [fmt].concat(replacements));
      }
      function format(fmt) {
        var argIndex = 1, args = [].slice.call(arguments), i2 = 0, n = fmt.length, result = "", c2, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
          return args[argIndex++];
        }, slurpNumber = function() {
          var digits = "";
          while (/\d/.test(fmt[i2])) {
            digits += fmt[i2++];
            c2 = fmt[i2];
          }
          return digits.length > 0 ? parseInt(digits) : null;
        };
        for (; i2 < n; ++i2) {
          c2 = fmt[i2];
          if (escaped) {
            escaped = false;
            if (c2 == ".") {
              leadingZero = false;
              c2 = fmt[++i2];
            } else if (c2 == "0" && fmt[i2 + 1] == ".") {
              leadingZero = true;
              i2 += 2;
              c2 = fmt[i2];
            } else {
              leadingZero = true;
            }
            precision = slurpNumber();
            switch (c2) {
              case "b":
                result += parseInt(nextArg(), 10).toString(2);
                break;
              case "c":
                arg = nextArg();
                if (typeof arg === "string" || arg instanceof String)
                  result += arg;
                else
                  result += String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
                result += parseInt(nextArg(), 10);
                break;
              case "f":
                tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                result += leadingZero ? tmp : tmp.replace(/^0/, "");
                break;
              case "j":
                result += JSON.stringify(nextArg());
                break;
              case "o":
                result += "0" + parseInt(nextArg(), 10).toString(8);
                break;
              case "s":
                result += nextArg();
                break;
              case "x":
                result += "0x" + parseInt(nextArg(), 10).toString(16);
                break;
              case "X":
                result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
                break;
              default:
                result += c2;
                break;
            }
          } else if (c2 === "%") {
            escaped = true;
          } else {
            result += c2;
          }
        }
        return result;
      }
    })();
  }
});

// node_modules/fault/index.js
var require_fault = __commonJS({
  "node_modules/fault/index.js"(exports, module) {
    "use strict";
    var formatter = require_format();
    var fault = create2(Error);
    module.exports = fault;
    fault.eval = create2(EvalError);
    fault.range = create2(RangeError);
    fault.reference = create2(ReferenceError);
    fault.syntax = create2(SyntaxError);
    fault.type = create2(TypeError);
    fault.uri = create2(URIError);
    fault.create = create2;
    function create2(EConstructor) {
      FormattedError.displayName = EConstructor.displayName || EConstructor.name;
      return FormattedError;
      function FormattedError(format) {
        if (format) {
          format = formatter.apply(null, arguments);
        }
        return new EConstructor(format);
      }
    }
  }
});

// node_modules/lowlight/lib/core.js
var require_core2 = __commonJS({
  "node_modules/lowlight/lib/core.js"(exports) {
    "use strict";
    var high = require_core();
    var fault = require_fault();
    exports.highlight = highlight;
    exports.highlightAuto = highlightAuto;
    exports.registerLanguage = registerLanguage;
    exports.listLanguages = listLanguages;
    exports.registerAlias = registerAlias;
    Emitter.prototype.addText = text3;
    Emitter.prototype.addKeyword = addKeyword;
    Emitter.prototype.addSublanguage = addSublanguage;
    Emitter.prototype.openNode = open;
    Emitter.prototype.closeNode = close;
    Emitter.prototype.closeAllNodes = noop3;
    Emitter.prototype.finalize = noop3;
    Emitter.prototype.toHTML = toHtmlNoop;
    var defaultPrefix = "hljs-";
    function highlight(name2, value, options) {
      var before = high.configure({});
      var settings2 = options || {};
      var prefix = settings2.prefix;
      var result;
      if (typeof name2 !== "string") {
        throw fault("Expected `string` for name, got `%s`", name2);
      }
      if (!high.getLanguage(name2)) {
        throw fault("Unknown language: `%s` is not registered", name2);
      }
      if (typeof value !== "string") {
        throw fault("Expected `string` for value, got `%s`", value);
      }
      if (prefix === null || prefix === void 0) {
        prefix = defaultPrefix;
      }
      high.configure({ __emitter: Emitter, classPrefix: prefix });
      result = high.highlight(value, { language: name2, ignoreIllegals: true });
      high.configure(before || {});
      if (result.errorRaised) {
        throw result.errorRaised;
      }
      return {
        relevance: result.relevance,
        language: result.language,
        value: result.emitter.rootNode.children
      };
    }
    function highlightAuto(value, options) {
      var settings2 = options || {};
      var subset = settings2.subset || high.listLanguages();
      var prefix = settings2.prefix;
      var length3 = subset.length;
      var index = -1;
      var result;
      var secondBest;
      var current2;
      var name2;
      if (prefix === null || prefix === void 0) {
        prefix = defaultPrefix;
      }
      if (typeof value !== "string") {
        throw fault("Expected `string` for value, got `%s`", value);
      }
      secondBest = { relevance: 0, language: null, value: [] };
      result = { relevance: 0, language: null, value: [] };
      while (++index < length3) {
        name2 = subset[index];
        if (!high.getLanguage(name2)) {
          continue;
        }
        current2 = highlight(name2, value, options);
        current2.language = name2;
        if (current2.relevance > secondBest.relevance) {
          secondBest = current2;
        }
        if (current2.relevance > result.relevance) {
          secondBest = result;
          result = current2;
        }
      }
      if (secondBest.language) {
        result.secondBest = secondBest;
      }
      return result;
    }
    function registerLanguage(name2, syntax) {
      high.registerLanguage(name2, syntax);
    }
    function listLanguages() {
      return high.listLanguages();
    }
    function registerAlias(name2, alias) {
      var map5 = name2;
      var key57;
      if (alias) {
        map5 = {};
        map5[name2] = alias;
      }
      for (key57 in map5) {
        high.registerAliases(map5[key57], { languageName: key57 });
      }
    }
    function Emitter(options) {
      this.options = options;
      this.rootNode = { children: [] };
      this.stack = [this.rootNode];
    }
    function addKeyword(value, name2) {
      this.openNode(name2);
      this.addText(value);
      this.closeNode();
    }
    function addSublanguage(other, name2) {
      var stack = this.stack;
      var current2 = stack[stack.length - 1];
      var results = other.rootNode.children;
      var node = name2 ? {
        type: "element",
        tagName: "span",
        properties: { className: [name2] },
        children: results
      } : results;
      current2.children = current2.children.concat(node);
    }
    function text3(value) {
      var stack = this.stack;
      var current2;
      var tail2;
      if (value === "") return;
      current2 = stack[stack.length - 1];
      tail2 = current2.children[current2.children.length - 1];
      if (tail2 && tail2.type === "text") {
        tail2.value += value;
      } else {
        current2.children.push({ type: "text", value });
      }
    }
    function open(name2) {
      var stack = this.stack;
      var className = this.options.classPrefix + name2;
      var current2 = stack[stack.length - 1];
      var child = {
        type: "element",
        tagName: "span",
        properties: { className: [className] },
        children: []
      };
      current2.children.push(child);
      stack.push(child);
    }
    function close() {
      this.stack.pop();
    }
    function toHtmlNoop() {
      return "";
    }
    function noop3() {
    }
  }
});

// node_modules/highlight.js/lib/languages/javascript.js
var require_javascript = __commonJS({
  "node_modules/highlight.js/lib/languages/javascript.js"(exports, module) {
    var IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
    var KEYWORDS = [
      "as",
      // for exports
      "in",
      "of",
      "if",
      "for",
      "while",
      "finally",
      "var",
      "new",
      "function",
      "do",
      "return",
      "void",
      "else",
      "break",
      "catch",
      "instanceof",
      "with",
      "throw",
      "case",
      "default",
      "try",
      "switch",
      "continue",
      "typeof",
      "delete",
      "let",
      "yield",
      "const",
      "class",
      // JS handles these with a special rule
      // "get",
      // "set",
      "debugger",
      "async",
      "await",
      "static",
      "import",
      "from",
      "export",
      "extends"
    ];
    var LITERALS = [
      "true",
      "false",
      "null",
      "undefined",
      "NaN",
      "Infinity"
    ];
    var TYPES = [
      "Intl",
      "DataView",
      "Number",
      "Math",
      "Date",
      "String",
      "RegExp",
      "Object",
      "Function",
      "Boolean",
      "Error",
      "Symbol",
      "Set",
      "Map",
      "WeakSet",
      "WeakMap",
      "Proxy",
      "Reflect",
      "JSON",
      "Promise",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Float32Array",
      "Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "ArrayBuffer",
      "BigInt64Array",
      "BigUint64Array",
      "BigInt"
    ];
    var ERROR_TYPES = [
      "EvalError",
      "InternalError",
      "RangeError",
      "ReferenceError",
      "SyntaxError",
      "TypeError",
      "URIError"
    ];
    var BUILT_IN_GLOBALS = [
      "setInterval",
      "setTimeout",
      "clearInterval",
      "clearTimeout",
      "require",
      "exports",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "unescape"
    ];
    var BUILT_IN_VARIABLES = [
      "arguments",
      "this",
      "super",
      "console",
      "window",
      "document",
      "localStorage",
      "module",
      "global"
      // Node.js
    ];
    var BUILT_INS = [].concat(
      BUILT_IN_GLOBALS,
      BUILT_IN_VARIABLES,
      TYPES,
      ERROR_TYPES
    );
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;
      return re.source;
    }
    function lookahead(re) {
      return concat4("(?=", re, ")");
    }
    function concat4(...args) {
      const joined = args.map((x2) => source(x2)).join("");
      return joined;
    }
    function javascript2(hljs) {
      const hasClosingTag = (match3, { after }) => {
        const tag = "</" + match3[0].slice(1);
        const pos = match3.input.indexOf(tag, after);
        return pos !== -1;
      };
      const IDENT_RE$1 = IDENT_RE;
      const FRAGMENT = {
        begin: "<>",
        end: "</>"
      };
      const XML_TAG = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        /**
         * @param {RegExpMatchArray} match
         * @param {CallbackResponse} response
         */
        isTrulyOpeningTag: (match3, response) => {
          const afterMatchIndex = match3[0].length + match3.index;
          const nextChar = match3.input[afterMatchIndex];
          if (nextChar === "<") {
            response.ignoreMatch();
            return;
          }
          if (nextChar === ">") {
            if (!hasClosingTag(match3, { after: afterMatchIndex })) {
              response.ignoreMatch();
            }
          }
        }
      };
      const KEYWORDS$1 = {
        $pattern: IDENT_RE,
        keyword: KEYWORDS,
        literal: LITERALS,
        built_in: BUILT_INS
      };
      const decimalDigits = "[0-9](_?[0-9])*";
      const frac = `\\.(${decimalDigits})`;
      const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
      const NUMBER = {
        className: "number",
        variants: [
          // DecimalLiteral
          { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
          { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
          // DecimalBigIntegerLiteral
          { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
          // NonDecimalIntegerLiteral
          { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
          { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
          { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
          // LegacyOctalIntegerLiteral (does not include underscore separators)
          // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
          { begin: "\\b0[0-7]+n?\\b" }
        ],
        relevance: 0
      };
      const SUBST = {
        className: "subst",
        begin: "\\$\\{",
        end: "\\}",
        keywords: KEYWORDS$1,
        contains: []
        // defined later
      };
      const HTML_TEMPLATE = {
        begin: "html`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "xml"
        }
      };
      const CSS_TEMPLATE = {
        begin: "css`",
        end: "",
        starts: {
          end: "`",
          returnEnd: false,
          contains: [
            hljs.BACKSLASH_ESCAPE,
            SUBST
          ],
          subLanguage: "css"
        }
      };
      const TEMPLATE_STRING = {
        className: "string",
        begin: "`",
        end: "`",
        contains: [
          hljs.BACKSLASH_ESCAPE,
          SUBST
        ]
      };
      const JSDOC_COMMENT = hljs.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+",
              contains: [
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      );
      const COMMENT = {
        className: "comment",
        variants: [
          JSDOC_COMMENT,
          hljs.C_BLOCK_COMMENT_MODE,
          hljs.C_LINE_COMMENT_MODE
        ]
      };
      const SUBST_INTERNALS = [
        hljs.APOS_STRING_MODE,
        hljs.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        TEMPLATE_STRING,
        NUMBER,
        hljs.REGEXP_MODE
      ];
      SUBST.contains = SUBST_INTERNALS.concat({
        // we need to pair up {} inside our subst to prevent
        // it from ending too early by matching another }
        begin: /\{/,
        end: /\}/,
        keywords: KEYWORDS$1,
        contains: [
          "self"
        ].concat(SUBST_INTERNALS)
      });
      const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);
      const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
        // eat recursive parens in sub expressions
        {
          begin: /\(/,
          end: /\)/,
          keywords: KEYWORDS$1,
          contains: ["self"].concat(SUBST_AND_COMMENTS)
        }
      ]);
      const PARAMS = {
        className: "params",
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: KEYWORDS$1,
        contains: PARAMS_CONTAINS
      };
      return {
        name: "Javascript",
        aliases: ["js", "jsx", "mjs", "cjs"],
        keywords: KEYWORDS$1,
        // this will be extended by TypeScript
        exports: { PARAMS_CONTAINS },
        illegal: /#(?![$_A-z])/,
        contains: [
          hljs.SHEBANG({
            label: "shebang",
            binary: "node",
            relevance: 5
          }),
          {
            label: "use_strict",
            className: "meta",
            relevance: 10,
            begin: /^\s*['"]use (strict|asm)['"]/
          },
          hljs.APOS_STRING_MODE,
          hljs.QUOTE_STRING_MODE,
          HTML_TEMPLATE,
          CSS_TEMPLATE,
          TEMPLATE_STRING,
          COMMENT,
          NUMBER,
          {
            // object attr container
            begin: concat4(
              /[{,\n]\s*/,
              // we need to look ahead to make sure that we actually have an
              // attribute coming up so we don't steal a comma from a potential
              // "value" container
              //
              // NOTE: this might not work how you think.  We don't actually always
              // enter this mode and stay.  Instead it might merely match `,
              // <comments up next>` and then immediately end after the , because it
              // fails to find any actual attrs. But this still does the job because
              // it prevents the value contain rule from grabbing this instead and
              // prevening this rule from firing when we actually DO have keys.
              lookahead(concat4(
                // we also need to allow for multiple possible comments inbetween
                // the first key:value pairing
                /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
                IDENT_RE$1 + "\\s*:"
              ))
            ),
            relevance: 0,
            contains: [
              {
                className: "attr",
                begin: IDENT_RE$1 + lookahead("\\s*:"),
                relevance: 0
              }
            ]
          },
          {
            // "value" container
            begin: "(" + hljs.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
            keywords: "return throw case",
            contains: [
              COMMENT,
              hljs.REGEXP_MODE,
              {
                className: "function",
                // we have to count the parens to make sure we actually have the
                // correct bounding ( ) before the =>.  There could be any number of
                // sub-expressions inside also surrounded by parens.
                begin: "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs.UNDERSCORE_IDENT_RE + ")\\s*=>",
                returnBegin: true,
                end: "\\s*=>",
                contains: [
                  {
                    className: "params",
                    variants: [
                      {
                        begin: hljs.UNDERSCORE_IDENT_RE,
                        relevance: 0
                      },
                      {
                        className: null,
                        begin: /\(\s*\)/,
                        skip: true
                      },
                      {
                        begin: /\(/,
                        end: /\)/,
                        excludeBegin: true,
                        excludeEnd: true,
                        keywords: KEYWORDS$1,
                        contains: PARAMS_CONTAINS
                      }
                    ]
                  }
                ]
              },
              {
                // could be a comma delimited list of params to a function call
                begin: /,/,
                relevance: 0
              },
              {
                className: "",
                begin: /\s/,
                end: /\s*/,
                skip: true
              },
              {
                // JSX
                variants: [
                  { begin: FRAGMENT.begin, end: FRAGMENT.end },
                  {
                    begin: XML_TAG.begin,
                    // we carefully check the opening tag to see if it truly
                    // is a tag and not a false positive
                    "on:begin": XML_TAG.isTrulyOpeningTag,
                    end: XML_TAG.end
                  }
                ],
                subLanguage: "xml",
                contains: [
                  {
                    begin: XML_TAG.begin,
                    end: XML_TAG.end,
                    skip: true,
                    contains: ["self"]
                  }
                ]
              }
            ],
            relevance: 0
          },
          {
            className: "function",
            beginKeywords: "function",
            end: /[{;]/,
            excludeEnd: true,
            keywords: KEYWORDS$1,
            contains: [
              "self",
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
              PARAMS
            ],
            illegal: /%/
          },
          {
            // prevent this from getting swallowed up by function
            // since they appear "function like"
            beginKeywords: "while if switch catch for"
          },
          {
            className: "function",
            // we have to count the parens to make sure we actually have the correct
            // bounding ( ).  There could be any number of sub-expressions inside
            // also surrounded by parens.
            begin: hljs.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
            // end parens
            returnBegin: true,
            contains: [
              PARAMS,
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 })
            ]
          },
          // hack: prevents detection of keywords in some circumstances
          // .keyword()
          // $keyword = x
          {
            variants: [
              { begin: "\\." + IDENT_RE$1 },
              { begin: "\\$" + IDENT_RE$1 }
            ],
            relevance: 0
          },
          {
            // ES6 class
            className: "class",
            beginKeywords: "class",
            end: /[{;=]/,
            excludeEnd: true,
            illegal: /[:"[\]]/,
            contains: [
              { beginKeywords: "extends" },
              hljs.UNDERSCORE_TITLE_MODE
            ]
          },
          {
            begin: /\b(?=constructor)/,
            end: /[{;]/,
            excludeEnd: true,
            contains: [
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
              "self",
              PARAMS
            ]
          },
          {
            begin: "(get|set)\\s+(?=" + IDENT_RE$1 + "\\()",
            end: /\{/,
            keywords: "get set",
            contains: [
              hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE$1 }),
              { begin: /\(\)/ },
              // eat to avoid empty params
              PARAMS
            ]
          },
          {
            begin: /\$[(.]/
            // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
          }
        ]
      };
    }
    module.exports = javascript2;
  }
});

// node_modules/highlight.js/lib/languages/json.js
var require_json = __commonJS({
  "node_modules/highlight.js/lib/languages/json.js"(exports, module) {
    function json3(hljs) {
      const LITERALS = {
        literal: "true false null"
      };
      const ALLOWED_COMMENTS = [
        hljs.C_LINE_COMMENT_MODE,
        hljs.C_BLOCK_COMMENT_MODE
      ];
      const TYPES = [
        hljs.QUOTE_STRING_MODE,
        hljs.C_NUMBER_MODE
      ];
      const VALUE_CONTAINER = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        contains: TYPES,
        keywords: LITERALS
      };
      const OBJECT = {
        begin: /\{/,
        end: /\}/,
        contains: [
          {
            className: "attr",
            begin: /"/,
            end: /"/,
            contains: [hljs.BACKSLASH_ESCAPE],
            illegal: "\\n"
          },
          hljs.inherit(VALUE_CONTAINER, {
            begin: /:/
          })
        ].concat(ALLOWED_COMMENTS),
        illegal: "\\S"
      };
      const ARRAY = {
        begin: "\\[",
        end: "\\]",
        contains: [hljs.inherit(VALUE_CONTAINER)],
        // inherit is a workaround for a bug that makes shared modes with endsWithParent compile only the ending of one of the parents
        illegal: "\\S"
      };
      TYPES.push(OBJECT, ARRAY);
      ALLOWED_COMMENTS.forEach(function(rule) {
        TYPES.push(rule);
      });
      return {
        name: "JSON",
        contains: TYPES,
        keywords: LITERALS,
        illegal: "\\S"
      };
    }
    module.exports = json3;
  }
});

// node_modules/highlight.js/lib/languages/xml.js
var require_xml = __commonJS({
  "node_modules/highlight.js/lib/languages/xml.js"(exports, module) {
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;
      return re.source;
    }
    function lookahead(re) {
      return concat4("(?=", re, ")");
    }
    function optional(re) {
      return concat4("(", re, ")?");
    }
    function concat4(...args) {
      const joined = args.map((x2) => source(x2)).join("");
      return joined;
    }
    function either3(...args) {
      const joined = "(" + args.map((x2) => source(x2)).join("|") + ")";
      return joined;
    }
    function xml3(hljs) {
      const TAG_NAME_RE = concat4(/[A-Z_]/, optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);
      const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;
      const XML_ENTITIES = {
        className: "symbol",
        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
      };
      const XML_META_KEYWORDS = {
        begin: /\s/,
        contains: [
          {
            className: "meta-keyword",
            begin: /#?[a-z_][a-z1-9_-]+/,
            illegal: /\n/
          }
        ]
      };
      const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {
        begin: /\(/,
        end: /\)/
      });
      const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {
        className: "meta-string"
      });
      const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {
        className: "meta-string"
      });
      const TAG_INTERNALS = {
        endsWithParent: true,
        illegal: /</,
        relevance: 0,
        contains: [
          {
            className: "attr",
            begin: XML_IDENT_RE,
            relevance: 0
          },
          {
            begin: /=\s*/,
            relevance: 0,
            contains: [
              {
                className: "string",
                endsParent: true,
                variants: [
                  {
                    begin: /"/,
                    end: /"/,
                    contains: [XML_ENTITIES]
                  },
                  {
                    begin: /'/,
                    end: /'/,
                    contains: [XML_ENTITIES]
                  },
                  {
                    begin: /[^\s"'=<>`]+/
                  }
                ]
              }
            ]
          }
        ]
      };
      return {
        name: "HTML, XML",
        aliases: [
          "html",
          "xhtml",
          "rss",
          "atom",
          "xjb",
          "xsd",
          "xsl",
          "plist",
          "wsf",
          "svg"
        ],
        case_insensitive: true,
        contains: [
          {
            className: "meta",
            begin: /<![a-z]/,
            end: />/,
            relevance: 10,
            contains: [
              XML_META_KEYWORDS,
              QUOTE_META_STRING_MODE,
              APOS_META_STRING_MODE,
              XML_META_PAR_KEYWORDS,
              {
                begin: /\[/,
                end: /\]/,
                contains: [
                  {
                    className: "meta",
                    begin: /<![a-z]/,
                    end: />/,
                    contains: [
                      XML_META_KEYWORDS,
                      XML_META_PAR_KEYWORDS,
                      QUOTE_META_STRING_MODE,
                      APOS_META_STRING_MODE
                    ]
                  }
                ]
              }
            ]
          },
          hljs.COMMENT(
            /<!--/,
            /-->/,
            {
              relevance: 10
            }
          ),
          {
            begin: /<!\[CDATA\[/,
            end: /\]\]>/,
            relevance: 10
          },
          XML_ENTITIES,
          {
            className: "meta",
            begin: /<\?xml/,
            end: /\?>/,
            relevance: 10
          },
          {
            className: "tag",
            /*
            The lookahead pattern (?=...) ensures that 'begin' only matches
            '<style' as a single word, followed by a whitespace or an
            ending braket. The '$' is needed for the lexeme to be recognized
            by hljs.subMode() that tests lexemes outside the stream.
            */
            begin: /<style(?=\s|>)/,
            end: />/,
            keywords: {
              name: "style"
            },
            contains: [TAG_INTERNALS],
            starts: {
              end: /<\/style>/,
              returnEnd: true,
              subLanguage: [
                "css",
                "xml"
              ]
            }
          },
          {
            className: "tag",
            // See the comment in the <style tag about the lookahead pattern
            begin: /<script(?=\s|>)/,
            end: />/,
            keywords: {
              name: "script"
            },
            contains: [TAG_INTERNALS],
            starts: {
              end: /<\/script>/,
              returnEnd: true,
              subLanguage: [
                "javascript",
                "handlebars",
                "xml"
              ]
            }
          },
          // we need this for now for jSX
          {
            className: "tag",
            begin: /<>|<\/>/
          },
          // open tag
          {
            className: "tag",
            begin: concat4(
              /</,
              lookahead(concat4(
                TAG_NAME_RE,
                // <tag/>
                // <tag>
                // <tag ...
                either3(/\/>/, />/, /\s/)
              ))
            ),
            end: /\/?>/,
            contains: [
              {
                className: "name",
                begin: TAG_NAME_RE,
                relevance: 0,
                starts: TAG_INTERNALS
              }
            ]
          },
          // close tag
          {
            className: "tag",
            begin: concat4(
              /<\//,
              lookahead(concat4(
                TAG_NAME_RE,
                />/
              ))
            ),
            contains: [
              {
                className: "name",
                begin: TAG_NAME_RE,
                relevance: 0
              },
              {
                begin: />/,
                relevance: 0,
                endsParent: true
              }
            ]
          }
        ]
      };
    }
    module.exports = xml3;
  }
});

// node_modules/highlight.js/lib/languages/bash.js
var require_bash = __commonJS({
  "node_modules/highlight.js/lib/languages/bash.js"(exports, module) {
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;
      return re.source;
    }
    function concat4(...args) {
      const joined = args.map((x2) => source(x2)).join("");
      return joined;
    }
    function bash2(hljs) {
      const VAR = {};
      const BRACED_VAR = {
        begin: /\$\{/,
        end: /\}/,
        contains: [
          "self",
          {
            begin: /:-/,
            contains: [VAR]
          }
          // default values
        ]
      };
      Object.assign(VAR, {
        className: "variable",
        variants: [
          { begin: concat4(
            /\$[\w\d#@][\w\d_]*/,
            // negative look-ahead tries to avoid matching patterns that are not
            // Perl at all like $ident$, @ident@, etc.
            `(?![\\w\\d])(?![$])`
          ) },
          BRACED_VAR
        ]
      });
      const SUBST = {
        className: "subst",
        begin: /\$\(/,
        end: /\)/,
        contains: [hljs.BACKSLASH_ESCAPE]
      };
      const HERE_DOC = {
        begin: /<<-?\s*(?=\w+)/,
        starts: {
          contains: [
            hljs.END_SAME_AS_BEGIN({
              begin: /(\w+)/,
              end: /(\w+)/,
              className: "string"
            })
          ]
        }
      };
      const QUOTE_STRING = {
        className: "string",
        begin: /"/,
        end: /"/,
        contains: [
          hljs.BACKSLASH_ESCAPE,
          VAR,
          SUBST
        ]
      };
      SUBST.contains.push(QUOTE_STRING);
      const ESCAPED_QUOTE = {
        className: "",
        begin: /\\"/
      };
      const APOS_STRING = {
        className: "string",
        begin: /'/,
        end: /'/
      };
      const ARITHMETIC = {
        begin: /\$\(\(/,
        end: /\)\)/,
        contains: [
          { begin: /\d+#[0-9a-f]+/, className: "number" },
          hljs.NUMBER_MODE,
          VAR
        ]
      };
      const SH_LIKE_SHELLS = [
        "fish",
        "bash",
        "zsh",
        "sh",
        "csh",
        "ksh",
        "tcsh",
        "dash",
        "scsh"
      ];
      const KNOWN_SHEBANG = hljs.SHEBANG({
        binary: `(${SH_LIKE_SHELLS.join("|")})`,
        relevance: 10
      });
      const FUNCTION = {
        className: "function",
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: true,
        contains: [hljs.inherit(hljs.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
        relevance: 0
      };
      return {
        name: "Bash",
        aliases: ["sh", "zsh"],
        keywords: {
          $pattern: /\b[a-z._-]+\b/,
          keyword: "if then else elif fi for while in do done case esac function",
          literal: "true false",
          built_in: (
            // Shell built-ins
            // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
            "break cd continue eval exec exit export getopts hash pwd readonly return shift test times trap umask unset alias bind builtin caller command declare echo enable help let local logout mapfile printf read readarray source type typeset ulimit unalias set shopt autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate fc fg float functions getcap getln history integer jobs kill limit log noglob popd print pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof zpty zregexparse zsocket zstyle ztcp"
          )
        },
        contains: [
          KNOWN_SHEBANG,
          // to catch known shells and boost relevancy
          hljs.SHEBANG(),
          // to catch unknown shells but still highlight the shebang
          FUNCTION,
          ARITHMETIC,
          hljs.HASH_COMMENT_MODE,
          HERE_DOC,
          QUOTE_STRING,
          ESCAPED_QUOTE,
          APOS_STRING,
          VAR
        ]
      };
    }
    module.exports = bash2;
  }
});

// node_modules/highlight.js/lib/languages/yaml.js
var require_yaml = __commonJS({
  "node_modules/highlight.js/lib/languages/yaml.js"(exports, module) {
    function yaml2(hljs) {
      var LITERALS = "true false yes no null";
      var URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
      var KEY = {
        className: "attr",
        variants: [
          { begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" },
          { begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)' },
          // double quoted keys
          { begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)" }
          // single quoted keys
        ]
      };
      var TEMPLATE_VARIABLES = {
        className: "template-variable",
        variants: [
          { begin: /\{\{/, end: /\}\}/ },
          // jinja templates Ansible
          { begin: /%\{/, end: /\}/ }
          // Ruby i18n
        ]
      };
      var STRING = {
        className: "string",
        relevance: 0,
        variants: [
          { begin: /'/, end: /'/ },
          { begin: /"/, end: /"/ },
          { begin: /\S+/ }
        ],
        contains: [
          hljs.BACKSLASH_ESCAPE,
          TEMPLATE_VARIABLES
        ]
      };
      var CONTAINER_STRING = hljs.inherit(STRING, {
        variants: [
          { begin: /'/, end: /'/ },
          { begin: /"/, end: /"/ },
          { begin: /[^\s,{}[\]]+/ }
        ]
      });
      var DATE_RE = "[0-9]{4}(-[0-9][0-9]){0,2}";
      var TIME_RE = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?";
      var FRACTION_RE = "(\\.[0-9]*)?";
      var ZONE_RE = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?";
      var TIMESTAMP = {
        className: "number",
        begin: "\\b" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + "\\b"
      };
      var VALUE_CONTAINER = {
        end: ",",
        endsWithParent: true,
        excludeEnd: true,
        keywords: LITERALS,
        relevance: 0
      };
      var OBJECT = {
        begin: /\{/,
        end: /\}/,
        contains: [VALUE_CONTAINER],
        illegal: "\\n",
        relevance: 0
      };
      var ARRAY = {
        begin: "\\[",
        end: "\\]",
        contains: [VALUE_CONTAINER],
        illegal: "\\n",
        relevance: 0
      };
      var MODES = [
        KEY,
        {
          className: "meta",
          begin: "^---\\s*$",
          relevance: 10
        },
        {
          // multi line string
          // Blocks start with a | or > followed by a newline
          //
          // Indentation of subsequent lines must be the same to
          // be considered part of the block
          className: "string",
          begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
        },
        {
          // Ruby/Rails erb
          begin: "<%[%=-]?",
          end: "[%-]?%>",
          subLanguage: "ruby",
          excludeBegin: true,
          excludeEnd: true,
          relevance: 0
        },
        {
          // named tags
          className: "type",
          begin: "!\\w+!" + URI_CHARACTERS
        },
        // https://yaml.org/spec/1.2/spec.html#id2784064
        {
          // verbatim tags
          className: "type",
          begin: "!<" + URI_CHARACTERS + ">"
        },
        {
          // primary tags
          className: "type",
          begin: "!" + URI_CHARACTERS
        },
        {
          // secondary tags
          className: "type",
          begin: "!!" + URI_CHARACTERS
        },
        {
          // fragment id &ref
          className: "meta",
          begin: "&" + hljs.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // fragment reference *ref
          className: "meta",
          begin: "\\*" + hljs.UNDERSCORE_IDENT_RE + "$"
        },
        {
          // array listing
          className: "bullet",
          // TODO: remove |$ hack when we have proper look-ahead support
          begin: "-(?=[ ]|$)",
          relevance: 0
        },
        hljs.HASH_COMMENT_MODE,
        {
          beginKeywords: LITERALS,
          keywords: { literal: LITERALS }
        },
        TIMESTAMP,
        // numbers are any valid C-style number that
        // sit isolated from other words
        {
          className: "number",
          begin: hljs.C_NUMBER_RE + "\\b",
          relevance: 0
        },
        OBJECT,
        ARRAY,
        STRING
      ];
      var VALUE_MODES = [...MODES];
      VALUE_MODES.pop();
      VALUE_MODES.push(CONTAINER_STRING);
      VALUE_CONTAINER.contains = VALUE_MODES;
      return {
        name: "YAML",
        case_insensitive: true,
        aliases: ["yml"],
        contains: MODES
      };
    }
    module.exports = yaml2;
  }
});

// node_modules/highlight.js/lib/languages/http.js
var require_http = __commonJS({
  "node_modules/highlight.js/lib/languages/http.js"(exports, module) {
    function source(re) {
      if (!re) return null;
      if (typeof re === "string") return re;
      return re.source;
    }
    function concat4(...args) {
      const joined = args.map((x2) => source(x2)).join("");
      return joined;
    }
    function http3(hljs) {
      const VERSION = "HTTP/(2|1\\.[01])";
      const HEADER_NAME = /[A-Za-z][A-Za-z0-9-]*/;
      const HEADER = {
        className: "attribute",
        begin: concat4("^", HEADER_NAME, "(?=\\:\\s)"),
        starts: {
          contains: [
            {
              className: "punctuation",
              begin: /: /,
              relevance: 0,
              starts: {
                end: "$",
                relevance: 0
              }
            }
          ]
        }
      };
      const HEADERS_AND_BODY = [
        HEADER,
        {
          begin: "\\n\\n",
          starts: { subLanguage: [], endsWithParent: true }
        }
      ];
      return {
        name: "HTTP",
        aliases: ["https"],
        illegal: /\S/,
        contains: [
          // response
          {
            begin: "^(?=" + VERSION + " \\d{3})",
            end: /$/,
            contains: [
              {
                className: "meta",
                begin: VERSION
              },
              {
                className: "number",
                begin: "\\b\\d{3}\\b"
              }
            ],
            starts: {
              end: /\b\B/,
              illegal: /\S/,
              contains: HEADERS_AND_BODY
            }
          },
          // request
          {
            begin: "(?=^[A-Z]+ (.*?) " + VERSION + "$)",
            end: /$/,
            contains: [
              {
                className: "string",
                begin: " ",
                end: " ",
                excludeBegin: true,
                excludeEnd: true
              },
              {
                className: "meta",
                begin: VERSION
              },
              {
                className: "keyword",
                begin: "[A-Z]+"
              }
            ],
            starts: {
              end: /\b\B/,
              illegal: /\S/,
              contains: HEADERS_AND_BODY
            }
          },
          // to allow headers to work even without a preamble
          hljs.inherit(HEADER, {
            relevance: 0
          })
        ]
      };
    }
    module.exports = http3;
  }
});

// node_modules/highlight.js/lib/languages/powershell.js
var require_powershell = __commonJS({
  "node_modules/highlight.js/lib/languages/powershell.js"(exports, module) {
    function powershell2(hljs) {
      const TYPES = [
        "string",
        "char",
        "byte",
        "int",
        "long",
        "bool",
        "decimal",
        "single",
        "double",
        "DateTime",
        "xml",
        "array",
        "hashtable",
        "void"
      ];
      const VALID_VERBS = "Add|Clear|Close|Copy|Enter|Exit|Find|Format|Get|Hide|Join|Lock|Move|New|Open|Optimize|Pop|Push|Redo|Remove|Rename|Reset|Resize|Search|Select|Set|Show|Skip|Split|Step|Switch|Undo|Unlock|Watch|Backup|Checkpoint|Compare|Compress|Convert|ConvertFrom|ConvertTo|Dismount|Edit|Expand|Export|Group|Import|Initialize|Limit|Merge|Mount|Out|Publish|Restore|Save|Sync|Unpublish|Update|Approve|Assert|Build|Complete|Confirm|Deny|Deploy|Disable|Enable|Install|Invoke|Register|Request|Restart|Resume|Start|Stop|Submit|Suspend|Uninstall|Unregister|Wait|Debug|Measure|Ping|Repair|Resolve|Test|Trace|Connect|Disconnect|Read|Receive|Send|Write|Block|Grant|Protect|Revoke|Unblock|Unprotect|Use|ForEach|Sort|Tee|Where";
      const COMPARISON_OPERATORS = "-and|-as|-band|-bnot|-bor|-bxor|-casesensitive|-ccontains|-ceq|-cge|-cgt|-cle|-clike|-clt|-cmatch|-cne|-cnotcontains|-cnotlike|-cnotmatch|-contains|-creplace|-csplit|-eq|-exact|-f|-file|-ge|-gt|-icontains|-ieq|-ige|-igt|-ile|-ilike|-ilt|-imatch|-in|-ine|-inotcontains|-inotlike|-inotmatch|-ireplace|-is|-isnot|-isplit|-join|-le|-like|-lt|-match|-ne|-not|-notcontains|-notin|-notlike|-notmatch|-or|-regex|-replace|-shl|-shr|-split|-wildcard|-xor";
      const KEYWORDS = {
        $pattern: /-?[A-z\.\-]+\b/,
        keyword: "if else foreach return do while until elseif begin for trap data dynamicparam end break throw param continue finally in switch exit filter try process catch hidden static parameter",
        // "echo" relevance has been set to 0 to avoid auto-detect conflicts with shell transcripts
        built_in: "ac asnp cat cd CFS chdir clc clear clhy cli clp cls clv cnsn compare copy cp cpi cpp curl cvpa dbp del diff dir dnsn ebp echo|0 epal epcsv epsn erase etsn exsn fc fhx fl ft fw gal gbp gc gcb gci gcm gcs gdr gerr ghy gi gin gjb gl gm gmo gp gps gpv group gsn gsnp gsv gtz gu gv gwmi h history icm iex ihy ii ipal ipcsv ipmo ipsn irm ise iwmi iwr kill lp ls man md measure mi mount move mp mv nal ndr ni nmo npssc nsn nv ogv oh popd ps pushd pwd r rbp rcjb rcsn rd rdr ren ri rjb rm rmdir rmo rni rnp rp rsn rsnp rujb rv rvpa rwmi sajb sal saps sasv sbp sc scb select set shcm si sl sleep sls sort sp spjb spps spsv start stz sujb sv swmi tee trcm type wget where wjb write"
        // TODO: 'validate[A-Z]+' can't work in keywords
      };
      const TITLE_NAME_RE = /\w[\w\d]*((-)[\w\d]+)*/;
      const BACKTICK_ESCAPE = {
        begin: "`[\\s\\S]",
        relevance: 0
      };
      const VAR = {
        className: "variable",
        variants: [
          {
            begin: /\$\B/
          },
          {
            className: "keyword",
            begin: /\$this/
          },
          {
            begin: /\$[\w\d][\w\d_:]*/
          }
        ]
      };
      const LITERAL = {
        className: "literal",
        begin: /\$(null|true|false)\b/
      };
      const QUOTE_STRING = {
        className: "string",
        variants: [
          {
            begin: /"/,
            end: /"/
          },
          {
            begin: /@"/,
            end: /^"@/
          }
        ],
        contains: [
          BACKTICK_ESCAPE,
          VAR,
          {
            className: "variable",
            begin: /\$[A-z]/,
            end: /[^A-z]/
          }
        ]
      };
      const APOS_STRING = {
        className: "string",
        variants: [
          {
            begin: /'/,
            end: /'/
          },
          {
            begin: /@'/,
            end: /^'@/
          }
        ]
      };
      const PS_HELPTAGS = {
        className: "doctag",
        variants: [
          /* no paramater help tags */
          {
            begin: /\.(synopsis|description|example|inputs|outputs|notes|link|component|role|functionality)/
          },
          /* one parameter help tags */
          {
            begin: /\.(parameter|forwardhelptargetname|forwardhelpcategory|remotehelprunspace|externalhelp)\s+\S+/
          }
        ]
      };
      const PS_COMMENT = hljs.inherit(
        hljs.COMMENT(null, null),
        {
          variants: [
            /* single-line comment */
            {
              begin: /#/,
              end: /$/
            },
            /* multi-line comment */
            {
              begin: /<#/,
              end: /#>/
            }
          ],
          contains: [PS_HELPTAGS]
        }
      );
      const CMDLETS = {
        className: "built_in",
        variants: [
          {
            begin: "(".concat(VALID_VERBS, ")+(-)[\\w\\d]+")
          }
        ]
      };
      const PS_CLASS = {
        className: "class",
        beginKeywords: "class enum",
        end: /\s*[{]/,
        excludeEnd: true,
        relevance: 0,
        contains: [hljs.TITLE_MODE]
      };
      const PS_FUNCTION = {
        className: "function",
        begin: /function\s+/,
        end: /\s*\{|$/,
        excludeEnd: true,
        returnBegin: true,
        relevance: 0,
        contains: [
          {
            begin: "function",
            relevance: 0,
            className: "keyword"
          },
          {
            className: "title",
            begin: TITLE_NAME_RE,
            relevance: 0
          },
          {
            begin: /\(/,
            end: /\)/,
            className: "params",
            relevance: 0,
            contains: [VAR]
          }
          // CMDLETS
        ]
      };
      const PS_USING = {
        begin: /using\s/,
        end: /$/,
        returnBegin: true,
        contains: [
          QUOTE_STRING,
          APOS_STRING,
          {
            className: "keyword",
            begin: /(using|assembly|command|module|namespace|type)/
          }
        ]
      };
      const PS_ARGUMENTS = {
        variants: [
          // PS literals are pretty verbose so it's a good idea to accent them a bit.
          {
            className: "operator",
            begin: "(".concat(COMPARISON_OPERATORS, ")\\b")
          },
          {
            className: "literal",
            begin: /(-)[\w\d]+/,
            relevance: 0
          }
        ]
      };
      const HASH_SIGNS = {
        className: "selector-tag",
        begin: /@\B/,
        relevance: 0
      };
      const PS_METHODS = {
        className: "function",
        begin: /\[.*\]\s*[\w]+[ ]??\(/,
        end: /$/,
        returnBegin: true,
        relevance: 0,
        contains: [
          {
            className: "keyword",
            begin: "(".concat(
              KEYWORDS.keyword.toString().replace(
                /\s/g,
                "|"
              ),
              ")\\b"
            ),
            endsParent: true,
            relevance: 0
          },
          hljs.inherit(hljs.TITLE_MODE, {
            endsParent: true
          })
        ]
      };
      const GENTLEMANS_SET = [
        // STATIC_MEMBER,
        PS_METHODS,
        PS_COMMENT,
        BACKTICK_ESCAPE,
        hljs.NUMBER_MODE,
        QUOTE_STRING,
        APOS_STRING,
        // PS_NEW_OBJECT_TYPE,
        CMDLETS,
        VAR,
        LITERAL,
        HASH_SIGNS
      ];
      const PS_TYPE = {
        begin: /\[/,
        end: /\]/,
        excludeBegin: true,
        excludeEnd: true,
        relevance: 0,
        contains: [].concat(
          "self",
          GENTLEMANS_SET,
          {
            begin: "(" + TYPES.join("|") + ")",
            className: "built_in",
            relevance: 0
          },
          {
            className: "type",
            begin: /[\.\w\d]+/,
            relevance: 0
          }
        )
      };
      PS_METHODS.contains.unshift(PS_TYPE);
      return {
        name: "PowerShell",
        aliases: [
          "ps",
          "ps1"
        ],
        case_insensitive: true,
        keywords: KEYWORDS,
        contains: GENTLEMANS_SET.concat(
          PS_CLASS,
          PS_FUNCTION,
          PS_USING,
          PS_ARGUMENTS,
          PS_TYPE
        )
      };
    }
    module.exports = powershell2;
  }
});

// node_modules/js-file-download/file-download.js
var require_file_download = __commonJS({
  "node_modules/js-file-download/file-download.js"(exports, module) {
    module.exports = function(data, filename, mime, bom) {
      var blobData = typeof bom !== "undefined" ? [bom, data] : [data];
      var blob = new Blob(blobData, { type: mime || "application/octet-stream" });
      if (typeof window.navigator.msSaveBlob !== "undefined") {
        window.navigator.msSaveBlob(blob, filename);
      } else {
        var blobURL = window.URL && window.URL.createObjectURL ? window.URL.createObjectURL(blob) : window.webkitURL.createObjectURL(blob);
        var tempLink = document.createElement("a");
        tempLink.style.display = "none";
        tempLink.href = blobURL;
        tempLink.setAttribute("download", filename);
        if (typeof tempLink.download === "undefined") {
          tempLink.setAttribute("target", "_blank");
        }
        document.body.appendChild(tempLink);
        tempLink.click();
        setTimeout(function() {
          document.body.removeChild(tempLink);
          window.URL.revokeObjectURL(blobURL);
        }, 200);
      }
    };
  }
});

// node_modules/lodash/_baseZipObject.js
var require_baseZipObject = __commonJS({
  "node_modules/lodash/_baseZipObject.js"(exports, module) {
    function baseZipObject(props3, values3, assignFunc) {
      var index = -1, length3 = props3.length, valsLength = values3.length, result = {};
      while (++index < length3) {
        var value = index < valsLength ? values3[index] : void 0;
        assignFunc(result, props3[index], value);
      }
      return result;
    }
    module.exports = baseZipObject;
  }
});

// node_modules/lodash/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/lodash/zipObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseZipObject = require_baseZipObject();
    function zipObject(props3, values3) {
      return baseZipObject(props3 || [], values3 || [], assignValue);
    }
    module.exports = zipObject;
  }
});

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/repeat-string/index.js"(exports, module) {
    "use strict";
    var res = "";
    var cache;
    module.exports = repeat6;
    function repeat6(str2, num) {
      if (typeof str2 !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1) return str2;
      if (num === 2) return str2 + str2;
      var max3 = str2.length * num;
      if (cache !== str2 || typeof cache === "undefined") {
        cache = str2;
        res = "";
      } else if (res.length >= max3) {
        return res.substr(0, max3);
      }
      while (max3 > res.length && num > 1) {
        if (num & 1) {
          res += str2;
        }
        num >>= 1;
        str2 += str2;
      }
      res += str2;
      res = res.substr(0, max3);
      return res;
    }
  }
});

// node_modules/xml-but-prettier/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/xml-but-prettier/dist/index.js"(exports, module) {
    "use strict";
    var repeat6 = require_repeat_string();
    var splitOnTags = function splitOnTags2(str2) {
      return str2.split(/(<\/?[^>]+>)/g).filter(function(line) {
        return line.trim() !== "";
      });
    };
    var isTag2 = function isTag3(str2) {
      return /<[^>!]+>/.test(str2);
    };
    var isClosingTag = function isClosingTag2(str2) {
      return /<\/+[^>]+>/.test(str2);
    };
    var isSelfClosingTag = function isSelfClosingTag2(str2) {
      return /<[^>]+\/>/.test(str2);
    };
    var isOpeningTag = function isOpeningTag2(str2) {
      return isTag2(str2) && !isClosingTag(str2) && !isSelfClosingTag(str2);
    };
    module.exports = function(xml3) {
      var config2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var indentor = config2.indentor, textNodesOnSameLine = config2.textNodesOnSameLine;
      var depth = 0;
      var indicesToRemove = [];
      indentor = indentor || "    ";
      var rawResult = lexer(xml3).map(function(element, i2, arr) {
        var value = element.value, type5 = element.type;
        if (type5 === "ClosingTag") {
          depth--;
        }
        var indentation = repeat6(indentor, depth);
        var line = indentation + value;
        if (type5 === "OpeningTag") {
          depth++;
        }
        if (textNodesOnSameLine) {
          var oneBefore = arr[i2 - 1];
          var twoBefore = arr[i2 - 2];
          if (type5 === "ClosingTag" && oneBefore.type === "Text" && twoBefore.type === "OpeningTag") {
            line = "" + indentation + twoBefore.value + oneBefore.value + value;
            indicesToRemove.push(i2 - 2, i2 - 1);
          }
        }
        return line;
      });
      indicesToRemove.forEach(function(idx) {
        return rawResult[idx] = null;
      });
      return rawResult.filter(function(val) {
        return !!val;
      }).join("\n");
    };
    function lexer(xmlStr) {
      var values3 = splitOnTags(xmlStr);
      return values3.map(function(value) {
        return {
          value,
          type: getType2(value)
        };
      });
    }
    function getType2(str2) {
      if (isClosingTag(str2)) {
        return "ClosingTag";
      }
      if (isOpeningTag(str2)) {
        return "OpeningTag";
      }
      if (isSelfClosingTag(str2)) {
        return "SelfClosingTag";
      }
      return "Text";
    }
  }
});

// node_modules/lodash/toLower.js
var require_toLower = __commonJS({
  "node_modules/lodash/toLower.js"(exports, module) {
    var toString5 = require_toString();
    function toLower2(value) {
      return toString5(value).toLowerCase();
    }
    module.exports = toLower2;
  }
});

// node_modules/lodash/escapeRegExp.js
var require_escapeRegExp = __commonJS({
  "node_modules/lodash/escapeRegExp.js"(exports, module) {
    var toString5 = require_toString();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reHasRegExpChar = RegExp(reRegExpChar.source);
    function escapeRegExp2(string) {
      string = toString5(string);
      return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
    }
    module.exports = escapeRegExp2;
  }
});

// node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "node_modules/lodash/_baseHas.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    function baseHas(object2, key57) {
      return object2 != null && hasOwnProperty3.call(object2, key57);
    }
    module.exports = baseHas;
  }
});

// node_modules/lodash/has.js
var require_has2 = __commonJS({
  "node_modules/lodash/has.js"(exports, module) {
    var baseHas = require_baseHas();
    var hasPath3 = require_hasPath();
    function has4(object2, path4) {
      return object2 != null && hasPath3(object2, path4, baseHas);
    }
    module.exports = has4;
  }
});

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var e = __toESM(require_base64_js());
var t = __toESM(require_ieee754());
var r = __toESM(require_react());

// node_modules/redux/dist/redux.mjs
var $$observable = (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var symbol_observable_default = $$observable;
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var ActionTypes = {
  INIT: `@@redux/INIT${randomString()}`,
  REPLACE: `@@redux/REPLACE${randomString()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
var actionTypes_default = ActionTypes;
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  let proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2 || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  const type5 = typeof val;
  switch (type5) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type5;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  const constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  let typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer, preloadedState, enhancer) {
  if (typeof reducer !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);
  }
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = /* @__PURE__ */ new Map();
  let nextListeners = currentListeners;
  let listenerIdCounter = 0;
  let isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = /* @__PURE__ */ new Map();
      currentListeners.forEach((listener, key57) => {
        nextListeners.set(key57, listener);
      });
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener)}'`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    let isSubscribed = true;
    ensureCanMutateNextListeners();
    const listenerId = listenerIdCounter++;
    nextListeners.set(listenerId, listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      nextListeners.delete(listenerId);
      currentListeners = null;
    };
  }
  function dispatch2(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (typeof action.type !== "string") {
      throw new Error(false ? formatProdErrorMessage(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    const listeners = currentListeners = nextListeners;
    listeners.forEach((listener) => {
      listener();
    });
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
    }
    currentReducer = nextReducer;
    dispatch2({
      type: actionTypes_default.REPLACE
    });
  }
  function observable() {
    const outerSubscribe = subscribe;
    return {
      /**
       * The minimal observable subscription method.
       * @param observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
        }
        function observeState() {
          const observerAsObserver = observer;
          if (observerAsObserver.next) {
            observerAsObserver.next(getState());
          }
        }
        observeState();
        const unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      },
      [symbol_observable_default]() {
        return this;
      }
    };
  }
  dispatch2({
    type: actionTypes_default.INIT
  });
  const store = {
    dispatch: dispatch2,
    subscribe,
    getState,
    replaceReducer,
    [symbol_observable_default]: observable
  };
  return store;
}
function bindActionCreator(actionCreator, dispatch2) {
  return function(...args) {
    return dispatch2(actionCreator.apply(this, args));
  };
}
function bindActionCreators(actionCreators, dispatch2) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch2);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(false ? formatProdErrorMessage(16) : `bindActionCreators expected an object or a function, but instead received: '${kindOf(actionCreators)}'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
  }
  const boundActionCreators = {};
  for (const key57 in actionCreators) {
    const actionCreator = actionCreators[key57];
    if (typeof actionCreator === "function") {
      boundActionCreators[key57] = bindActionCreator(actionCreator, dispatch2);
    }
  }
  return boundActionCreators;
}
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce((a2, b) => (...args) => a2(b(...args)));
}
function applyMiddleware(...middlewares) {
  return (createStore2) => (reducer, preloadedState) => {
    const store = createStore2(reducer, preloadedState);
    let dispatch2 = () => {
      throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
    };
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch2(action, ...args)
    };
    const chain4 = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch2 = compose(...chain4)(store.dispatch);
    return {
      ...store,
      dispatch: dispatch2
    };
  };
}

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var a = __toESM(require_immutable());
var o3 = __toESM(require_dist());
var s = __toESM(require_serialize_error());
var l = __toESM(require_merge());
var i = __toESM(require_dist2());
var c = __toESM(require_camelCase());
var u = __toESM(require_upperFirst());
var d = __toESM(require_memoize());
var p = __toESM(require_find());
var m = __toESM(require_some());
var f = __toESM(require_eq());
var h = __toESM(require_isFunction());
var g = __toESM(require_css_escape());
var y = __toESM(require_url_parse());

// node_modules/reselect/dist/reselect.mjs
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
  if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
    let isInputSameAsOutput = false;
    try {
      const emptyObject = {};
      if (resultFunc(emptyObject) === emptyObject)
        isInputSameAsOutput = true;
    } catch {
    }
    if (isInputSameAsOutput) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e2) {
        ;
        ({ stack } = e2);
      }
      console.warn(
        "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
        { stack }
      );
    }
  }
};
var runInputStabilityCheck = (inputSelectorResultsObject, options, inputSelectorArgs) => {
  const { memoize, memoizeOptions } = options;
  const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions);
  const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
  if (!areInputSelectorResultsEqual) {
    let stack = void 0;
    try {
      throw new Error();
    } catch (e2) {
      ;
      ({ stack } = e2);
    }
    console.warn(
      "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
      {
        arguments: inputSelectorArgs,
        firstInputs: inputSelectorResults,
        secondInputs: inputSelectorResultsCopy,
        stack
      }
    );
  }
};
var globalDevModeChecks = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
};
var NOT_FOUND = Symbol("NOT_FOUND");
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
  if (typeof func !== "function") {
    throw new TypeError(errorMessage);
  }
}
function assertIsObject(object2, errorMessage = `expected an object, instead received ${typeof object2}`) {
  if (typeof object2 !== "object") {
    throw new TypeError(errorMessage);
  }
}
function assertIsArrayOfFunctions(array2, errorMessage = `expected all items to be functions, instead received the following types: `) {
  if (!array2.every((item) => typeof item === "function")) {
    const itemTypes = array2.map(
      (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
    ).join(", ");
    throw new TypeError(`${errorMessage}[${itemTypes}]`);
  }
}
var ensureIsArray = (item) => {
  return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
  const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
  assertIsArrayOfFunctions(
    dependencies,
    `createSelector expects all input-selectors to be functions, but received the following types: `
  );
  return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
  const inputSelectorResults = [];
  const { length: length3 } = dependencies;
  for (let i2 = 0; i2 < length3; i2++) {
    inputSelectorResults.push(dependencies[i2].apply(null, inputSelectorArgs));
  }
  return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
  const { identityFunctionCheck, inputStabilityCheck } = {
    ...globalDevModeChecks,
    ...devModeChecks
  };
  return {
    identityFunctionCheck: {
      shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
      run: runIdentityFunctionCheck
    },
    inputStabilityCheck: {
      shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
      run: runInputStabilityCheck
    }
  };
};
var REDUX_PROXY_LABEL = Symbol();
var proto = Object.getPrototypeOf({});
var StrongRef = class {
  constructor(value) {
    this.value = value;
  }
  deref() {
    return this.value;
  }
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
  return {
    s: UNTERMINATED,
    v: void 0,
    o: null,
    p: null
  };
}
function weakMapMemoize(func, options = {}) {
  let fnNode = createCacheNode();
  const { resultEqualityCheck } = options;
  let lastResult;
  let resultsCount = 0;
  function memoized() {
    var _a6;
    let cacheNode = fnNode;
    const { length: length3 } = arguments;
    for (let i2 = 0, l2 = length3; i2 < l2; i2++) {
      const arg = arguments[i2];
      if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
        let objectCache = cacheNode.o;
        if (objectCache === null) {
          cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
        }
        const objectNode = objectCache.get(arg);
        if (objectNode === void 0) {
          cacheNode = createCacheNode();
          objectCache.set(arg, cacheNode);
        } else {
          cacheNode = objectNode;
        }
      } else {
        let primitiveCache = cacheNode.p;
        if (primitiveCache === null) {
          cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
        }
        const primitiveNode = primitiveCache.get(arg);
        if (primitiveNode === void 0) {
          cacheNode = createCacheNode();
          primitiveCache.set(arg, cacheNode);
        } else {
          cacheNode = primitiveNode;
        }
      }
    }
    const terminatedNode = cacheNode;
    let result;
    if (cacheNode.s === TERMINATED) {
      result = cacheNode.v;
    } else {
      result = func.apply(null, arguments);
      resultsCount++;
      if (resultEqualityCheck) {
        const lastResultValue = ((_a6 = lastResult == null ? void 0 : lastResult.deref) == null ? void 0 : _a6.call(lastResult)) ?? lastResult;
        if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
          result = lastResultValue;
          resultsCount !== 0 && resultsCount--;
        }
        const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
        lastResult = needsWeakRef ? new Ref(result) : result;
      }
    }
    terminatedNode.s = TERMINATED;
    terminatedNode.v = result;
    return result;
  }
  memoized.clearCache = () => {
    fnNode = createCacheNode();
    memoized.resetResultsCount();
  };
  memoized.resultsCount = () => resultsCount;
  memoized.resetResultsCount = () => {
    resultsCount = 0;
  };
  return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
  const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
    memoize: memoizeOrOptions,
    memoizeOptions: memoizeOptionsFromArgs
  } : memoizeOrOptions;
  const createSelector2 = (...createSelectorArgs) => {
    let recomputations = 0;
    let dependencyRecomputations = 0;
    let lastResult;
    let directlyPassedOptions = {};
    let resultFunc = createSelectorArgs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = createSelectorArgs.pop();
    }
    assertIsFunction(
      resultFunc,
      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
    );
    const combinedOptions = {
      ...createSelectorCreatorOptions,
      ...directlyPassedOptions
    };
    const {
      memoize,
      memoizeOptions = [],
      argsMemoize = weakMapMemoize,
      argsMemoizeOptions = [],
      devModeChecks = {}
    } = combinedOptions;
    const finalMemoizeOptions = ensureIsArray(memoizeOptions);
    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
    const dependencies = getDependencies(createSelectorArgs);
    const memoizedResultFunc = memoize(function recomputationWrapper() {
      recomputations++;
      return resultFunc.apply(
        null,
        arguments
      );
    }, ...finalMemoizeOptions);
    let firstRun = true;
    const selector = argsMemoize(function dependenciesChecker() {
      dependencyRecomputations++;
      const inputSelectorResults = collectInputSelectorResults(
        dependencies,
        arguments
      );
      lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
      if (true) {
        const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
        if (identityFunctionCheck.shouldRun) {
          identityFunctionCheck.run(
            resultFunc,
            inputSelectorResults,
            lastResult
          );
        }
        if (inputStabilityCheck.shouldRun) {
          const inputSelectorResultsCopy = collectInputSelectorResults(
            dependencies,
            arguments
          );
          inputStabilityCheck.run(
            { inputSelectorResults, inputSelectorResultsCopy },
            { memoize, memoizeOptions: finalMemoizeOptions },
            arguments
          );
        }
        if (firstRun)
          firstRun = false;
      }
      return lastResult;
    }, ...finalArgsMemoizeOptions);
    return Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      dependencyRecomputations: () => dependencyRecomputations,
      resetDependencyRecomputations: () => {
        dependencyRecomputations = 0;
      },
      lastResult: () => lastResult,
      recomputations: () => recomputations,
      resetRecomputations: () => {
        recomputations = 0;
      },
      memoize,
      argsMemoize
    });
  };
  Object.assign(createSelector2, {
    withTypes: () => createSelector2
  });
  return createSelector2;
}
var createSelector = createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign(
  (inputSelectorsObject, selectorCreator = createSelector) => {
    assertIsObject(
      inputSelectorsObject,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
    );
    const inputSelectorKeys = Object.keys(inputSelectorsObject);
    const dependencies = inputSelectorKeys.map(
      (key57) => inputSelectorsObject[key57]
    );
    const structuredSelector = selectorCreator(
      dependencies,
      (...inputSelectorResults) => {
        return inputSelectorResults.reduce((composition, value, index) => {
          composition[inputSelectorKeys[index]] = value;
          return composition;
        }, {});
      }
    );
    return structuredSelector;
  },
  { withTypes: () => createStructuredSelector }
);

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var _ = __toESM(require_prop_types());
var v = __toESM(require_omit());

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence3) {
  if (Array.isArray(sequence3)) return sequence3;
  else if (isNothing(sequence3)) return [];
  return [sequence3];
}
function extend(target, source) {
  var index, length3, key57, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length3 = sourceKeys.length; index < length3; index += 1) {
      key57 = sourceKeys[index];
      target[key57] = source[key57];
    }
  }
  return target;
}
function repeat(string, count2) {
  var result = "", cycle;
  for (cycle = 0; cycle < count2; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact2) {
  var where3 = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where3 += 'in "' + exception2.mark.name + '" ';
  }
  where3 += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact2 && exception2.mark.snippet) {
    where3 += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where3;
}
function YAMLException$1(reason, mark2) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark2;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact2) {
  return this.name + ": " + formatError(this, compact2);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head2 = "";
  var tail2 = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head2 = " ... ";
    lineStart = position - maxHalfLength + head2.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail2 = " ...";
    lineEnd = position + maxHalfLength - tail2.length;
  }
  return {
    str: head2 + buffer.slice(lineStart, lineEnd).replace(/\t/g, "") + tail2,
    pos: position - lineStart + head2.length
    // relative position
  };
}
function padStart(string, max3) {
  return common.repeat(" ", max3 - string.length) + string;
}
function makeSnippet(mark2, options) {
  options = Object.create(options || null);
  if (!mark2.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match3;
  var foundLineNo = -1;
  while (match3 = re.exec(mark2.buffer)) {
    lineEnds.push(match3.index);
    lineStarts.push(match3.index + match3[0].length);
    if (mark2.position <= match3.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i2, line;
  var lineNoLength = Math.min(mark2.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options.linesBefore; i2++) {
    if (foundLineNo - i2 < 0) break;
    line = getLine(
      mark2.buffer,
      lineStarts[foundLineNo - i2],
      lineEnds[foundLineNo - i2],
      mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark2.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark2.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark2.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark2.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i2 = 1; i2 <= options.linesAfter; i2++) {
    if (foundLineNo + i2 >= lineEnds.length) break;
    line = getLine(
      mark2.buffer,
      lineStarts[foundLineNo + i2],
      lineEnds[foundLineNo + i2],
      mark2.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark2.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map5) {
  var result = {};
  if (map5 !== null) {
    Object.keys(map5).forEach(function(style) {
      map5[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name2) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
      throw new exception('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema4, name2) {
  var result = [];
  schema4[name2].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length3;
  function collectType(type5) {
    if (type5.multi) {
      result.multi[type5.kind].push(type5);
      result.multi["fallback"].push(type5);
    } else {
      result[type5.kind][type5.tag] = result["fallback"][type5.tag] = type5;
    }
  }
  for (index = 0, length3 = arguments.length; index < length3; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null) return true;
  var max3 = data.length;
  return max3 === 1 && data === "~" || max3 === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object2) {
  return object2 === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max3 = data.length;
  return max3 === 4 && (data === "true" || data === "True" || data === "TRUE") || max3 === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object2) {
  return Object.prototype.toString.call(object2) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object2) {
      return object2 ? "true" : "false";
    },
    uppercase: function(object2) {
      return object2 ? "TRUE" : "FALSE";
    },
    camelcase: function(object2) {
      return object2 ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max3 = data.length, index = 0, hasDigits = false, ch;
  if (!max3) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max3) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max3; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max3; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max3; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max3; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign2 = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign2 = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign2 * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign2 * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign2 * parseInt(value.slice(2), 8);
  }
  return sign2 * parseInt(value, 10);
}
function isInteger(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 === 0 && !common.isNegativeZero(object2));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign2;
  value = data.replace(/_/g, "").toLowerCase();
  sign2 = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign2 * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object2, style) {
  var res;
  if (isNaN(object2)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object2) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object2)) {
    return "-0.0";
  }
  res = object2.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object2) {
  return Object.prototype.toString.call(object2) === "[object Number]" && (object2 % 1 !== 0 || common.isNegativeZero(object2));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match3, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date2;
  match3 = YAML_DATE_REGEXP.exec(data);
  if (match3 === null) match3 = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match3 === null) throw new Error("Date resolve error");
  year = +match3[1];
  month = +match3[2] - 1;
  day = +match3[3];
  if (!match3[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match3[4];
  minute = +match3[5];
  second = +match3[6];
  if (match3[7]) {
    fraction = match3[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match3[9]) {
    tz_hour = +match3[10];
    tz_minute = +(match3[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match3[9] === "-") delta = -delta;
  }
  date2 = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date2.setTime(date2.getTime() - delta);
  return date2;
}
function representYamlTimestamp(object2) {
  return object2.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code2, idx, bitlen = 0, max3 = data.length, map5 = BASE64_MAP;
  for (idx = 0; idx < max3; idx++) {
    code2 = map5.indexOf(data.charAt(idx));
    if (code2 > 64) continue;
    if (code2 < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max3 = input.length, map5 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max3; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map5.indexOf(input.charAt(idx));
  }
  tailbits = max3 % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object2) {
  var result = "", bits = 0, idx, tail2, max3 = object2.length, map5 = BASE64_MAP;
  for (idx = 0; idx < max3; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map5[bits >> 18 & 63];
      result += map5[bits >> 12 & 63];
      result += map5[bits >> 6 & 63];
      result += map5[bits & 63];
    }
    bits = (bits << 8) + object2[idx];
  }
  tail2 = max3 % 3;
  if (tail2 === 0) {
    result += map5[bits >> 18 & 63];
    result += map5[bits >> 12 & 63];
    result += map5[bits >> 6 & 63];
    result += map5[bits & 63];
  } else if (tail2 === 2) {
    result += map5[bits >> 10 & 63];
    result += map5[bits >> 4 & 63];
    result += map5[bits << 2 & 63];
    result += map5[64];
  } else if (tail2 === 1) {
    result += map5[bits >> 2 & 63];
    result += map5[bits << 4 & 63];
    result += map5[64];
    result += map5[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length3, pair3, pairKey, pairHasKey, object2 = data;
  for (index = 0, length3 = object2.length; index < length3; index += 1) {
    pair3 = object2[index];
    pairHasKey = false;
    if (_toString$2.call(pair3) !== "[object Object]") return false;
    for (pairKey in pair3) {
      if (_hasOwnProperty$3.call(pair3, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length3, pair3, keys4, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length3 = object2.length; index < length3; index += 1) {
    pair3 = object2[index];
    if (_toString$1.call(pair3) !== "[object Object]") return false;
    keys4 = Object.keys(pair3);
    if (keys4.length !== 1) return false;
    result[index] = [keys4[0], pair3[keys4[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length3, pair3, keys4, result, object2 = data;
  result = new Array(object2.length);
  for (index = 0, length3 = object2.length; index < length3; index += 1) {
    pair3 = object2[index];
    keys4 = Object.keys(pair3);
    result[index] = [keys4[0], pair3[keys4[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key57, object2 = data;
  for (key57 in object2) {
    if (_hasOwnProperty$2.call(object2, key57)) {
      if (object2[key57] !== null) return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc;
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  lc = c2 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c2) {
  if (c2 === 120) {
    return 2;
  }
  if (c2 === 117) {
    return 4;
  }
  if (c2 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c2) {
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "" : c2 === 95 ? "" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  if (c2 <= 65535) {
    return String.fromCharCode(c2);
  }
  return String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i2 = 0; i2 < 256; i2++) {
  simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
  simpleEscapeMap[i2] = simpleEscapeSequence(i2);
}
var i2;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state2, message) {
  var mark2 = {
    name: state2.filename,
    buffer: state2.input.slice(0, -1),
    // omit trailing \0
    position: state2.position,
    line: state2.line,
    column: state2.position - state2.lineStart
  };
  mark2.snippet = snippet(mark2);
  return new exception(message, mark2);
}
function throwError(state2, message) {
  throw generateError(state2, message);
}
function throwWarning(state2, message) {
  if (state2.onWarning) {
    state2.onWarning.call(null, generateError(state2, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state2, name2, args) {
    var match3, major, minor;
    if (state2.version !== null) {
      throwError(state2, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state2, "YAML directive accepts exactly one argument");
    }
    match3 = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match3 === null) {
      throwError(state2, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match3[1], 10);
    minor = parseInt(match3[2], 10);
    if (major !== 1) {
      throwError(state2, "unacceptable YAML version of the document");
    }
    state2.version = args[0];
    state2.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state2, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state2, name2, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state2, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state2, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state2.tagMap, handle)) {
      throwError(state2, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state2, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err2) {
      throwError(state2, "tag prefix is malformed: " + prefix);
    }
    state2.tagMap[handle] = prefix;
  }
};
function captureSegment(state2, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state2.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state2, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state2, "the stream contains non-printable characters");
    }
    state2.result += _result;
  }
}
function mergeMappings(state2, destination, source, overridableKeys) {
  var sourceKeys, key57, index, quantity;
  if (!common.isObject(source)) {
    throwError(state2, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key57 = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key57)) {
      destination[key57] = source[key57];
      overridableKeys[key57] = true;
    }
  }
}
function storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state2, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state2, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state2, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state2.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state2.line = startLine || state2.line;
      state2.lineStart = startLineStart || state2.lineStart;
      state2.position = startPos || state2.position;
      throwError(state2, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state2) {
  var ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 10) {
    state2.position++;
  } else if (ch === 13) {
    state2.position++;
    if (state2.input.charCodeAt(state2.position) === 10) {
      state2.position++;
    }
  } else {
    throwError(state2, "a line break is expected");
  }
  state2.line += 1;
  state2.lineStart = state2.position;
  state2.firstTabInLine = -1;
}
function skipSeparationSpace(state2, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state2.firstTabInLine === -1) {
        state2.firstTabInLine = state2.position;
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state2);
      ch = state2.input.charCodeAt(state2.position);
      lineBreaks++;
      state2.lineIndent = 0;
      while (ch === 32) {
        state2.lineIndent++;
        ch = state2.input.charCodeAt(++state2.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state2.lineIndent < checkIndent) {
    throwWarning(state2, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state2) {
  var _position = state2.position, ch;
  ch = state2.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state2.input.charCodeAt(_position + 1) && ch === state2.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state2.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state2, count2) {
  if (count2 === 1) {
    state2.result += " ";
  } else if (count2 > 1) {
    state2.result += common.repeat("\n", count2 - 1);
  }
}
function readPlainScalar(state2, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state2.kind, _result = state2.result, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state2.input.charCodeAt(state2.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state2.kind = "scalar";
  state2.result = "";
  captureStart = captureEnd = state2.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state2.input.charCodeAt(state2.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state2.line;
      _lineStart = state2.lineStart;
      _lineIndent = state2.lineIndent;
      skipSeparationSpace(state2, false, -1);
      if (state2.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state2.input.charCodeAt(state2.position);
        continue;
      } else {
        state2.position = captureEnd;
        state2.line = _line;
        state2.lineStart = _lineStart;
        state2.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state2, captureStart, captureEnd, false);
      writeFoldedLines(state2, state2.line - _line);
      captureStart = captureEnd = state2.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state2.position + 1;
    }
    ch = state2.input.charCodeAt(++state2.position);
  }
  captureSegment(state2, captureStart, captureEnd, false);
  if (state2.result) {
    return true;
  }
  state2.kind = _kind;
  state2.result = _result;
  return false;
}
function readSingleQuotedScalar(state2, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 39) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (ch === 39) {
        captureStart = state2.position;
        state2.position++;
        captureEnd = state2.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a single quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state2, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 34) {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  state2.position++;
  captureStart = captureEnd = state2.position;
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state2, captureStart, state2.position, true);
      state2.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state2, captureStart, state2.position, true);
      ch = state2.input.charCodeAt(++state2.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state2, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state2.result += simpleEscapeMap[ch];
        state2.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state2.input.charCodeAt(++state2.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state2, "expected hexadecimal character");
          }
        }
        state2.result += charFromCodepoint(hexResult);
        state2.position++;
      } else {
        throwError(state2, "unknown escape sequence");
      }
      captureStart = captureEnd = state2.position;
    } else if (is_EOL(ch)) {
      captureSegment(state2, captureStart, captureEnd, true);
      writeFoldedLines(state2, skipSeparationSpace(state2, false, nodeIndent));
      captureStart = captureEnd = state2.position;
    } else if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
      throwError(state2, "unexpected end of the document within a double quoted scalar");
    } else {
      state2.position++;
      captureEnd = state2.position;
    }
  }
  throwError(state2, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state2, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state2.tag, _result, _anchor = state2.anchor, following, terminator, isPair2, isExplicitPair, isMapping2, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 91) {
    terminator = 93;
    isMapping2 = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping2 = true;
    _result = {};
  } else {
    return false;
  }
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(++state2.position);
  while (ch !== 0) {
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === terminator) {
      state2.position++;
      state2.tag = _tag;
      state2.anchor = _anchor;
      state2.kind = isMapping2 ? "mapping" : "sequence";
      state2.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state2, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state2, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair2 = isExplicitPair = false;
    if (ch === 63) {
      following = state2.input.charCodeAt(state2.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair2 = isExplicitPair = true;
        state2.position++;
        skipSeparationSpace(state2, true, nodeIndent);
      }
    }
    _line = state2.line;
    _lineStart = state2.lineStart;
    _pos = state2.position;
    composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state2.tag;
    keyNode = state2.result;
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if ((isExplicitPair || state2.line === _line) && ch === 58) {
      isPair2 = true;
      ch = state2.input.charCodeAt(++state2.position);
      skipSeparationSpace(state2, true, nodeIndent);
      composeNode(state2, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state2.result;
    }
    if (isMapping2) {
      storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair2) {
      _result.push(storeMappingPair(state2, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state2, true, nodeIndent);
    ch = state2.input.charCodeAt(state2.position);
    if (ch === 44) {
      readNext = true;
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      readNext = false;
    }
  }
  throwError(state2, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state2, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state2.kind = "scalar";
  state2.result = "";
  while (ch !== 0) {
    ch = state2.input.charCodeAt(++state2.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state2, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state2, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state2, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state2.input.charCodeAt(++state2.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state2);
    state2.lineIndent = 0;
    ch = state2.input.charCodeAt(state2.position);
    while ((!detectedIndent || state2.lineIndent < textIndent) && ch === 32) {
      state2.lineIndent++;
      ch = state2.input.charCodeAt(++state2.position);
    }
    if (!detectedIndent && state2.lineIndent > textIndent) {
      textIndent = state2.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state2.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state2.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state2.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state2.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state2.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state2.result += " ";
        }
      } else {
        state2.result += common.repeat("\n", emptyLines);
      }
    } else {
      state2.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state2.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    captureSegment(state2, captureStart, state2.position, false);
  }
  return true;
}
function readBlockSequence(state2, nodeIndent) {
  var _line, _tag = state2.tag, _anchor = state2.anchor, _result = [], following, detected = false, ch;
  if (state2.firstTabInLine !== -1) return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state2.input.charCodeAt(state2.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state2.position++;
    if (skipSeparationSpace(state2, true, -1)) {
      if (state2.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state2.input.charCodeAt(state2.position);
        continue;
      }
    }
    _line = state2.line;
    composeNode(state2, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state2.result);
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a sequence entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "sequence";
    state2.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state2, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state2.tag, _anchor = state2.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state2.firstTabInLine !== -1) return false;
  if (state2.anchor !== null) {
    state2.anchorMap[state2.anchor] = _result;
  }
  ch = state2.input.charCodeAt(state2.position);
  while (ch !== 0) {
    if (!atExplicitKey && state2.firstTabInLine !== -1) {
      state2.position = state2.firstTabInLine;
      throwError(state2, "tab characters must not be used in indentation");
    }
    following = state2.input.charCodeAt(state2.position + 1);
    _line = state2.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state2, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state2.position += 1;
      ch = following;
    } else {
      _keyLine = state2.line;
      _keyLineStart = state2.lineStart;
      _keyPos = state2.position;
      if (!composeNode(state2, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state2.line === _line) {
        ch = state2.input.charCodeAt(state2.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state2.input.charCodeAt(++state2.position);
        }
        if (ch === 58) {
          ch = state2.input.charCodeAt(++state2.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state2, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state2.tag;
          keyNode = state2.result;
        } else if (detected) {
          throwError(state2, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state2.tag = _tag;
          state2.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state2, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state2.tag = _tag;
        state2.anchor = _anchor;
        return true;
      }
    }
    if (state2.line === _line || state2.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state2.line;
        _keyLineStart = state2.lineStart;
        _keyPos = state2.position;
      }
      if (composeNode(state2, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state2.result;
        } else {
          valueNode = state2.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state2, true, -1);
      ch = state2.input.charCodeAt(state2.position);
    }
    if ((state2.line === _line || state2.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state2, "bad indentation of a mapping entry");
    } else if (state2.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state2, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state2.tag = _tag;
    state2.anchor = _anchor;
    state2.kind = "mapping";
    state2.result = _result;
  }
  return detected;
}
function readTagProperty(state2) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 33) return false;
  if (state2.tag !== null) {
    throwError(state2, "duplication of a tag property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state2.input.charCodeAt(++state2.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state2.input.charCodeAt(++state2.position);
  } else {
    tagHandle = "!";
  }
  _position = state2.position;
  if (isVerbatim) {
    do {
      ch = state2.input.charCodeAt(++state2.position);
    } while (ch !== 0 && ch !== 62);
    if (state2.position < state2.length) {
      tagName = state2.input.slice(_position, state2.position);
      ch = state2.input.charCodeAt(++state2.position);
    } else {
      throwError(state2, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state2.input.slice(_position - 1, state2.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state2, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state2.position + 1;
        } else {
          throwError(state2, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state2.input.charCodeAt(++state2.position);
    }
    tagName = state2.input.slice(_position, state2.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state2, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state2, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err2) {
    throwError(state2, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state2.tag = tagName;
  } else if (_hasOwnProperty$1.call(state2.tagMap, tagHandle)) {
    state2.tag = state2.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state2.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state2.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state2, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state2) {
  var _position, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 38) return false;
  if (state2.anchor !== null) {
    throwError(state2, "duplication of an anchor property");
  }
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an anchor node must contain at least one character");
  }
  state2.anchor = state2.input.slice(_position, state2.position);
  return true;
}
function readAlias(state2) {
  var _position, alias, ch;
  ch = state2.input.charCodeAt(state2.position);
  if (ch !== 42) return false;
  ch = state2.input.charCodeAt(++state2.position);
  _position = state2.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state2.input.charCodeAt(++state2.position);
  }
  if (state2.position === _position) {
    throwError(state2, "name of an alias node must contain at least one character");
  }
  alias = state2.input.slice(_position, state2.position);
  if (!_hasOwnProperty$1.call(state2.anchorMap, alias)) {
    throwError(state2, 'unidentified alias "' + alias + '"');
  }
  state2.result = state2.anchorMap[alias];
  skipSeparationSpace(state2, true, -1);
  return true;
}
function composeNode(state2, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type5, flowIndent, blockIndent;
  if (state2.listener !== null) {
    state2.listener("open", state2);
  }
  state2.tag = null;
  state2.anchor = null;
  state2.kind = null;
  state2.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state2, true, -1)) {
      atNewLine = true;
      if (state2.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state2.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state2.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state2) || readAnchorProperty(state2)) {
      if (skipSeparationSpace(state2, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state2.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state2.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state2.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state2.position - state2.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state2, blockIndent) || readBlockMapping(state2, blockIndent, flowIndent)) || readFlowCollection(state2, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state2, flowIndent) || readSingleQuotedScalar(state2, flowIndent) || readDoubleQuotedScalar(state2, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state2)) {
          hasContent = true;
          if (state2.tag !== null || state2.anchor !== null) {
            throwError(state2, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state2, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state2.tag === null) {
            state2.tag = "?";
          }
        }
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state2, blockIndent);
    }
  }
  if (state2.tag === null) {
    if (state2.anchor !== null) {
      state2.anchorMap[state2.anchor] = state2.result;
    }
  } else if (state2.tag === "?") {
    if (state2.result !== null && state2.kind !== "scalar") {
      throwError(state2, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state2.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state2.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type5 = state2.implicitTypes[typeIndex];
      if (type5.resolve(state2.result)) {
        state2.result = type5.construct(state2.result);
        state2.tag = type5.tag;
        if (state2.anchor !== null) {
          state2.anchorMap[state2.anchor] = state2.result;
        }
        break;
      }
    }
  } else if (state2.tag !== "!") {
    if (_hasOwnProperty$1.call(state2.typeMap[state2.kind || "fallback"], state2.tag)) {
      type5 = state2.typeMap[state2.kind || "fallback"][state2.tag];
    } else {
      type5 = null;
      typeList = state2.typeMap.multi[state2.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state2.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type5 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type5) {
      throwError(state2, "unknown tag !<" + state2.tag + ">");
    }
    if (state2.result !== null && type5.kind !== state2.kind) {
      throwError(state2, "unacceptable node kind for !<" + state2.tag + '> tag; it should be "' + type5.kind + '", not "' + state2.kind + '"');
    }
    if (!type5.resolve(state2.result, state2.tag)) {
      throwError(state2, "cannot resolve a node with !<" + state2.tag + "> explicit tag");
    } else {
      state2.result = type5.construct(state2.result, state2.tag);
      if (state2.anchor !== null) {
        state2.anchorMap[state2.anchor] = state2.result;
      }
    }
  }
  if (state2.listener !== null) {
    state2.listener("close", state2);
  }
  return state2.tag !== null || state2.anchor !== null || hasContent;
}
function readDocument(state2) {
  var documentStart = state2.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state2.version = null;
  state2.checkLineBreaks = state2.legacy;
  state2.tagMap = /* @__PURE__ */ Object.create(null);
  state2.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state2.input.charCodeAt(state2.position)) !== 0) {
    skipSeparationSpace(state2, true, -1);
    ch = state2.input.charCodeAt(state2.position);
    if (state2.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state2.input.charCodeAt(++state2.position);
    _position = state2.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state2.input.charCodeAt(++state2.position);
    }
    directiveName = state2.input.slice(_position, state2.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state2, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      if (ch === 35) {
        do {
          ch = state2.input.charCodeAt(++state2.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state2.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state2.input.charCodeAt(++state2.position);
      }
      directiveArgs.push(state2.input.slice(_position, state2.position));
    }
    if (ch !== 0) readLineBreak(state2);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state2, directiveName, directiveArgs);
    } else {
      throwWarning(state2, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state2, true, -1);
  if (state2.lineIndent === 0 && state2.input.charCodeAt(state2.position) === 45 && state2.input.charCodeAt(state2.position + 1) === 45 && state2.input.charCodeAt(state2.position + 2) === 45) {
    state2.position += 3;
    skipSeparationSpace(state2, true, -1);
  } else if (hasDirectives) {
    throwError(state2, "directives end mark is expected");
  }
  composeNode(state2, state2.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state2, true, -1);
  if (state2.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state2.input.slice(documentStart, state2.position))) {
    throwWarning(state2, "non-ASCII line breaks are interpreted as content");
  }
  state2.documents.push(state2.result);
  if (state2.position === state2.lineStart && testDocumentSeparator(state2)) {
    if (state2.input.charCodeAt(state2.position) === 46) {
      state2.position += 3;
      skipSeparationSpace(state2, true, -1);
    }
    return;
  }
  if (state2.position < state2.length - 1) {
    throwError(state2, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state2 = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state2.position = nullpos;
    throwError(state2, "null byte is not allowed in input");
  }
  state2.input += "\0";
  while (state2.input.charCodeAt(state2.position) === 32) {
    state2.lineIndent += 1;
    state2.position += 1;
  }
  while (state2.position < state2.length - 1) {
    readDocument(state2);
  }
  return state2.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length3 = documents.length; index < length3; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema4, map5) {
  var result, keys4, index, length3, tag, style, type5;
  if (map5 === null) return {};
  result = {};
  keys4 = Object.keys(map5);
  for (index = 0, length3 = keys4.length; index < length3; index += 1) {
    tag = keys4[index];
    style = String(map5[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type5 = schema4.compiledTypeMap["fallback"][tag];
    if (type5 && _hasOwnProperty.call(type5.styleAliases, style)) {
      style = type5.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length3;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length3 = 2;
  } else if (character <= 65535) {
    handle = "u";
    length3 = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length3 = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length3 - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length3 = string.length;
  while (position < length3) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length3;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state2, level) {
  return "\n" + common.repeat(" ", state2.indent * level);
}
function testImplicitResolving(state2, str2) {
  var index, length3, type5;
  for (index = 0, length3 = state2.implicitTypes.length; index < length3; index += 1) {
    type5 = state2.implicitTypes[index];
    if (type5.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c2) {
  return c2 === CHAR_SPACE || c2 === CHAR_TAB;
}
function isPrintable(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
}
function isNsCharOrWhitespace(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
}
function isPlainSafe(c2, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c2 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c2) {
  return !isWhitespace(c2) && c2 !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i2;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i2;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state2, string, level, iskey, inblock) {
  state2.dump = function() {
    if (string.length === 0) {
      return state2.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state2.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state2.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state2.indent * Math.max(1, level);
    var lineWidth = state2.lineWidth === -1 ? -1 : Math.max(Math.min(state2.lineWidth, 40), state2.lineWidth - indent);
    var singleLineOnly = iskey || state2.flowLevel > -1 && level >= state2.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state2, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state2.indent,
      lineWidth,
      testAmbiguity,
      state2.quotingType,
      state2.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state2.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match3;
  while (match3 = lineRe.exec(string)) {
    var prefix = match3[1], line = match3[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match3;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match3 = breakRe.exec(line)) {
    next = match3.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
    char = codePointAt(string, i2);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i2];
      if (char >= 65536) result += string[i2 + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state2, level, object2) {
  var _result = "", _tag = state2.tag, index, length3, value;
  for (index = 0, length3 = object2.length; index < length3; index += 1) {
    value = object2[index];
    if (state2.replacer) {
      value = state2.replacer.call(object2, String(index), value);
    }
    if (writeNode(state2, level, value, false, false) || typeof value === "undefined" && writeNode(state2, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state2.condenseFlow ? " " : "");
      _result += state2.dump;
    }
  }
  state2.tag = _tag;
  state2.dump = "[" + _result + "]";
}
function writeBlockSequence(state2, level, object2, compact2) {
  var _result = "", _tag = state2.tag, index, length3, value;
  for (index = 0, length3 = object2.length; index < length3; index += 1) {
    value = object2[index];
    if (state2.replacer) {
      value = state2.replacer.call(object2, String(index), value);
    }
    if (writeNode(state2, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state2, level + 1, null, true, true, false, true)) {
      if (!compact2 || _result !== "") {
        _result += generateNextLine(state2, level);
      }
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state2.dump;
    }
  }
  state2.tag = _tag;
  state2.dump = _result || "[]";
}
function writeFlowMapping(state2, level, object2) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object2), index, length3, objectKey, objectValue, pairBuffer;
  for (index = 0, length3 = objectKeyList.length; index < length3; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state2.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state2.replacer) {
      objectValue = state2.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state2, level, objectKey, false, false)) {
      continue;
    }
    if (state2.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state2.dump + (state2.condenseFlow ? '"' : "") + ":" + (state2.condenseFlow ? "" : " ");
    if (!writeNode(state2, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state2.dump;
    _result += pairBuffer;
  }
  state2.tag = _tag;
  state2.dump = "{" + _result + "}";
}
function writeBlockMapping(state2, level, object2, compact2) {
  var _result = "", _tag = state2.tag, objectKeyList = Object.keys(object2), index, length3, objectKey, objectValue, explicitPair, pairBuffer;
  if (state2.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state2.sortKeys === "function") {
    objectKeyList.sort(state2.sortKeys);
  } else if (state2.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length3 = objectKeyList.length; index < length3; index += 1) {
    pairBuffer = "";
    if (!compact2 || _result !== "") {
      pairBuffer += generateNextLine(state2, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object2[objectKey];
    if (state2.replacer) {
      objectValue = state2.replacer.call(object2, objectKey, objectValue);
    }
    if (!writeNode(state2, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state2.tag !== null && state2.tag !== "?" || state2.dump && state2.dump.length > 1024;
    if (explicitPair) {
      if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state2.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state2, level);
    }
    if (!writeNode(state2, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state2.dump && CHAR_LINE_FEED === state2.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state2.dump;
    _result += pairBuffer;
  }
  state2.tag = _tag;
  state2.dump = _result || "{}";
}
function detectType(state2, object2, explicit) {
  var _result, typeList, index, length3, type5, style;
  typeList = explicit ? state2.explicitTypes : state2.implicitTypes;
  for (index = 0, length3 = typeList.length; index < length3; index += 1) {
    type5 = typeList[index];
    if ((type5.instanceOf || type5.predicate) && (!type5.instanceOf || typeof object2 === "object" && object2 instanceof type5.instanceOf) && (!type5.predicate || type5.predicate(object2))) {
      if (explicit) {
        if (type5.multi && type5.representName) {
          state2.tag = type5.representName(object2);
        } else {
          state2.tag = type5.tag;
        }
      } else {
        state2.tag = "?";
      }
      if (type5.represent) {
        style = state2.styleMap[type5.tag] || type5.defaultStyle;
        if (_toString.call(type5.represent) === "[object Function]") {
          _result = type5.represent(object2, style);
        } else if (_hasOwnProperty.call(type5.represent, style)) {
          _result = type5.represent[style](object2, style);
        } else {
          throw new exception("!<" + type5.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state2.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state2, level, object2, block2, compact2, iskey, isblockseq) {
  state2.tag = null;
  state2.dump = object2;
  if (!detectType(state2, object2, false)) {
    detectType(state2, object2, true);
  }
  var type5 = _toString.call(state2.dump);
  var inblock = block2;
  var tagStr;
  if (block2) {
    block2 = state2.flowLevel < 0 || state2.flowLevel > level;
  }
  var objectOrArray = type5 === "[object Object]" || type5 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state2.duplicates.indexOf(object2);
    duplicate = duplicateIndex !== -1;
  }
  if (state2.tag !== null && state2.tag !== "?" || duplicate || state2.indent !== 2 && level > 0) {
    compact2 = false;
  }
  if (duplicate && state2.usedDuplicates[duplicateIndex]) {
    state2.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state2.usedDuplicates[duplicateIndex]) {
      state2.usedDuplicates[duplicateIndex] = true;
    }
    if (type5 === "[object Object]") {
      if (block2 && Object.keys(state2.dump).length !== 0) {
        writeBlockMapping(state2, level, state2.dump, compact2);
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowMapping(state2, level, state2.dump);
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type5 === "[object Array]") {
      if (block2 && state2.dump.length !== 0) {
        if (state2.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state2, level - 1, state2.dump, compact2);
        } else {
          writeBlockSequence(state2, level, state2.dump, compact2);
        }
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + state2.dump;
        }
      } else {
        writeFlowSequence(state2, level, state2.dump);
        if (duplicate) {
          state2.dump = "&ref_" + duplicateIndex + " " + state2.dump;
        }
      }
    } else if (type5 === "[object String]") {
      if (state2.tag !== "?") {
        writeScalar(state2, state2.dump, level, iskey, inblock);
      }
    } else if (type5 === "[object Undefined]") {
      return false;
    } else {
      if (state2.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type5);
    }
    if (state2.tag !== null && state2.tag !== "?") {
      tagStr = encodeURI(
        state2.tag[0] === "!" ? state2.tag.slice(1) : state2.tag
      ).replace(/!/g, "%21");
      if (state2.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state2.dump = tagStr + " " + state2.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object2, state2) {
  var objects = [], duplicatesIndexes = [], index, length3;
  inspectNode(object2, objects, duplicatesIndexes);
  for (index = 0, length3 = duplicatesIndexes.length; index < length3; index += 1) {
    state2.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state2.usedDuplicates = new Array(length3);
}
function inspectNode(object2, objects, duplicatesIndexes) {
  var objectKeyList, index, length3;
  if (object2 !== null && typeof object2 === "object") {
    index = objects.indexOf(object2);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object2);
      if (Array.isArray(object2)) {
        for (index = 0, length3 = object2.length; index < length3; index += 1) {
          inspectNode(object2[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object2);
        for (index = 0, length3 = objectKeyList.length; index < length3; index += 1) {
          inspectNode(object2[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state2 = new State(options);
  if (!state2.noRefs) getDuplicateReferences(input, state2);
  var value = input;
  if (state2.replacer) {
    value = state2.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state2, 0, value, true, true)) return state2.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from2, to2) {
  return function() {
    throw new Error("Function yaml." + from2 + " is removed in js-yaml 4. Use yaml." + to2 + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types = {
  binary,
  float,
  map,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var w = __toESM(require_zenscroll());
var C = __toESM(require_ImmutablePropTypes());
var x = __toESM(require_reduce());
var O = __toESM(require_get());

// node_modules/@babel/runtime-corejs3/helpers/esm/extends.js
var import_assign = __toESM(require_assign5());
var import_bind = __toESM(require_bind6());
function _extends() {
  var _context;
  return _extends = import_assign.default ? (0, import_bind.default)(_context = import_assign.default).call(_context) : function(n) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n[r2] = t2[r2]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var N = __toESM(require_classnames());
var A = __toESM(require_lib());

// node_modules/react-immutable-pure-component/lib/react-immutable-pure-component.es.js
var import_react = __toESM(require_react());
var import_immutable = __toESM(require_immutable());
function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props3) {
  for (var i2 = 0; i2 < props3.length; i2++) {
    var descriptor = props3[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key57, value) {
  if (key57 in obj) {
    Object.defineProperty(obj, key57, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key57] = value;
  }
  return obj;
}
function ownKeys(object2, enumerableOnly) {
  var keys4 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    });
    keys4.push.apply(keys4, symbols);
  }
  return keys4;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(source, true).forEach(function(key57) {
        _defineProperty(target, key57, source[key57]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function(key57) {
        Object.defineProperty(target, key57, Object.getOwnPropertyDescriptor(source, key57));
      });
    }
  }
  return target;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o4) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o5) {
    return o5.__proto__ || Object.getPrototypeOf(o5);
  };
  return _getPrototypeOf(o4);
}
function _setPrototypeOf(o4, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf3(o5, p3) {
    o5.__proto__ = p3;
    return o5;
  };
  return _setPrototypeOf(o4, p2);
}
function _assertThisInitialized(self3) {
  if (self3 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self3;
}
function _possibleConstructorReturn(self3, call3) {
  if (call3 && (typeof call3 === "object" || typeof call3 === "function")) {
    return call3;
  }
  return _assertThisInitialized(self3);
}
var NOT_SET = {};
function isMapLike(collection) {
  return collection !== null && _typeof(collection) === "object" && typeof collection.get === "function" && typeof collection.has === "function";
}
function isInvalid(collection) {
  return collection === null || collection === void 0;
}
function get(collection, key57, notSetValue) {
  if (isInvalid(collection)) {
    return notSetValue;
  }
  if (isMapLike(collection)) {
    return collection.has(key57) ? collection.get(key57) : notSetValue;
  }
  return hasOwnProperty.call(collection, key57) ? collection[key57] : notSetValue;
}
function getIn(collection, keyPath, notSetValue) {
  var i2 = 0;
  while (i2 !== keyPath.length) {
    collection = get(collection, keyPath[i2++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
function check(config2) {
  var prev = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var next = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var checkItem = createChecker(prev, next);
  var checklist = config2 || Object.keys(_objectSpread2({}, next, {}, prev));
  return checklist.every(checkItem);
}
function createChecker(prev, next) {
  return function(name2) {
    if (typeof name2 === "string") {
      return (0, import_immutable.is)(next[name2], prev[name2]);
    } else if (Array.isArray(name2)) {
      return (0, import_immutable.is)(getIn(next, name2), getIn(prev, name2));
    }
    throw new TypeError("Invalid key: expected Array or string: " + name2);
  };
}
var ImmutablePureComponent = function(_React$Component) {
  _inherits(ImmutablePureComponent2, _React$Component);
  function ImmutablePureComponent2() {
    _classCallCheck(this, ImmutablePureComponent2);
    return _possibleConstructorReturn(this, _getPrototypeOf(ImmutablePureComponent2).apply(this, arguments));
  }
  _createClass(ImmutablePureComponent2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps) {
      var nextState = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return !check(this.updateOnProps, this.props, nextProps, "updateOnProps") || !check(this.updateOnStates, this.state, nextState, "updateOnStates");
    }
  }]);
  return ImmutablePureComponent2;
}(import_react.default.Component);
var react_immutable_pure_component_es_default = ImmutablePureComponent;

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var R = __toESM(require_lib2());
var T2 = __toESM(require_randexp());
var B = __toESM(require_isEmpty());
var j = __toESM(require_constant());
var P = __toESM(require_isString());
var M = __toESM(require_debounce());
var q = __toESM(require_set());
var L = __toESM(require_assocPath());

// node_modules/fast-json-patch/module/core.mjs
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate,
  validator: () => validator
});

// node_modules/fast-json-patch/module/helpers.mjs
var __extends = /* @__PURE__ */ function() {
  var extendStatics2 = function(d2, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (b2.hasOwnProperty(p2)) d3[p2] = b2[p2];
    };
    return extendStatics2(d2, b);
  };
  return function(d2, b) {
    extendStatics2(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var _hasOwnProperty2 = Object.prototype.hasOwnProperty;
function hasOwnProperty2(obj, key57) {
  return _hasOwnProperty2.call(obj, key57);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys_1 = new Array(obj.length);
    for (var k = 0; k < keys_1.length; k++) {
      keys_1[k] = "" + k;
    }
    return keys_1;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys4 = [];
  for (var i2 in obj) {
    if (hasOwnProperty2(obj, i2)) {
      keys4.push(i2);
    }
  }
  return keys4;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    case "undefined":
      return null;
    default:
      return obj;
  }
}
function isInteger2(str2) {
  var i2 = 0;
  var len = str2.length;
  var charCode;
  while (i2 < len) {
    charCode = str2.charCodeAt(i2);
    if (charCode >= 48 && charCode <= 57) {
      i2++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path4) {
  if (path4.indexOf("/") === -1 && path4.indexOf("~") === -1)
    return path4;
  return path4.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path4) {
  return path4.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
        if (hasUndefined(obj[i_1])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i2 = 0; i2 < objKeysLength; i2++) {
        if (hasUndefined(obj[objKeys[i2]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key57 in args) {
    var value = typeof args[key57] === "object" ? JSON.stringify(args[key57], null, 2) : args[key57];
    if (typeof value !== "undefined") {
      messageParts.push(key57 + ": " + value);
    }
  }
  return messageParts.join("\n");
}
var PatchError = (
  /** @class */
  function(_super) {
    __extends(PatchError2, _super);
    function PatchError2(message, name2, index, operation, tree) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name2, index, operation, tree })) || this;
      _this.name = name2;
      _this.index = index;
      _this.operation = operation;
      _this.tree = tree;
      Object.setPrototypeOf(_this, _newTarget.prototype);
      _this.message = patchErrorMessageFormatter(message, { name: name2, index, operation, tree });
      return _this;
    }
    return PatchError2;
  }(Error)
);

// node_modules/fast-json-patch/module/core.mjs
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key57, document2) {
    obj[key57] = this.value;
    return { newDocument: document2 };
  },
  remove: function(obj, key57, document2) {
    var removed = obj[key57];
    delete obj[key57];
    return { newDocument: document2, removed };
  },
  replace: function(obj, key57, document2) {
    var removed = obj[key57];
    obj[key57] = this.value;
    return { newDocument: document2, removed };
  },
  move: function(obj, key57, document2) {
    var removed = getValueByPointer(document2, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document2, { op: "remove", path: this.from }).removed;
    applyOperation(document2, { op: "add", path: this.path, value: originalValue });
    return { newDocument: document2, removed };
  },
  copy: function(obj, key57, document2) {
    var valueToCopy = getValueByPointer(document2, this.from);
    applyOperation(document2, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
    return { newDocument: document2 };
  },
  test: function(obj, key57, document2) {
    return { newDocument: document2, test: _areEquals(obj[key57], this.value) };
  },
  _get: function(obj, key57, document2) {
    this.value = obj[key57];
    return { newDocument: document2 };
  }
};
var arrOps = {
  add: function(arr, i2, document2) {
    if (isInteger2(i2)) {
      arr.splice(i2, 0, this.value);
    } else {
      arr[i2] = this.value;
    }
    return { newDocument: document2, index: i2 };
  },
  remove: function(arr, i2, document2) {
    var removedList = arr.splice(i2, 1);
    return { newDocument: document2, removed: removedList[0] };
  },
  replace: function(arr, i2, document2) {
    var removed = arr[i2];
    arr[i2] = this.value;
    return { newDocument: document2, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document2, pointer) {
  if (pointer == "") {
    return document2;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document2, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document2, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index === void 0) {
    index = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document2, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document2 };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document2;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document2, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document2;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document2, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
      }
      returnValue.newDocument = document2;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document2;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document2;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document2 = _deepClone(document2);
    }
    var path4 = operation.path || "";
    var keys4 = path4.split("/");
    var obj = document2;
    var t2 = 1;
    var len = keys4.length;
    var existingPathFragment = void 0;
    var key57 = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key57 = keys4[t2];
      if (key57 && key57.indexOf("~") != -1) {
        key57 = unescapePathComponent(key57);
      }
      if (banPrototypeModifications && (key57 == "__proto__" || key57 == "prototype" && t2 > 0 && keys4[t2 - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key57] === void 0) {
            existingPathFragment = keys4.slice(0, t2).join("/");
          } else if (t2 == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document2, existingPathFragment);
          }
        }
      }
      t2++;
      if (Array.isArray(obj)) {
        if (key57 === "-") {
          key57 = obj.length;
        } else {
          if (validateOperation && !isInteger2(key57)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document2);
          } else if (isInteger2(key57)) {
            key57 = ~~key57;
          }
        }
        if (t2 >= len) {
          if (validateOperation && operation.op === "add" && key57 > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document2);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key57, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      } else {
        if (t2 >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key57, document2);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
          }
          return returnValue;
        }
      }
      obj = obj[key57];
      if (validateOperation && t2 < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
function applyPatch(document2, patch, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document2 = _deepClone(document2);
  }
  var results = new Array(patch.length);
  for (var i2 = 0, length_1 = patch.length; i2 < length_1; i2++) {
    results[i2] = applyOperation(document2, patch[i2], validateOperation, true, banPrototypeModifications, i2);
    document2 = results[i2].newDocument;
  }
  results.newDocument = document2;
  return results;
}
function applyReducer(document2, operation, index) {
  var operationResult = applyOperation(document2, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document2);
  }
  return operationResult.newDocument;
}
function validator(operation, index, document2, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document2);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document2);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document2);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document2);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document2);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document2);
  } else if (document2) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document2);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document2);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error = validate([existingValue], document2);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document2);
      }
    }
  }
}
function validate(sequence3, document2, externalValidator) {
  try {
    if (!Array.isArray(sequence3)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document2) {
      applyPatch(_deepClone(document2), _deepClone(sequence3), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i2 = 0; i2 < sequence3.length; i2++) {
        externalValidator(sequence3[i2], i2, document2, void 0);
      }
    }
  } catch (e2) {
    if (e2 instanceof JsonPatchError) {
      return e2;
    } else {
      throw e2;
    }
  }
}
function _areEquals(a2, b) {
  if (a2 === b)
    return true;
  if (a2 && b && typeof a2 == "object" && typeof b == "object") {
    var arrA = Array.isArray(a2), arrB = Array.isArray(b), i2, length3, key57;
    if (arrA && arrB) {
      length3 = a2.length;
      if (length3 != b.length)
        return false;
      for (i2 = length3; i2-- !== 0; )
        if (!_areEquals(a2[i2], b[i2]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys4 = Object.keys(a2);
    length3 = keys4.length;
    if (length3 !== Object.keys(b).length)
      return false;
    for (i2 = length3; i2-- !== 0; )
      if (!b.hasOwnProperty(keys4[i2]))
        return false;
    for (i2 = length3; i2-- !== 0; ) {
      key57 = keys4[i2];
      if (!_areEquals(a2[key57], b[key57]))
        return false;
    }
    return true;
  }
  return a2 !== a2 && b !== b;
}

// node_modules/fast-json-patch/module/duplex.mjs
var duplex_exports = {};
__export(duplex_exports, {
  compare: () => compare,
  generate: () => generate,
  observe: () => observe,
  unobserve: () => unobserve
});
var beforeDict = /* @__PURE__ */ new WeakMap();
var Mirror = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mirror2(obj) {
      this.observers = /* @__PURE__ */ new Map();
      this.obj = obj;
    }
    return Mirror2;
  }()
);
var ObserverInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ObserverInfo2(callback, observer) {
      this.callback = callback;
      this.observer = observer;
    }
    return ObserverInfo2;
  }()
);
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
function unobserve(root, observer) {
  observer.unobserve();
}
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function() {
      generate(observer);
    };
    var fastCheck = function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
function generate(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp = observer.patches;
  if (temp.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp);
    }
  }
  return temp;
}
function _generate(mirror, obj, patches, path4, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t2 = oldKeys.length - 1; t2 >= 0; t2--) {
    var key57 = oldKeys[t2];
    var oldVal = mirror[key57];
    if (hasOwnProperty2(obj, key57) && !(obj[key57] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key57];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path4 + "/" + escapePathComponent(key57), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({ op: "test", path: path4 + "/" + escapePathComponent(key57), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path4 + "/" + escapePathComponent(key57), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path4 + "/" + escapePathComponent(key57), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path4 + "/" + escapePathComponent(key57) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path: path4, value: mirror });
      }
      patches.push({ op: "replace", path: path4, value: obj });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t2 = 0; t2 < newKeys.length; t2++) {
    var key57 = newKeys[t2];
    if (!hasOwnProperty2(mirror, key57) && obj[key57] !== void 0) {
      patches.push({ op: "add", path: path4 + "/" + escapePathComponent(key57), value: _deepClone(obj[key57]) });
    }
  }
}
function compare(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}

// node_modules/fast-json-patch/index.mjs
var fast_json_patch_default = Object.assign({}, core_exports, duplex_exports, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});

// node_modules/swagger-client/es/resolver/specmap/lib/index.js
var import_deepmerge = __toESM(require_cjs());
var lib_default = {
  add,
  replace,
  remove,
  merge: merge2,
  mergeDeep,
  context,
  getIn: getIn2,
  applyPatch: applyPatch2,
  parentPathMatch,
  flatten,
  fullyNormalizeArray,
  normalizeArray,
  isPromise,
  forEachNew,
  forEachNewPrimitive,
  isJsonPatch,
  isContextPatch,
  isPatch,
  isMutation,
  isAdditiveMutation,
  isGenerator,
  isFunction,
  isObject: isObject2,
  isError: isError2
};
function applyPatch2(obj, patch, opts) {
  opts = opts || {};
  patch = {
    ...patch,
    path: patch.path && normalizeJSONPath(patch.path)
  };
  if (patch.op === "merge") {
    const newValue = getInByJsonPath(obj, patch.path);
    Object.assign(newValue, patch.value);
    applyPatch(obj, [replace(patch.path, newValue)]);
  } else if (patch.op === "mergeDeep") {
    const currentValue = getInByJsonPath(obj, patch.path);
    const newValue = (0, import_deepmerge.default)(currentValue, patch.value);
    obj = applyPatch(obj, [replace(patch.path, newValue)]).newDocument;
  } else if (patch.op === "add" && patch.path === "" && isObject2(patch.value)) {
    const patches = Object.keys(patch.value).reduce((arr, key57) => {
      arr.push({
        op: "add",
        path: `/${normalizeJSONPath(key57)}`,
        value: patch.value[key57]
      });
      return arr;
    }, []);
    applyPatch(obj, patches);
  } else if (patch.op === "replace" && patch.path === "") {
    let {
      value
    } = patch;
    if (opts.allowMetaPatches && patch.meta && isAdditiveMutation(patch) && (Array.isArray(patch.value) || isObject2(patch.value))) {
      value = {
        ...value,
        ...patch.meta
      };
    }
    obj = value;
  } else {
    applyPatch(obj, [patch]);
    if (opts.allowMetaPatches && patch.meta && isAdditiveMutation(patch) && (Array.isArray(patch.value) || isObject2(patch.value))) {
      const currentValue = getInByJsonPath(obj, patch.path);
      const newValue = {
        ...currentValue,
        ...patch.meta
      };
      applyPatch(obj, [replace(patch.path, newValue)]);
    }
  }
  return obj;
}
function normalizeJSONPath(path4) {
  if (Array.isArray(path4)) {
    if (path4.length < 1) {
      return "";
    }
    return `/${path4.map(
      (item) => (
        // eslint-disable-line prefer-template
        (item + "").replace(/~/g, "~0").replace(/\//g, "~1")
      )
      // eslint-disable-line prefer-template
    ).join("/")}`;
  }
  return path4;
}
function add(path4, value) {
  return {
    op: "add",
    path: path4,
    value
  };
}
function replace(path4, value, meta) {
  return {
    op: "replace",
    path: path4,
    value,
    meta
  };
}
function remove(path4) {
  return {
    op: "remove",
    path: path4
  };
}
function merge2(path4, value) {
  return {
    type: "mutation",
    op: "merge",
    path: path4,
    value
  };
}
function mergeDeep(path4, value) {
  return {
    type: "mutation",
    op: "mergeDeep",
    path: path4,
    value
  };
}
function context(path4, value) {
  return {
    type: "context",
    path: path4,
    value
  };
}
function forEachNew(mutations, fn2) {
  try {
    return forEachNewPatch(mutations, forEach, fn2);
  } catch (e2) {
    return e2;
  }
}
function forEachNewPrimitive(mutations, fn2) {
  try {
    return forEachNewPatch(mutations, forEachPrimitive, fn2);
  } catch (e2) {
    return e2;
  }
}
function forEachNewPatch(mutations, fn2, callback) {
  const res = mutations.filter(isAdditiveMutation).map((mutation) => fn2(mutation.value, callback, mutation.path)) || [];
  const flat = flatten(res);
  const clean = cleanArray(flat);
  return clean;
}
function forEachPrimitive(obj, fn2, basePath) {
  basePath = basePath || [];
  if (Array.isArray(obj)) {
    return obj.map((val, key57) => forEachPrimitive(val, fn2, basePath.concat(key57)));
  }
  if (isObject2(obj)) {
    return Object.keys(obj).map((key57) => forEachPrimitive(obj[key57], fn2, basePath.concat(key57)));
  }
  return fn2(obj, basePath[basePath.length - 1], basePath);
}
function forEach(obj, fn2, basePath) {
  basePath = basePath || [];
  let results = [];
  if (basePath.length > 0) {
    const newResults = fn2(obj, basePath[basePath.length - 1], basePath);
    if (newResults) {
      results = results.concat(newResults);
    }
  }
  if (Array.isArray(obj)) {
    const arrayResults = obj.map((val, key57) => forEach(val, fn2, basePath.concat(key57)));
    if (arrayResults) {
      results = results.concat(arrayResults);
    }
  } else if (isObject2(obj)) {
    const moreResults = Object.keys(obj).map((key57) => forEach(obj[key57], fn2, basePath.concat(key57)));
    if (moreResults) {
      results = results.concat(moreResults);
    }
  }
  results = flatten(results);
  return results;
}
function parentPathMatch(path4, arr) {
  if (!Array.isArray(arr)) {
    return false;
  }
  for (let i2 = 0, len = arr.length; i2 < len; i2 += 1) {
    if (arr[i2] !== path4[i2]) {
      return false;
    }
  }
  return true;
}
function getIn2(obj, path4) {
  return path4.reduce((val, token) => {
    if (typeof token !== "undefined" && val) {
      return val[token];
    }
    return val;
  }, obj);
}
function fullyNormalizeArray(arr) {
  return cleanArray(flatten(normalizeArray(arr)));
}
function normalizeArray(arr) {
  return Array.isArray(arr) ? arr : [arr];
}
function flatten(arr) {
  return [].concat(...arr.map((val) => Array.isArray(val) ? flatten(val) : val));
}
function cleanArray(arr) {
  return arr.filter((elm) => typeof elm !== "undefined");
}
function isObject2(val) {
  return val && typeof val === "object";
}
function isPromise(val) {
  return isObject2(val) && isFunction(val.then);
}
function isFunction(val) {
  return val && typeof val === "function";
}
function isError2(patch) {
  return patch instanceof Error;
}
function isJsonPatch(patch) {
  if (isPatch(patch)) {
    const {
      op
    } = patch;
    return op === "add" || op === "remove" || op === "replace";
  }
  return false;
}
function isGenerator(thing) {
  return Object.prototype.toString.call(thing) === "[object GeneratorFunction]";
}
function isMutation(patch) {
  return isJsonPatch(patch) || isPatch(patch) && patch.type === "mutation";
}
function isAdditiveMutation(patch) {
  return isMutation(patch) && (patch.op === "add" || patch.op === "replace" || patch.op === "merge" || patch.op === "mergeDeep");
}
function isContextPatch(patch) {
  return isPatch(patch) && patch.type === "context";
}
function isPatch(patch) {
  return patch && typeof patch === "object";
}
function getInByJsonPath(obj, jsonPath) {
  try {
    return getValueByPointer(obj, jsonPath);
  } catch (e2) {
    console.error(e2);
    return {};
  }
}

// node_modules/@swagger-api/apidom-error/src/ApiDOMAggregateError.mjs
var import_aggregate_error = __toESM(require_aggregate_error6(), 1);
var ApiDOMAggregateError = class extends import_aggregate_error.default {
  constructor(errors, message, options) {
    super(errors, message, options);
    this.name = this.constructor.name;
    if (typeof message === "string") {
      this.message = message;
    }
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
    if (options != null && typeof options === "object" && Object.hasOwn(options, "cause") && !("cause" in this)) {
      const {
        cause
      } = options;
      this.cause = cause;
      if (cause instanceof Error && "stack" in cause) {
        this.stack = `${this.stack}
CAUSE: ${cause.stack}`;
      }
    }
  }
};
var ApiDOMAggregateError_default = ApiDOMAggregateError;

// node_modules/@swagger-api/apidom-error/src/ApiDOMError.mjs
var ApiDOMError = class extends Error {
  static [Symbol.hasInstance](instance) {
    return super[Symbol.hasInstance](instance) || Function.prototype[Symbol.hasInstance].call(ApiDOMAggregateError_default, instance);
  }
  constructor(message, options) {
    super(message, options);
    this.name = this.constructor.name;
    if (typeof message === "string") {
      this.message = message;
    }
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
    if (options != null && typeof options === "object" && Object.hasOwn(options, "cause") && !("cause" in this)) {
      const {
        cause
      } = options;
      this.cause = cause;
      if (cause instanceof Error && "stack" in cause) {
        this.stack = `${this.stack}
CAUSE: ${cause.stack}`;
      }
    }
  }
};
var ApiDOMError_default = ApiDOMError;

// node_modules/@swagger-api/apidom-error/src/ApiDOMStructuredError.mjs
var ApiDOMStructuredError = class extends ApiDOMError_default {
  constructor(message, structuredOptions) {
    super(message, structuredOptions);
    if (structuredOptions != null && typeof structuredOptions === "object") {
      const {
        cause,
        ...causelessOptions
      } = structuredOptions;
      Object.assign(this, causelessOptions);
    }
  }
};
var ApiDOMStructuredError_default = ApiDOMStructuredError;

// node_modules/@swagger-api/apidom-error/src/UnsupportedOperationError.mjs
var UnsupportedOperationError = class extends ApiDOMError_default {
};
var UnsupportedOperationError_default = UnsupportedOperationError;

// node_modules/@swagger-api/apidom-error/src/NotImplementedError.mjs
var NotImplementedError = class extends UnsupportedOperationError_default {
};
var NotImplementedError_default = NotImplementedError;

// node_modules/ramda/es/F.js
var F = function() {
  return false;
};
var F_default = F;

// node_modules/ramda/es/T.js
var T = function() {
  return true;
};
var T_default = T;

// node_modules/ramda/es/__.js
var __default = {
  "@@functional/placeholder": true
};

// node_modules/ramda/es/internal/_isPlaceholder.js
function _isPlaceholder(a2) {
  return a2 != null && typeof a2 === "object" && a2["@@functional/placeholder"] === true;
}

// node_modules/ramda/es/internal/_curry1.js
function _curry1(fn2) {
  return function f1(a2) {
    if (arguments.length === 0 || _isPlaceholder(a2)) {
      return f1;
    } else {
      return fn2.apply(this, arguments);
    }
  };
}

// node_modules/ramda/es/internal/_curry2.js
function _curry2(fn2) {
  return function f2(a2, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a2) ? f2 : _curry1(function(_b) {
          return fn2(a2, _b);
        });
      default:
        return _isPlaceholder(a2) && _isPlaceholder(b) ? f2 : _isPlaceholder(a2) ? _curry1(function(_a6) {
          return fn2(_a6, b);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn2(a2, _b);
        }) : fn2(a2, b);
    }
  };
}

// node_modules/ramda/es/add.js
var add2 = _curry2(function add3(a2, b) {
  return Number(a2) + Number(b);
});
var add_default = add2;

// node_modules/ramda/es/internal/_concat.js
function _concat(set1, set22) {
  set1 = set1 || [];
  set22 = set22 || [];
  var idx;
  var len1 = set1.length;
  var len2 = set22.length;
  var result = [];
  idx = 0;
  while (idx < len1) {
    result[result.length] = set1[idx];
    idx += 1;
  }
  idx = 0;
  while (idx < len2) {
    result[result.length] = set22[idx];
    idx += 1;
  }
  return result;
}

// node_modules/ramda/es/internal/_arity.js
function _arity(n, fn2) {
  switch (n) {
    case 0:
      return function() {
        return fn2.apply(this, arguments);
      };
    case 1:
      return function(a0) {
        return fn2.apply(this, arguments);
      };
    case 2:
      return function(a0, a1) {
        return fn2.apply(this, arguments);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn2.apply(this, arguments);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn2.apply(this, arguments);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn2.apply(this, arguments);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn2.apply(this, arguments);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn2.apply(this, arguments);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn2.apply(this, arguments);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn2.apply(this, arguments);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn2.apply(this, arguments);
      };
    default:
      throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
  }
}

// node_modules/ramda/es/internal/_curryN.js
function _curryN(length3, received, fn2) {
  return function() {
    var combined = [];
    var argsIdx = 0;
    var left = length3;
    var combinedIdx = 0;
    var hasPlaceholder = false;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      } else {
        hasPlaceholder = true;
      }
      combinedIdx += 1;
    }
    return !hasPlaceholder && left <= 0 ? fn2.apply(this, combined) : _arity(Math.max(0, left), _curryN(length3, combined, fn2));
  };
}

// node_modules/ramda/es/curryN.js
var curryN = _curry2(function curryN2(length3, fn2) {
  if (length3 === 1) {
    return _curry1(fn2);
  }
  return _arity(length3, _curryN(length3, [], fn2));
});
var curryN_default = curryN;

// node_modules/ramda/es/addIndex.js
var addIndex = _curry1(function addIndex2(fn2) {
  return curryN_default(fn2.length, function() {
    var idx = 0;
    var origFn = arguments[0];
    var list4 = arguments[arguments.length - 1];
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function() {
      var result = origFn.apply(this, _concat(arguments, [idx, list4]));
      idx += 1;
      return result;
    };
    return fn2.apply(this, args);
  });
});
var addIndex_default = addIndex;

// node_modules/ramda/es/addIndexRight.js
var addIndexRight = _curry1(function addIndex3(fn2) {
  return curryN_default(fn2.length, function() {
    var origFn = arguments[0];
    var list4 = arguments[arguments.length - 1];
    var idx = list4.length - 1;
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = function() {
      var result = origFn.apply(this, _concat(arguments, [idx, list4]));
      idx -= 1;
      return result;
    };
    return fn2.apply(this, args);
  });
});

// node_modules/ramda/es/internal/_curry3.js
function _curry3(fn2) {
  return function f3(a2, b, c2) {
    switch (arguments.length) {
      case 0:
        return f3;
      case 1:
        return _isPlaceholder(a2) ? f3 : _curry2(function(_b, _c) {
          return fn2(a2, _b, _c);
        });
      case 2:
        return _isPlaceholder(a2) && _isPlaceholder(b) ? f3 : _isPlaceholder(a2) ? _curry2(function(_a6, _c) {
          return fn2(_a6, b, _c);
        }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
          return fn2(a2, _b, _c);
        }) : _curry1(function(_c) {
          return fn2(a2, b, _c);
        });
      default:
        return _isPlaceholder(a2) && _isPlaceholder(b) && _isPlaceholder(c2) ? f3 : _isPlaceholder(a2) && _isPlaceholder(b) ? _curry2(function(_a6, _b) {
          return fn2(_a6, _b, c2);
        }) : _isPlaceholder(a2) && _isPlaceholder(c2) ? _curry2(function(_a6, _c) {
          return fn2(_a6, b, _c);
        }) : _isPlaceholder(b) && _isPlaceholder(c2) ? _curry2(function(_b, _c) {
          return fn2(a2, _b, _c);
        }) : _isPlaceholder(a2) ? _curry1(function(_a6) {
          return fn2(_a6, b, c2);
        }) : _isPlaceholder(b) ? _curry1(function(_b) {
          return fn2(a2, _b, c2);
        }) : _isPlaceholder(c2) ? _curry1(function(_c) {
          return fn2(a2, b, _c);
        }) : fn2(a2, b, c2);
    }
  };
}

// node_modules/ramda/es/adjust.js
var adjust = _curry3(function adjust2(idx, fn2, list4) {
  var len = list4.length;
  if (idx >= len || idx < -len) {
    return list4;
  }
  var _idx = (len + idx) % len;
  var _list = _concat(list4);
  _list[_idx] = fn2(list4[_idx]);
  return _list;
});
var adjust_default = adjust;

// node_modules/ramda/es/internal/_isArray.js
var isArray_default = Array.isArray || function _isArray(val) {
  return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
};

// node_modules/ramda/es/internal/_isTransformer.js
function _isTransformer(obj) {
  return obj != null && typeof obj["@@transducer/step"] === "function";
}

// node_modules/ramda/es/internal/_dispatchable.js
function _dispatchable(methodNames, transducerCreator, fn2) {
  return function() {
    if (arguments.length === 0) {
      return fn2();
    }
    var obj = arguments[arguments.length - 1];
    if (!isArray_default(obj)) {
      var idx = 0;
      while (idx < methodNames.length) {
        if (typeof obj[methodNames[idx]] === "function") {
          return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
        }
        idx += 1;
      }
      if (_isTransformer(obj)) {
        var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
        return transducer(obj);
      }
    }
    return fn2.apply(this, arguments);
  };
}

// node_modules/ramda/es/internal/_reduced.js
function _reduced(x2) {
  return x2 && x2["@@transducer/reduced"] ? x2 : {
    "@@transducer/value": x2,
    "@@transducer/reduced": true
  };
}

// node_modules/ramda/es/internal/_xfBase.js
var xfBase_default = {
  init: function() {
    return this.xf["@@transducer/init"]();
  },
  result: function(result) {
    return this.xf["@@transducer/result"](result);
  }
};

// node_modules/ramda/es/internal/_xall.js
var XAll = function() {
  function XAll2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.all = true;
  }
  XAll2.prototype["@@transducer/init"] = xfBase_default.init;
  XAll2.prototype["@@transducer/result"] = function(result) {
    if (this.all) {
      result = this.xf["@@transducer/step"](result, true);
    }
    return this.xf["@@transducer/result"](result);
  };
  XAll2.prototype["@@transducer/step"] = function(result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = _reduced(this.xf["@@transducer/step"](result, false));
    }
    return result;
  };
  return XAll2;
}();
function _xall(f2) {
  return function(xf) {
    return new XAll(f2, xf);
  };
}

// node_modules/ramda/es/all.js
var all = _curry2(_dispatchable(["all"], _xall, function all2(fn2, list4) {
  var idx = 0;
  while (idx < list4.length) {
    if (!fn2(list4[idx])) {
      return false;
    }
    idx += 1;
  }
  return true;
}));
var all_default = all;

// node_modules/ramda/es/internal/_arrayFromIterator.js
function _arrayFromIterator(iter) {
  var list4 = [];
  var next;
  while (!(next = iter.next()).done) {
    list4.push(next.value);
  }
  return list4;
}

// node_modules/ramda/es/internal/_includesWith.js
function _includesWith(pred, x2, list4) {
  var idx = 0;
  var len = list4.length;
  while (idx < len) {
    if (pred(x2, list4[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}

// node_modules/ramda/es/internal/_functionName.js
function _functionName(f2) {
  var match3 = String(f2).match(/^function (\w*)/);
  return match3 == null ? "" : match3[1];
}

// node_modules/ramda/es/internal/_has.js
function _has(prop3, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop3);
}

// node_modules/ramda/es/internal/_objectIs.js
function _objectIs(a2, b) {
  if (a2 === b) {
    return a2 !== 0 || 1 / a2 === 1 / b;
  } else {
    return a2 !== a2 && b !== b;
  }
}
var objectIs_default = typeof Object.is === "function" ? Object.is : _objectIs;

// node_modules/ramda/es/internal/_isArguments.js
var toString2 = Object.prototype.toString;
var _isArguments = function() {
  return toString2.call(arguments) === "[object Arguments]" ? function _isArguments2(x2) {
    return toString2.call(x2) === "[object Arguments]";
  } : function _isArguments2(x2) {
    return _has("callee", x2);
  };
}();
var isArguments_default = _isArguments;

// node_modules/ramda/es/keys.js
var hasEnumBug = !{
  toString: null
}.propertyIsEnumerable("toString");
var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
var hasArgsEnumBug = function() {
  "use strict";
  return arguments.propertyIsEnumerable("length");
}();
var contains = function contains2(list4, item) {
  var idx = 0;
  while (idx < list4.length) {
    if (list4[idx] === item) {
      return true;
    }
    idx += 1;
  }
  return false;
};
var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? _curry1(function keys2(obj) {
  return Object(obj) !== obj ? [] : Object.keys(obj);
}) : _curry1(function keys3(obj) {
  if (Object(obj) !== obj) {
    return [];
  }
  var prop3, nIdx;
  var ks2 = [];
  var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
  for (prop3 in obj) {
    if (_has(prop3, obj) && (!checkArgsLength || prop3 !== "length")) {
      ks2[ks2.length] = prop3;
    }
  }
  if (hasEnumBug) {
    nIdx = nonEnumerableProps.length - 1;
    while (nIdx >= 0) {
      prop3 = nonEnumerableProps[nIdx];
      if (_has(prop3, obj) && !contains(ks2, prop3)) {
        ks2[ks2.length] = prop3;
      }
      nIdx -= 1;
    }
  }
  return ks2;
});
var keys_default = keys;

// node_modules/ramda/es/type.js
var type2 = _curry1(function type3(val) {
  return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
});
var type_default = type2;

// node_modules/ramda/es/internal/_equals.js
function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
  var a2 = _arrayFromIterator(aIterator);
  var b = _arrayFromIterator(bIterator);
  function eq(_a6, _b) {
    return _equals(_a6, _b, stackA.slice(), stackB.slice());
  }
  return !_includesWith(function(b2, aItem) {
    return !_includesWith(eq, aItem, b2);
  }, b, a2);
}
function _equals(a2, b, stackA, stackB) {
  if (objectIs_default(a2, b)) {
    return true;
  }
  var typeA = type_default(a2);
  if (typeA !== type_default(b)) {
    return false;
  }
  if (typeof a2["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
    return typeof a2["fantasy-land/equals"] === "function" && a2["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a2);
  }
  if (typeof a2.equals === "function" || typeof b.equals === "function") {
    return typeof a2.equals === "function" && a2.equals(b) && typeof b.equals === "function" && b.equals(a2);
  }
  switch (typeA) {
    case "Arguments":
    case "Array":
    case "Object":
      if (typeof a2.constructor === "function" && _functionName(a2.constructor) === "Promise") {
        return a2 === b;
      }
      break;
    case "Boolean":
    case "Number":
    case "String":
      if (!(typeof a2 === typeof b && objectIs_default(a2.valueOf(), b.valueOf()))) {
        return false;
      }
      break;
    case "Date":
      if (!objectIs_default(a2.valueOf(), b.valueOf())) {
        return false;
      }
      break;
    case "Error":
      return a2.name === b.name && a2.message === b.message;
    case "RegExp":
      if (!(a2.source === b.source && a2.global === b.global && a2.ignoreCase === b.ignoreCase && a2.multiline === b.multiline && a2.sticky === b.sticky && a2.unicode === b.unicode)) {
        return false;
      }
      break;
  }
  var idx = stackA.length - 1;
  while (idx >= 0) {
    if (stackA[idx] === a2) {
      return stackB[idx] === b;
    }
    idx -= 1;
  }
  switch (typeA) {
    case "Map":
      if (a2.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a2.entries(), b.entries(), stackA.concat([a2]), stackB.concat([b]));
    case "Set":
      if (a2.size !== b.size) {
        return false;
      }
      return _uniqContentEquals(a2.values(), b.values(), stackA.concat([a2]), stackB.concat([b]));
    case "Arguments":
    case "Array":
    case "Object":
    case "Boolean":
    case "Number":
    case "String":
    case "Date":
    case "Error":
    case "RegExp":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "ArrayBuffer":
      break;
    default:
      return false;
  }
  var keysA = keys_default(a2);
  if (keysA.length !== keys_default(b).length) {
    return false;
  }
  var extendedStackA = stackA.concat([a2]);
  var extendedStackB = stackB.concat([b]);
  idx = keysA.length - 1;
  while (idx >= 0) {
    var key57 = keysA[idx];
    if (!(_has(key57, b) && _equals(b[key57], a2[key57], extendedStackA, extendedStackB))) {
      return false;
    }
    idx -= 1;
  }
  return true;
}

// node_modules/ramda/es/equals.js
var equals = _curry2(function equals2(a2, b) {
  return _equals(a2, b, [], []);
});
var equals_default = equals;

// node_modules/ramda/es/internal/_indexOf.js
function _indexOf(list4, a2, idx) {
  var inf, item;
  if (typeof list4.indexOf === "function") {
    switch (typeof a2) {
      case "number":
        if (a2 === 0) {
          inf = 1 / a2;
          while (idx < list4.length) {
            item = list4[idx];
            if (item === 0 && 1 / item === inf) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        } else if (a2 !== a2) {
          while (idx < list4.length) {
            item = list4[idx];
            if (typeof item === "number" && item !== item) {
              return idx;
            }
            idx += 1;
          }
          return -1;
        }
        return list4.indexOf(a2, idx);
      case "string":
      case "boolean":
      case "function":
      case "undefined":
        return list4.indexOf(a2, idx);
      case "object":
        if (a2 === null) {
          return list4.indexOf(a2, idx);
        }
    }
  }
  while (idx < list4.length) {
    if (equals_default(list4[idx], a2)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}

// node_modules/ramda/es/internal/_includes.js
function _includes(a2, list4) {
  return _indexOf(list4, a2, 0) >= 0;
}

// node_modules/ramda/es/internal/_map.js
function _map(fn2, functor) {
  var idx = 0;
  var len = functor.length;
  var result = Array(len);
  while (idx < len) {
    result[idx] = fn2(functor[idx]);
    idx += 1;
  }
  return result;
}

// node_modules/ramda/es/internal/_quote.js
function _quote(s2) {
  var escaped = s2.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
  return '"' + escaped.replace(/"/g, '\\"') + '"';
}

// node_modules/ramda/es/internal/_toISOString.js
var pad = function pad2(n) {
  return (n < 10 ? "0" : "") + n;
};
var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d2) {
  return d2.toISOString();
} : function _toISOString3(d2) {
  return d2.getUTCFullYear() + "-" + pad(d2.getUTCMonth() + 1) + "-" + pad(d2.getUTCDate()) + "T" + pad(d2.getUTCHours()) + ":" + pad(d2.getUTCMinutes()) + ":" + pad(d2.getUTCSeconds()) + "." + (d2.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
};
var toISOString_default = _toISOString;

// node_modules/ramda/es/internal/_complement.js
function _complement(f2) {
  return function() {
    return !f2.apply(this, arguments);
  };
}

// node_modules/ramda/es/internal/_arrayReduce.js
function _arrayReduce(reducer, acc, list4) {
  var index = 0;
  var length3 = list4.length;
  while (index < length3) {
    acc = reducer(acc, list4[index]);
    index += 1;
  }
  return acc;
}

// node_modules/ramda/es/internal/_filter.js
function _filter(fn2, list4) {
  var idx = 0;
  var len = list4.length;
  var result = [];
  while (idx < len) {
    if (fn2(list4[idx])) {
      result[result.length] = list4[idx];
    }
    idx += 1;
  }
  return result;
}

// node_modules/ramda/es/internal/_isObject.js
function _isObject(x2) {
  return Object.prototype.toString.call(x2) === "[object Object]";
}

// node_modules/ramda/es/internal/_xfilter.js
var XFilter = function() {
  function XFilter2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XFilter2.prototype["@@transducer/init"] = xfBase_default.init;
  XFilter2.prototype["@@transducer/result"] = xfBase_default.result;
  XFilter2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.xf["@@transducer/step"](result, input) : result;
  };
  return XFilter2;
}();
function _xfilter(f2) {
  return function(xf) {
    return new XFilter(f2, xf);
  };
}

// node_modules/ramda/es/filter.js
var filter = _curry2(_dispatchable(["fantasy-land/filter", "filter"], _xfilter, function(pred, filterable) {
  return _isObject(filterable) ? _arrayReduce(function(acc, key57) {
    if (pred(filterable[key57])) {
      acc[key57] = filterable[key57];
    }
    return acc;
  }, {}, keys_default(filterable)) : (
    // else
    _filter(pred, filterable)
  );
}));
var filter_default = filter;

// node_modules/ramda/es/reject.js
var reject = _curry2(function reject2(pred, filterable) {
  return filter_default(_complement(pred), filterable);
});
var reject_default = reject;

// node_modules/ramda/es/internal/_toString.js
function _toString2(x2, seen) {
  var recur = function recur2(y2) {
    var xs2 = seen.concat([x2]);
    return _includes(y2, xs2) ? "<Circular>" : _toString2(y2, xs2);
  };
  var mapPairs = function(obj, keys4) {
    return _map(function(k) {
      return _quote(k) + ": " + recur(obj[k]);
    }, keys4.slice().sort());
  };
  switch (Object.prototype.toString.call(x2)) {
    case "[object Arguments]":
      return "(function() { return arguments; }(" + _map(recur, x2).join(", ") + "))";
    case "[object Array]":
      return "[" + _map(recur, x2).concat(mapPairs(x2, reject_default(function(k) {
        return /^\d+$/.test(k);
      }, keys_default(x2)))).join(", ") + "]";
    case "[object Boolean]":
      return typeof x2 === "object" ? "new Boolean(" + recur(x2.valueOf()) + ")" : x2.toString();
    case "[object Date]":
      return "new Date(" + (isNaN(x2.valueOf()) ? recur(NaN) : _quote(toISOString_default(x2))) + ")";
    case "[object Map]":
      return "new Map(" + recur(Array.from(x2)) + ")";
    case "[object Null]":
      return "null";
    case "[object Number]":
      return typeof x2 === "object" ? "new Number(" + recur(x2.valueOf()) + ")" : 1 / x2 === -Infinity ? "-0" : x2.toString(10);
    case "[object Set]":
      return "new Set(" + recur(Array.from(x2).sort()) + ")";
    case "[object String]":
      return typeof x2 === "object" ? "new String(" + recur(x2.valueOf()) + ")" : _quote(x2);
    case "[object Undefined]":
      return "undefined";
    default:
      if (typeof x2.toString === "function") {
        var repr = x2.toString();
        if (repr !== "[object Object]") {
          return repr;
        }
      }
      return "{" + mapPairs(x2, keys_default(x2)).join(", ") + "}";
  }
}

// node_modules/ramda/es/toString.js
var toString3 = _curry1(function toString4(val) {
  return _toString2(val, []);
});
var toString_default = toString3;

// node_modules/ramda/es/max.js
var max = _curry2(function max2(a2, b) {
  if (a2 === b) {
    return b;
  }
  function safeMax(x2, y2) {
    if (x2 > y2 !== y2 > x2) {
      return y2 > x2 ? y2 : x2;
    }
    return void 0;
  }
  var maxByValue = safeMax(a2, b);
  if (maxByValue !== void 0) {
    return maxByValue;
  }
  var maxByType = safeMax(typeof a2, typeof b);
  if (maxByType !== void 0) {
    return maxByType === typeof a2 ? a2 : b;
  }
  var stringA = toString_default(a2);
  var maxByStringValue = safeMax(stringA, toString_default(b));
  if (maxByStringValue !== void 0) {
    return maxByStringValue === stringA ? a2 : b;
  }
  return b;
});
var max_default = max;

// node_modules/ramda/es/internal/_xmap.js
var XMap = function() {
  function XMap2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XMap2.prototype["@@transducer/init"] = xfBase_default.init;
  XMap2.prototype["@@transducer/result"] = xfBase_default.result;
  XMap2.prototype["@@transducer/step"] = function(result, input) {
    return this.xf["@@transducer/step"](result, this.f(input));
  };
  return XMap2;
}();
var _xmap = function _xmap2(f2) {
  return function(xf) {
    return new XMap(f2, xf);
  };
};
var xmap_default = _xmap;

// node_modules/ramda/es/map.js
var map2 = _curry2(_dispatchable(["fantasy-land/map", "map"], xmap_default, function map3(fn2, functor) {
  switch (Object.prototype.toString.call(functor)) {
    case "[object Function]":
      return curryN_default(functor.length, function() {
        return fn2.call(this, functor.apply(this, arguments));
      });
    case "[object Object]":
      return _arrayReduce(function(acc, key57) {
        acc[key57] = fn2(functor[key57]);
        return acc;
      }, {}, keys_default(functor));
    default:
      return _map(fn2, functor);
  }
}));
var map_default = map2;

// node_modules/ramda/es/internal/_isInteger.js
var isInteger_default = Number.isInteger || function _isInteger(n) {
  return n << 0 === n;
};

// node_modules/ramda/es/internal/_isString.js
function _isString(x2) {
  return Object.prototype.toString.call(x2) === "[object String]";
}

// node_modules/ramda/es/internal/_nth.js
function _nth(offset, list4) {
  var idx = offset < 0 ? list4.length + offset : offset;
  return _isString(list4) ? list4.charAt(idx) : list4[idx];
}

// node_modules/ramda/es/prop.js
var prop = _curry2(function prop2(p2, obj) {
  if (obj == null) {
    return;
  }
  return isInteger_default(p2) ? _nth(p2, obj) : obj[p2];
});
var prop_default = prop;

// node_modules/ramda/es/pluck.js
var pluck = _curry2(function pluck2(p2, list4) {
  return map_default(prop_default(p2), list4);
});
var pluck_default = pluck;

// node_modules/ramda/es/internal/_isArrayLike.js
var _isArrayLike = _curry1(function isArrayLike(x2) {
  if (isArray_default(x2)) {
    return true;
  }
  if (!x2) {
    return false;
  }
  if (typeof x2 !== "object") {
    return false;
  }
  if (_isString(x2)) {
    return false;
  }
  if (x2.length === 0) {
    return true;
  }
  if (x2.length > 0) {
    return x2.hasOwnProperty(0) && x2.hasOwnProperty(x2.length - 1);
  }
  return false;
});
var isArrayLike_default = _isArrayLike;

// node_modules/ramda/es/internal/_createReduce.js
var symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
function _createReduce(arrayReduce, methodReduce, iterableReduce) {
  return function _reduce2(xf, acc, list4) {
    if (isArrayLike_default(list4)) {
      return arrayReduce(xf, acc, list4);
    }
    if (list4 == null) {
      return acc;
    }
    if (typeof list4["fantasy-land/reduce"] === "function") {
      return methodReduce(xf, acc, list4, "fantasy-land/reduce");
    }
    if (list4[symIterator] != null) {
      return iterableReduce(xf, acc, list4[symIterator]());
    }
    if (typeof list4.next === "function") {
      return iterableReduce(xf, acc, list4);
    }
    if (typeof list4.reduce === "function") {
      return methodReduce(xf, acc, list4, "reduce");
    }
    throw new TypeError("reduce: list must be array or iterable");
  };
}

// node_modules/ramda/es/internal/_xArrayReduce.js
function _xArrayReduce(xf, acc, list4) {
  var idx = 0;
  var len = list4.length;
  while (idx < len) {
    acc = xf["@@transducer/step"](acc, list4[idx]);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    idx += 1;
  }
  return xf["@@transducer/result"](acc);
}

// node_modules/ramda/es/bind.js
var bind = _curry2(function bind2(fn2, thisObj) {
  return _arity(fn2.length, function() {
    return fn2.apply(thisObj, arguments);
  });
});
var bind_default = bind;

// node_modules/ramda/es/internal/_xReduce.js
function _xIterableReduce(xf, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = xf["@@transducer/step"](acc, step.value);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    step = iter.next();
  }
  return xf["@@transducer/result"](acc);
}
function _xMethodReduce(xf, acc, obj, methodName) {
  return xf["@@transducer/result"](obj[methodName](bind_default(xf["@@transducer/step"], xf), acc));
}
var _xReduce = _createReduce(_xArrayReduce, _xMethodReduce, _xIterableReduce);
var xReduce_default = _xReduce;

// node_modules/ramda/es/internal/_xwrap.js
var XWrap = function() {
  function XWrap2(fn2) {
    this.f = fn2;
  }
  XWrap2.prototype["@@transducer/init"] = function() {
    throw new Error("init not implemented on XWrap");
  };
  XWrap2.prototype["@@transducer/result"] = function(acc) {
    return acc;
  };
  XWrap2.prototype["@@transducer/step"] = function(acc, x2) {
    return this.f(acc, x2);
  };
  return XWrap2;
}();
function _xwrap(fn2) {
  return new XWrap(fn2);
}

// node_modules/ramda/es/reduce.js
var reduce = _curry3(function(xf, acc, list4) {
  return xReduce_default(typeof xf === "function" ? _xwrap(xf) : xf, acc, list4);
});
var reduce_default = reduce;

// node_modules/ramda/es/allPass.js
var allPass = _curry1(function allPass2(preds) {
  return curryN_default(reduce_default(max_default, 0, pluck_default("length", preds)), function() {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (!preds[idx].apply(this, arguments)) {
        return false;
      }
      idx += 1;
    }
    return true;
  });
});
var allPass_default = allPass;

// node_modules/ramda/es/always.js
var always = _curry1(function always2(val) {
  return function() {
    return val;
  };
});
var always_default = always;

// node_modules/ramda/es/and.js
var and = _curry2(function and2(a2, b) {
  return a2 && b;
});
var and_default = and;

// node_modules/ramda/es/internal/_xany.js
var XAny = function() {
  function XAny2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.any = false;
  }
  XAny2.prototype["@@transducer/init"] = xfBase_default.init;
  XAny2.prototype["@@transducer/result"] = function(result) {
    if (!this.any) {
      result = this.xf["@@transducer/step"](result, false);
    }
    return this.xf["@@transducer/result"](result);
  };
  XAny2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f(input)) {
      this.any = true;
      result = _reduced(this.xf["@@transducer/step"](result, true));
    }
    return result;
  };
  return XAny2;
}();
function _xany(f2) {
  return function(xf) {
    return new XAny(f2, xf);
  };
}

// node_modules/ramda/es/any.js
var any = _curry2(_dispatchable(["any"], _xany, function any2(fn2, list4) {
  var idx = 0;
  while (idx < list4.length) {
    if (fn2(list4[idx])) {
      return true;
    }
    idx += 1;
  }
  return false;
}));

// node_modules/ramda/es/anyPass.js
var anyPass = _curry1(function anyPass2(preds) {
  return curryN_default(reduce_default(max_default, 0, pluck_default("length", preds)), function() {
    var idx = 0;
    var len = preds.length;
    while (idx < len) {
      if (preds[idx].apply(this, arguments)) {
        return true;
      }
      idx += 1;
    }
    return false;
  });
});
var anyPass_default = anyPass;

// node_modules/ramda/es/internal/_reduce.js
function _iterableReduce(reducer, acc, iter) {
  var step = iter.next();
  while (!step.done) {
    acc = reducer(acc, step.value);
    step = iter.next();
  }
  return acc;
}
function _methodReduce(reducer, acc, obj, methodName) {
  return obj[methodName](reducer, acc);
}
var _reduce = _createReduce(_arrayReduce, _methodReduce, _iterableReduce);
var reduce_default2 = _reduce;

// node_modules/ramda/es/ap.js
var ap = _curry2(function ap2(applyF, applyX) {
  return typeof applyX["fantasy-land/ap"] === "function" ? applyX["fantasy-land/ap"](applyF) : typeof applyF.ap === "function" ? applyF.ap(applyX) : typeof applyF === "function" ? function(x2) {
    return applyF(x2)(applyX(x2));
  } : reduce_default2(function(acc, f2) {
    return _concat(acc, map_default(f2, applyX));
  }, [], applyF);
});
var ap_default = ap;

// node_modules/ramda/es/internal/_aperture.js
function _aperture(n, list4) {
  var idx = 0;
  var limit = list4.length - (n - 1);
  var acc = new Array(limit >= 0 ? limit : 0);
  while (idx < limit) {
    acc[idx] = Array.prototype.slice.call(list4, idx, idx + n);
    idx += 1;
  }
  return acc;
}

// node_modules/ramda/es/internal/_xaperture.js
var XAperture = function() {
  function XAperture2(n, xf) {
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XAperture2.prototype["@@transducer/init"] = xfBase_default.init;
  XAperture2.prototype["@@transducer/result"] = function(result) {
    this.acc = null;
    return this.xf["@@transducer/result"](result);
  };
  XAperture2.prototype["@@transducer/step"] = function(result, input) {
    this.store(input);
    return this.full ? this.xf["@@transducer/step"](result, this.getCopy()) : result;
  };
  XAperture2.prototype.store = function(input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  XAperture2.prototype.getCopy = function() {
    return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
  };
  return XAperture2;
}();
function _xaperture(n) {
  return function(xf) {
    return new XAperture(n, xf);
  };
}

// node_modules/ramda/es/aperture.js
var aperture = _curry2(_dispatchable([], _xaperture, _aperture));

// node_modules/ramda/es/append.js
var append = _curry2(function append2(el2, list4) {
  return _concat(list4, [el2]);
});
var append_default = append;

// node_modules/ramda/es/apply.js
var apply = _curry2(function apply2(fn2, args) {
  return fn2.apply(this, args);
});
var apply_default = apply;

// node_modules/ramda/es/values.js
var values = _curry1(function values2(obj) {
  var props3 = keys_default(obj);
  var len = props3.length;
  var vals = [];
  var idx = 0;
  while (idx < len) {
    vals[idx] = obj[props3[idx]];
    idx += 1;
  }
  return vals;
});
var values_default = values;

// node_modules/ramda/es/applySpec.js
function mapValues(fn2, obj) {
  return isArray_default(obj) ? obj.map(fn2) : keys_default(obj).reduce(function(acc, key57) {
    acc[key57] = fn2(obj[key57]);
    return acc;
  }, {});
}
var applySpec = _curry1(function applySpec2(spec2) {
  spec2 = mapValues(function(v2) {
    return typeof v2 == "function" ? v2 : applySpec2(v2);
  }, spec2);
  return curryN_default(reduce_default(max_default, 0, pluck_default("length", values_default(spec2))), function() {
    var args = arguments;
    return mapValues(function(f2) {
      return apply_default(f2, args);
    }, spec2);
  });
});

// node_modules/ramda/es/applyTo.js
var applyTo = _curry2(function applyTo2(x2, f2) {
  return f2(x2);
});
var applyTo_default = applyTo;

// node_modules/ramda/es/ascend.js
var ascend = _curry3(function ascend2(fn2, a2, b) {
  var aa2 = fn2(a2);
  var bb = fn2(b);
  return aa2 < bb ? -1 : aa2 > bb ? 1 : 0;
});
var ascend_default = ascend;

// node_modules/ramda/es/curry.js
var curry = _curry1(function curry2(fn2) {
  return curryN_default(fn2.length, fn2);
});
var curry_default = curry;

// node_modules/ramda/es/ascendNatural.js
var ascendNatural = curry_default(function ascendNatural2(locales, fn2, a2, b) {
  const aa2 = fn2(a2);
  const bb = fn2(b);
  return aa2.localeCompare(bb, locales, {
    numeric: true
  });
});

// node_modules/ramda/es/internal/_assoc.js
function _assoc(prop3, val, obj) {
  if (isInteger_default(prop3) && isArray_default(obj)) {
    var arr = [].concat(obj);
    arr[prop3] = val;
    return arr;
  }
  var result = {};
  for (var p2 in obj) {
    result[p2] = obj[p2];
  }
  result[prop3] = val;
  return result;
}

// node_modules/ramda/es/isNil.js
var isNil = _curry1(function isNil2(x2) {
  return x2 == null;
});
var isNil_default = isNil;

// node_modules/ramda/es/assocPath.js
var assocPath = _curry3(function assocPath2(path4, val, obj) {
  if (path4.length === 0) {
    return val;
  }
  var idx = path4[0];
  if (path4.length > 1) {
    var nextObj = !isNil_default(obj) && _has(idx, obj) && typeof obj[idx] === "object" ? obj[idx] : isInteger_default(path4[1]) ? [] : {};
    val = assocPath2(Array.prototype.slice.call(path4, 1), val, nextObj);
  }
  return _assoc(idx, val, obj);
});
var assocPath_default = assocPath;

// node_modules/ramda/es/assoc.js
var assoc = _curry3(function assoc2(prop3, val, obj) {
  return assocPath_default([prop3], val, obj);
});
var assoc_default = assoc;

// node_modules/ramda/es/nAry.js
var nAry = _curry2(function nAry2(n, fn2) {
  switch (n) {
    case 0:
      return function() {
        return fn2.call(this);
      };
    case 1:
      return function(a0) {
        return fn2.call(this, a0);
      };
    case 2:
      return function(a0, a1) {
        return fn2.call(this, a0, a1);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn2.call(this, a0, a1, a2);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn2.call(this, a0, a1, a2, a3);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn2.call(this, a0, a1, a2, a3, a4);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5, a6);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn2.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
      };
    default:
      throw new Error("First argument to nAry must be a non-negative integer no greater than ten");
  }
});
var nAry_default = nAry;

// node_modules/ramda/es/binary.js
var binary2 = _curry1(function binary3(fn2) {
  return nAry_default(2, fn2);
});

// node_modules/ramda/es/internal/_isFunction.js
function _isFunction(x2) {
  var type5 = Object.prototype.toString.call(x2);
  return type5 === "[object Function]" || type5 === "[object AsyncFunction]" || type5 === "[object GeneratorFunction]" || type5 === "[object AsyncGeneratorFunction]";
}

// node_modules/ramda/es/liftN.js
var liftN = _curry2(function liftN2(arity, fn2) {
  var lifted = curryN_default(arity, fn2);
  return curryN_default(arity, function() {
    return _arrayReduce(ap_default, map_default(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
  });
});
var liftN_default = liftN;

// node_modules/ramda/es/lift.js
var lift = _curry1(function lift2(fn2) {
  return liftN_default(fn2.length, fn2);
});
var lift_default = lift;

// node_modules/ramda/es/both.js
var both = _curry2(function both2(f2, g2) {
  return _isFunction(f2) ? function _both() {
    return f2.apply(this, arguments) && g2.apply(this, arguments);
  } : lift_default(and_default)(f2, g2);
});
var both_default = both;

// node_modules/ramda/es/call.js
var call = _curry1(function call2(fn2) {
  return fn2.apply(this, Array.prototype.slice.call(arguments, 1));
});

// node_modules/ramda/es/internal/_makeFlat.js
function _makeFlat(recursive) {
  return function flatt(list4) {
    var value, jlen, j2;
    var result = [];
    var idx = 0;
    var ilen = list4.length;
    while (idx < ilen) {
      if (isArrayLike_default(list4[idx])) {
        value = recursive ? flatt(list4[idx]) : list4[idx];
        j2 = 0;
        jlen = value.length;
        while (j2 < jlen) {
          result[result.length] = value[j2];
          j2 += 1;
        }
      } else {
        result[result.length] = list4[idx];
      }
      idx += 1;
    }
    return result;
  };
}

// node_modules/ramda/es/internal/_forceReduced.js
function _forceReduced(x2) {
  return {
    "@@transducer/value": x2,
    "@@transducer/reduced": true
  };
}

// node_modules/ramda/es/internal/_flatCat.js
var tInit = "@@transducer/init";
var tStep = "@@transducer/step";
var tResult = "@@transducer/result";
var XPreservingReduced = function() {
  function XPreservingReduced2(xf) {
    this.xf = xf;
  }
  XPreservingReduced2.prototype[tInit] = xfBase_default.init;
  XPreservingReduced2.prototype[tResult] = xfBase_default.result;
  XPreservingReduced2.prototype[tStep] = function(result, input) {
    var ret = this.xf[tStep](result, input);
    return ret["@@transducer/reduced"] ? _forceReduced(ret) : ret;
  };
  return XPreservingReduced2;
}();
var XFlatCat = function() {
  function XFlatCat2(xf) {
    this.xf = new XPreservingReduced(xf);
  }
  XFlatCat2.prototype[tInit] = xfBase_default.init;
  XFlatCat2.prototype[tResult] = xfBase_default.result;
  XFlatCat2.prototype[tStep] = function(result, input) {
    return !isArrayLike_default(input) ? _xArrayReduce(this.xf, result, [input]) : xReduce_default(this.xf, result, input);
  };
  return XFlatCat2;
}();
var _flatCat = function _xcat(xf) {
  return new XFlatCat(xf);
};
var flatCat_default = _flatCat;

// node_modules/ramda/es/internal/_xchain.js
function _xchain(f2) {
  return function(xf) {
    return xmap_default(f2)(flatCat_default(xf));
  };
}

// node_modules/ramda/es/chain.js
var chain = _curry2(_dispatchable(["fantasy-land/chain", "chain"], _xchain, function chain2(fn2, monad) {
  if (typeof monad === "function") {
    return function(x2) {
      return fn2(monad(x2))(x2);
    };
  }
  return _makeFlat(false)(map_default(fn2, monad));
}));
var chain_default = chain;

// node_modules/ramda/es/clamp.js
var clamp = _curry3(function clamp2(min3, max3, value) {
  if (min3 > max3) {
    throw new Error("min must not be greater than max in clamp(min, max, value)");
  }
  return value < min3 ? min3 : value > max3 ? max3 : value;
});

// node_modules/ramda/es/internal/_cloneRegExp.js
function _cloneRegExp(pattern) {
  return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : "") + (pattern.dotAll ? "s" : ""));
}

// node_modules/ramda/es/internal/_clone.js
function _clone(value, deep, map5) {
  map5 || (map5 = new _ObjectMap());
  if (_isPrimitive(value)) {
    return value;
  }
  var copy3 = function copy4(copiedValue) {
    var cachedCopy = map5.get(value);
    if (cachedCopy) {
      return cachedCopy;
    }
    map5.set(value, copiedValue);
    for (var key57 in value) {
      if (Object.prototype.hasOwnProperty.call(value, key57)) {
        copiedValue[key57] = deep ? _clone(value[key57], true, map5) : value[key57];
      }
    }
    return copiedValue;
  };
  switch (type_default(value)) {
    case "Object":
      return copy3(Object.create(Object.getPrototypeOf(value)));
    case "Array":
      return copy3(Array(value.length));
    case "Date":
      return new Date(value.valueOf());
    case "RegExp":
      return _cloneRegExp(value);
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "BigInt64Array":
    case "BigUint64Array":
      return value.slice();
    default:
      return value;
  }
}
function _isPrimitive(param) {
  var type5 = typeof param;
  return param == null || type5 != "object" && type5 != "function";
}
var _ObjectMap = function() {
  function _ObjectMap2() {
    this.map = {};
    this.length = 0;
  }
  _ObjectMap2.prototype.set = function(key57, value) {
    var hashedKey = this.hash(key57);
    var bucket = this.map[hashedKey];
    if (!bucket) {
      this.map[hashedKey] = bucket = [];
    }
    bucket.push([key57, value]);
    this.length += 1;
  };
  _ObjectMap2.prototype.hash = function(key57) {
    var hashedKey = [];
    for (var value in key57) {
      hashedKey.push(Object.prototype.toString.call(key57[value]));
    }
    return hashedKey.join();
  };
  _ObjectMap2.prototype.get = function(key57) {
    if (this.length <= 180) {
      for (var p2 in this.map) {
        var bucket = this.map[p2];
        for (var i2 = 0; i2 < bucket.length; i2 += 1) {
          var element = bucket[i2];
          if (element[0] === key57) {
            return element[1];
          }
        }
      }
      return;
    }
    var hashedKey = this.hash(key57);
    var bucket = this.map[hashedKey];
    if (!bucket) {
      return;
    }
    for (var i2 = 0; i2 < bucket.length; i2 += 1) {
      var element = bucket[i2];
      if (element[0] === key57) {
        return element[1];
      }
    }
  };
  return _ObjectMap2;
}();

// node_modules/ramda/es/clone.js
var clone = _curry1(function clone2(value) {
  return value != null && typeof value.clone === "function" ? value.clone() : _clone(value, true);
});
var clone_default = clone;

// node_modules/ramda/es/collectBy.js
var collectBy = _curry2(function collectBy2(fn2, list4) {
  var group = reduce_default2(function(o4, x2) {
    var tag2 = fn2(x2);
    if (o4[tag2] === void 0) {
      o4[tag2] = [];
    }
    o4[tag2].push(x2);
    return o4;
  }, {}, list4);
  var newList = [];
  for (var tag in group) {
    newList.push(group[tag]);
  }
  return newList;
});

// node_modules/ramda/es/comparator.js
var comparator = _curry1(function comparator2(pred) {
  return function(a2, b) {
    return pred(a2, b) ? -1 : pred(b, a2) ? 1 : 0;
  };
});
var comparator_default = comparator;

// node_modules/ramda/es/not.js
var not = _curry1(function not2(a2) {
  return !a2;
});
var not_default = not;

// node_modules/ramda/es/complement.js
var complement = lift_default(not_default);
var complement_default = complement;

// node_modules/ramda/es/internal/_pipe.js
function _pipe(f2, g2) {
  return function() {
    return g2.call(this, f2.apply(this, arguments));
  };
}

// node_modules/ramda/es/internal/_checkForMethod.js
function _checkForMethod(methodname, fn2) {
  return function() {
    var length3 = arguments.length;
    if (length3 === 0) {
      return fn2();
    }
    var obj = arguments[length3 - 1];
    return isArray_default(obj) || typeof obj[methodname] !== "function" ? fn2.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length3 - 1));
  };
}

// node_modules/ramda/es/slice.js
var slice = _curry3(_checkForMethod("slice", function slice2(fromIndex, toIndex, list4) {
  return Array.prototype.slice.call(list4, fromIndex, toIndex);
}));
var slice_default = slice;

// node_modules/ramda/es/tail.js
var tail = _curry1(_checkForMethod("tail", slice_default(1, Infinity)));
var tail_default = tail;

// node_modules/ramda/es/pipe.js
function pipe() {
  if (arguments.length === 0) {
    throw new Error("pipe requires at least one argument");
  }
  return _arity(arguments[0].length, reduce_default(_pipe, arguments[0], tail_default(arguments)));
}

// node_modules/ramda/es/reverse.js
var reverse = _curry1(function reverse2(list4) {
  return _isString(list4) ? list4.split("").reverse().join("") : Array.prototype.slice.call(list4, 0).reverse();
});
var reverse_default = reverse;

// node_modules/ramda/es/compose.js
function compose2() {
  if (arguments.length === 0) {
    throw new Error("compose requires at least one argument");
  }
  return pipe.apply(this, reverse_default(arguments));
}

// node_modules/ramda/es/head.js
var head = _curry1(function(list4) {
  return _nth(0, list4);
});
var head_default = head;

// node_modules/ramda/es/internal/_identity.js
function _identity(x2) {
  return x2;
}

// node_modules/ramda/es/identity.js
var identity = _curry1(_identity);
var identity_default = identity;

// node_modules/ramda/es/pipeWith.js
var pipeWith = _curry2(function pipeWith2(xf, list4) {
  if (list4.length <= 0) {
    return identity_default;
  }
  var headList = head_default(list4);
  var tailList = tail_default(list4);
  return _arity(headList.length, function() {
    return reduce_default2(function(result, f2) {
      return xf.call(this, f2, result);
    }, headList.apply(this, arguments), tailList);
  });
});
var pipeWith_default = pipeWith;

// node_modules/ramda/es/composeWith.js
var composeWith = _curry2(function composeWith2(xf, list4) {
  return pipeWith_default.apply(this, [xf, reverse_default(list4)]);
});

// node_modules/ramda/es/concat.js
var concat = _curry2(function concat2(a2, b) {
  if (isArray_default(a2)) {
    if (isArray_default(b)) {
      return a2.concat(b);
    }
    throw new TypeError(toString_default(b) + " is not an array");
  }
  if (_isString(a2)) {
    if (_isString(b)) {
      return a2 + b;
    }
    throw new TypeError(toString_default(b) + " is not a string");
  }
  if (a2 != null && _isFunction(a2["fantasy-land/concat"])) {
    return a2["fantasy-land/concat"](b);
  }
  if (a2 != null && _isFunction(a2.concat)) {
    return a2.concat(b);
  }
  throw new TypeError(toString_default(a2) + ' does not have a method named "concat" or "fantasy-land/concat"');
});
var concat_default = concat;

// node_modules/ramda/es/cond.js
var cond = _curry1(function cond2(pairs2) {
  var arity = reduce_default(max_default, 0, map_default(function(pair3) {
    return pair3[0].length;
  }, pairs2));
  return _arity(arity, function() {
    var idx = 0;
    while (idx < pairs2.length) {
      if (pairs2[idx][0].apply(this, arguments)) {
        return pairs2[idx][1].apply(this, arguments);
      }
      idx += 1;
    }
  });
});

// node_modules/ramda/es/constructN.js
var constructN = _curry2(function constructN2(n, Fn2) {
  if (n > 10) {
    throw new Error("Constructor with greater than ten arguments");
  }
  if (n === 0) {
    return function() {
      return new Fn2();
    };
  }
  return curry_default(nAry_default(n, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
    switch (n) {
      case 1:
        return new Fn2($0);
      case 2:
        return new Fn2($0, $1);
      case 3:
        return new Fn2($0, $1, $2);
      case 4:
        return new Fn2($0, $1, $2, $3);
      case 5:
        return new Fn2($0, $1, $2, $3, $4);
      case 6:
        return new Fn2($0, $1, $2, $3, $4, $5);
      case 7:
        return new Fn2($0, $1, $2, $3, $4, $5, $6);
      case 8:
        return new Fn2($0, $1, $2, $3, $4, $5, $6, $7);
      case 9:
        return new Fn2($0, $1, $2, $3, $4, $5, $6, $7, $8);
      case 10:
        return new Fn2($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
    }
  }));
});
var constructN_default = constructN;

// node_modules/ramda/es/construct.js
var construct = _curry1(function construct2(Fn2) {
  return constructN_default(Fn2.length, Fn2);
});

// node_modules/ramda/es/converge.js
var converge = _curry2(function converge2(after, fns) {
  return curryN_default(reduce_default(max_default, 0, pluck_default("length", fns)), function() {
    var args = arguments;
    var context2 = this;
    return after.apply(context2, _map(function(fn2) {
      return fn2.apply(context2, args);
    }, fns));
  });
});
var converge_default = converge;

// node_modules/ramda/es/count.js
var count = curry_default(function(pred, list4) {
  return reduce_default2(function(a2, e2) {
    return pred(e2) ? a2 + 1 : a2;
  }, 0, list4);
});

// node_modules/ramda/es/internal/_xreduceBy.js
var XReduceBy = function() {
  function XReduceBy2(valueFn, valueAcc, keyFn, xf) {
    this.valueFn = valueFn;
    this.valueAcc = valueAcc;
    this.keyFn = keyFn;
    this.xf = xf;
    this.inputs = {};
  }
  XReduceBy2.prototype["@@transducer/init"] = xfBase_default.init;
  XReduceBy2.prototype["@@transducer/result"] = function(result) {
    var key57;
    for (key57 in this.inputs) {
      if (_has(key57, this.inputs)) {
        result = this.xf["@@transducer/step"](result, this.inputs[key57]);
        if (result["@@transducer/reduced"]) {
          result = result["@@transducer/value"];
          break;
        }
      }
    }
    this.inputs = null;
    return this.xf["@@transducer/result"](result);
  };
  XReduceBy2.prototype["@@transducer/step"] = function(result, input) {
    var key57 = this.keyFn(input);
    this.inputs[key57] = this.inputs[key57] || [key57, _clone(this.valueAcc, false)];
    this.inputs[key57][1] = this.valueFn(this.inputs[key57][1], input);
    return result;
  };
  return XReduceBy2;
}();
function _xreduceBy(valueFn, valueAcc, keyFn) {
  return function(xf) {
    return new XReduceBy(valueFn, valueAcc, keyFn, xf);
  };
}

// node_modules/ramda/es/reduceBy.js
var reduceBy = _curryN(4, [], _dispatchable([], _xreduceBy, function reduceBy2(valueFn, valueAcc, keyFn, list4) {
  var xf = _xwrap(function(acc, elt) {
    var key57 = keyFn(elt);
    var value = valueFn(_has(key57, acc) ? acc[key57] : _clone(valueAcc, false), elt);
    if (value && value["@@transducer/reduced"]) {
      return _reduced(acc);
    }
    acc[key57] = value;
    return acc;
  });
  return xReduce_default(xf, {}, list4);
}));
var reduceBy_default = reduceBy;

// node_modules/ramda/es/countBy.js
var countBy = reduceBy_default(function(acc, elem) {
  return acc + 1;
}, 0);

// node_modules/ramda/es/dec.js
var dec = add_default(-1);

// node_modules/ramda/es/defaultTo.js
var defaultTo = _curry2(function defaultTo2(d2, v2) {
  return v2 == null || v2 !== v2 ? d2 : v2;
});
var defaultTo_default = defaultTo;

// node_modules/ramda/es/descend.js
var descend = _curry3(function descend2(fn2, a2, b) {
  var aa2 = fn2(a2);
  var bb = fn2(b);
  return aa2 > bb ? -1 : aa2 < bb ? 1 : 0;
});

// node_modules/ramda/es/descendNatural.js
var descendNatural = curry_default(function descendNatural2(locales, fn2, a2, b) {
  const aa2 = fn2(a2);
  const bb = fn2(b);
  return bb.localeCompare(aa2, locales, {
    numeric: true
  });
});

// node_modules/ramda/es/internal/_Set.js
var _Set = function() {
  function _Set2() {
    this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
    this._items = {};
  }
  _Set2.prototype.add = function(item) {
    return !hasOrAdd(item, true, this);
  };
  _Set2.prototype.has = function(item) {
    return hasOrAdd(item, false, this);
  };
  return _Set2;
}();
function hasOrAdd(item, shouldAdd, set4) {
  var type5 = typeof item;
  var prevSize, newSize;
  switch (type5) {
    case "string":
    case "number":
      if (item === 0 && 1 / item === -Infinity) {
        if (set4._items["-0"]) {
          return true;
        } else {
          if (shouldAdd) {
            set4._items["-0"] = true;
          }
          return false;
        }
      }
      if (set4._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set4._nativeSet.size;
          set4._nativeSet.add(item);
          newSize = set4._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set4._nativeSet.has(item);
        }
      } else {
        if (!(type5 in set4._items)) {
          if (shouldAdd) {
            set4._items[type5] = {};
            set4._items[type5][item] = true;
          }
          return false;
        } else if (item in set4._items[type5]) {
          return true;
        } else {
          if (shouldAdd) {
            set4._items[type5][item] = true;
          }
          return false;
        }
      }
    case "boolean":
      if (type5 in set4._items) {
        var bIdx = item ? 1 : 0;
        if (set4._items[type5][bIdx]) {
          return true;
        } else {
          if (shouldAdd) {
            set4._items[type5][bIdx] = true;
          }
          return false;
        }
      } else {
        if (shouldAdd) {
          set4._items[type5] = item ? [false, true] : [true, false];
        }
        return false;
      }
    case "function":
      if (set4._nativeSet !== null) {
        if (shouldAdd) {
          prevSize = set4._nativeSet.size;
          set4._nativeSet.add(item);
          newSize = set4._nativeSet.size;
          return newSize === prevSize;
        } else {
          return set4._nativeSet.has(item);
        }
      } else {
        if (!(type5 in set4._items)) {
          if (shouldAdd) {
            set4._items[type5] = [item];
          }
          return false;
        }
        if (!_includes(item, set4._items[type5])) {
          if (shouldAdd) {
            set4._items[type5].push(item);
          }
          return false;
        }
        return true;
      }
    case "undefined":
      if (set4._items[type5]) {
        return true;
      } else {
        if (shouldAdd) {
          set4._items[type5] = true;
        }
        return false;
      }
    case "object":
      if (item === null) {
        if (!set4._items["null"]) {
          if (shouldAdd) {
            set4._items["null"] = true;
          }
          return false;
        }
        return true;
      }
    default:
      type5 = Object.prototype.toString.call(item);
      if (!(type5 in set4._items)) {
        if (shouldAdd) {
          set4._items[type5] = [item];
        }
        return false;
      }
      if (!_includes(item, set4._items[type5])) {
        if (shouldAdd) {
          set4._items[type5].push(item);
        }
        return false;
      }
      return true;
  }
}
var Set_default = _Set;

// node_modules/ramda/es/difference.js
var difference = _curry2(function difference2(first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  var secondLen = second.length;
  var toFilterOut = new Set_default();
  for (var i2 = 0; i2 < secondLen; i2 += 1) {
    toFilterOut.add(second[i2]);
  }
  while (idx < firstLen) {
    if (toFilterOut.add(first[idx])) {
      out[out.length] = first[idx];
    }
    idx += 1;
  }
  return out;
});
var difference_default = difference;

// node_modules/ramda/es/differenceWith.js
var differenceWith = _curry3(function differenceWith2(pred, first, second) {
  var out = [];
  var idx = 0;
  var firstLen = first.length;
  while (idx < firstLen) {
    if (!_includesWith(pred, first[idx], second) && !_includesWith(pred, first[idx], out)) {
      out.push(first[idx]);
    }
    idx += 1;
  }
  return out;
});
var differenceWith_default = differenceWith;

// node_modules/ramda/es/remove.js
var remove2 = _curry3(function remove3(start, count2, list4) {
  var result = Array.prototype.slice.call(list4, 0);
  result.splice(start, count2);
  return result;
});
var remove_default = remove2;

// node_modules/ramda/es/internal/_dissoc.js
function _dissoc(prop3, obj) {
  if (obj == null) {
    return obj;
  }
  if (isInteger_default(prop3) && isArray_default(obj)) {
    return remove_default(prop3, 1, obj);
  }
  var result = {};
  for (var p2 in obj) {
    result[p2] = obj[p2];
  }
  delete result[prop3];
  return result;
}

// node_modules/ramda/es/dissocPath.js
function _shallowCloneObject(prop3, obj) {
  if (isInteger_default(prop3) && isArray_default(obj)) {
    return [].concat(obj);
  }
  var result = {};
  for (var p2 in obj) {
    result[p2] = obj[p2];
  }
  return result;
}
var dissocPath = _curry2(function dissocPath2(path4, obj) {
  if (obj == null) {
    return obj;
  }
  switch (path4.length) {
    case 0:
      return obj;
    case 1:
      return _dissoc(path4[0], obj);
    default:
      var head2 = path4[0];
      var tail2 = Array.prototype.slice.call(path4, 1);
      if (obj[head2] == null) {
        return _shallowCloneObject(head2, obj);
      } else {
        return assoc_default(head2, dissocPath2(tail2, obj[head2]), obj);
      }
  }
});
var dissocPath_default = dissocPath;

// node_modules/ramda/es/dissoc.js
var dissoc = _curry2(function dissoc2(prop3, obj) {
  return dissocPath_default([prop3], obj);
});

// node_modules/ramda/es/divide.js
var divide = _curry2(function divide2(a2, b) {
  return a2 / b;
});
var divide_default = divide;

// node_modules/ramda/es/internal/_xdrop.js
var XDrop = function() {
  function XDrop2(n, xf) {
    this.xf = xf;
    this.n = n;
  }
  XDrop2.prototype["@@transducer/init"] = xfBase_default.init;
  XDrop2.prototype["@@transducer/result"] = xfBase_default.result;
  XDrop2.prototype["@@transducer/step"] = function(result, input) {
    if (this.n > 0) {
      this.n -= 1;
      return result;
    }
    return this.xf["@@transducer/step"](result, input);
  };
  return XDrop2;
}();
function _xdrop(n) {
  return function(xf) {
    return new XDrop(n, xf);
  };
}

// node_modules/ramda/es/drop.js
var drop = _curry2(_dispatchable(["drop"], _xdrop, function drop2(n, xs2) {
  return slice_default(Math.max(0, n), Infinity, xs2);
}));
var drop_default = drop;

// node_modules/ramda/es/internal/_xtake.js
var XTake = function() {
  function XTake2(n, xf) {
    this.xf = xf;
    this.n = n;
    this.i = 0;
  }
  XTake2.prototype["@@transducer/init"] = xfBase_default.init;
  XTake2.prototype["@@transducer/result"] = xfBase_default.result;
  XTake2.prototype["@@transducer/step"] = function(result, input) {
    this.i += 1;
    var ret = this.n === 0 ? result : this.xf["@@transducer/step"](result, input);
    return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
  };
  return XTake2;
}();
function _xtake(n) {
  return function(xf) {
    return new XTake(n, xf);
  };
}

// node_modules/ramda/es/take.js
var take = _curry2(_dispatchable(["take"], _xtake, function take2(n, xs2) {
  return slice_default(0, n < 0 ? Infinity : n, xs2);
}));
var take_default = take;

// node_modules/ramda/es/internal/_dropLast.js
function dropLast(n, xs2) {
  return take_default(n < xs2.length ? xs2.length - n : 0, xs2);
}

// node_modules/ramda/es/internal/_xdropLast.js
var XDropLast = function() {
  function XDropLast2(n, xf) {
    if (n <= 0) {
      return xf;
    }
    this.xf = xf;
    this.pos = 0;
    this.full = false;
    this.acc = new Array(n);
  }
  XDropLast2.prototype["@@transducer/init"] = xfBase_default.init;
  XDropLast2.prototype["@@transducer/result"] = function(result) {
    this.acc = null;
    return this.xf["@@transducer/result"](result);
  };
  XDropLast2.prototype["@@transducer/step"] = function(result, input) {
    if (this.full) {
      result = this.xf["@@transducer/step"](result, this.acc[this.pos]);
    }
    this.store(input);
    return result;
  };
  XDropLast2.prototype.store = function(input) {
    this.acc[this.pos] = input;
    this.pos += 1;
    if (this.pos === this.acc.length) {
      this.pos = 0;
      this.full = true;
    }
  };
  return XDropLast2;
}();
function _xdropLast(n) {
  return function(xf) {
    return new XDropLast(n, xf);
  };
}

// node_modules/ramda/es/dropLast.js
var dropLast2 = _curry2(_dispatchable([], _xdropLast, dropLast));

// node_modules/ramda/es/internal/_dropLastWhile.js
function dropLastWhile(pred, xs2) {
  var idx = xs2.length - 1;
  while (idx >= 0 && pred(xs2[idx])) {
    idx -= 1;
  }
  return slice_default(0, idx + 1, xs2);
}

// node_modules/ramda/es/internal/_xdropLastWhile.js
var XDropLastWhile = function() {
  function XDropLastWhile2(fn2, xf) {
    this.f = fn2;
    this.retained = [];
    this.xf = xf;
  }
  XDropLastWhile2.prototype["@@transducer/init"] = xfBase_default.init;
  XDropLastWhile2.prototype["@@transducer/result"] = function(result) {
    this.retained = null;
    return this.xf["@@transducer/result"](result);
  };
  XDropLastWhile2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.retain(result, input) : this.flush(result, input);
  };
  XDropLastWhile2.prototype.flush = function(result, input) {
    result = xReduce_default(this.xf, result, this.retained);
    this.retained = [];
    return this.xf["@@transducer/step"](result, input);
  };
  XDropLastWhile2.prototype.retain = function(result, input) {
    this.retained.push(input);
    return result;
  };
  return XDropLastWhile2;
}();
function _xdropLastWhile(fn2) {
  return function(xf) {
    return new XDropLastWhile(fn2, xf);
  };
}

// node_modules/ramda/es/dropLastWhile.js
var dropLastWhile2 = _curry2(_dispatchable([], _xdropLastWhile, dropLastWhile));
var dropLastWhile_default = dropLastWhile2;

// node_modules/ramda/es/internal/_xdropRepeatsWith.js
var XDropRepeatsWith = function() {
  function XDropRepeatsWith2(pred, xf) {
    this.xf = xf;
    this.pred = pred;
    this.lastValue = void 0;
    this.seenFirstValue = false;
  }
  XDropRepeatsWith2.prototype["@@transducer/init"] = xfBase_default.init;
  XDropRepeatsWith2.prototype["@@transducer/result"] = xfBase_default.result;
  XDropRepeatsWith2.prototype["@@transducer/step"] = function(result, input) {
    var sameAsLast = false;
    if (!this.seenFirstValue) {
      this.seenFirstValue = true;
    } else if (this.pred(this.lastValue, input)) {
      sameAsLast = true;
    }
    this.lastValue = input;
    return sameAsLast ? result : this.xf["@@transducer/step"](result, input);
  };
  return XDropRepeatsWith2;
}();
function _xdropRepeatsWith(pred) {
  return function(xf) {
    return new XDropRepeatsWith(pred, xf);
  };
}

// node_modules/ramda/es/last.js
var last = _curry1(function(list4) {
  return _nth(-1, list4);
});
var last_default = last;

// node_modules/ramda/es/dropRepeatsWith.js
var dropRepeatsWith = _curry2(_dispatchable([], _xdropRepeatsWith, function dropRepeatsWith2(pred, list4) {
  var result = [];
  var idx = 1;
  var len = list4.length;
  if (len !== 0) {
    result[0] = list4[0];
    while (idx < len) {
      if (!pred(last_default(result), list4[idx])) {
        result[result.length] = list4[idx];
      }
      idx += 1;
    }
  }
  return result;
}));
var dropRepeatsWith_default = dropRepeatsWith;

// node_modules/ramda/es/dropRepeats.js
var dropRepeats = _curry1(_dispatchable([], function() {
  return _xdropRepeatsWith(equals_default);
}, dropRepeatsWith_default(equals_default)));

// node_modules/ramda/es/eqBy.js
var eqBy = _curry3(function eqBy2(f2, x2, y2) {
  return equals_default(f2(x2), f2(y2));
});
var eqBy_default = eqBy;

// node_modules/ramda/es/dropRepeatsBy.js
var dropRepeatsBy = _curry2(function(fn2, list4) {
  return _dispatchable([], function() {
    return _xdropRepeatsWith(eqBy_default(fn2));
  }, dropRepeatsWith_default(eqBy_default(fn2)))(list4);
});

// node_modules/ramda/es/internal/_xdropWhile.js
var XDropWhile = function() {
  function XDropWhile2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XDropWhile2.prototype["@@transducer/init"] = xfBase_default.init;
  XDropWhile2.prototype["@@transducer/result"] = xfBase_default.result;
  XDropWhile2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f) {
      if (this.f(input)) {
        return result;
      }
      this.f = null;
    }
    return this.xf["@@transducer/step"](result, input);
  };
  return XDropWhile2;
}();
function _xdropWhile(f2) {
  return function(xf) {
    return new XDropWhile(f2, xf);
  };
}

// node_modules/ramda/es/dropWhile.js
var dropWhile = _curry2(_dispatchable(["dropWhile"], _xdropWhile, function dropWhile2(pred, xs2) {
  var idx = 0;
  var len = xs2.length;
  while (idx < len && pred(xs2[idx])) {
    idx += 1;
  }
  return slice_default(idx, Infinity, xs2);
}));
var dropWhile_default = dropWhile;

// node_modules/ramda/es/or.js
var or = _curry2(function or2(a2, b) {
  return a2 || b;
});
var or_default = or;

// node_modules/ramda/es/either.js
var either = _curry2(function either2(f2, g2) {
  return _isFunction(f2) ? function _either() {
    return f2.apply(this, arguments) || g2.apply(this, arguments);
  } : lift_default(or_default)(f2, g2);
});
var either_default = either;

// node_modules/ramda/es/internal/_isTypedArray.js
function _isTypedArray(val) {
  var type5 = Object.prototype.toString.call(val);
  return type5 === "[object Uint8ClampedArray]" || type5 === "[object Int8Array]" || type5 === "[object Uint8Array]" || type5 === "[object Int16Array]" || type5 === "[object Uint16Array]" || type5 === "[object Int32Array]" || type5 === "[object Uint32Array]" || type5 === "[object Float32Array]" || type5 === "[object Float64Array]" || type5 === "[object BigInt64Array]" || type5 === "[object BigUint64Array]";
}

// node_modules/ramda/es/empty.js
var empty = _curry1(function empty2(x2) {
  return x2 != null && typeof x2["fantasy-land/empty"] === "function" ? x2["fantasy-land/empty"]() : x2 != null && x2.constructor != null && typeof x2.constructor["fantasy-land/empty"] === "function" ? x2.constructor["fantasy-land/empty"]() : x2 != null && typeof x2.empty === "function" ? x2.empty() : x2 != null && x2.constructor != null && typeof x2.constructor.empty === "function" ? x2.constructor.empty() : isArray_default(x2) ? [] : _isString(x2) ? "" : _isObject(x2) ? {} : isArguments_default(x2) ? /* @__PURE__ */ function() {
    return arguments;
  }() : _isTypedArray(x2) ? x2.constructor.from("") : void 0;
});
var empty_default = empty;

// node_modules/ramda/es/takeLast.js
var takeLast = _curry2(function takeLast2(n, xs2) {
  return drop_default(n >= 0 ? xs2.length - n : 0, xs2);
});
var takeLast_default = takeLast;

// node_modules/ramda/es/endsWith.js
var endsWith = _curry2(function(suffix, list4) {
  return equals_default(takeLast_default(suffix.length, list4), suffix);
});

// node_modules/ramda/es/eqProps.js
var eqProps = _curry3(function eqProps2(prop3, obj1, obj2) {
  return equals_default(obj1[prop3], obj2[prop3]);
});

// node_modules/ramda/es/evolve.js
var evolve = _curry2(function evolve2(transformations, object2) {
  if (!_isObject(object2) && !isArray_default(object2)) {
    return object2;
  }
  var result = object2 instanceof Array ? [] : {};
  var transformation, key57, type5;
  for (key57 in object2) {
    transformation = transformations[key57];
    type5 = typeof transformation;
    result[key57] = type5 === "function" ? transformation(object2[key57]) : transformation && type5 === "object" ? evolve2(transformation, object2[key57]) : object2[key57];
  }
  return result;
});

// node_modules/ramda/es/internal/_xfind.js
var XFind = function() {
  function XFind2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.found = false;
  }
  XFind2.prototype["@@transducer/init"] = xfBase_default.init;
  XFind2.prototype["@@transducer/result"] = function(result) {
    if (!this.found) {
      result = this.xf["@@transducer/step"](result, void 0);
    }
    return this.xf["@@transducer/result"](result);
  };
  XFind2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf["@@transducer/step"](result, input));
    }
    return result;
  };
  return XFind2;
}();
function _xfind(f2) {
  return function(xf) {
    return new XFind(f2, xf);
  };
}

// node_modules/ramda/es/find.js
var find = _curry2(_dispatchable(["find"], _xfind, function find2(fn2, list4) {
  var idx = 0;
  var len = list4.length;
  while (idx < len) {
    if (fn2(list4[idx])) {
      return list4[idx];
    }
    idx += 1;
  }
}));
var find_default = find;

// node_modules/ramda/es/internal/_xfindIndex.js
var XFindIndex = function() {
  function XFindIndex2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.idx = -1;
    this.found = false;
  }
  XFindIndex2.prototype["@@transducer/init"] = xfBase_default.init;
  XFindIndex2.prototype["@@transducer/result"] = function(result) {
    if (!this.found) {
      result = this.xf["@@transducer/step"](result, -1);
    }
    return this.xf["@@transducer/result"](result);
  };
  XFindIndex2.prototype["@@transducer/step"] = function(result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.found = true;
      result = _reduced(this.xf["@@transducer/step"](result, this.idx));
    }
    return result;
  };
  return XFindIndex2;
}();
function _xfindIndex(f2) {
  return function(xf) {
    return new XFindIndex(f2, xf);
  };
}

// node_modules/ramda/es/findIndex.js
var findIndex = _curry2(_dispatchable([], _xfindIndex, function findIndex2(fn2, list4) {
  var idx = 0;
  var len = list4.length;
  while (idx < len) {
    if (fn2(list4[idx])) {
      return idx;
    }
    idx += 1;
  }
  return -1;
}));

// node_modules/ramda/es/internal/_xfindLast.js
var XFindLast = function() {
  function XFindLast2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XFindLast2.prototype["@@transducer/init"] = xfBase_default.init;
  XFindLast2.prototype["@@transducer/result"] = function(result) {
    return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.last));
  };
  XFindLast2.prototype["@@transducer/step"] = function(result, input) {
    if (this.f(input)) {
      this.last = input;
    }
    return result;
  };
  return XFindLast2;
}();
function _xfindLast(f2) {
  return function(xf) {
    return new XFindLast(f2, xf);
  };
}

// node_modules/ramda/es/findLast.js
var findLast = _curry2(_dispatchable([], _xfindLast, function findLast2(fn2, list4) {
  var idx = list4.length - 1;
  while (idx >= 0) {
    if (fn2(list4[idx])) {
      return list4[idx];
    }
    idx -= 1;
  }
}));

// node_modules/ramda/es/internal/_xfindLastIndex.js
var XFindLastIndex = function() {
  function XFindLastIndex2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.idx = -1;
    this.lastIdx = -1;
  }
  XFindLastIndex2.prototype["@@transducer/init"] = xfBase_default.init;
  XFindLastIndex2.prototype["@@transducer/result"] = function(result) {
    return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.lastIdx));
  };
  XFindLastIndex2.prototype["@@transducer/step"] = function(result, input) {
    this.idx += 1;
    if (this.f(input)) {
      this.lastIdx = this.idx;
    }
    return result;
  };
  return XFindLastIndex2;
}();
function _xfindLastIndex(f2) {
  return function(xf) {
    return new XFindLastIndex(f2, xf);
  };
}

// node_modules/ramda/es/findLastIndex.js
var findLastIndex = _curry2(_dispatchable([], _xfindLastIndex, function findLastIndex2(fn2, list4) {
  var idx = list4.length - 1;
  while (idx >= 0) {
    if (fn2(list4[idx])) {
      return idx;
    }
    idx -= 1;
  }
  return -1;
}));

// node_modules/ramda/es/flatten.js
var flatten2 = _curry1(_makeFlat(true));

// node_modules/ramda/es/flip.js
var flip = _curry1(function flip2(fn2) {
  return curryN_default(fn2.length, function(a2, b) {
    var args = Array.prototype.slice.call(arguments, 0);
    args[0] = b;
    args[1] = a2;
    return fn2.apply(this, args);
  });
});
var flip_default = flip;

// node_modules/ramda/es/flow.js
var flow = _curry2(function flow2(seed, pipeline) {
  return reduce_default2(applyTo_default, seed, pipeline);
});

// node_modules/ramda/es/forEach.js
var forEach2 = _curry2(_checkForMethod("forEach", function forEach3(fn2, list4) {
  var len = list4.length;
  var idx = 0;
  while (idx < len) {
    fn2(list4[idx]);
    idx += 1;
  }
  return list4;
}));

// node_modules/ramda/es/forEachObjIndexed.js
var forEachObjIndexed = _curry2(function forEachObjIndexed2(fn2, obj) {
  var keyList = keys_default(obj);
  var idx = 0;
  while (idx < keyList.length) {
    var key57 = keyList[idx];
    fn2(obj[key57], key57, obj);
    idx += 1;
  }
  return obj;
});

// node_modules/ramda/es/fromPairs.js
var fromPairs = _curry1(function fromPairs2(pairs2) {
  var result = {};
  var idx = 0;
  while (idx < pairs2.length) {
    result[pairs2[idx][0]] = pairs2[idx][1];
    idx += 1;
  }
  return result;
});
var fromPairs_default = fromPairs;

// node_modules/ramda/es/groupBy.js
var groupBy = _curry2(_checkForMethod("groupBy", reduceBy_default(function(acc, item) {
  acc.push(item);
  return acc;
}, [])));
var groupBy_default = groupBy;

// node_modules/ramda/es/groupWith.js
var groupWith = _curry2(function(fn2, list4) {
  var res = [];
  var idx = 0;
  var len = list4.length;
  while (idx < len) {
    var nextidx = idx + 1;
    while (nextidx < len && fn2(list4[nextidx - 1], list4[nextidx])) {
      nextidx += 1;
    }
    res.push(list4.slice(idx, nextidx));
    idx = nextidx;
  }
  return res;
});

// node_modules/ramda/es/gt.js
var gt = _curry2(function gt2(a2, b) {
  return a2 > b;
});
var gt_default = gt;

// node_modules/ramda/es/gte.js
var gte = _curry2(function gte2(a2, b) {
  return a2 >= b;
});
var gte_default = gte;

// node_modules/ramda/es/hasPath.js
var hasPath = _curry2(function hasPath2(_path2, obj) {
  if (_path2.length === 0 || isNil_default(obj)) {
    return false;
  }
  var val = obj;
  var idx = 0;
  while (idx < _path2.length) {
    if (!isNil_default(val) && _has(_path2[idx], val)) {
      val = val[_path2[idx]];
      idx += 1;
    } else {
      return false;
    }
  }
  return true;
});
var hasPath_default = hasPath;

// node_modules/ramda/es/has.js
var has = _curry2(function has2(prop3, obj) {
  return hasPath_default([prop3], obj);
});
var has_default = has;

// node_modules/ramda/es/hasIn.js
var hasIn = _curry2(function hasIn2(prop3, obj) {
  if (isNil_default(obj)) {
    return false;
  }
  return prop3 in obj;
});
var hasIn_default = hasIn;

// node_modules/ramda/es/identical.js
var identical = function(a2, b) {
  switch (arguments.length) {
    case 0:
      return identical;
    case 1:
      return /* @__PURE__ */ function() {
        return function unaryIdentical(_b) {
          switch (arguments.length) {
            case 0:
              return unaryIdentical;
            default:
              return objectIs_default(a2, _b);
          }
        };
      }();
    default:
      return objectIs_default(a2, b);
  }
};
var identical_default = identical;

// node_modules/ramda/es/ifElse.js
var ifElse = _curry3(function ifElse2(condition, onTrue, onFalse) {
  return curryN_default(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
    return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
  });
});
var ifElse_default = ifElse;

// node_modules/ramda/es/inc.js
var inc = add_default(1);

// node_modules/ramda/es/includes.js
var includes = _curry2(_includes);
var includes_default = includes;

// node_modules/ramda/es/indexBy.js
var indexBy = reduceBy_default(function(acc, elem) {
  return elem;
}, null);

// node_modules/ramda/es/indexOf.js
var indexOf = _curry2(function indexOf2(target, xs2) {
  return typeof xs2.indexOf === "function" && !isArray_default(xs2) ? xs2.indexOf(target) : _indexOf(xs2, target, 0);
});

// node_modules/ramda/es/init.js
var init = slice_default(0, -1);
var init_default = init;

// node_modules/ramda/es/innerJoin.js
var innerJoin = _curry3(function innerJoin2(pred, xs2, ys2) {
  return _filter(function(x2) {
    return _includesWith(pred, x2, ys2);
  }, xs2);
});

// node_modules/ramda/es/insert.js
var insert = _curry3(function insert2(idx, elt, list4) {
  idx = idx < list4.length && idx >= 0 ? idx : list4.length;
  var result = Array.prototype.slice.call(list4, 0);
  result.splice(idx, 0, elt);
  return result;
});
var insert_default = insert;

// node_modules/ramda/es/insertAll.js
var insertAll = _curry3(function insertAll2(idx, elts, list4) {
  idx = idx < list4.length && idx >= 0 ? idx : list4.length;
  return [].concat(Array.prototype.slice.call(list4, 0, idx), elts, Array.prototype.slice.call(list4, idx));
});

// node_modules/ramda/es/internal/_xuniqBy.js
var XUniqBy = function() {
  function XUniqBy2(f2, xf) {
    this.xf = xf;
    this.f = f2;
    this.set = new Set_default();
  }
  XUniqBy2.prototype["@@transducer/init"] = xfBase_default.init;
  XUniqBy2.prototype["@@transducer/result"] = xfBase_default.result;
  XUniqBy2.prototype["@@transducer/step"] = function(result, input) {
    return this.set.add(this.f(input)) ? this.xf["@@transducer/step"](result, input) : result;
  };
  return XUniqBy2;
}();
function _xuniqBy(f2) {
  return function(xf) {
    return new XUniqBy(f2, xf);
  };
}

// node_modules/ramda/es/uniqBy.js
var uniqBy = _curry2(_dispatchable([], _xuniqBy, function(fn2, list4) {
  var set4 = new Set_default();
  var result = [];
  var idx = 0;
  var appliedItem, item;
  while (idx < list4.length) {
    item = list4[idx];
    appliedItem = fn2(item);
    if (set4.add(appliedItem)) {
      result.push(item);
    }
    idx += 1;
  }
  return result;
}));
var uniqBy_default = uniqBy;

// node_modules/ramda/es/uniq.js
var uniq = uniqBy_default(identity_default);
var uniq_default = uniq;

// node_modules/ramda/es/intersection.js
var intersection = _curry2(function intersection2(list1, list22) {
  var toKeep = new Set_default();
  for (var i2 = 0; i2 < list1.length; i2 += 1) {
    toKeep.add(list1[i2]);
  }
  return uniq_default(_filter(toKeep.has.bind(toKeep), list22));
});
var intersection_default = intersection;

// node_modules/ramda/es/intersperse.js
var intersperse = _curry2(_checkForMethod("intersperse", function _intersperse(separator, list4) {
  var length3 = list4.length;
  if (length3 === 0) {
    return [];
  }
  var out = Array(length3 * 2 - 1);
  var idx = 0;
  while (idx < length3) {
    var i2 = idx * 2;
    if (idx === length3 - 1) {
      out[i2] = list4[idx];
    } else {
      out[i2] = list4[idx];
      out[i2 + 1] = separator;
    }
    idx += 1;
  }
  return out;
}));

// node_modules/ramda/es/internal/_objectAssign.js
function _objectAssign(target) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }
  var output = Object(target);
  var idx = 1;
  var length3 = arguments.length;
  while (idx < length3) {
    var source = arguments[idx];
    if (source != null) {
      for (var nextKey in source) {
        if (_has(nextKey, source)) {
          output[nextKey] = source[nextKey];
        }
      }
    }
    idx += 1;
  }
  return output;
}
var objectAssign_default = typeof Object.assign === "function" ? Object.assign : _objectAssign;

// node_modules/ramda/es/objOf.js
var objOf = _curry2(function objOf2(key57, val) {
  var obj = {};
  obj[key57] = val;
  return obj;
});
var objOf_default = objOf;

// node_modules/ramda/es/internal/_stepCat.js
var _stepCatArray = {
  "@@transducer/init": Array,
  "@@transducer/step": function(xs2, x2) {
    xs2.push(x2);
    return xs2;
  },
  "@@transducer/result": _identity
};
var _stepCatString = {
  "@@transducer/init": String,
  "@@transducer/step": function(a2, b) {
    return a2 + b;
  },
  "@@transducer/result": _identity
};
var _stepCatObject = {
  "@@transducer/init": Object,
  "@@transducer/step": function(result, input) {
    return objectAssign_default(result, isArrayLike_default(input) ? objOf_default(input[0], input[1]) : input);
  },
  "@@transducer/result": _identity
};
function _stepCat(obj) {
  if (_isTransformer(obj)) {
    return obj;
  }
  if (isArrayLike_default(obj)) {
    return _stepCatArray;
  }
  if (typeof obj === "string") {
    return _stepCatString;
  }
  if (typeof obj === "object") {
    return _stepCatObject;
  }
  throw new Error("Cannot create transformer for " + obj);
}

// node_modules/ramda/es/into.js
var into = _curry3(function into2(acc, transducer, list4) {
  var xf = transducer(_isTransformer(acc) ? acc : _stepCat(acc));
  return xReduce_default(xf, xf["@@transducer/init"](), list4);
});

// node_modules/ramda/es/invert.js
var invert = _curry1(function invert2(obj) {
  var props3 = keys_default(obj);
  var len = props3.length;
  var idx = 0;
  var out = {};
  while (idx < len) {
    var key57 = props3[idx];
    var val = obj[key57];
    var list4 = _has(val, out) ? out[val] : out[val] = [];
    list4[list4.length] = key57;
    idx += 1;
  }
  return out;
});

// node_modules/ramda/es/invertObj.js
var invertObj = _curry1(function invertObj2(obj) {
  var props3 = keys_default(obj);
  var len = props3.length;
  var idx = 0;
  var out = {};
  while (idx < len) {
    var key57 = props3[idx];
    out[obj[key57]] = key57;
    idx += 1;
  }
  return out;
});

// node_modules/ramda/es/invoker.js
var invoker = _curry2(function invoker2(arity, method) {
  return curryN_default(arity + 1, function() {
    var target = arguments[arity];
    if (target != null && _isFunction(target[method])) {
      return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
    }
    throw new TypeError(toString_default(target) + ' does not have a method named "' + method + '"');
  });
});
var invoker_default = invoker;

// node_modules/ramda/es/is.js
var is2 = _curry2(function is3(Ctor, val) {
  return val instanceof Ctor || val != null && (val.constructor === Ctor || Ctor.name === "Object" && typeof val === "object");
});
var is_default = is2;

// node_modules/ramda/es/isEmpty.js
var isEmpty = _curry1(function isEmpty2(x2) {
  return x2 != null && equals_default(x2, empty_default(x2));
});
var isEmpty_default = isEmpty;

// node_modules/ramda/es/isNotEmpty.js
var isNotEmpty = _curry1(function isNotEmpty2(x2) {
  return !isEmpty_default(x2);
});
var isNotEmpty_default = isNotEmpty;

// node_modules/ramda/es/isNotNil.js
var isNotNil = _curry1(function isNotNil2(x2) {
  return !isNil_default(x2);
});

// node_modules/ramda/es/join.js
var join = invoker_default(1, "join");
var join_default = join;

// node_modules/ramda/es/juxt.js
var juxt = _curry1(function juxt2(fns) {
  return converge_default(function() {
    return Array.prototype.slice.call(arguments, 0);
  }, fns);
});
var juxt_default = juxt;

// node_modules/ramda/es/keysIn.js
var keysIn = _curry1(function keysIn2(obj) {
  var prop3;
  var ks2 = [];
  for (prop3 in obj) {
    ks2[ks2.length] = prop3;
  }
  return ks2;
});

// node_modules/ramda/es/lastIndexOf.js
var lastIndexOf = _curry2(function lastIndexOf2(target, xs2) {
  if (typeof xs2.lastIndexOf === "function" && !isArray_default(xs2)) {
    return xs2.lastIndexOf(target);
  } else {
    var idx = xs2.length - 1;
    while (idx >= 0) {
      if (equals_default(xs2[idx], target)) {
        return idx;
      }
      idx -= 1;
    }
    return -1;
  }
});

// node_modules/ramda/es/internal/_isNumber.js
function _isNumber(x2) {
  return Object.prototype.toString.call(x2) === "[object Number]";
}

// node_modules/ramda/es/length.js
var length = _curry1(function length2(list4) {
  return list4 != null && _isNumber(list4.length) ? list4.length : NaN;
});
var length_default = length;

// node_modules/ramda/es/lens.js
var lens = _curry2(function lens2(getter, setter) {
  return function(toFunctorFn) {
    return function(target) {
      return map_default(function(focus) {
        return setter(focus, target);
      }, toFunctorFn(getter(target)));
    };
  };
});
var lens_default = lens;

// node_modules/ramda/es/update.js
var update = _curry3(function update2(idx, x2, list4) {
  return adjust_default(idx, always_default(x2), list4);
});
var update_default = update;

// node_modules/ramda/es/lensIndex.js
var lensIndex = _curry1(function lensIndex2(n) {
  return lens_default(function(val) {
    return _nth(n, val);
  }, update_default(n));
});
var lensIndex_default = lensIndex;

// node_modules/ramda/es/internal/_path.js
function _path(pathAr, obj) {
  var val = obj;
  for (var i2 = 0; i2 < pathAr.length; i2 += 1) {
    if (val == null) {
      return void 0;
    }
    var p2 = pathAr[i2];
    if (isInteger_default(p2)) {
      val = _nth(p2, val);
    } else {
      val = val[p2];
    }
  }
  return val;
}

// node_modules/ramda/es/lensPath.js
var lensPath = _curry1(function lensPath2(p2) {
  return lens_default(function(val) {
    return _path(p2, val);
  }, assocPath_default(p2));
});
var lensPath_default = lensPath;

// node_modules/ramda/es/lensProp.js
var lensProp = _curry1(function lensProp2(k) {
  return lens_default(prop_default(k), assoc_default(k));
});

// node_modules/ramda/es/lt.js
var lt = _curry2(function lt2(a2, b) {
  return a2 < b;
});
var lt_default = lt;

// node_modules/ramda/es/lte.js
var lte = _curry2(function lte2(a2, b) {
  return a2 <= b;
});
var lte_default = lte;

// node_modules/ramda/es/mapAccum.js
var mapAccum = _curry3(function mapAccum2(fn2, acc, list4) {
  var idx = 0;
  var len = list4.length;
  var result = Array(len);
  var tuple = [acc];
  while (idx < len) {
    tuple = fn2(tuple[0], list4[idx]);
    result[idx] = tuple[1];
    idx += 1;
  }
  return [tuple[0], result];
});

// node_modules/ramda/es/mapAccumRight.js
var mapAccumRight = _curry3(function mapAccumRight2(fn2, acc, list4) {
  var idx = list4.length - 1;
  var result = Array(list4.length);
  var tuple = [acc];
  while (idx >= 0) {
    tuple = fn2(tuple[0], list4[idx]);
    result[idx] = tuple[1];
    idx -= 1;
  }
  return [tuple[0], result];
});

// node_modules/ramda/es/mapObjIndexed.js
var mapObjIndexed = _curry2(function mapObjIndexed2(fn2, obj) {
  return _arrayReduce(function(acc, key57) {
    acc[key57] = fn2(obj[key57], key57, obj);
    return acc;
  }, {}, keys_default(obj));
});
var mapObjIndexed_default = mapObjIndexed;

// node_modules/ramda/es/match.js
var match = _curry2(function match2(rx, str2) {
  return str2.match(rx) || [];
});

// node_modules/ramda/es/mathMod.js
var mathMod = _curry2(function mathMod2(m2, p2) {
  if (!isInteger_default(m2)) {
    return NaN;
  }
  if (!isInteger_default(p2) || p2 < 1) {
    return NaN;
  }
  return (m2 % p2 + p2) % p2;
});

// node_modules/ramda/es/maxBy.js
var maxBy = _curry3(function maxBy2(f2, a2, b) {
  var resultB = f2(b);
  return max_default(f2(a2), resultB) === resultB ? b : a2;
});

// node_modules/ramda/es/sum.js
var sum = reduce_default(add_default, 0);
var sum_default = sum;

// node_modules/ramda/es/mean.js
var mean = _curry1(function mean2(list4) {
  return sum_default(list4) / list4.length;
});
var mean_default = mean;

// node_modules/ramda/es/median.js
var median = _curry1(function median2(list4) {
  var len = list4.length;
  if (len === 0) {
    return NaN;
  }
  var width = 2 - len % 2;
  var idx = (len - width) / 2;
  return mean_default(Array.prototype.slice.call(list4, 0).sort(function(a2, b) {
    return a2 < b ? -1 : a2 > b ? 1 : 0;
  }).slice(idx, idx + width));
});

// node_modules/ramda/es/memoizeWith.js
var memoizeWith = _curry2(function memoizeWith2(keyGen, fn2) {
  var cache = {};
  return _arity(fn2.length, function() {
    var key57 = keyGen.apply(this, arguments);
    if (!_has(key57, cache)) {
      cache[key57] = fn2.apply(this, arguments);
    }
    return cache[key57];
  });
});

// node_modules/ramda/es/mergeAll.js
var mergeAll = _curry1(function mergeAll2(list4) {
  return objectAssign_default.apply(null, [{}].concat(list4));
});
var mergeAll_default = mergeAll;

// node_modules/ramda/es/mergeWithKey.js
var mergeWithKey = _curry3(function mergeWithKey2(fn2, l2, r2) {
  var result = {};
  var k;
  l2 = l2 || {};
  r2 = r2 || {};
  for (k in l2) {
    if (_has(k, l2)) {
      result[k] = _has(k, r2) ? fn2(k, l2[k], r2[k]) : l2[k];
    }
  }
  for (k in r2) {
    if (_has(k, r2) && !_has(k, result)) {
      result[k] = r2[k];
    }
  }
  return result;
});
var mergeWithKey_default = mergeWithKey;

// node_modules/ramda/es/mergeDeepWithKey.js
var mergeDeepWithKey = _curry3(function mergeDeepWithKey2(fn2, lObj, rObj) {
  return mergeWithKey_default(function(k, lVal, rVal) {
    if (_isObject(lVal) && _isObject(rVal)) {
      return mergeDeepWithKey2(fn2, lVal, rVal);
    } else {
      return fn2(k, lVal, rVal);
    }
  }, lObj, rObj);
});
var mergeDeepWithKey_default = mergeDeepWithKey;

// node_modules/ramda/es/mergeDeepLeft.js
var mergeDeepLeft = _curry2(function mergeDeepLeft2(lObj, rObj) {
  return mergeDeepWithKey_default(function(k, lVal, rVal) {
    return lVal;
  }, lObj, rObj);
});

// node_modules/ramda/es/mergeDeepRight.js
var mergeDeepRight = _curry2(function mergeDeepRight2(lObj, rObj) {
  return mergeDeepWithKey_default(function(k, lVal, rVal) {
    return rVal;
  }, lObj, rObj);
});
var mergeDeepRight_default = mergeDeepRight;

// node_modules/ramda/es/mergeDeepWith.js
var mergeDeepWith = _curry3(function mergeDeepWith2(fn2, lObj, rObj) {
  return mergeDeepWithKey_default(function(k, lVal, rVal) {
    return fn2(lVal, rVal);
  }, lObj, rObj);
});

// node_modules/ramda/es/mergeLeft.js
var mergeLeft = _curry2(function mergeLeft2(l2, r2) {
  return objectAssign_default({}, r2, l2);
});
var mergeLeft_default = mergeLeft;

// node_modules/ramda/es/mergeRight.js
var mergeRight = _curry2(function mergeRight2(l2, r2) {
  return objectAssign_default({}, l2, r2);
});
var mergeRight_default = mergeRight;

// node_modules/ramda/es/mergeWith.js
var mergeWith = _curry3(function mergeWith2(fn2, l2, r2) {
  return mergeWithKey_default(function(_2, _l, _r2) {
    return fn2(_l, _r2);
  }, l2, r2);
});

// node_modules/ramda/es/min.js
var min = _curry2(function min2(a2, b) {
  if (a2 === b) {
    return a2;
  }
  function safeMin(x2, y2) {
    if (x2 < y2 !== y2 < x2) {
      return y2 < x2 ? y2 : x2;
    }
    return void 0;
  }
  var minByValue = safeMin(a2, b);
  if (minByValue !== void 0) {
    return minByValue;
  }
  var minByType = safeMin(typeof a2, typeof b);
  if (minByType !== void 0) {
    return minByType === typeof a2 ? a2 : b;
  }
  var stringA = toString_default(a2);
  var minByStringValue = safeMin(stringA, toString_default(b));
  if (minByStringValue !== void 0) {
    return minByStringValue === stringA ? a2 : b;
  }
  return a2;
});
var min_default = min;

// node_modules/ramda/es/minBy.js
var minBy = _curry3(function minBy2(f2, a2, b) {
  var resultB = f2(b);
  return min_default(f2(a2), resultB) === resultB ? b : a2;
});

// node_modules/ramda/es/internal/_modify.js
function _modify(prop3, fn2, obj) {
  if (isInteger_default(prop3) && isArray_default(obj)) {
    var arr = [].concat(obj);
    arr[prop3] = fn2(arr[prop3]);
    return arr;
  }
  var result = {};
  for (var p2 in obj) {
    result[p2] = obj[p2];
  }
  result[prop3] = fn2(result[prop3]);
  return result;
}

// node_modules/ramda/es/modifyPath.js
var modifyPath = _curry3(function modifyPath2(path4, fn2, object2) {
  if (!_isObject(object2) && !isArray_default(object2)) {
    return object2;
  }
  if (path4.length === 0) {
    return fn2(object2);
  }
  var idx = path4[0];
  if (!_has(idx, object2)) {
    return object2;
  }
  if (path4.length === 1) {
    return _modify(idx, fn2, object2);
  }
  var val = modifyPath2(Array.prototype.slice.call(path4, 1), fn2, object2[idx]);
  if (val === object2[idx]) {
    return object2;
  }
  return _assoc(idx, val, object2);
});
var modifyPath_default = modifyPath;

// node_modules/ramda/es/modify.js
var modify = _curry3(function modify2(prop3, fn2, object2) {
  return modifyPath_default([prop3], fn2, object2);
});

// node_modules/ramda/es/modulo.js
var modulo = _curry2(function modulo2(a2, b) {
  return a2 % b;
});
var modulo_default = modulo;

// node_modules/ramda/es/move.js
var move = _curry3(function(from2, to2, list4) {
  var length3 = list4.length;
  var result = list4.slice();
  var positiveFrom = from2 < 0 ? length3 + from2 : from2;
  var positiveTo = to2 < 0 ? length3 + to2 : to2;
  var item = result.splice(positiveFrom, 1);
  return positiveFrom < 0 || positiveFrom >= list4.length || positiveTo < 0 || positiveTo >= list4.length ? list4 : [].concat(result.slice(0, positiveTo)).concat(item).concat(result.slice(positiveTo, list4.length));
});

// node_modules/ramda/es/multiply.js
var multiply = _curry2(function multiply2(a2, b) {
  return a2 * b;
});
var multiply_default = multiply;

// node_modules/ramda/es/partialObject.js
var partialObject = _curry2((f2, o4) => (props3) => f2.call(void 0, mergeDeepRight_default(o4, props3)));

// node_modules/ramda/es/negate.js
var negate = _curry1(function negate2(n) {
  return -n;
});

// node_modules/ramda/es/none.js
var none = _curry2(function none2(fn2, input) {
  return all_default(_complement(fn2), input);
});
var none_default = none;

// node_modules/ramda/es/nth.js
var nth = _curry2(_nth);
var nth_default = nth;

// node_modules/ramda/es/nthArg.js
var nthArg = _curry1(function nthArg2(n) {
  var arity = n < 0 ? 1 : n + 1;
  return curryN_default(arity, function() {
    return _nth(n, arguments);
  });
});
var nthArg_default = nthArg;

// node_modules/ramda/es/o.js
var o = _curry3(function o2(f2, g2, x2) {
  return f2(g2(x2));
});

// node_modules/ramda/es/of.js
var of = _curry2(function of2(Ctor, val) {
  return typeof Ctor["fantasy-land/of"] === "function" ? Ctor["fantasy-land/of"](val) : typeof Ctor.of === "function" ? Ctor.of(val) : [val];
});
var of_default = of;

// node_modules/ramda/es/omit.js
var omit = _curry2(function omit2(names, obj) {
  var result = {};
  var index = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    index[names[idx]] = 1;
    idx += 1;
  }
  for (var prop3 in obj) {
    if (!index.hasOwnProperty(prop3)) {
      result[prop3] = obj[prop3];
    }
  }
  return result;
});

// node_modules/ramda/es/on.js
var on = _curryN(4, [], function on2(f2, g2, a2, b) {
  return f2(g2(a2), g2(b));
});

// node_modules/ramda/es/once.js
var once = _curry1(function once2(fn2) {
  var called = false;
  var result;
  return _arity(fn2.length, function() {
    if (called) {
      return result;
    }
    called = true;
    result = fn2.apply(this, arguments);
    return result;
  });
});

// node_modules/ramda/es/internal/_assertPromise.js
function _assertPromise(name2, p2) {
  if (p2 == null || !_isFunction(p2.then)) {
    throw new TypeError("`" + name2 + "` expected a Promise, received " + _toString2(p2, []));
  }
}

// node_modules/ramda/es/otherwise.js
var otherwise = _curry2(function otherwise2(f2, p2) {
  _assertPromise("otherwise", p2);
  return p2.then(null, f2);
});

// node_modules/ramda/es/over.js
var Identity = function(x2) {
  return {
    value: x2,
    map: function(f2) {
      return Identity(f2(x2));
    }
  };
};
var over = _curry3(function over2(lens3, f2, x2) {
  return lens3(function(y2) {
    return Identity(f2(y2));
  })(x2).value;
});
var over_default = over;

// node_modules/ramda/es/pair.js
var pair = _curry2(function pair2(fst, snd) {
  return [fst, snd];
});

// node_modules/ramda/es/internal/_createPartialApplicator.js
function _createPartialApplicator(concat4) {
  return _curry2(function(fn2, args) {
    return _arity(Math.max(0, fn2.length - args.length), function() {
      return fn2.apply(this, concat4(args, arguments));
    });
  });
}

// node_modules/ramda/es/partial.js
var partial = _createPartialApplicator(_concat);
var partial_default = partial;

// node_modules/ramda/es/partialRight.js
var partialRight = _createPartialApplicator(flip_default(_concat));

// node_modules/ramda/es/partition.js
var partition = juxt_default([filter_default, reject_default]);

// node_modules/ramda/es/path.js
var path = _curry2(_path);
var path_default = path;

// node_modules/ramda/es/paths.js
var paths = _curry2(function paths2(pathsArray, obj) {
  return pathsArray.map(function(paths4) {
    var val = obj;
    var idx = 0;
    var p2;
    while (idx < paths4.length) {
      if (val == null) {
        return;
      }
      p2 = paths4[idx];
      val = isInteger_default(p2) ? _nth(p2, val) : val[p2];
      idx += 1;
    }
    return val;
  });
});

// node_modules/ramda/es/pathEq.js
var pathEq = _curry3(function pathEq2(val, pathAr, obj) {
  return equals_default(_path(pathAr, obj), val);
});
var pathEq_default = pathEq;

// node_modules/ramda/es/pathOr.js
var pathOr = _curry3(function pathOr2(d2, p2, obj) {
  return defaultTo_default(d2, _path(p2, obj));
});
var pathOr_default = pathOr;

// node_modules/ramda/es/pathSatisfies.js
var pathSatisfies = _curry3(function pathSatisfies2(pred, propPath, obj) {
  return pred(_path(propPath, obj));
});
var pathSatisfies_default = pathSatisfies;

// node_modules/ramda/es/pick.js
var pick = _curry2(function pick2(names, obj) {
  var result = {};
  var idx = 0;
  while (idx < names.length) {
    if (names[idx] in obj) {
      result[names[idx]] = obj[names[idx]];
    }
    idx += 1;
  }
  return result;
});
var pick_default = pick;

// node_modules/ramda/es/pickAll.js
var pickAll = _curry2(function pickAll2(names, obj) {
  var result = {};
  var idx = 0;
  var len = names.length;
  while (idx < len) {
    var name2 = names[idx];
    result[name2] = obj[name2];
    idx += 1;
  }
  return result;
});
var pickAll_default = pickAll;

// node_modules/ramda/es/pickBy.js
var pickBy = _curry2(function pickBy2(test4, obj) {
  var result = {};
  for (var prop3 in obj) {
    if (test4(obj[prop3], prop3, obj)) {
      result[prop3] = obj[prop3];
    }
  }
  return result;
});
var pickBy_default = pickBy;

// node_modules/ramda/es/prepend.js
var prepend = _curry2(function prepend2(el2, list4) {
  return _concat([el2], list4);
});
var prepend_default = prepend;

// node_modules/ramda/es/product.js
var product = reduce_default(multiply_default, 1);

// node_modules/ramda/es/useWith.js
var useWith = _curry2(function useWith2(fn2, transformers) {
  return curryN_default(transformers.length, function() {
    var args = [];
    var idx = 0;
    while (idx < transformers.length) {
      args.push(transformers[idx].call(this, arguments[idx]));
      idx += 1;
    }
    return fn2.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
  });
});
var useWith_default = useWith;

// node_modules/ramda/es/project.js
var project = useWith_default(_map, [pickAll_default, identity_default]);

// node_modules/ramda/es/internal/_promap.js
function _promap(f2, g2, profunctor) {
  return function(x2) {
    return g2(profunctor(f2(x2)));
  };
}

// node_modules/ramda/es/internal/_xpromap.js
var XPromap = function() {
  function XPromap2(f2, g2, xf) {
    this.xf = xf;
    this.f = f2;
    this.g = g2;
  }
  XPromap2.prototype["@@transducer/init"] = xfBase_default.init;
  XPromap2.prototype["@@transducer/result"] = xfBase_default.result;
  XPromap2.prototype["@@transducer/step"] = function(result, input) {
    return this.xf["@@transducer/step"](result, _promap(this.f, this.g, input));
  };
  return XPromap2;
}();
function _xpromap(f2, g2) {
  return function(xf) {
    return new XPromap(f2, g2, xf);
  };
}

// node_modules/ramda/es/promap.js
var promap = _curry3(_dispatchable(["fantasy-land/promap", "promap"], _xpromap, _promap));

// node_modules/ramda/es/propEq.js
var propEq = _curry3(function propEq2(val, name2, obj) {
  return equals_default(val, prop_default(name2, obj));
});
var propEq_default = propEq;

// node_modules/ramda/es/propIs.js
var propIs = _curry3(function propIs2(type5, name2, obj) {
  return is_default(type5, prop_default(name2, obj));
});

// node_modules/ramda/es/propOr.js
var propOr = _curry3(function propOr2(val, p2, obj) {
  return defaultTo_default(val, prop_default(p2, obj));
});
var propOr_default = propOr;

// node_modules/ramda/es/propSatisfies.js
var propSatisfies = _curry3(function propSatisfies2(pred, name2, obj) {
  return pred(prop_default(name2, obj));
});
var propSatisfies_default = propSatisfies;

// node_modules/ramda/es/props.js
var props = _curry2(function props2(ps2, obj) {
  return ps2.map(function(p2) {
    return prop_default(p2, obj);
  });
});
var props_default = props;

// node_modules/ramda/es/range.js
var range = _curry2(function range2(from2, to2) {
  if (!(_isNumber(from2) && _isNumber(to2))) {
    throw new TypeError("Both arguments to range must be numbers");
  }
  var result = Array(from2 < to2 ? to2 - from2 : 0);
  var finish = from2 < 0 ? to2 + Math.abs(from2) : to2 - from2;
  var idx = 0;
  while (idx < finish) {
    result[idx] = idx + from2;
    idx += 1;
  }
  return result;
});
var range_default = range;

// node_modules/ramda/es/reduceRight.js
var reduceRight = _curry3(function reduceRight2(fn2, acc, list4) {
  var idx = list4.length - 1;
  while (idx >= 0) {
    acc = fn2(list4[idx], acc);
    if (acc && acc["@@transducer/reduced"]) {
      acc = acc["@@transducer/value"];
      break;
    }
    idx -= 1;
  }
  return acc;
});
var reduceRight_default = reduceRight;

// node_modules/ramda/es/reduceWhile.js
var reduceWhile = _curryN(4, [], function _reduceWhile(pred, fn2, a2, list4) {
  var xf = _xwrap(function(acc, x2) {
    return pred(acc, x2) ? fn2(acc, x2) : _reduced(acc);
  });
  return xReduce_default(xf, a2, list4);
});

// node_modules/ramda/es/reduced.js
var reduced = _curry1(_reduced);
var reduced_default = reduced;

// node_modules/ramda/es/times.js
var times = _curry2(function times2(fn2, n) {
  var len = Number(n);
  if (len < 0 || isNaN(len)) {
    throw new RangeError("n must be a non-negative number");
  }
  var idx = 0;
  var list4 = Array(len);
  while (idx < len) {
    list4[idx] = fn2(idx);
    idx += 1;
  }
  return list4;
});
var times_default = times;

// node_modules/ramda/es/repeat.js
var repeat2 = _curry2(function repeat3(value, n) {
  return times_default(always_default(value), n);
});

// node_modules/ramda/es/replace.js
var replace2 = _curry3(function replace3(regex2, replacement, str2) {
  return str2.replace(regex2, replacement);
});
var replace_default = replace2;

// node_modules/ramda/es/internal/_xscan.js
var tInit2 = "@@transducer/init";
var tStep2 = "@@transducer/step";
var XScan = function() {
  function XScan2(reducer, acc, xf) {
    this.xf = xf;
    this.f = reducer;
    this.acc = acc;
  }
  XScan2.prototype[tInit2] = function() {
    return this.xf[tStep2](this.xf[tInit2](), this.acc);
  };
  XScan2.prototype["@@transducer/result"] = xfBase_default.result;
  XScan2.prototype[tStep2] = function(result, input) {
    if (result["@@transducer/reduced"]) {
      return result;
    }
    this.acc = this.f(this.acc, input);
    return this.xf[tStep2](result, this.acc);
  };
  return XScan2;
}();
var _xscan = _curry3(function _xscan2(reducer, acc, xf) {
  return new XScan(reducer, acc, xf);
});
var xscan_default = _xscan;

// node_modules/ramda/es/scan.js
var scan = _curry3(_dispatchable([], xscan_default, function scan2(fn2, acc, list4) {
  var idx = 0;
  var len = list4.length;
  var result = Array(len + 1);
  result[0] = acc;
  while (idx < len) {
    acc = fn2(acc, list4[idx]);
    result[idx + 1] = acc;
    idx += 1;
  }
  return result;
}));

// node_modules/ramda/es/sequence.js
var sequence = _curry2(function sequence2(F2, traversable) {
  var of4 = typeof F2["fantasy-land/of"] === "function" ? F2["fantasy-land/of"] : typeof F2.of === "function" ? F2.of : F2;
  var TypeRep = {
    "fantasy-land/of": of4
  };
  return typeof traversable["fantasy-land/traverse"] === "function" ? traversable["fantasy-land/traverse"](TypeRep, _identity) : typeof traversable.traverse === "function" ? traversable.traverse(TypeRep, _identity) : reduceRight_default(function(x2, acc) {
    return ap_default(map_default(prepend_default, x2), acc);
  }, of4([]), traversable);
});
var sequence_default = sequence;

// node_modules/ramda/es/set.js
var set2 = _curry3(function set3(lens3, v2, x2) {
  return over_default(lens3, always_default(v2), x2);
});

// node_modules/ramda/es/sort.js
var sort = _curry2(function sort2(comparator3, list4) {
  return Array.prototype.slice.call(list4, 0).sort(comparator3);
});
var sort_default = sort;

// node_modules/ramda/es/sortBy.js
var sortBy = _curry2(function sortBy2(fn2, list4) {
  return Array.prototype.slice.call(list4, 0).sort(function(a2, b) {
    var aa2 = fn2(a2);
    var bb = fn2(b);
    return aa2 < bb ? -1 : aa2 > bb ? 1 : 0;
  });
});

// node_modules/ramda/es/sortWith.js
var sortWith = _curry2(function sortWith2(fns, list4) {
  return Array.prototype.slice.call(list4, 0).sort(function(a2, b) {
    var result = 0;
    var i2 = 0;
    while (result === 0 && i2 < fns.length) {
      result = fns[i2](a2, b);
      i2 += 1;
    }
    return result;
  });
});
var sortWith_default = sortWith;

// node_modules/ramda/es/split.js
var split = invoker_default(1, "split");
var split_default = split;

// node_modules/ramda/es/splitAt.js
var splitAt = _curry2(function splitAt2(index, array2) {
  return [slice_default(0, index, array2), slice_default(index, length_default(array2), array2)];
});

// node_modules/ramda/es/splitEvery.js
var splitEvery = _curry2(function splitEvery2(n, list4) {
  if (n <= 0) {
    throw new Error("First argument to splitEvery must be a positive integer");
  }
  var result = [];
  var idx = 0;
  while (idx < list4.length) {
    result.push(slice_default(idx, idx += n, list4));
  }
  return result;
});

// node_modules/ramda/es/splitWhen.js
var splitWhen = _curry2(function splitWhen2(pred, list4) {
  var idx = 0;
  var len = list4.length;
  var prefix = [];
  while (idx < len && !pred(list4[idx])) {
    prefix.push(list4[idx]);
    idx += 1;
  }
  return [prefix, Array.prototype.slice.call(list4, idx)];
});

// node_modules/ramda/es/splitWhenever.js
var splitWhenever = _curryN(2, [], function splitWhenever2(pred, list4) {
  var acc = [];
  var curr = [];
  for (var i2 = 0; i2 < list4.length; i2 = i2 + 1) {
    if (!pred(list4[i2])) {
      curr.push(list4[i2]);
    }
    if ((i2 < list4.length - 1 && pred(list4[i2 + 1]) || i2 === list4.length - 1) && curr.length > 0) {
      acc.push(curr);
      curr = [];
    }
  }
  return acc;
});

// node_modules/ramda/es/startsWith.js
var startsWith = _curry2(function(prefix, list4) {
  return equals_default(take_default(prefix.length, list4), prefix);
});
var startsWith_default = startsWith;

// node_modules/ramda/es/subtract.js
var subtract = _curry2(function subtract2(a2, b) {
  return Number(a2) - Number(b);
});
var subtract_default = subtract;

// node_modules/ramda/es/swap.js
var swapObject = function(indexA, indexB, o4) {
  var copy3 = clone_default(o4);
  var properties = Object.getOwnPropertyNames(copy3);
  if (properties.includes(indexA) && properties.includes(indexB)) {
    var tmp = copy3[indexA];
    copy3[indexA] = copy3[indexB];
    copy3[indexB] = tmp;
  }
  return copy3;
};
var swapList = function(indexA, indexB, list4) {
  var length3 = list4.length;
  var result = list4.slice();
  var positiveIndexA = indexA < 0 ? length3 + indexA : indexA;
  var positiveIndexB = indexB < 0 ? length3 + indexB : indexB;
  var positiveMin = Math.min(positiveIndexA, positiveIndexB);
  var positiveMax = Math.max(positiveIndexA, positiveIndexB);
  if (positiveIndexA < 0 || positiveIndexA > length3) {
    return result;
  }
  if (positiveIndexB < 0 || positiveIndexB > length3) {
    return result;
  }
  if (positiveIndexA === positiveIndexB) {
    return result;
  }
  result = [].concat(result.slice(0, positiveMin)).concat([result[positiveMax]]).concat(result.slice(positiveMin + 1, positiveMax)).concat([result[positiveMin]]).concat(result.slice(positiveMax + 1, length3));
  return result;
};
var swapString = function(indexA, indexB, s2) {
  var result = swapList(indexA, indexB, s2);
  return isArray_default(result) ? result.join("") : result;
};
var swap = _curry3(function(indexA, indexB, o4) {
  if (isArray_default(o4)) {
    return swapList(indexA, indexB, o4);
  } else if (_isString(o4)) {
    return swapString(indexA, indexB, o4);
  } else {
    return swapObject(indexA, indexB, o4);
  }
});

// node_modules/ramda/es/symmetricDifference.js
var symmetricDifference = _curry2(function symmetricDifference2(list1, list22) {
  return concat_default(difference_default(list1, list22), difference_default(list22, list1));
});

// node_modules/ramda/es/symmetricDifferenceWith.js
var symmetricDifferenceWith = _curry3(function symmetricDifferenceWith2(pred, list1, list22) {
  return concat_default(differenceWith_default(pred, list1, list22), differenceWith_default(pred, list22, list1));
});

// node_modules/ramda/es/takeLastWhile.js
var takeLastWhile = _curry2(function takeLastWhile2(fn2, xs2) {
  var idx = xs2.length - 1;
  while (idx >= 0 && fn2(xs2[idx])) {
    idx -= 1;
  }
  return slice_default(idx + 1, Infinity, xs2);
});

// node_modules/ramda/es/internal/_xtakeWhile.js
var XTakeWhile = function() {
  function XTakeWhile2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XTakeWhile2.prototype["@@transducer/init"] = xfBase_default.init;
  XTakeWhile2.prototype["@@transducer/result"] = xfBase_default.result;
  XTakeWhile2.prototype["@@transducer/step"] = function(result, input) {
    return this.f(input) ? this.xf["@@transducer/step"](result, input) : _reduced(result);
  };
  return XTakeWhile2;
}();
function _xtakeWhile(f2) {
  return function(xf) {
    return new XTakeWhile(f2, xf);
  };
}

// node_modules/ramda/es/takeWhile.js
var takeWhile = _curry2(_dispatchable(["takeWhile"], _xtakeWhile, function takeWhile2(fn2, xs2) {
  var idx = 0;
  var len = xs2.length;
  while (idx < len && fn2(xs2[idx])) {
    idx += 1;
  }
  return slice_default(0, idx, xs2);
}));

// node_modules/ramda/es/internal/_xtap.js
var XTap = function() {
  function XTap2(f2, xf) {
    this.xf = xf;
    this.f = f2;
  }
  XTap2.prototype["@@transducer/init"] = xfBase_default.init;
  XTap2.prototype["@@transducer/result"] = xfBase_default.result;
  XTap2.prototype["@@transducer/step"] = function(result, input) {
    this.f(input);
    return this.xf["@@transducer/step"](result, input);
  };
  return XTap2;
}();
function _xtap(f2) {
  return function(xf) {
    return new XTap(f2, xf);
  };
}

// node_modules/ramda/es/tap.js
var tap = _curry2(_dispatchable([], _xtap, function tap2(fn2, x2) {
  fn2(x2);
  return x2;
}));
var tap_default = tap;

// node_modules/ramda/es/internal/_isRegExp.js
function _isRegExp(x2) {
  return Object.prototype.toString.call(x2) === "[object RegExp]";
}

// node_modules/ramda/es/test.js
var test = _curry2(function test2(pattern, str2) {
  if (!_isRegExp(pattern)) {
    throw new TypeError("test requires a value of type RegExp as its first argument; received " + toString_default(pattern));
  }
  return _cloneRegExp(pattern).test(str2);
});
var test_default = test;

// node_modules/ramda/es/andThen.js
var andThen = _curry2(function andThen2(f2, p2) {
  _assertPromise("andThen", p2);
  return p2.then(f2);
});

// node_modules/ramda/es/toLower.js
var toLower = invoker_default(0, "toLowerCase");

// node_modules/ramda/es/toPairs.js
var toPairs = _curry1(function toPairs2(obj) {
  var pairs2 = [];
  for (var prop3 in obj) {
    if (_has(prop3, obj)) {
      pairs2[pairs2.length] = [prop3, obj[prop3]];
    }
  }
  return pairs2;
});
var toPairs_default = toPairs;

// node_modules/ramda/es/toPairsIn.js
var toPairsIn = _curry1(function toPairsIn2(obj) {
  var pairs2 = [];
  for (var prop3 in obj) {
    pairs2[pairs2.length] = [prop3, obj[prop3]];
  }
  return pairs2;
});

// node_modules/ramda/es/toUpper.js
var toUpper = invoker_default(0, "toUpperCase");

// node_modules/ramda/es/transduce.js
var transduce = curryN_default(4, function transduce2(xf, fn2, acc, list4) {
  return xReduce_default(xf(typeof fn2 === "function" ? _xwrap(fn2) : fn2), acc, list4);
});

// node_modules/ramda/es/transpose.js
var transpose = _curry1(function transpose2(outerlist) {
  var i2 = 0;
  var result = [];
  while (i2 < outerlist.length) {
    var innerlist = outerlist[i2];
    var j2 = 0;
    while (j2 < innerlist.length) {
      if (typeof result[j2] === "undefined") {
        result[j2] = [];
      }
      result[j2].push(innerlist[j2]);
      j2 += 1;
    }
    i2 += 1;
  }
  return result;
});
var transpose_default = transpose;

// node_modules/ramda/es/traverse.js
var traverse = _curry3(function traverse2(F2, f2, traversable) {
  var of4 = typeof F2["fantasy-land/of"] === "function" ? F2["fantasy-land/of"] : typeof F2.of === "function" ? F2.of : F2;
  var TypeRep = {
    "fantasy-land/of": of4
  };
  return typeof traversable["fantasy-land/traverse"] === "function" ? traversable["fantasy-land/traverse"](TypeRep, f2) : typeof traversable.traverse === "function" ? traversable.traverse(TypeRep, f2) : sequence_default(TypeRep, map_default(f2, traversable));
});
var traverse_default = traverse;

// node_modules/ramda/es/trim.js
var ws = "	\n\v\f\r \u2028\u2029\uFEFF";
var zeroWidth = "";
var hasProtoTrim = typeof String.prototype.trim === "function";
var trim = !hasProtoTrim || ws.trim() || !zeroWidth.trim() ? _curry1(function trim2(str2) {
  var beginRx = new RegExp("^[" + ws + "][" + ws + "]*");
  var endRx = new RegExp("[" + ws + "][" + ws + "]*$");
  return str2.replace(beginRx, "").replace(endRx, "");
}) : _curry1(function trim3(str2) {
  return str2.trim();
});
var trim_default = trim;

// node_modules/ramda/es/tryCatch.js
var tryCatch = _curry2(function _tryCatch(tryer, catcher) {
  return _arity(tryer.length, function() {
    try {
      return tryer.apply(this, arguments);
    } catch (e2) {
      return catcher.apply(this, _concat([e2], arguments));
    }
  });
});

// node_modules/ramda/es/unapply.js
var unapply = _curry1(function unapply2(fn2) {
  return function() {
    return fn2(Array.prototype.slice.call(arguments, 0));
  };
});
var unapply_default = unapply;

// node_modules/ramda/es/unary.js
var unary = _curry1(function unary2(fn2) {
  return nAry_default(1, fn2);
});
var unary_default = unary;

// node_modules/ramda/es/uncurryN.js
var uncurryN = _curry2(function uncurryN2(depth, fn2) {
  return curryN_default(depth, function() {
    var currentDepth = 1;
    var value = fn2;
    var idx = 0;
    var endIdx;
    while (currentDepth <= depth && typeof value === "function") {
      endIdx = currentDepth === depth ? arguments.length : idx + value.length;
      value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
      currentDepth += 1;
      idx = endIdx;
    }
    return value;
  });
});

// node_modules/ramda/es/unfold.js
var unfold = _curry2(function unfold2(fn2, seed) {
  var pair3 = fn2(seed);
  var result = [];
  while (pair3 && pair3.length) {
    result[result.length] = pair3[0];
    pair3 = fn2(pair3[1]);
  }
  return result;
});

// node_modules/ramda/es/union.js
var union = _curry2(compose2(uniq_default, _concat));

// node_modules/ramda/es/internal/_xuniqWith.js
var XUniqWith = function() {
  function XUniqWith2(pred, xf) {
    this.xf = xf;
    this.pred = pred;
    this.items = [];
  }
  XUniqWith2.prototype["@@transducer/init"] = xfBase_default.init;
  XUniqWith2.prototype["@@transducer/result"] = xfBase_default.result;
  XUniqWith2.prototype["@@transducer/step"] = function(result, input) {
    if (_includesWith(this.pred, input, this.items)) {
      return result;
    } else {
      this.items.push(input);
      return this.xf["@@transducer/step"](result, input);
    }
  };
  return XUniqWith2;
}();
function _xuniqWith(pred) {
  return function(xf) {
    return new XUniqWith(pred, xf);
  };
}

// node_modules/ramda/es/uniqWith.js
var uniqWith = _curry2(_dispatchable([], _xuniqWith, function(pred, list4) {
  var idx = 0;
  var len = list4.length;
  var result = [];
  var item;
  while (idx < len) {
    item = list4[idx];
    if (!_includesWith(pred, item, result)) {
      result[result.length] = item;
    }
    idx += 1;
  }
  return result;
}));
var uniqWith_default = uniqWith;

// node_modules/ramda/es/unionWith.js
var unionWith = _curry3(function unionWith2(pred, list1, list22) {
  return uniqWith_default(pred, _concat(list1, list22));
});

// node_modules/ramda/es/unless.js
var unless = _curry3(function unless2(pred, whenFalseFn, x2) {
  return pred(x2) ? x2 : whenFalseFn(x2);
});

// node_modules/ramda/es/unnest.js
var unnest = chain_default(_identity);

// node_modules/ramda/es/until.js
var until = _curry3(function until2(pred, fn2, init2) {
  var val = init2;
  while (!pred(val)) {
    val = fn2(val);
  }
  return val;
});

// node_modules/ramda/es/unwind.js
var unwind = _curry2(function(key57, object2) {
  if (!(key57 in object2 && isArray_default(object2[key57]))) {
    return [object2];
  }
  return _map(function(item) {
    return _assoc(key57, item, object2);
  }, object2[key57]);
});

// node_modules/ramda/es/valuesIn.js
var valuesIn = _curry1(function valuesIn2(obj) {
  var prop3;
  var vs2 = [];
  for (prop3 in obj) {
    vs2[vs2.length] = obj[prop3];
  }
  return vs2;
});

// node_modules/ramda/es/view.js
var Const = function(x2) {
  return {
    value: x2,
    "fantasy-land/map": function() {
      return this;
    }
  };
};
var view = _curry2(function view2(lens3, x2) {
  return lens3(Const)(x2).value;
});
var view_default = view;

// node_modules/ramda/es/when.js
var when = _curry3(function when2(pred, whenTrueFn, x2) {
  return pred(x2) ? whenTrueFn(x2) : x2;
});
var when_default = when;

// node_modules/ramda/es/where.js
var where = _curry2(function where2(spec2, testObj) {
  for (var prop3 in spec2) {
    if (_has(prop3, spec2) && !spec2[prop3](testObj[prop3])) {
      return false;
    }
  }
  return true;
});
var where_default = where;

// node_modules/ramda/es/whereAny.js
var whereAny = _curry2(function whereAny2(spec2, testObj) {
  for (var prop3 in spec2) {
    if (_has(prop3, spec2) && spec2[prop3](testObj[prop3])) {
      return true;
    }
  }
  return false;
});

// node_modules/ramda/es/whereEq.js
var whereEq = _curry2(function whereEq2(spec2, testObj) {
  return where_default(map_default(equals_default, spec2), testObj);
});

// node_modules/ramda/es/without.js
var without = _curry2(function without2(xs2, list4) {
  var toRemove = new Set_default();
  for (var i2 = 0; i2 < xs2.length; i2 += 1) {
    toRemove.add(xs2[i2]);
  }
  return reject_default(toRemove.has.bind(toRemove), list4);
});

// node_modules/ramda/es/xor.js
var xor = _curry2(function xor2(a2, b) {
  return Boolean(!a2 ^ !b);
});

// node_modules/ramda/es/xprod.js
var xprod = _curry2(function xprod2(a2, b) {
  var i2 = 0;
  var ilen = a2.length;
  var j2;
  var jlen = b.length;
  var result = Array(ilen * jlen);
  while (i2 < ilen) {
    j2 = 0;
    while (j2 < jlen) {
      result[i2 * jlen + j2] = [a2[i2], b[j2]];
      j2 += 1;
    }
    i2 += 1;
  }
  return result;
});

// node_modules/ramda/es/zip.js
var zip = _curry2(function zip2(a2, b) {
  var len = Math.min(a2.length, b.length);
  var rv = Array(len);
  var idx = 0;
  while (idx < len) {
    rv[idx] = [a2[idx], b[idx]];
    idx += 1;
  }
  return rv;
});
var zip_default = zip;

// node_modules/ramda/es/zipObj.js
var zipObj = _curry2(function zipObj2(keys4, values3) {
  var idx = 0;
  var len = Math.min(keys4.length, values3.length);
  var out = {};
  while (idx < len) {
    out[keys4[idx]] = values3[idx];
    idx += 1;
  }
  return out;
});

// node_modules/ramda/es/zipWith.js
var zipWith = _curry3(function zipWith2(fn2, a2, b) {
  var len = Math.min(a2.length, b.length);
  var rv = Array(len);
  var idx = 0;
  while (idx < len) {
    rv[idx] = fn2(a2[idx], b[idx]);
    idx += 1;
  }
  return rv;
});

// node_modules/ramda/es/thunkify.js
var thunkify = _curry1(function thunkify2(fn2) {
  return curryN_default(fn2.length, function createThunk() {
    var fnArgs = arguments;
    return function invokeThunk() {
      return fn2.apply(this, fnArgs);
    };
  });
});

// node_modules/ramda-adjunct/es/stubUndefined.js
var stubUndefined = always_default(void 0);
var stubUndefined_default = stubUndefined;

// node_modules/ramda-adjunct/es/isUndefined.js
var isUndefined = equals_default(stubUndefined_default());
var isUndefined_default = isUndefined;

// node_modules/ramda-adjunct/es/isNotUndefined.js
var isNotUndefined = complement_default(isUndefined_default);
var isNotUndefined_default = isNotUndefined;

// node_modules/ramda-adjunct/es/isNull.js
var isNull2 = equals_default(null);
var isNull_default = isNull2;

// node_modules/ramda-adjunct/es/isNotNull.js
var isNotNull = complement_default(isNull_default);
var isNotNull_default = isNotNull;

// node_modules/ramda-adjunct/es/isNotNil.js
var isNotNil3 = complement_default(isNil_default);
var isNotNil_default2 = isNotNil3;

// node_modules/ramda-adjunct/es/isGeneratorFunction.js
var isGeneratorFunction = curryN_default(1, pipe(type_default, identical_default("GeneratorFunction")));
var isGeneratorFunction_default = isGeneratorFunction;

// node_modules/ramda-adjunct/es/isAsyncFunction.js
var isAsyncFunction = curryN_default(1, pipe(type_default, identical_default("AsyncFunction")));
var isAsyncFunction_default = isAsyncFunction;

// node_modules/ramda-adjunct/es/isFunction.js
var isFunction2 = anyPass_default([pipe(type_default, identical_default("Function")), isGeneratorFunction_default, isAsyncFunction_default]);
var isFunction_default = isFunction2;

// node_modules/ramda-adjunct/es/isArray.js
var isArray = curryN_default(1, isFunction_default(Array.isArray) ? Array.isArray : pipe(type_default, identical_default("Array")));
var isArray_default2 = isArray;

// node_modules/ramda-adjunct/es/isIterable.js
var isIterable = curryN_default(1, function(val) {
  if (typeof Symbol === "undefined") {
    return false;
  }
  return hasIn_default(Symbol.iterator, Object(val)) && isFunction_default(val[Symbol.iterator]);
});
var isIterable_default = isIterable;

// node_modules/ramda-adjunct/es/isEmptyArray.js
var isEmptyArray = both_default(isArray_default2, isEmpty_default);
var isEmptyArray_default = isEmptyArray;

// node_modules/ramda-adjunct/es/isNotArray.js
var isNotArray = complement_default(isArray_default2);
var isNotArray_default = isNotArray;

// node_modules/ramda-adjunct/es/isNonEmptyArray.js
var isNonEmptyArray = both_default(isArray_default2, isNotEmpty_default);
var isNonEmptyArray_default = isNonEmptyArray;

// node_modules/ramda-adjunct/es/isBoolean.js
var isBoolean2 = curryN_default(1, pipe(type_default, identical_default("Boolean")));
var isBoolean_default = isBoolean2;

// node_modules/ramda-adjunct/es/isNotBoolean.js
var isNotBoolean = complement_default(isBoolean_default);

// node_modules/ramda-adjunct/es/isNilOrEmpty.js
var isNilOrEmpty = curryN_default(1, either_default(isNil_default, isEmpty_default));
var isNilOrEmpty_default = isNilOrEmpty;

// node_modules/ramda-adjunct/es/isString.js
var isString = curryN_default(1, pipe(type_default, identical_default("String")));
var isString_default = isString;

// node_modules/ramda-adjunct/es/isEmptyString.js
var isEmptyString = equals_default("");
var isEmptyString_default = isEmptyString;

// node_modules/ramda-adjunct/es/isNotString.js
var isNotString = complement_default(isString_default);

// node_modules/ramda-adjunct/es/internal/isOfTypeObject.js
function _typeof2(o4) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof2(o4);
}
var isOfTypeObject = function isOfTypeObject2(val) {
  return _typeof2(val) === "object";
};
var isOfTypeObject_default = isOfTypeObject;

// node_modules/ramda-adjunct/es/isObj.js
var isObj = curryN_default(1, both_default(isNotNull_default, either_default(isOfTypeObject_default, isFunction_default)));
var isObj_default = isObj;

// node_modules/ramda-adjunct/es/isNotObj.js
var isNotObj = complement_default(isObj_default);
var isNotObj_default = isNotObj;

// node_modules/ramda-adjunct/es/isNonEmptyString.js
var isNonEmptyString = allPass_default([isString_default, isNotObj_default, isNotEmpty_default]);
var isNonEmptyString_default = isNonEmptyString;

// node_modules/ramda-adjunct/es/isArrayLike.js
function _typeof3(o4) {
  "@babel/helpers - typeof";
  return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof3(o4);
}
var isArrayLike2 = curryN_default(1, function(val) {
  if (isArray_default2(val)) {
    return true;
  }
  if (!val) {
    return false;
  }
  if (isString_default(val)) {
    return false;
  }
  if (_typeof3(val) !== "object") {
    return false;
  }
  if (val.nodeType === 1) {
    return !!val.length;
  }
  if (val.length === 0) {
    return true;
  }
  if (val.length > 0) {
    return has_default(0, val) && has_default(val.length - 1, val);
  }
  return false;
});
var isArrayLike_default2 = isArrayLike2;

// node_modules/ramda-adjunct/es/isNotArrayLike.js
var isNotArrayLike = complement_default(isArrayLike_default2);

// node_modules/ramda-adjunct/es/isNotGeneratorFunction.js
var isNotGeneratorFunction = complement_default(isGeneratorFunction_default);

// node_modules/ramda-adjunct/es/isNotAsyncFunction.js
var isNotAsyncFunction = complement_default(isAsyncFunction_default);

// node_modules/ramda-adjunct/es/isNotFunction.js
var isNotFunction = complement_default(isFunction_default);
var isNotFunction_default = isNotFunction;

// node_modules/ramda-adjunct/es/isObjLike.js
var isObjLike = curryN_default(1, both_default(isNotNull_default, isOfTypeObject_default));
var isObjLike_default = isObjLike;

// node_modules/ramda-adjunct/es/isNotObjLike.js
var isNotObjLike = complement_default(isObjLike_default);

// node_modules/ramda-adjunct/es/isPlainObj.js
var isObject3 = pipe(type_default, identical_default("Object"));
var isObjectConstructor = pipe(toString_default, equals_default(toString_default(Object)));
var hasObjectConstructor = pathSatisfies_default(both_default(isFunction_default, isObjectConstructor), ["constructor"]);
var isPlainObj = curryN_default(1, function(val) {
  if (!isObjLike_default(val) || !isObject3(val)) {
    return false;
  }
  var proto2 = Object.getPrototypeOf(val);
  if (isNull_default(proto2)) {
    return true;
  }
  return hasObjectConstructor(proto2);
});
var isPlainObj_default = isPlainObj;

// node_modules/ramda-adjunct/es/isNotPlainObj.js
var isNotPlainObj = complement_default(isPlainObj_default);

// node_modules/ramda-adjunct/es/isDate.js
var isDate2 = curryN_default(1, pipe(type_default, identical_default("Date")));
var isDate_default = isDate2;

// node_modules/ramda-adjunct/es/isNotDate.js
var isNotDate = complement_default(isDate_default);

// node_modules/ramda-adjunct/es/isNumber.js
var isNumber = curryN_default(1, pipe(type_default, identical_default("Number")));
var isNumber_default = isNumber;

// node_modules/ramda-adjunct/es/internal/ponyfills/Number.isNaN.js
var isNaNPonyfill = both_default(isNumber_default, isNaN);
var Number_isNaN_default = isNaNPonyfill;

// node_modules/ramda-adjunct/es/isNaN.js
var isNaNPonyfill2 = curryN_default(1, Number_isNaN_default);
var _isNaN = isFunction_default(Number.isNaN) ? curryN_default(1, Number.isNaN) : isNaNPonyfill2;
var isNaN_default = _isNaN;

// node_modules/ramda-adjunct/es/isNotNaN.js
var isNotNaN = complement_default(isNaN_default);
var isNotNaN_default = isNotNaN;

// node_modules/ramda-adjunct/es/isValidDate.js
var isValidDate = curryN_default(1, both_default(isDate_default, pipe(invoker_default(0, "getTime"), isNotNaN_default)));
var isValidDate_default = isValidDate;

// node_modules/ramda-adjunct/es/isNotValidDate.js
var isNotValidDate = complement_default(isValidDate_default);

// node_modules/ramda-adjunct/es/isNotNumber.js
var isNotNumber = complement_default(isNumber_default);

// node_modules/ramda-adjunct/es/isPositive.js
var isPositive = both_default(isNumber_default, lt_default(0));

// node_modules/ramda-adjunct/es/isNegative.js
var isNegative = curryN_default(1, both_default(isNumber_default, gt_default(0)));
var isNegative_default = isNegative;

// node_modules/ramda-adjunct/es/isPositiveZero.js
var isPositiveZero = curryN_default(1, identical_default(0));

// node_modules/ramda-adjunct/es/isNegativeZero.js
var isNegativeZero2 = curryN_default(1, identical_default(-0));

// node_modules/ramda-adjunct/es/isNotNilOrEmpty.js
var isNotNilOrEmpty = complement_default(isNilOrEmpty_default);

// node_modules/ramda-adjunct/es/isNonPositive.js
var isNonPositive = curryN_default(1, both_default(isNumber_default, flip_default(lte_default)(0)));

// node_modules/ramda-adjunct/es/isNonNegative.js
var isNonNegative = curryN_default(1, both_default(isNumber_default, flip_default(gte_default)(0)));
var isNonNegative_default = isNonNegative;

// node_modules/ramda-adjunct/es/isMap.js
var isMap = curryN_default(1, pipe(type_default, identical_default("Map")));
var isMap_default = isMap;

// node_modules/ramda-adjunct/es/isNotMap.js
var isNotMap = complement_default(isMap_default);

// node_modules/ramda-adjunct/es/internal/ponyfills/Number.isFinite.js
var isFinitePonyfill = both_default(isNumber_default, isFinite);
var Number_isFinite_default = isFinitePonyfill;

// node_modules/ramda-adjunct/es/isFinite.js
var isFinitePonyfill2 = curryN_default(1, Number_isFinite_default);
var _isFinite = isFunction_default(Number.isFinite) ? curryN_default(1, bind_default(Number.isFinite, Number)) : isFinitePonyfill2;
var isFinite_default = _isFinite;

// node_modules/ramda-adjunct/es/isNotFinite.js
var isNotFinite = complement_default(isFinite_default);
var isNotFinite_default = isNotFinite;

// node_modules/ramda-adjunct/es/internal/ponyfills/Number.isInteger.js
var isIntegerPonyfill = both_default(isFinite_default, converge_default(equals_default, [Math.floor, identity_default]));
var Number_isInteger_default = isIntegerPonyfill;

// node_modules/ramda-adjunct/es/isInteger.js
var isIntegerPonyfill2 = curryN_default(1, Number_isInteger_default);
var isInteger3 = isFunction_default(Number.isInteger) ? curryN_default(1, bind_default(Number.isInteger, Number)) : isIntegerPonyfill2;
var isInteger_default2 = isInteger3;

// node_modules/ramda-adjunct/es/toInteger32.js
var toInteger32 = curryN_default(1, function(val) {
  return val >> 0;
});
var toInteger32_default = toInteger32;

// node_modules/ramda-adjunct/es/isInteger32.js
var isInteger32 = curryN_default(1, function(val) {
  return toInteger32_default(val) === val;
});
var isInteger32_default = isInteger32;

// node_modules/ramda-adjunct/es/toUinteger32.js
var toUinteger32 = curryN_default(1, function(val) {
  return val >>> 0;
});
var toUinteger32_default = toUinteger32;

// node_modules/ramda-adjunct/es/isUinteger32.js
var isUinteger32 = curryN_default(1, function(val) {
  return toUinteger32_default(val) === val;
});

// node_modules/ramda-adjunct/es/isNotInteger.js
var isNotInteger = complement_default(isInteger_default2);

// node_modules/ramda-adjunct/es/isBigInt.js
var isBigInt = curryN_default(1, pipe(type_default, identical_default("BigInt")));
var isBigInt_default = isBigInt;

// node_modules/ramda-adjunct/es/isFloat.js
var isFloat2 = both_default(isFinite_default, complement_default(isInteger_default2));
var isFloat_default = isFloat2;

// node_modules/ramda-adjunct/es/isNotFloat.js
var isNotFloat = curryN_default(1, complement_default(isFloat_default));

// node_modules/ramda-adjunct/es/isValidNumber.js
var isValidNumber = curryN_default(1, either_default(isInteger_default2, isFloat_default));
var isValidNumber_default = isValidNumber;

// node_modules/ramda-adjunct/es/isNotValidNumber.js
var isNotValidNumber = complement_default(isValidNumber_default);

// node_modules/ramda-adjunct/es/isOdd.js
var isOdd = curryN_default(1, both_default(isInteger_default2, pipe(flip_default(modulo_default)(2), complement_default(equals_default)(0))));
var isOdd_default = isOdd;

// node_modules/ramda-adjunct/es/isEven.js
var isEven = curryN_default(1, both_default(isInteger_default2, complement_default(isOdd_default)));

// node_modules/ramda-adjunct/es/isPair.js
var isPair = curryN_default(1, both_default(isArray_default2, pipe(length_default, equals_default(2))));
var isPair_default = isPair;

// node_modules/ramda-adjunct/es/isNotPair.js
var isNotPair = complement_default(isPair_default);

// node_modules/ramda-adjunct/es/isThenable.js
var isThenable = pathSatisfies_default(isFunction_default, ["then"]);

// node_modules/ramda-adjunct/es/isPromise.js
var isPromise2 = curryN_default(1, both_default(isObj_default, pipe(toString_default, equals_default("[object Promise]"))));

// node_modules/ramda-adjunct/es/isTrue.js
var isTrue = curryN_default(1, identical_default(true));
var isTrue_default = isTrue;

// node_modules/ramda-adjunct/es/isFalse.js
var isFalse = curryN_default(1, identical_default(false));
var isFalse_default = isFalse;

// node_modules/ramda-adjunct/es/isTruthy.js
var isTruthy = curryN_default(1, Boolean);
var isTruthy_default = isTruthy;

// node_modules/ramda-adjunct/es/isFalsy.js
var isFalsy = complement_default(isTruthy_default);
var isFalsy_default = isFalsy;

// node_modules/ramda-adjunct/es/isRegExp.js
var isRegExp = curryN_default(1, pipe(type_default, identical_default("RegExp")));
var isRegExp_default = isRegExp;

// node_modules/ramda-adjunct/es/isNotRegExp.js
var isNotRegExp = complement_default(isRegExp_default);

// node_modules/ramda-adjunct/es/isSet.js
var isSet = curryN_default(1, pipe(type_default, identical_default("Set")));
var isSet_default = isSet;

// node_modules/ramda-adjunct/es/isNotSet.js
var isNotSet = complement_default(isSet_default);

// node_modules/ramda-adjunct/es/isSparseArray.js
var isSparseArray = both_default(isArray_default2, converge_default(complement_default(identical_default), [pipe(values_default, length_default), length_default]));

// node_modules/ramda-adjunct/es/isSymbol.js
function _typeof4(o4) {
  "@babel/helpers - typeof";
  return _typeof4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof4(o4);
}
var isSymbol = curryN_default(1, function(val) {
  return _typeof4(val) === "symbol" || _typeof4(val) === "object" && type_default(val) === "Symbol";
});
var isSymbol_default = isSymbol;

// node_modules/ramda-adjunct/es/internal/ponyfills/Number.MAX_SAFE_INTEGER.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
var Number_MAX_SAFE_INTEGER_default = MAX_SAFE_INTEGER;

// node_modules/ramda-adjunct/es/internal/ponyfills/Number.isSafeInteger.js
var isSafeIntegerPonyfill = both_default(isInteger_default2, function(value) {
  return Math.abs(value) <= Number_MAX_SAFE_INTEGER_default;
});
var Number_isSafeInteger_default = isSafeIntegerPonyfill;

// node_modules/ramda-adjunct/es/isSafeInteger.js
var isSafeIntegerPonyfill2 = curryN_default(1, Number_isSafeInteger_default);
var isSafeInteger = isFunction_default(Number.isSafeInteger) ? curryN_default(1, bind_default(Number.isSafeInteger, Number)) : isSafeIntegerPonyfill2;

// node_modules/ramda-adjunct/es/isIndexed.js
var isIndexed = curryN_default(1, either_default(isString_default, isArray_default2));

// node_modules/ramda-adjunct/es/isError.js
var isError3 = curryN_default(1, pipe(type_default, identical_default("Error")));

// node_modules/ramda-adjunct/es/isNaturalNumber.js
var isNaturalNumber = curryN_default(1, both_default(isInteger_default2, complement_default(isNegative_default)));

// node_modules/ramda-adjunct/es/isPrimitive.js
var isPrimitive = both_default(isNotObj_default, anyPass_default([isString_default, isNumber_default, isBigInt_default, isBoolean_default, isUndefined_default, isNull_default, isSymbol_default]));
var isPrimitive_default = isPrimitive;

// node_modules/ramda-adjunct/es/isNotPrimitive.js
var isNotPrimitive = curryN_default(1, complement_default(isPrimitive_default));

// node_modules/ramda-adjunct/es/isSentinelValue.js
var isSentinelValue = curryN_default(1, function(val) {
  return isInteger32_default(val) && ~val === 0;
});

// node_modules/ramda-adjunct/es/isBlank.js
var isBlank = anyPass_default([isFalse_default, isNil_default, isEmpty_default, test_default(/^\s+$/gm)]);

// node_modules/ramda-adjunct/es/stubNull.js
var stubNull = always_default(null);

// node_modules/ramda-adjunct/es/stubString.js
var stubString = always_default("");

// node_modules/ramda-adjunct/es/noop.js
var noop = always_default(stubUndefined_default());

// node_modules/ramda-adjunct/es/fantasy-land/mapping.js
var equals3 = "fantasy-land/equals";
var lte3 = "fantasy-land/lte";
var concat3 = "fantasy-land/concat";
var empty3 = "fantasy-land/empty";
var map4 = "fantasy-land/map";
var contramap = "fantasy-land/contramap";
var ap3 = "fantasy-land/ap";
var of3 = "fantasy-land/of";
var chain3 = "fantasy-land/chain";

// node_modules/ramda-adjunct/es/internal/ap.js
var isFunctor = either_default(pathSatisfies_default(isFunction_default, ["map"]), pathSatisfies_default(isFunction_default, [map4]));
var isApply = both_default(isFunctor, either_default(pathSatisfies_default(isFunction_default, ["ap"]), pathSatisfies_default(isFunction_default, [ap3])));
var ap4 = curryN_default(2, function(applyF, applyX) {
  if (!isApply(applyF) || !isApply(applyX)) {
    return ap_default(applyF, applyX);
  }
  try {
    return applyF.ap(applyX);
  } catch (e2) {
    return applyX.ap(applyF);
  }
});
var ap_default2 = ap4;

// node_modules/ramda-adjunct/es/liftFN.js
var liftFN = curry_default(function(arity, fn2) {
  var lifted = curryN_default(arity, fn2);
  return curryN_default(arity, function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var accumulator = map_default(lifted, head_default(args));
    var apps = slice_default(1, Infinity, args);
    return reduce_default(ap_default2, accumulator, apps);
  });
});
var liftFN_default = liftFN;

// node_modules/ramda-adjunct/es/liftF.js
var liftF = curryN_default(1, function(fn2) {
  return liftFN_default(fn2.length, fn2);
});

// node_modules/ramda-adjunct/es/cata.js
var catamorphism = curry_default(function(leftFn, rightFn, catamorphicObj) {
  if (isFunction_default(catamorphicObj.matchWith)) {
    return catamorphicObj.matchWith({
      // Result type
      Ok: function Ok(_ref) {
        var value2 = _ref.value;
        return rightFn(value2);
      },
      Error: function Error2(_ref2) {
        var value2 = _ref2.value;
        return leftFn(value2);
      },
      // Maybe type
      Just: function Just(_ref3) {
        var value2 = _ref3.value;
        return rightFn(value2);
      },
      Nothing: function Nothing() {
        return leftFn(void 0);
      },
      // Validation type
      Success: function Success(_ref4) {
        var value2 = _ref4.value;
        return rightFn(value2);
      },
      Failure: function Failure(_ref5) {
        var value2 = _ref5.value;
        return leftFn(value2);
      }
    });
  }
  if (isFunction_default(catamorphicObj.cata)) {
    return catamorphicObj.cata(leftFn, rightFn);
  }
  if (isFunction_default(catamorphicObj.getOrElse)) {
    var elseValue = "RA.cata".concat(Math.random());
    var value = catamorphicObj.getOrElse(elseValue);
    return value === elseValue ? leftFn() : rightFn(value);
  }
  return catamorphicObj.either(leftFn, rightFn);
});

// node_modules/ramda-adjunct/es/weave.js
var weave = curryN_default(2, function(fn2, config2) {
  return curryN_default(fn2.length, function() {
    return fn2.apply(void 0, arguments).run(config2);
  });
});

// node_modules/ramda-adjunct/es/weaveLazy.js
var weaveLazy = curryN_default(2, function(fn2, configAccessor) {
  return curryN_default(fn2.length, function() {
    return fn2.apply(void 0, arguments).run(configAccessor());
  });
});

// node_modules/ramda-adjunct/es/curryRightN.js
var curryRightN = curryN_default(2, function(arity, fn2) {
  return curryN_default(arity, function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return fn2.apply(this, reverse_default(args));
  });
});
var curryRightN_default = curryRightN;

// node_modules/ramda-adjunct/es/curryRight.js
var curryRight = converge_default(curryRightN_default, [length_default, identity_default]);

// node_modules/ramda-adjunct/es/allP.js
var allP = curryN_default(1, bind_default(Promise.all, Promise));
var allP_default = allP;

// node_modules/ramda-adjunct/es/catchP.js
var catchP = invoker_default(1, "catch");

// node_modules/ramda-adjunct/es/rejectP.js
var rejectP = bind_default(Promise.reject, Promise);
var rejectP_default = rejectP;

// node_modules/ramda-adjunct/es/resolveP.js
var resolveP = bind_default(Promise.resolve, Promise);
var resolveP_default = resolveP;

// node_modules/ramda-adjunct/es/noneP.js
var noneP = curryN_default(1, pipe(map_default(resolveP_default), map_default(function(p2) {
  return p2.then(rejectP_default, resolveP_default);
}), allP_default));

// node_modules/ramda-adjunct/es/delayP.js
var makeDelay = curry_default(function(settleFnPicker, opts) {
  var timeout;
  var value;
  if (isInteger_default2(opts) && isNonNegative_default(opts)) {
    timeout = opts;
  } else {
    timeout = propOr_default(0, "timeout", opts);
    value = propOr_default(value, "value", opts);
  }
  return new Promise(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var settleFn = settleFnPicker(args);
    setTimeout(partial_default(settleFn, [value]), timeout);
  });
});
var delayP = makeDelay(nth_default(0));
delayP.reject = makeDelay(nth_default(1));

// node_modules/ramda-adjunct/es/thenCatchP.js
var thenCatchP = invoker_default(2, "then");

// node_modules/ramda-adjunct/es/internal/ponyfills/Promise.allSettled.js
function _toConsumableArray(r2) {
  return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
  }
}
function _iterableToArray(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray(r2);
}
function _arrayLikeToArray(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}
var onFulfill = function onFulfill2(value) {
  return {
    status: "fulfilled",
    value
  };
};
var onReject = function onReject2(reason) {
  return {
    status: "rejected",
    reason
  };
};
var allSettledPonyfill = function allSettledPonyfill2(iterable) {
  var array2 = map_default(function(p2) {
    return resolveP_default(p2).then(onFulfill)["catch"](onReject);
  }, _toConsumableArray(iterable));
  return allP_default(array2);
};
var Promise_allSettled_default = allSettledPonyfill;

// node_modules/ramda-adjunct/es/allSettledP.js
var allSettledPPonyfill = curryN_default(1, Promise_allSettled_default);
var allSettledP = isFunction_default(Promise.allSettled) ? curryN_default(1, bind_default(Promise.allSettled, Promise)) : allSettledPPonyfill;

// node_modules/ramda-adjunct/es/Y.js
var Y = curryN_default(1, function(le) {
  return function(f2) {
    return f2(f2);
  }(function(g2) {
    return le(function(x2) {
      return g2(g2)(x2);
    });
  });
});

// node_modules/ramda-adjunct/es/seq.js
var seq2 = curry_default(function(fns, x2) {
  return tap_default(function(tx) {
    return map_default(function(fn2) {
      return fn2(tx);
    })(fns);
  })(x2);
});

// node_modules/ramda-adjunct/es/dispatch.js
function _toConsumableArray2(r2) {
  return _arrayWithoutHoles2(r2) || _iterableToArray2(r2) || _unsupportedIterableToArray2(r2) || _nonIterableSpread2();
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray2(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray2(r2, a2) : void 0;
  }
}
function _iterableToArray2(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles2(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray2(r2);
}
function _arrayLikeToArray2(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}
var byArity = comparator_default(function(a2, b) {
  return a2.length > b.length;
});
var getMaxArity = pipe(sort_default(byArity), head_default, prop_default("length"));
var iteratorFn = curry_default(function(args, accumulator, fn2) {
  var result = fn2.apply(void 0, _toConsumableArray2(args));
  return isNotNil_default2(result) ? reduced_default(result) : accumulator;
});
var dispatchImpl = function dispatchImpl2(functions) {
  var arity = getMaxArity(functions);
  return curryN_default(arity, function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return reduce_default(iteratorFn(args), void 0, functions);
  });
};
var dispatch = ifElse_default(isNonEmptyArray_default, dispatchImpl, stubUndefined_default);
var dispatch_default = dispatch;

// node_modules/ramda-adjunct/es/async.js
var async = curryN_default(1, function(generatorFn) {
  function asyncWrapper() {
    var iterator = bind_default(generatorFn, this).apply(void 0, arguments);
    var _handle = function handle(result) {
      var resolved = resolveP_default(result.value);
      return result.done ? resolved : resolved.then(function(value) {
        return _handle(iterator.next(value));
      }, function(error) {
        return _handle(iterator["throw"](error));
      });
    };
    try {
      return _handle(iterator.next());
    } catch (error) {
      return rejectP_default(error);
    }
  }
  if (generatorFn.length > 0) {
    return curryN_default(generatorFn.length, asyncWrapper);
  }
  return asyncWrapper;
});

// node_modules/ramda-adjunct/es/internal/ponyfills/Promise.any.js
function _typeof5(o4) {
  "@babel/helpers - typeof";
  return _typeof5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof5(o4);
}
function _toConsumableArray3(r2) {
  return _arrayWithoutHoles3(r2) || _iterableToArray3(r2) || _unsupportedIterableToArray3(r2) || _nonIterableSpread3();
}
function _nonIterableSpread3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray3(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray3(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray3(r2, a2) : void 0;
  }
}
function _iterableToArray3(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles3(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray3(r2);
}
function _arrayLikeToArray3(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}
function _defineProperties2(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o4 = r2[t2];
    o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(e2, _toPropertyKey(o4.key), o4);
  }
}
function _createClass2(e2, r2, t2) {
  return r2 && _defineProperties2(e2.prototype, r2), t2 && _defineProperties2(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
}
function _toPropertyKey(t2) {
  var i2 = _toPrimitive(t2, "string");
  return "symbol" == _typeof5(i2) ? i2 : i2 + "";
}
function _toPrimitive(t2, r2) {
  if ("object" != _typeof5(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof5(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function _classCallCheck2(a2, n) {
  if (!(a2 instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _callSuper(t2, o4, e2) {
  return o4 = _getPrototypeOf2(o4), _possibleConstructorReturn2(t2, _isNativeReflectConstruct() ? Reflect.construct(o4, e2 || [], _getPrototypeOf2(t2).constructor) : o4.apply(t2, e2));
}
function _possibleConstructorReturn2(t2, e2) {
  if (e2 && ("object" == _typeof5(e2) || "function" == typeof e2)) return e2;
  if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized2(t2);
}
function _assertThisInitialized2(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function _inherits2(t2, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), Object.defineProperty(t2, "prototype", { writable: false }), e2 && _setPrototypeOf2(t2, e2);
}
function _wrapNativeSuper(t2) {
  var r2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t3) {
    if (null === t3 || !_isNativeFunction(t3)) return t3;
    if ("function" != typeof t3) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r2) {
      if (r2.has(t3)) return r2.get(t3);
      r2.set(t3, Wrapper);
    }
    function Wrapper() {
      return _construct(t3, arguments, _getPrototypeOf2(this).constructor);
    }
    return Wrapper.prototype = Object.create(t3.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf2(Wrapper, t3);
  }, _wrapNativeSuper(t2);
}
function _construct(t2, e2, r2) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o4 = [null];
  o4.push.apply(o4, e2);
  var p2 = new (t2.bind.apply(t2, o4))();
  return r2 && _setPrototypeOf2(p2, r2.prototype), p2;
}
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _isNativeFunction(t2) {
  try {
    return -1 !== Function.toString.call(t2).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t2;
  }
}
function _setPrototypeOf2(t2, e2) {
  return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, _setPrototypeOf2(t2, e2);
}
function _getPrototypeOf2(t2) {
  return _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, _getPrototypeOf2(t2);
}
var AggregatedError = function(_Error) {
  function AggregatedError2() {
    var _this;
    var errors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    _classCallCheck2(this, AggregatedError2);
    _this = _callSuper(this, AggregatedError2, [message]);
    _this.errors = errors;
    return _this;
  }
  _inherits2(AggregatedError2, _Error);
  return _createClass2(AggregatedError2);
}(_wrapNativeSuper(Error));
var anyPonyfill = function anyPonyfill2(iterable) {
  var exceptions = [];
  return new Promise(function(resolve4, reject3) {
    var onReject3 = function onReject4(e2) {
      exceptions.push(e2);
      if (exceptions.length === iterable.length) {
        reject3(new AggregatedError(exceptions));
      }
    };
    map_default(function(p2) {
      return resolveP_default(p2).then(resolve4)["catch"](onReject3);
    }, _toConsumableArray3(iterable));
  });
};
var Promise_any_default = anyPonyfill;

// node_modules/ramda-adjunct/es/anyP.js
var anyPPonyfill = curryN_default(1, Promise_any_default);
var anyP = isFunction_default(Promise.any) ? curryN_default(1, bind_default(Promise.any, Promise)) : anyPPonyfill;

// node_modules/ramda-adjunct/es/internal/compareLength.js
var compareLength = curry_default(function(comparator3, value, list4) {
  return compose2(comparator3(value), length_default)(list4);
});
var compareLength_default = compareLength;

// node_modules/ramda-adjunct/es/lengthEq.js
var lengthEq = compareLength_default(equals_default);
var lengthEq_default = lengthEq;

// node_modules/ramda-adjunct/es/lengthGte.js
var lengthGte = compareLength_default(flip_default(gte_default));
var lengthGte_default = lengthGte;

// node_modules/ramda-adjunct/es/lastP.js
function _toConsumableArray4(r2) {
  return _arrayWithoutHoles4(r2) || _iterableToArray4(r2) || _unsupportedIterableToArray4(r2) || _nonIterableSpread4();
}
function _nonIterableSpread4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray4(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray4(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray4(r2, a2) : void 0;
  }
}
function _iterableToArray4(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles4(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray4(r2);
}
function _arrayLikeToArray4(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}
var lastP = curryN_default(1, function(iterable) {
  var fulfilled = [];
  var rejected = [];
  var onFulfill3 = bind_default(fulfilled.push, fulfilled);
  var onReject3 = bind_default(rejected.push, rejected);
  var listOfPromises = map_default(function(p2) {
    return resolveP_default(p2).then(onFulfill3)["catch"](onReject3);
  }, _toConsumableArray4(iterable));
  return allP_default(listOfPromises).then(function() {
    if (lengthEq_default(0, fulfilled) && lengthEq_default(0, rejected)) {
      return void 0;
    }
    if (lengthGte_default(1, fulfilled)) {
      return last_default(fulfilled);
    }
    return rejectP_default(rejected);
  });
});

// node_modules/ramda-adjunct/es/defaultWhen.js
var defaultWhen = curry_default(function(predicate, defaultVal, val) {
  return predicate(val) ? defaultVal : val;
});
var defaultWhen_default = defaultWhen;

// node_modules/ramda-adjunct/es/mapIndexed.js
var mapIndexed = addIndex_default(map_default);
var mapIndexed_default = mapIndexed;

// node_modules/ramda-adjunct/es/fnull.js
var fnull = curry_default(function(fn2, defaults2) {
  return curryN_default(fn2.length, function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var argsWithDefaults = mapIndexed_default(function(val, idx) {
      return defaultWhen_default(isNil_default, defaults2[idx], val);
    }, args);
    return apply_default(fn2, argsWithDefaults);
  });
});

// node_modules/ramda-adjunct/es/reduceIndexed.js
var reduceIndexed = addIndex_default(reduce_default);

// node_modules/ramda-adjunct/es/filterIndexed.js
var filterIndexed = addIndex_default(filter_default);

// node_modules/ramda-adjunct/es/pickIndexes.js
var filterIndexed2 = addIndex_default(filter_default);
var containsIndex = curry_default(function(indexes, val, index) {
  return includes_default(index, indexes);
});
var pickIndexes = curry_default(function(indexes, list4) {
  return filterIndexed2(containsIndex(indexes), list4);
});

// node_modules/ramda-adjunct/es/list.js
var list = unapply_default(identity_default);
var list_default = list;

// node_modules/ramda-adjunct/es/ensureArray.js
var ensureArray = when_default(isNotArray_default, of_default(Array));

// node_modules/ramda-adjunct/es/concatAll.js
var leftIdentitySemigroup = {
  concat: identity_default
};
var concatAll = pipe(reduce_default(concat_default, leftIdentitySemigroup), when_default(identical_default(leftIdentitySemigroup), stubUndefined_default));

// node_modules/ramda-adjunct/es/concatRight.js
var concatRight = flip_default(concat_default);

// node_modules/ramda-adjunct/es/reduceP.js
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray5(r2, e2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray5(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray5(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray5(r2, a2) : void 0;
  }
}
function _arrayLikeToArray5(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n, i2, u2, a2 = [], f2 = true, o4 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f2 = false;
      } else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o4 = true, n = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o4) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
var reduceP = curryN_default(3, function(fn2, acc, list4) {
  return resolveP_default(list4).then(function(iterable) {
    var listLength = length_default(iterable);
    if (listLength === 0) {
      return acc;
    }
    var reducer = reduce_default(function(accP, currentValueP) {
      return accP.then(function(previousValue) {
        return allP_default([previousValue, currentValueP]);
      }).then(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), previousValue = _ref2[0], currentValue = _ref2[1];
        if (isUndefined_default(previousValue) && listLength === 1) {
          return currentValue;
        }
        return fn2(previousValue, currentValue);
      });
    });
    return reducer(resolveP_default(acc), iterable);
  });
});

// node_modules/ramda-adjunct/es/reduceRightP.js
function _slicedToArray2(r2, e2) {
  return _arrayWithHoles2(r2) || _iterableToArrayLimit2(r2, e2) || _unsupportedIterableToArray6(r2, e2) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray6(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray6(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray6(r2, a2) : void 0;
  }
}
function _arrayLikeToArray6(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}
function _iterableToArrayLimit2(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e2, n, i2, u2, a2 = [], f2 = true, o4 = false;
    try {
      if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2) return;
        f2 = false;
      } else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
    } catch (r3) {
      o4 = true, n = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
      } finally {
        if (o4) throw n;
      }
    }
    return a2;
  }
}
function _arrayWithHoles2(r2) {
  if (Array.isArray(r2)) return r2;
}
var flipArgs = pipe(reduceRight_default(concat_default, ""), equals_default("ba"))(["a", "b"]);
var reduceRightP = curryN_default(3, function(fn2, acc, list4) {
  return resolveP_default(list4).then(function(iterable) {
    var listLength = length_default(iterable);
    if (listLength === 0) {
      return acc;
    }
    var reducer = reduceRight_default(function(arg1, arg2) {
      var accP;
      var currentValueP;
      if (flipArgs) {
        accP = arg1;
        currentValueP = arg2;
      } else {
        accP = arg2;
        currentValueP = arg1;
      }
      return accP.then(function(previousValue) {
        return allP_default([previousValue, currentValueP]);
      }).then(function(_ref) {
        var _ref2 = _slicedToArray2(_ref, 2), previousValue = _ref2[0], currentValue = _ref2[1];
        if (isUndefined_default(previousValue) && listLength === 1) {
          return currentValue;
        }
        return fn2(currentValue, previousValue);
      });
    });
    return reducer(resolveP_default(acc), iterable);
  });
});

// node_modules/ramda-adjunct/es/sliceFrom.js
var sliceFrom = slice_default(__default, Infinity);

// node_modules/ramda-adjunct/es/sliceTo.js
var sliceTo = slice_default(0);

// node_modules/ramda-adjunct/es/omitIndexes.js
var rejectIndexed = addIndex_default(reject_default);
var containsIndex2 = curry_default(function(indexes, val, index) {
  return includes_default(index, indexes);
});
var omitIndexes = curry_default(function(indexes, list4) {
  return rejectIndexed(containsIndex2(indexes), list4);
});

// node_modules/ramda-adjunct/es/compact.js
var compact = reject_default(isFalsy_default);

// node_modules/ramda-adjunct/es/appendFlipped.js
var appendFlipped = flip_default(append_default);

// node_modules/ramda-adjunct/es/included.js
var included = flip_default(includes_default);
var included_default = included;

// node_modules/ramda-adjunct/es/move.js
var move2 = curry_default(function(fromIdx, toIdx, list4) {
  return compose2(insert_default(toIdx, nth_default(fromIdx, list4)), remove_default(fromIdx, 1))(list4);
});

// node_modules/ramda-adjunct/es/lengthGt.js
var lengthGt = compareLength_default(flip_default(gt_default));

// node_modules/ramda-adjunct/es/lengthLt.js
var lengthLt = compareLength_default(flip_default(lt_default));

// node_modules/ramda-adjunct/es/lengthLte.js
var lengthLte = compareLength_default(flip_default(lte_default));
var lengthLte_default = lengthLte;

// node_modules/ramda-adjunct/es/lengthNotEq.js
var lengthNotEq = compareLength_default(complement_default(equals_default));

// node_modules/ramda-adjunct/es/allEqual.js
var allEqual = curryN_default(1, pipe(uniq_default, lengthLte_default(1)));

// node_modules/ramda-adjunct/es/internal/ponyfills/String.repeat.js
var repeat4 = function repeat5(value, count2) {
  var validCount = Number(count2);
  if (validCount !== count2) {
    validCount = 0;
  }
  if (isNegative_default(validCount)) {
    throw new RangeError("repeat count must be non-negative");
  }
  if (isNotFinite_default(validCount)) {
    throw new RangeError("repeat count must be less than infinity");
  }
  validCount = Math.floor(validCount);
  if (value.length === 0 || validCount === 0) {
    return "";
  }
  if (value.length * validCount >= 1 << 28) {
    throw new RangeError("repeat count must not overflow maximum string size");
  }
  var maxCount = value.length * validCount;
  validCount = Math.floor(Math.log(validCount) / Math.log(2));
  var result = value;
  while (validCount) {
    result += value;
    validCount -= 1;
  }
  result += result.substring(0, maxCount - result.length);
  return result;
};
var String_repeat_default = repeat4;

// node_modules/ramda-adjunct/es/repeatStr.js
var repeatStrPonyfill = curry_default(String_repeat_default);
var repeatStrInvoker = flip_default(invoker_default(1, "repeat"));
var repeatStr = isFunction_default(String.prototype.repeat) ? repeatStrInvoker : repeatStrPonyfill;

// node_modules/ramda-adjunct/es/allIdentical.js
var allIdentical = curryN_default(1, pipe(uniqWith_default(identical_default), lengthLte_default(1)));

// node_modules/ramda-adjunct/es/allIdenticalTo.js
var allIdenticalTo = curry_default(function(val, list4) {
  return all_default(identical_default(val), list4);
});

// node_modules/ramda-adjunct/es/allEqualTo.js
var allEqualTo = curry_default(function(val, list4) {
  return all_default(equals_default(val), list4);
});

// node_modules/ramda-adjunct/es/internal/makeFlat.js
var makeFlat = function makeFlat2(recursive) {
  return function flatt(list4) {
    var value;
    var jlen;
    var j2;
    var result = [];
    var idx = 0;
    while (idx < list4.length) {
      if (isArrayLike_default2(list4[idx])) {
        value = recursive ? flatt(list4[idx]) : list4[idx];
        j2 = 0;
        jlen = value.length;
        while (j2 < jlen) {
          result[result.length] = value[j2];
          j2 += 1;
        }
      } else {
        result[result.length] = list4[idx];
      }
      idx += 1;
    }
    return result;
  };
};
var makeFlat_default = makeFlat;

// node_modules/ramda-adjunct/es/flattenDepth.js
function _toConsumableArray5(r2) {
  return _arrayWithoutHoles5(r2) || _iterableToArray5(r2) || _unsupportedIterableToArray7(r2) || _nonIterableSpread5();
}
function _nonIterableSpread5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray7(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray7(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray7(r2, a2) : void 0;
  }
}
function _iterableToArray5(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles5(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray7(r2);
}
function _arrayLikeToArray7(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}
var flatten1 = makeFlat_default(false);
var flattenDepth = curry_default(function(depth, list4) {
  var currentDept = depth;
  var flatList = _toConsumableArray5(list4);
  while (currentDept > 0) {
    flatList = flatten1(flatList);
    currentDept -= 1;
  }
  return flatList;
});

// node_modules/ramda-adjunct/es/internal/ponyfills/Array.from.js
function _toConsumableArray6(r2) {
  return _arrayWithoutHoles6(r2) || _iterableToArray6(r2) || _unsupportedIterableToArray8(r2) || _nonIterableSpread6();
}
function _nonIterableSpread6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray8(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray8(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray8(r2, a2) : void 0;
  }
}
function _iterableToArray6(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithoutHoles6(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray8(r2);
}
function _arrayLikeToArray8(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}
var copyArray = function copyArray2(items, mapFn, thisArg) {
  var boundMapFn = isNotUndefined_default(thisArg) ? bind_default(mapFn, thisArg) : mapFn;
  return isNotUndefined_default(mapFn) ? _toConsumableArray6(items).map(boundMapFn) : _toConsumableArray6(items);
};
var fromArray = function fromArray2(items, mapFn, thisArg) {
  if (items == null) {
    throw new TypeError("Array.from requires an array-like object - not null or undefined");
  }
  if (isNotNil_default2(mapFn) && isNotFunction_default(mapFn)) {
    throw new TypeError("Array.from: when provided, the second argument must be a function");
  }
  if (isIterable_default(items)) {
    return copyArray(items, mapFn, thisArg);
  }
  return [];
};
var Array_from_default = fromArray;

// node_modules/ramda-adjunct/es/toArray.js
var fromPonyfill = curryN_default(1, Array_from_default);
var fromArray3 = isFunction_default(Array.from) ? curryN_default(1, Array.from) : fromPonyfill;
var toArray2 = ifElse_default(isIterable_default, fromArray3, values_default);

// node_modules/ramda-adjunct/es/allUnique.js
var allUnique = converge_default(lengthEq_default, [length_default, uniq_default]);
var allUnique_default = allUnique;

// node_modules/ramda-adjunct/es/notAllUnique.js
var notAllUnique = complement_default(allUnique_default);

// node_modules/ramda-adjunct/es/sortByProps.js
function _toArray(r2) {
  return _arrayWithHoles3(r2) || _iterableToArray7(r2) || _unsupportedIterableToArray9(r2) || _nonIterableRest3();
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray9(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray9(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray9(r2, a2) : void 0;
  }
}
function _arrayLikeToArray9(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}
function _iterableToArray7(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}
function _arrayWithHoles3(r2) {
  if (Array.isArray(r2)) return r2;
}
var sortByProps = curry_default(function(props3, list4) {
  var firstTruthy = function firstTruthy2(_ref) {
    var _ref2 = _toArray(_ref), head2 = _ref2[0], tail2 = _ref2.slice(1);
    return reduce_default(either_default, head2, tail2);
  };
  var makeComparator = function makeComparator2(propName) {
    return comparator_default(function(a2, b) {
      return lt_default(prop_default(propName, a2), prop_default(propName, b));
    });
  };
  return sort_default(firstTruthy(map_default(makeComparator, props3)), list4);
});
var sortByProps_default = sortByProps;

// node_modules/ramda-adjunct/es/sortByProp.js
var addValueInAnArray = append_default(__default, []);
var sortByProp = useWith_default(sortByProps_default, [addValueInAnArray, identity_default]);

// node_modules/ramda-adjunct/es/sortByPaths.js
var pathToAscendSort = pipe(path_default, ascend_default);
var mapPathsToAscendSort = map_default(pathToAscendSort);
var sortByPaths = useWith_default(sortWith_default, [mapPathsToAscendSort, identity_default]);

// node_modules/ramda-adjunct/es/skipTake.js
var skipTake = curry_default(function(n, list4) {
  return addIndex_default(filter_default)(pipe(nthArg_default(1), modulo_default(__default, n), identical_default(0)))(list4);
});

// node_modules/ramda-adjunct/es/floor.js
var floor = curryN_default(1, bind_default(Math.floor, Math));
var floor_default = floor;

// node_modules/ramda-adjunct/es/rangeStep.js
var rangeStep = curryN_default(3, function(step, from2, to2) {
  var callback = step === 0 ? always_default(from2) : function(n) {
    return from2 + step * n;
  };
  var rangeEnd = step === 0 ? to2 - from2 : floor_default((to2 - from2) / step);
  return map_default(callback, range_default(0, rangeEnd));
});

// node_modules/ramda-adjunct/es/findOr.js
var findOr = curry_default(function(defaultVal, fn2, list4) {
  return pipe(find_default(fn2), defaultTo_default(defaultVal))(list4);
});

// node_modules/ramda-adjunct/es/invokeArgs.js
var invokeArgs = curryN_default(3, function(mpath, args, obj) {
  var method = path_default(mpath, obj);
  var context2 = path_default(init_default(mpath), obj);
  if (isNotFunction_default(method)) return void 0;
  if (isEmptyArray_default(mpath)) return void 0;
  var boundMethod = bind_default(method, context2);
  return apply_default(boundMethod, args);
});
var invokeArgs_default = invokeArgs;

// node_modules/ramda-adjunct/es/invoke.js
var invoke = invokeArgs_default(__default, [], __default);

// node_modules/ramda-adjunct/es/paths.js
var paths3 = curry_default(function(ps2, obj) {
  return ap_default([path_default(__default, obj)], ps2);
});
var paths_default2 = paths3;

// node_modules/ramda-adjunct/es/renameKeysWith.js
var renameKeysWith = curry_default(function(fn2, obj) {
  return pipe(toPairs_default, map_default(over_default(lensIndex_default(0), fn2)), fromPairs_default)(obj);
});
var renameKeysWith_default = renameKeysWith;

// node_modules/ramda-adjunct/es/renameKeys.js
var valueOrKey = function valueOrKey2(keysMap) {
  return function(key57) {
    if (has_default(key57, keysMap)) {
      return keysMap[key57];
    }
    return key57;
  };
};
var renameKeys = curry_default(function(keysMap, obj) {
  return renameKeysWith_default(valueOrKey(keysMap), obj);
});
var renameKeys_default = renameKeys;

// node_modules/ramda-adjunct/es/renameKey.js
function _typeof6(o4) {
  "@babel/helpers - typeof";
  return _typeof6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof6(o4);
}
function _defineProperty2(e2, r2, t2) {
  return (r2 = _toPropertyKey2(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey2(t2) {
  var i2 = _toPrimitive2(t2, "string");
  return "symbol" == _typeof6(i2) ? i2 : i2 + "";
}
function _toPrimitive2(t2, r2) {
  if ("object" != _typeof6(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof6(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var renameKey = curry_default(function(oldKey, newKey, obj) {
  return renameKeys_default(_defineProperty2({}, oldKey, newKey), obj);
});

// node_modules/ramda-adjunct/es/renameKeyWith.js
var renameKeyWith = curry_default(function(fn2, key57, obj) {
  return renameKeysWith_default(when_default(equals_default(key57), fn2), obj);
});

// node_modules/ramda-adjunct/es/copyKeys.js
function _typeof7(o4) {
  "@babel/helpers - typeof";
  return _typeof7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof7(o4);
}
function ownKeys2(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e2);
    r2 && (o4 = o4.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o4);
  }
  return t2;
}
function _objectSpread(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys2(Object(t2), true).forEach(function(r3) {
      _defineProperty3(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys2(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function _defineProperty3(e2, r2, t2) {
  return (r2 = _toPropertyKey3(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey3(t2) {
  var i2 = _toPrimitive3(t2, "string");
  return "symbol" == _typeof7(i2) ? i2 : i2 + "";
}
function _toPrimitive3(t2, r2) {
  if ("object" != _typeof7(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof7(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var copyKeys = curryN_default(2, function(keysMap, obj) {
  return _objectSpread(_objectSpread({}, obj), renameKeys_default(keysMap, obj));
});

// node_modules/ramda-adjunct/es/mergeProps.js
var mergeProps = curryN_default(2, pipe(props_default, mergeAll_default));

// node_modules/ramda-adjunct/es/mergePaths.js
var mergePaths = curryN_default(2, pipe(paths_default2, mergeAll_default));

// node_modules/ramda-adjunct/es/mergePath.js
var mergePath = curry_default(function(path4, source, obj) {
  return over_default(lensPath_default(path4), mergeLeft_default(source), obj);
});
var mergePath_default = mergePath;

// node_modules/ramda-adjunct/es/mergeProp.js
var mergeProp = curry_default(function(p2, subj, obj) {
  return mergePath_default(of_default(Array, p2), subj, obj);
});

// node_modules/ramda-adjunct/es/omitBy.js
var omitBy = useWith_default(pickBy_default, [complement_default, identity_default]);

// node_modules/ramda-adjunct/es/pathOrLazy.js
var pathOrLazy = curryN_default(3, function(defaultFn, path4, obj) {
  return when_default(identical_default(defaultFn), partial_default(unary_default(defaultFn), [obj]), pathOr_default(defaultFn, path4, obj));
});

// node_modules/ramda-adjunct/es/viewOr.js
var viewOr = curryN_default(3, function(defaultValue, lens3, data) {
  return defaultTo_default(defaultValue, view_default(lens3, data));
});

// node_modules/ramda-adjunct/es/spreadPath.js
var spreadPath = curryN_default(2, converge_default(mergeRight_default, [dissocPath_default, pathOr_default({})]));
var spreadPath_default = spreadPath;

// node_modules/ramda-adjunct/es/spreadProp.js
var spreadProp = curry_default(function(prop3, obj) {
  return spreadPath_default(of_default(Array, prop3), obj);
});

// node_modules/ramda-adjunct/es/flattenPath.js
var flattenPath = curry_default(function(path4, obj) {
  return mergeRight_default(obj, pathOr_default({}, path4, obj));
});
var flattenPath_default = flattenPath;

// node_modules/ramda-adjunct/es/flattenProp.js
var flattenProp = curry_default(function(prop3, obj) {
  return flattenPath_default(of_default(Array, prop3), obj);
});

// node_modules/ramda-adjunct/es/unzipObjWith.js
var unzipObjWith = curryN_default(2, function(fn2, obj) {
  return pipe(toPairs_default, map_default(pipe(flip_default, apply_default)(fn2)), transpose_default, when_default(lengthEq_default(0), function() {
    return [[], []];
  }))(obj);
});

// node_modules/ramda-adjunct/es/zipObjWith.js
var zipObjWith = curryN_default(3, function(fn2, keys4, values3) {
  return pipe(zip_default, map_default(apply_default(fn2)), fromPairs_default)(values3, keys4);
});

// node_modules/ramda-adjunct/es/isPrototypeOf.js
var isPrototypeOf = curry_default(function(type5, object2) {
  return Boolean(invokeArgs_default(["prototype", "isPrototypeOf"], [object2], type5));
});

// node_modules/ramda-adjunct/es/lensEq.js
var lensEq = curryN_default(3, function(lens3, val, data) {
  return pipe(view_default(lens3), equals_default(val))(data);
});
var lensEq_default = lensEq;

// node_modules/ramda-adjunct/es/lensNotEq.js
var lensNotEq = complement_default(lensEq_default);

// node_modules/ramda-adjunct/es/lensSatisfies.js
var lensSatisfies = curryN_default(3, function(predicate, lens3, data) {
  return pipe(view_default(lens3), predicate, isTrue_default)(data);
});
var lensSatisfies_default = lensSatisfies;

// node_modules/ramda-adjunct/es/lensNotSatisfy.js
var lensNotSatisfy = complement_default(lensSatisfies_default);

// node_modules/ramda-adjunct/es/fantasy-land/util.js
var type4 = either_default(path_default(["@@type"]), path_default(["constructor", "@@type"]));
var typeEquals = curry_default(function(typeIdent, monad) {
  return type4(monad) === typeIdent;
});
var isSameType = curryN_default(2, useWith_default(equals_default, [type4, type4]));
var isNotSameType = complement_default(isSameType);

// node_modules/ramda-adjunct/es/fantasy-land/traits.js
function _typeof8(o4) {
  "@babel/helpers - typeof";
  return _typeof8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof8(o4);
}
function _defineProperty4(e2, r2, t2) {
  return (r2 = _toPropertyKey4(r2)) in e2 ? Object.defineProperty(e2, r2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[r2] = t2, e2;
}
function _toPropertyKey4(t2) {
  var i2 = _toPrimitive4(t2, "string");
  return "symbol" == _typeof8(i2) ? i2 : i2 + "";
}
function _toPrimitive4(t2, r2) {
  if ("object" != _typeof8(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof8(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var functorTrait = _defineProperty4({}, map4, function(fn2) {
  return this.constructor[of3](fn2(this.value));
});
var applyTrait = _defineProperty4({}, ap3, function(applyWithFn) {
  var _this = this;
  return applyWithFn.map(function(fn2) {
    return fn2(_this.value);
  });
});
var setoidTrait = _defineProperty4({}, equals3, function(setoid) {
  return isSameType(this, setoid) && equals_default(this.value, setoid.value);
});
var semigroupTrait = _defineProperty4({}, concat3, function(semigroup) {
  var concatenatedValue = this.value;
  if (isString_default(this.value) || isNumber_default(this.value)) {
    concatenatedValue = this.value + semigroup.value;
  } else if (pathSatisfies_default(isFunction_default, ["value", concat3], this)) {
    concatenatedValue = this.value[concat3](semigroup.value);
  } else if (pathSatisfies_default(isFunction_default, ["value", "concat"], this)) {
    concatenatedValue = this.value.concat(semigroup.value);
  }
  return this.constructor[of3](concatenatedValue);
});
var chainTrait = _defineProperty4({}, chain3, function(fn2) {
  var newChain = fn2(this.value);
  return isSameType(this, newChain) ? newChain : this;
});
var ordTrait = _defineProperty4({}, lte3, function(ord) {
  return isSameType(this, ord) && (this.value < ord.value || this[equals3](ord));
});

// node_modules/ramda-adjunct/es/fantasy-land/Identity.js
function _typeof9(o4) {
  "@babel/helpers - typeof";
  return _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof9(o4);
}
function _classCallCheck3(a2, n) {
  if (!(a2 instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties3(e2, r2) {
  for (var t2 = 0; t2 < r2.length; t2++) {
    var o4 = r2[t2];
    o4.enumerable = o4.enumerable || false, o4.configurable = true, "value" in o4 && (o4.writable = true), Object.defineProperty(e2, _toPropertyKey5(o4.key), o4);
  }
}
function _createClass3(e2, r2, t2) {
  return r2 && _defineProperties3(e2.prototype, r2), t2 && _defineProperties3(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
}
function _toPropertyKey5(t2) {
  var i2 = _toPrimitive5(t2, "string");
  return "symbol" == _typeof9(i2) ? i2 : i2 + "";
}
function _toPrimitive5(t2, r2) {
  if ("object" != _typeof9(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof9(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
var Identity2 = function(_fl$of, _fl$ap, _fl$map, _fl$equals, _fl$concat, _fl$chain, _fl$lte, _fl$empty, _fl$contramap) {
  function Identity3(value) {
    _classCallCheck3(this, Identity3);
    this.value = value;
  }
  return _createClass3(Identity3, [{
    key: "get",
    value: function get3() {
      return this.value;
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#apply|Apply} specification.
     *
     * @sig ap :: Apply f => f a ~> f (a -> b) -> f b
     * @param {RA.Identity} applyWithFn
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of(1);
     * const b = Identity.of(1).map(a => b => a + b);
     *
     * a.ap(b); //=> Identity(2)
     */
  }, {
    key: _fl$ap,
    value: function value(applyWithFn) {
      return applyTrait[ap3].call(this, applyWithFn);
    }
  }, {
    key: "ap",
    value: function ap5(applyWithFn) {
      return this[ap3](applyWithFn);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#functor|Functor} specification.
     *
     * @sig map :: Functor f => f a ~> (a -> b) -> f b
     * @param {Function} fn
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of(1);
     * a.map(a => a + 1); //=> Identity(2)
     */
  }, {
    key: _fl$map,
    value: function value(fn2) {
      return functorTrait[map4].call(this, fn2);
    }
  }, {
    key: "map",
    value: function map5(fn2) {
      return this[map4](fn2);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#setoid|Setoid} specification.
     *
     * @sig equals :: Setoid a => a ~> a -> Boolean
     * @param {RA.Identity} setoid
     * @return {boolean}
     * @example
     *
     * const a = Identity.of(1);
     * const b = Identity.of(1);
     * const c = Identity.of(2);
     *
     * a.equals(b); //=> true
     * a.equals(c); //=> false
     */
  }, {
    key: _fl$equals,
    value: function value(setoid) {
      return setoidTrait[equals3].call(this, setoid);
    }
  }, {
    key: "equals",
    value: function equals4(setoid) {
      return this[equals3](setoid);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#semigroup|Semigroup} specification.
     *
     * @sig concat :: Semigroup a => a ~> a -> a
     * @param {RA.Identity} semigroup
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of(1);
     * const b = Identity.of(1);
     * a.concat(b); //=> 2
     *
     * const c = Identity.of('c');
     * const d = Identity.of('d');
     * c.concat(d); //=> 'cd'
     *
     * const e = Identity.of(['e']);
     * const f = Identity.of(['f']);
     * e.concat(f); //=> ['e', 'f']
     */
  }, {
    key: _fl$concat,
    value: function value(semigroup) {
      return semigroupTrait[concat3].call(this, semigroup);
    }
  }, {
    key: "concat",
    value: function concat4(semigroup) {
      return this[concat3](semigroup);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#chain|Chain} specification.
     *
     * @sig chain :: Chain m => m a ~> (a -> m b) -> m b
     * @param {Function} fn Function returning the value of the same {@link https://github.com/fantasyland/fantasy-land#semigroup|Chain}
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of(1);
     * const fn = val => Identity.of(val + 1);
     *
     * a.chain(fn).chain(fn); //=> Identity(3)
     */
  }, {
    key: _fl$chain,
    value: function value(fn2) {
      return chainTrait[chain3].call(this, fn2);
    }
  }, {
    key: "chain",
    value: function chain4(fn2) {
      return this[chain3](fn2);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#ord|Ord} specification.
     *
     * @sig lte :: Ord a => a ~> a -> Boolean
     * @param {RA.Identity} ord
     * @return {boolean}
     * @example
     *
     * const a = Identity.of(1);
     * const b = Identity.of(1);
     * const c = Identity.of(2);
     *
     * a.lte(b); //=> true
     * a.lte(c); //=> true
     * c.lte(a); //=> false
     */
  }, {
    key: _fl$lte,
    value: function value(ord) {
      return ordTrait[lte3].call(this, ord);
    }
  }, {
    key: "lte",
    value: function lte4(ord) {
      return this[lte3](ord);
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#monoid|Monoid*} specification.
     * Partial implementation of Monoid specification. `empty` method on instance only, returning
     * identity value of the wrapped type. Using `R.empty` under the hood.
     *
     *
     * @sig empty :: Monoid m => () -> m
     * @return {RA.Identity}
     * @example
     *
     * const a = Identity.of('test');
     * const i = a.empty();
     *
     * a.concat(i); //=> Identity('string');
     * i.concat(a); //=> Identity('string');
     */
  }, {
    key: _fl$empty,
    value: function value() {
      return this.constructor.of(empty_default(this.value));
    }
  }, {
    key: "empty",
    value: function empty4() {
      return this[empty3]();
    }
    /**
     * Fantasy land {@link https://github.com/fantasyland/fantasy-land#contravariant|Contravariant} specification.
     *
     * @sig contramap :: Contravariant f => f a ~> (b -> a) -> f b
     * @param {Function} fn
     * @return {RA.Identity}
     * @example
     *
     * const identity = a => a;
     * const add1 = a => a + 1;
     * const divide2 = a => a / 2;
     *
     * Identity.of(divide2).contramap(add1).get()(3); //=> 2
     * Identity.of(identity).contramap(divide2).contramap(add1).get()(3); //=> 2
     * Identity.of(identity).contramap(a => divide2(add1(a))).get()(3); //=> 2
     */
  }, {
    key: _fl$contramap,
    value: function value(fn2) {
      var _this = this;
      return this.constructor.of(function(value2) {
        return _this.value(fn2(value2));
      });
    }
  }, {
    key: "contramap",
    value: function contramap2(fn2) {
      return this[contramap](fn2);
    }
  }], [{
    key: _fl$of,
    value: (
      /**
       * Fantasy land {@link https://github.com/fantasyland/fantasy-land#applicative|Applicative} specification.
       *
       * @static
       * @sig of :: Applicative f => a -> f a
       * @param {*} value
       * @returns {RA.Identity}
       * @example
       *
       * const a = Identity.of(1); //=> Identity(1)
       */
      function value(_value2) {
        return new Identity3(_value2);
      }
    )
  }, {
    key: "of",
    value: function of4(value) {
      return new Identity3(value);
    }
    /**
     * @static
     */
  }, {
    key: "@@type",
    get: function get3() {
      return "RA/Identity";
    }
  }]);
}(of3, ap3, map4, equals3, concat3, chain3, lte3, empty3, contramap);
var Identity_default = Identity2;

// node_modules/ramda-adjunct/es/lensTraverse.js
var lensTraverse = curryN_default(1, function(F2) {
  var of4 = typeof F2["fantasy-land/of"] === "function" ? F2["fantasy-land/of"] : typeof F2.of === "function" ? F2.of : F2;
  var TypeRep = {
    "fantasy-land/of": of4
  };
  return curry_default(function(toFunctorFn, target) {
    return Identity_default.of(traverse_default(TypeRep, pipe(toFunctorFn, prop_default("value")), target));
  });
});

// node_modules/ramda-adjunct/es/lensIso.js
var isomorphic = function isomorphic2(to2, from2) {
  var isomorphism = function isomorphism2(x2) {
    return to2(x2);
  };
  isomorphism.from = from2;
  return isomorphism;
};
var isomorphisms = function isomorphisms2(to2, from2) {
  return isomorphic(curry_default(function(toFunctorFn, target) {
    return map_default(from2, toFunctorFn(to2(target)));
  }), curry_default(function(toFunctorFn, target) {
    return map_default(to2, toFunctorFn(from2(target)));
  }));
};
var from = curry_default(function(isomorphism, x2) {
  return isomorphism.from(x2);
});
var lensIso = curry_default(isomorphisms);
lensIso.from = from;

// node_modules/ramda-adjunct/es/propNotEq.js
var propNotEq = complement_default(propEq_default);

// node_modules/ramda-adjunct/es/pathNotEq.js
var pathNotEq = complement_default(pathEq_default);

// node_modules/ramda-adjunct/es/inRange.js
var inRangeImp = ifElse_default(gte_default, function() {
  throw new Error("low must not be greater than high in inRange(low, high, value)");
}, useWith_default(both_default, [lte_default, gt_default]));
var inRange_default = curry_default(function(low, high, value) {
  return inRangeImp(low, high)(value);
});

// node_modules/ramda-adjunct/es/notEqual.js
var notEqual = complement_default(equals_default);

// node_modules/ramda-adjunct/es/overlaps.js
var overlaps = curryN_default(2, function(list1, list22) {
  if (isEmpty_default(list1)) {
    return true;
  }
  return pipe(intersection_default, isNotEmpty_default)(list1, list22);
});

// node_modules/ramda-adjunct/es/notBoth.js
var notBoth = curry_default(compose2(complement_default, both_default));

// node_modules/ramda-adjunct/es/nand.js
var nand = complement_default(and_default);

// node_modules/ramda-adjunct/es/neither.js
var neither = curry_default(compose2(complement_default, either_default));
var neither_default = neither;

// node_modules/ramda-adjunct/es/nor.js
var nor = complement_default(or_default);

// node_modules/ramda-adjunct/es/notAllPass.js
var notAllPass = curry_default(compose2(complement_default, allPass_default));

// node_modules/ramda-adjunct/es/nonePass.js
var nonePass = curryN_default(1, compose2(complement_default, anyPass_default));

// node_modules/ramda-adjunct/es/argsPass.js
var argsPass = curry_default(function(combiningPredicate, predicates) {
  return useWith_default(compose2(combiningPredicate(isTruthy_default), list_default), predicates);
});

// node_modules/ramda-adjunct/es/dropArgs.js
var dropArgs = nAry_default(0);

// node_modules/ramda-adjunct/es/round.js
var round = curryN_default(1, bind_default(Math.round, Math));

// node_modules/ramda-adjunct/es/ceil.js
var ceil = curryN_default(1, bind_default(Math.ceil, Math));

// node_modules/ramda-adjunct/es/divideNum.js
var divideNum = flip_default(divide_default);

// node_modules/ramda-adjunct/es/internal/ponyfills/Math.trunc.js
var truncPonyfill = function truncPonyfill2(v2) {
  var numV = Number(v2);
  if (!isFinite_default(numV)) {
    return numV;
  }
  return numV - numV % 1 || (numV < 0 ? -0 : numV === 0 ? numV : 0);
};
var Math_trunc_default = truncPonyfill;

// node_modules/ramda-adjunct/es/trunc.js
var truncPonyfill3 = curryN_default(1, Math_trunc_default);
var trunc = isFunction_default(Math.trunc) ? curryN_default(1, bind_default(Math.trunc, Math)) : truncPonyfill3;

// node_modules/ramda-adjunct/es/internal/ponyfills/Math.sign.js
var signPonyfill = function signPonyfill2(number) {
  return (number > 0) - (number < 0) || +number;
};
var Math_sign_default = signPonyfill;

// node_modules/ramda-adjunct/es/sign.js
var signPonyfill3 = curryN_default(1, Math_sign_default);
var sign = isFunction_default(Math.sign) ? curryN_default(1, bind_default(Math.sign, Math)) : signPonyfill3;

// node_modules/ramda-adjunct/es/subtractNum.js
var subtractNum = flip_default(subtract_default);

// node_modules/ramda-adjunct/es/internal/isCoercible.js
var isCoercible = neither_default(isSymbol_default, both_default(isObj_default, neither_default(hasIn_default("toString"), hasIn_default("valueOf"))));
var isCoercible_default = isCoercible;

// node_modules/ramda-adjunct/es/toNumber.js
var toNumber = ifElse_default(isCoercible_default, Number, always_default(NaN));

// node_modules/ramda-adjunct/es/escapeRegExp.js
var escapeRegExp = when_default(isString_default, replace_default(/[.*+?^${}()|[\]\\-]/g, "\\$&"));
var escapeRegExp_default = escapeRegExp;

// node_modules/ramda-adjunct/es/internal/ponyfills/String.replaceAll.js
var checkArguments = function checkArguments2(searchValue, replaceValue, str2) {
  if (str2 == null || searchValue == null || replaceValue == null) {
    throw TypeError("Input values must not be `null` or `undefined`");
  }
};
var checkValue = function checkValue2(value, valueName) {
  if (typeof value !== "string") {
    if (!(value instanceof String)) {
      throw TypeError("`".concat(valueName, "` must be a string"));
    }
  }
};
var checkSearchValue = function checkSearchValue2(searchValue) {
  if (typeof searchValue !== "string" && !(searchValue instanceof String) && !(searchValue instanceof RegExp)) {
    throw TypeError("`searchValue` must be a string or an regexp");
  }
};
var replaceAll = function replaceAll2(searchValue, replaceValue, str2) {
  checkArguments(searchValue, replaceValue, str2);
  checkValue(str2, "str");
  checkValue(replaceValue, "replaceValue");
  checkSearchValue(searchValue);
  var regexp = new RegExp(isRegExp_default(searchValue) ? searchValue : escapeRegExp_default(searchValue), "g");
  return replace_default(regexp, replaceValue, str2);
};
var String_replaceAll_default = replaceAll;

// node_modules/ramda-adjunct/es/replaceAll.js
var replaceAllPonyfill = curryN_default(3, String_replaceAll_default);
var replaceAllInvoker = invoker_default(2, "replaceAll");
var replaceAll3 = isFunction_default(String.prototype.replaceAll) ? replaceAllInvoker : replaceAllPonyfill;
var replaceAll_default = replaceAll3;

// node_modules/ramda-adjunct/es/internal/ponyfills/String.trimStart.js
var trimStart = replace_default(/^[\s\uFEFF\xA0]+/, "");
var String_trimStart_default = trimStart;

// node_modules/ramda-adjunct/es/trimStart.js
var trimStartPonyfill = String_trimStart_default;
var trimStartInvoker = invoker_default(0, "trimStart");
var trimStart2 = isFunction_default(String.prototype.trimStart) ? trimStartInvoker : trimStartPonyfill;
var trimStart_default = trimStart2;

// node_modules/ramda-adjunct/es/internal/ponyfills/String.trimEnd.js
var trimStart3 = replace_default(/[\s\uFEFF\xA0]+$/, "");
var String_trimEnd_default = trimStart3;

// node_modules/ramda-adjunct/es/trimEnd.js
var trimEndPonyfill = String_trimEnd_default;
var trimEndInvoker = invoker_default(0, "trimEnd");
var trimEnd = isFunction_default(String.prototype.trimEnd) ? trimEndInvoker : trimEndPonyfill;

// node_modules/ramda-adjunct/es/trimCharsEnd.js
var trimCharsEnd = curry_default(function(chars, value) {
  return pipe(split_default(""), dropLastWhile_default(included_default(chars)), join_default(""))(value);
});
var trimCharsEnd_default = trimCharsEnd;

// node_modules/ramda-adjunct/es/trimCharsStart.js
var trimCharsStart = curry_default(function(chars, value) {
  return pipe(split_default(""), dropWhile_default(included_default(chars)), join_default(""))(value);
});
var trimCharsStart_default = trimCharsStart;

// node_modules/ramda-adjunct/es/internal/ponyfills/String.padStart.js
var padStartPonyfill = function padStartPonyfill2(padString, targetLength, value) {
  var finalLength = targetLength >> 0;
  var finalPadString = String(isNotUndefined_default(padString) ? padString : " ");
  if (value.length >= finalLength) {
    return String(value);
  }
  finalLength -= value.length;
  if (finalLength > finalPadString.length) {
    var lenghtToPad = finalLength / finalPadString.length;
    finalPadString += isFunction_default(String.prototype.repeat) ? finalPadString.repeat(lenghtToPad) : String_repeat_default(finalPadString, lenghtToPad);
  }
  return finalPadString.slice(0, finalLength) + String(value);
};
var String_padStart_default = padStartPonyfill;

// node_modules/ramda-adjunct/es/padCharsStart.js
var padStartInvoker = flip_default(invoker_default(2, "padStart"));
var padStartPonyfill3 = curry_default(String_padStart_default);
var padCharsStart = isFunction_default(String.prototype.padStart) ? padStartInvoker : padStartPonyfill3;
var padCharsStart_default = padCharsStart;

// node_modules/ramda-adjunct/es/internal/ponyfills/String.padEnd.js
var padEndPonyfill = function padEndPonyfill2(padString, targetLength, value) {
  var finalLength = targetLength >> 0;
  var finalPadString = String(isNotUndefined_default(padString) ? padString : " ");
  if (value.length > finalLength) {
    return String(value);
  }
  finalLength -= value.length;
  if (finalLength > finalPadString.length) {
    var remainingLength = finalLength / finalPadString.length;
    finalPadString += isFunction_default(String.prototype.repeat) ? finalPadString.repeat(remainingLength) : String_repeat_default(finalPadString, remainingLength);
  }
  return String(value) + finalPadString.slice(0, finalLength);
};
var String_padEnd_default = padEndPonyfill;

// node_modules/ramda-adjunct/es/padCharsEnd.js
var padEndPonyfill3 = curry_default(String_padEnd_default);
var padEndInvoker = flip_default(invoker_default(2, "padEnd"));
var padCharsEnd = isFunction_default(String.prototype.padEnd) ? padEndInvoker : padEndPonyfill3;
var padCharsEnd_default = padCharsEnd;

// node_modules/ramda-adjunct/es/padEnd.js
var padEnd = padCharsEnd_default(" ");

// node_modules/ramda-adjunct/es/padStart.js
var padStart2 = padCharsStart_default(" ");

// node_modules/@swagger-api/apidom-reference/src/util/url.mjs
var url_exports = {};
__export(url_exports, {
  cwd: () => cwd,
  fromFileSystemPath: () => fromFileSystemPath,
  getExtension: () => getExtension,
  getHash: () => getHash,
  getProtocol: () => getProtocol,
  hasProtocol: () => hasProtocol,
  isFileSystemPath: () => isFileSystemPath,
  isHttpUrl: () => isHttpUrl,
  isURI: () => isURI,
  resolve: () => resolve,
  sanitize: () => sanitize,
  stripHash: () => stripHash,
  toFileSystemPath: () => toFileSystemPath,
  unsanitize: () => unsanitize
});
var import_process = __toESM(require_browser(), 1);
var isWindows = () => pathSatisfies_default(test_default(/^win/), ["platform"], import_process.default);
var getProtocol = (url) => {
  try {
    const parsedUrl = new URL(url);
    return trimCharsEnd_default(":", parsedUrl.protocol);
  } catch {
    return void 0;
  }
};
var hasProtocol = pipe(getProtocol, isNotUndefined_default);
var getExtension = (url) => {
  const lastDotPosition = url.lastIndexOf(".");
  if (lastDotPosition >= 0) {
    return url.substring(lastDotPosition).toLowerCase();
  }
  return "";
};
var isFileSystemPath = (uri2) => {
  if (import_process.default.browser) {
    return false;
  }
  const protocol = getProtocol(uri2);
  return isUndefined_default(protocol) || protocol === "file" || /^[a-zA-Z]$/.test(protocol);
};
var isHttpUrl = (url) => {
  const protocol = getProtocol(url);
  return protocol === "http" || protocol === "https";
};
var isURI = (uri2) => {
  try {
    return new URL(uri2) && true;
  } catch {
    return false;
  }
};
var toFileSystemPath = (uri2, options) => {
  const urlDecodePatterns = [/%23/g, "#", /%24/g, "$", /%26/g, "&", /%2C/g, ",", /%40/g, "@"];
  const keepFileProtocol = propOr_default(false, "keepFileProtocol", options);
  const isWindowsPredicate = propOr_default(isWindows, "isWindows", options);
  let path4 = decodeURI(uri2);
  for (let i2 = 0; i2 < urlDecodePatterns.length; i2 += 2) {
    path4 = path4.replace(urlDecodePatterns[i2], urlDecodePatterns[i2 + 1]);
  }
  let isFileUrl = path4.substring(0, 7).toLowerCase() === "file://";
  if (isFileUrl) {
    path4 = path4[7] === "/" ? path4.substring(8) : path4.substring(7);
    if (isWindowsPredicate() && path4[1] === "/") {
      path4 = `${path4[0]}:${path4.substring(1)}`;
    }
    if (keepFileProtocol) {
      path4 = `file:///${path4}`;
    } else {
      isFileUrl = false;
      path4 = isWindowsPredicate() ? path4 : `/${path4}`;
    }
  }
  if (isWindowsPredicate() && !isFileUrl) {
    path4 = replaceAll_default("/", "\\", path4);
    if (path4.substring(1, 3) === ":\\") {
      path4 = path4[0].toUpperCase() + path4.substring(1);
    }
  }
  return path4;
};
var fromFileSystemPath = (uri2) => {
  const urlEncodePatterns = [/\?/g, "%3F", /#/g, "%23"];
  let path4 = uri2;
  if (isWindows()) {
    path4 = path4.replace(/\\/g, "/");
  }
  path4 = encodeURI(path4);
  for (let i2 = 0; i2 < urlEncodePatterns.length; i2 += 2) {
    path4 = path4.replace(urlEncodePatterns[i2], urlEncodePatterns[i2 + 1]);
  }
  return path4;
};
var getHash = (uri2) => {
  const hashIndex = uri2.indexOf("#");
  if (hashIndex !== -1) {
    return uri2.substring(hashIndex);
  }
  return "#";
};
var stripHash = (uri2) => {
  const hashIndex = uri2.indexOf("#");
  let hashStrippedUri = uri2;
  if (hashIndex >= 0) {
    hashStrippedUri = uri2.substring(0, hashIndex);
  }
  return hashStrippedUri;
};
var cwd = () => {
  if (import_process.default.browser) {
    return stripHash(globalThis.location.href);
  }
  const path4 = import_process.default.cwd();
  const lastChar = last_default(path4);
  if (["/", "\\"].includes(lastChar)) {
    return path4;
  }
  return path4 + (isWindows() ? "\\" : "/");
};
var resolve = (from2, to2) => {
  const resolvedUrl = new URL(to2, new URL(from2, "resolve://"));
  if (resolvedUrl.protocol === "resolve:") {
    const {
      pathname,
      search,
      hash
    } = resolvedUrl;
    return pathname + search + hash;
  }
  return resolvedUrl.toString();
};
var sanitize = (uri2) => {
  if (isFileSystemPath(uri2)) {
    return fromFileSystemPath(toFileSystemPath(uri2));
  }
  try {
    return new URL(uri2).toString();
  } catch {
    return encodeURI(decodeURI(uri2)).replace(/%5B/g, "[").replace(/%5D/g, "]");
  }
};
var unsanitize = (uri2) => {
  if (isFileSystemPath(uri2)) {
    return toFileSystemPath(uri2);
  }
  return decodeURI(uri2);
};

// node_modules/@swagger-api/apidom-reference/src/File.mjs
var File2 = class {
  constructor({
    uri: uri2,
    mediaType = "text/plain",
    data,
    parseResult
  }) {
    __publicField(this, "uri");
    __publicField(this, "mediaType");
    __publicField(this, "data");
    __publicField(this, "parseResult");
    this.uri = uri2;
    this.mediaType = mediaType;
    this.data = data;
    this.parseResult = parseResult;
  }
  get extension() {
    if (isString_default(this.uri)) {
      return getExtension(this.uri);
    }
    return "";
  }
  toString() {
    if (typeof this.data === "string") {
      return this.data;
    }
    if (this.data instanceof ArrayBuffer || ["ArrayBuffer"].includes(type_default(this.data)) || ArrayBuffer.isView(this.data)) {
      const textDecoder = new TextDecoder("utf-8");
      return textDecoder.decode(this.data);
    }
    return String(this.data);
  }
};
var File_default = File2;

// node_modules/@swagger-api/apidom-reference/src/ReferenceSet.mjs
var ReferenceSet = class {
  constructor({
    refs = [],
    circular = false
  } = {}) {
    __publicField(this, "rootRef");
    __publicField(this, "refs");
    __publicField(this, "circular");
    this.refs = [];
    this.circular = circular;
    refs.forEach(this.add.bind(this));
  }
  get size() {
    return this.refs.length;
  }
  add(reference) {
    if (!this.has(reference)) {
      this.refs.push(reference);
      this.rootRef = this.rootRef === void 0 ? reference : this.rootRef;
      reference.refSet = this;
    }
    return this;
  }
  merge(anotherRefSet) {
    for (const reference of anotherRefSet.values()) {
      this.add(reference);
    }
    return this;
  }
  has(thing) {
    const uri2 = isString_default(thing) ? thing : thing.uri;
    return isNotUndefined_default(this.find((ref) => ref.uri === uri2));
  }
  find(predicate) {
    return this.refs.find(predicate);
  }
  *values() {
    yield* this.refs;
  }
  clean() {
    this.refs.forEach((ref) => {
      ref.refSet = void 0;
    });
    this.rootRef = void 0;
    this.refs.length = 0;
  }
};
var ReferenceSet_default = ReferenceSet;

// node_modules/@swagger-api/apidom-reference/src/options/index.mjs
var defaultOptions = {
  parse: {
    /**
     * This is media type that will be used to parse the input.
     */
    mediaType: "text/plain",
    /**
     * Determines how different types of files will be parsed.
     *
     * You can add additional parsers of your own, replace an existing one with
     * your own implementation, or remove any resolver by removing it from the list.
     * It's recommended to keep the order of parser from most specific ones to most generic ones.
     */
    parsers: [],
    /**
     * These options are merged with parser plugin instance before the plugin is run.
     */
    parserOpts: {}
  },
  resolve: {
    /**
     * baseURI serves as a base for all relative URL found in ApiDOM references.
     */
    baseURI: "",
    /**
     * Determines how References will be resolved.
     *
     * You can add additional resolvers of your own, replace an existing one with
     * your own implementation, or remove any resolver by removing it from the list.
     */
    resolvers: [],
    /**
     * These options are merged with resolver plugin instance before the plugin is run.
     */
    resolverOpts: {},
    /**
     * Determines strategies how References are identified and processed by resolvers.
     * Strategy is determined by media type.
     *
     * You can add additional resolver strategies of your own, replace an existing one with
     * your own implementation, or remove any resolve strategy by removing it from the list.
     */
    strategies: [],
    /**
     * These options are available in resolver strategy `canResolve` and `resolve` methods.
     */
    strategyOpts: {},
    /**
     * Determines whether internal references will be resolved.
     * Internal references will simply be ignored.
     */
    internal: true,
    /**
     * Determines whether external references will be resolved.
     * If this option is disabled, then none of above resolvers will be called.
     * Instead, external references will simply be ignored.
     */
    external: true,
    /**
     * Determines the maximum depth of resolve algorithms.
     * By default, there is no limit.
     *
     * This option tracks the depth of the file tree not the depth of the dereference path.
     *
     * It can be set to any positive integer number or zero (0).
     *
     * The resolver should throw MaximumResolverDepthError if resolution depth
     * is exceeded by this option.
     */
    maxDepth: Infinity
  },
  dereference: {
    /**
     * Determines strategies how ApiDOM is dereferenced.
     * Strategy is determined by media type or by inspecting ApiDOM to be dereferenced.
     *
     * You can add additional dereference strategies of your own, replace an existing one with
     * your own implementation, or remove any dereference strategy by removing it from the list.
     */
    strategies: [],
    /**
     * These options are available in dereference strategy `canDereference` and `dereference` methods.
     */
    strategyOpts: {},
    /**
     * This option accepts an instance of pre-computed ReferenceSet.
     * If provided it will speed up the dereferencing significantly as the external
     * resolution doesn't need to happen anymore.
     */
    refSet: null,
    /**
     * Determines the maximum depth of dereferencing.
     * By default, there is no limit.
     *
     * The maxDepth represents a number of references that needed to be followed
     * before the eventual value was reached.
     *
     * It can be set to any positive integer number or zero (0).
     *
     * The dereferencing should throw MaximumDereferenceDepthError if dereferencing depth
     * is exceeded by this option.
     */
    maxDepth: Infinity,
    /**
     * Determines how circular references are handled.
     *
     * "ignore" - circular reference are allowed
     * "replace" - circular references are not allowed and are translated to RefElement
     * "error" - circular references are not allowed and will throw an error
     */
    circular: "ignore",
    /**
     * This function is used to replace circular references when `circular` option is set to "replace".
     * By default, it's an identity function. It means that circular references are replaced with RefElement.
     */
    circularReplacer: identity_default,
    /**
     * Determines whether the dereferencing process will be immutable.
     * By default, the dereferencing process is immutable, which means that the original
     * ApiDOM passed to the dereference process is NOT modified.
     *
     * true - the dereferencing process will be immutable (deep cloning of ApiDOM is involved)
     * false - the dereferencing process will be mutable
     */
    immutable: true
  },
  bundle: {
    /**
     * Determines strategies how ApiDOM is bundled.
     * Strategy is determined by media type or by inspecting ApiDOM to be bundled.
     *
     * You can add additional bundle strategies of your own, replace an existing one with
     * your own implementation, or remove any bundle strategy by removing it from the list.
     */
    strategies: [],
    /**
     * This option accepts an instance of pre-computed ReferenceSet.
     * If provided it will speed up the bundling significantly as the external
     * resolution doesn't need to happen anymore.
     */
    refSet: null,
    /**
     * Determines the maximum depth of bundling.
     * By default, there is no limit.
     *
     * The maxDepth represents a number of references that needed to be followed
     * before the eventual value was reached.
     *
     * It can be set to any positive integer number or zero (0).
     *
     * The bundling should throw MaximumBundleDepthError if bundling depth
     * is exceeded by this option.
     */
    maxDepth: Infinity
  }
};
var options_default = defaultOptions;

// node_modules/@swagger-api/apidom-reference/src/options/util.mjs
var baseURILens = lens_default(path_default(["resolve", "baseURI"]), assocPath_default(["resolve", "baseURI"]));
var baseURIDefault = (baseURI) => isEmptyString_default(baseURI) ? cwd() : baseURI;
var merge3 = (lObj, rObj) => {
  const withoutDefaults = mergeDeepRight_default(lObj, rObj);
  return over_default(baseURILens, baseURIDefault, withoutDefaults);
};

// node_modules/@swagger-api/apidom-reference/src/errors/PluginError.mjs
var PluginError = class extends ApiDOMError_default {
  constructor(message, options) {
    super(message, {
      cause: options.cause
    });
    __publicField(this, "plugin");
    this.plugin = options.plugin;
  }
};
var PluginError_default = PluginError;

// node_modules/@swagger-api/apidom-reference/src/util/plugins.mjs
var filter2 = async (method, parameters, plugins2) => {
  const pluginResults = await Promise.all(plugins2.map(invokeArgs_default([method], parameters)));
  return plugins2.filter((plugin7, index) => pluginResults[index]);
};
var run = async (method, parameters, plugins2) => {
  let lastError;
  for (const plugin7 of plugins2) {
    try {
      const result = await plugin7[method].call(plugin7, ...parameters);
      return {
        plugin: plugin7,
        result
      };
    } catch (error) {
      lastError = new PluginError_default("Error while running plugin", {
        cause: error,
        plugin: plugin7
      });
    }
  }
  return Promise.reject(lastError);
};

// node_modules/@swagger-api/apidom-reference/src/errors/ParseError.mjs
var ParseError = class extends ApiDOMError_default {
};
var ParseError_default = ParseError;

// node_modules/@swagger-api/apidom-reference/src/errors/ResolveError.mjs
var ResolveError = class extends ApiDOMError_default {
};
var ResolveError_default = ResolveError;

// node_modules/@swagger-api/apidom-reference/src/errors/ResolverError.mjs
var ResolverError = class extends ResolveError_default {
};
var ResolverError_default = ResolverError;

// node_modules/@swagger-api/apidom-reference/src/errors/UnmatchedResolverError.mjs
var UnmatchedResolverError = class extends ResolverError_default {
};
var UnmatchedResolverError_default = UnmatchedResolverError;

// node_modules/@swagger-api/apidom-reference/src/resolve/util.mjs
var readFile = async (file, options) => {
  const optsBoundResolvers = options.resolve.resolvers.map((resolver2) => {
    const clonedResolver = Object.create(resolver2);
    return Object.assign(clonedResolver, options.resolve.resolverOpts);
  });
  const resolvers = await filter2("canRead", [file, options], optsBoundResolvers);
  if (isEmpty_default(resolvers)) {
    throw new UnmatchedResolverError_default(file.uri);
  }
  try {
    const {
      result
    } = await run("read", [file], resolvers);
    return result;
  } catch (error) {
    throw new ResolveError_default(`Error while reading file "${file.uri}"`, {
      cause: error
    });
  }
};

// node_modules/@swagger-api/apidom-reference/src/parse/index.mjs
var parseFile = async (file, options) => {
  const optsBoundParsers = options.parse.parsers.map((parser) => {
    const clonedParser = Object.create(parser);
    return Object.assign(clonedParser, options.parse.parserOpts);
  });
  const parsers = await filter2("canParse", [file, options], optsBoundParsers);
  if (isEmpty_default(parsers)) {
    throw new UnmatchedResolverError_default(file.uri);
  }
  try {
    const {
      plugin: plugin7,
      result
    } = await run("parse", [file, options], parsers);
    if (!plugin7.allowEmpty && result.isEmpty) {
      return Promise.reject(new ParseError_default(`Error while parsing file "${file.uri}". File is empty.`));
    }
    return result;
  } catch (error) {
    throw new ParseError_default(`Error while parsing file "${file.uri}"`, {
      cause: error
    });
  }
};
var parse = async (uri2, options) => {
  const file = new File_default({
    uri: sanitize(stripHash(uri2)),
    mediaType: options.parse.mediaType
  });
  const data = await readFile(file, options);
  return parseFile(new File_default({
    ...file,
    data
  }), options);
};
var parse_default = parse;

// node_modules/@swagger-api/apidom-core/src/predicates/index.mjs
var predicates_exports = {};
__export(predicates_exports, {
  hasElementSourceMap: () => hasElementSourceMap,
  includesClasses: () => includesClasses,
  includesSymbols: () => includesSymbols,
  isAnnotationElement: () => isAnnotationElement,
  isArrayElement: () => isArrayElement,
  isBooleanElement: () => isBooleanElement,
  isCommentElement: () => isCommentElement,
  isElement: () => isElement,
  isLinkElement: () => isLinkElement,
  isMemberElement: () => isMemberElement,
  isNullElement: () => isNullElement,
  isNumberElement: () => isNumberElement,
  isObjectElement: () => isObjectElement,
  isParseResultElement: () => isParseResultElement,
  isPrimitiveElement: () => isPrimitiveElement,
  isRefElement: () => isRefElement,
  isSourceMapElement: () => isSourceMapElement,
  isStringElement: () => isStringElement
});
var import_minim6 = __toESM(require_minim(), 1);

// node_modules/@swagger-api/apidom-core/src/elements/Annotation.mjs
var import_minim = __toESM(require_minim(), 1);
var Annotation = class extends import_minim.StringElement {
  // classes: warning | error
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "annotation";
  }
  get code() {
    return this.attributes.get("code");
  }
  set code(value) {
    this.attributes.set("code", value);
  }
};
var Annotation_default = Annotation;

// node_modules/@swagger-api/apidom-core/src/elements/Comment.mjs
var import_minim2 = __toESM(require_minim(), 1);
var Comment = class extends import_minim2.StringElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "comment";
  }
};
var Comment_default = Comment;

// node_modules/@swagger-api/apidom-core/src/elements/ParseResult.mjs
var import_minim3 = __toESM(require_minim(), 1);
var ParseResult = class extends import_minim3.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "parseResult";
  }
  get api() {
    return this.children.filter((item) => item.classes.contains("api")).first;
  }
  get results() {
    return this.children.filter((item) => item.classes.contains("result"));
  }
  get result() {
    return this.results.first;
  }
  get annotations() {
    return this.children.filter((item) => item.element === "annotation");
  }
  get warnings() {
    return this.children.filter((item) => item.element === "annotation" && item.classes.contains("warning"));
  }
  get errors() {
    return this.children.filter((item) => item.element === "annotation" && item.classes.contains("error"));
  }
  get isEmpty() {
    return this.children.reject((item) => item.element === "annotation").isEmpty;
  }
  replaceResult(replacement) {
    const {
      result
    } = this;
    if (isUndefined_default(result)) {
      return false;
    }
    const searchIndex = this.content.findIndex((e2) => e2 === result);
    if (searchIndex === -1) {
      return false;
    }
    this.content[searchIndex] = replacement;
    return true;
  }
};
var ParseResult_default = ParseResult;

// node_modules/@swagger-api/apidom-core/src/elements/SourceMap.mjs
var import_minim4 = __toESM(require_minim(), 1);
var SourceMap = class extends import_minim4.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "sourceMap";
  }
  get positionStart() {
    return this.children.filter((item) => item.classes.contains("position")).get(0);
  }
  get positionEnd() {
    return this.children.filter((item) => item.classes.contains("position")).get(1);
  }
  set position(position) {
    if (typeof position === "undefined") {
      return;
    }
    const start = new import_minim4.ArrayElement([position.start.row, position.start.column, position.start.char]);
    const end = new import_minim4.ArrayElement([position.end.row, position.end.column, position.end.char]);
    start.classes.push("position");
    end.classes.push("position");
    this.push(start).push(end);
  }
};
var SourceMap_default = SourceMap;

// node_modules/@swagger-api/apidom-core/src/predicates/helpers.mjs
var import_minim5 = __toESM(require_minim(), 1);
var hasMethod = (name2, element) => {
  return typeof element === "object" && element !== null && name2 in element && typeof element[name2] === "function";
};
var hasBasicElementProps = (element) => typeof element === "object" && element != null && "_storedElement" in element && typeof element._storedElement === "string" && // eslint-disable-line no-underscore-dangle
"_content" in element;
var primitiveEq = (val, element) => {
  if (typeof element === "object" && element !== null && "primitive" in element) {
    return typeof element.primitive === "function" && element.primitive() === val;
  }
  return false;
};
var hasClass = (cls, element) => {
  return typeof element === "object" && element !== null && "classes" in element && (Array.isArray(element.classes) || element.classes instanceof import_minim5.ArrayElement) && element.classes.includes(cls);
};
var isElementType = (name2, element) => typeof element === "object" && element !== null && "element" in element && element.element === name2;
var createPredicate = (predicateCreator) => {
  return predicateCreator({
    hasMethod,
    hasBasicElementProps,
    primitiveEq,
    isElementType,
    hasClass
  });
};
var helpers_default = createPredicate;

// node_modules/@swagger-api/apidom-core/src/predicates/index.mjs
var isElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof import_minim6.Element || hasBasicElementProps2(element) && primitiveEq2(void 0, element);
});
var isStringElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof import_minim6.StringElement || hasBasicElementProps2(element) && primitiveEq2("string", element);
});
var isNumberElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof import_minim6.NumberElement || hasBasicElementProps2(element) && primitiveEq2("number", element);
});
var isNullElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof import_minim6.NullElement || hasBasicElementProps2(element) && primitiveEq2("null", element);
});
var isBooleanElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof import_minim6.BooleanElement || hasBasicElementProps2(element) && primitiveEq2("boolean", element);
});
var isObjectElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  primitiveEq: primitiveEq2,
  hasMethod: hasMethod2
}) => {
  return (element) => element instanceof import_minim6.ObjectElement || hasBasicElementProps2(element) && primitiveEq2("object", element) && hasMethod2("keys", element) && hasMethod2("values", element) && hasMethod2("items", element);
});
var isArrayElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  primitiveEq: primitiveEq2,
  hasMethod: hasMethod2
}) => {
  return (element) => element instanceof import_minim6.ArrayElement && !(element instanceof import_minim6.ObjectElement) || hasBasicElementProps2(element) && primitiveEq2("array", element) && hasMethod2("push", element) && hasMethod2("unshift", element) && hasMethod2("map", element) && hasMethod2("reduce", element);
});
var isMemberElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof import_minim6.MemberElement || hasBasicElementProps2(element) && isElementType2("member", element) && primitiveEq2(void 0, element);
});
var isLinkElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof import_minim6.LinkElement || hasBasicElementProps2(element) && isElementType2("link", element) && primitiveEq2(void 0, element);
});
var isRefElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof import_minim6.RefElement || hasBasicElementProps2(element) && isElementType2("ref", element) && primitiveEq2(void 0, element);
});
var isAnnotationElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Annotation_default || hasBasicElementProps2(element) && isElementType2("annotation", element) && primitiveEq2("array", element);
});
var isCommentElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Comment_default || hasBasicElementProps2(element) && isElementType2("comment", element) && primitiveEq2("string", element);
});
var isParseResultElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof ParseResult_default || hasBasicElementProps2(element) && isElementType2("parseResult", element) && primitiveEq2("array", element);
});
var isSourceMapElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof SourceMap_default || hasBasicElementProps2(element) && isElementType2("sourceMap", element) && primitiveEq2("array", element);
});
var isPrimitiveElement = (element) => {
  return isElementType("object", element) || isElementType("array", element) || isElementType("boolean", element) || isElementType("number", element) || isElementType("string", element) || isElementType("null", element) || isElementType("member", element);
};
var hasElementSourceMap = (element) => {
  return isSourceMapElement(element.meta.get("sourceMap"));
};
var includesSymbols = (symbols, element) => {
  if (symbols.length === 0) {
    return true;
  }
  const elementSymbols = element.attributes.get("symbols");
  if (!isArrayElement(elementSymbols)) {
    return false;
  }
  return all_default(included_default(elementSymbols.toValue()), symbols);
};
var includesClasses = (classes, element) => {
  if (classes.length === 0) {
    return true;
  }
  return all_default(included_default(element.classes.toValue()), classes);
};

// node_modules/@swagger-api/apidom-core/src/namespace.mjs
var import_minim7 = __toESM(require_minim(), 1);
var Namespace = class extends import_minim7.Namespace {
  constructor() {
    super();
    this.register("annotation", Annotation_default);
    this.register("comment", Comment_default);
    this.register("parseResult", ParseResult_default);
    this.register("sourceMap", SourceMap_default);
  }
};
var namespace = new Namespace();
var createNamespace = (namespacePlugin) => {
  const namespaceInstance = new Namespace();
  if (isPlainObj_default(namespacePlugin)) {
    namespaceInstance.use(namespacePlugin);
  }
  return namespaceInstance;
};
var namespace_default = namespace;

// node_modules/@swagger-api/apidom-core/src/refractor/toolbox.mjs
var createToolbox = () => {
  const predicates = {
    ...predicates_exports
  };
  return {
    predicates,
    namespace: namespace_default
  };
};
var toolbox_default = createToolbox;

// node_modules/@swagger-api/apidom-ast/src/Node.mjs
var Node = class {
  constructor({
    children = [],
    position,
    isMissing = false
  } = {}) {
    __publicField(this, "type", "node");
    __publicField(this, "isMissing");
    __publicField(this, "children");
    __publicField(this, "position");
    this.type = this.constructor.type;
    this.isMissing = isMissing;
    this.children = children;
    this.position = position;
  }
  // creates shallow clone of node
  clone() {
    const copy3 = Object.create(Object.getPrototypeOf(this));
    Object.getOwnPropertyNames(this).forEach((propKey) => {
      const descriptor = Object.getOwnPropertyDescriptor(this, propKey);
      Object.defineProperty(copy3, propKey, descriptor);
    });
    return copy3;
  }
};
__publicField(Node, "type", "node");
var Node_default = Node;

// node_modules/@swagger-api/apidom-ast/src/predicates.mjs
var isNodeType = (type5, node) => node != null && typeof node === "object" && "type" in node && node.type === type5;

// node_modules/@swagger-api/apidom-ast/src/yaml/nodes/YamlNode.mjs
var YamlNode = class extends Node_default {
  constructor({
    anchor,
    tag,
    style,
    styleGroup,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "anchor");
    __publicField(this, "tag");
    __publicField(this, "style");
    __publicField(this, "styleGroup");
    this.anchor = anchor;
    this.tag = tag;
    this.style = style;
    this.styleGroup = styleGroup;
  }
};
var YamlNode_default = YamlNode;

// node_modules/@swagger-api/apidom-ast/src/yaml/nodes/YamlCollection.mjs
var YamlCollection = class extends YamlNode_default {
};
var YamlCollection_default = YamlCollection;

// node_modules/@swagger-api/apidom-ast/src/yaml/nodes/predicates.mjs
var isDocument = (node) => isNodeType("document", node);
var isMapping = (node) => isNodeType("mapping", node);
var isSequence = (node) => isNodeType("sequence", node);
var isKeyValuePair = (node) => isNodeType("keyValuePair", node);
var isScalar = (node) => isNodeType("scalar", node);
var isAlias = (node) => isNodeType("alias", node);
var isComment = (node) => isNodeType("comment", node);

// node_modules/@swagger-api/apidom-ast/src/yaml/nodes/YamlKeyValuePair.mjs
var YamlKeyValuePair = class extends Node_default {
  constructor({
    styleGroup,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "styleGroup");
    this.styleGroup = styleGroup;
  }
};
__publicField(YamlKeyValuePair, "type", "keyValuePair");
Object.defineProperties(YamlKeyValuePair.prototype, {
  key: {
    get() {
      return this.children.filter((node) => isScalar(node) || isMapping(node) || isSequence(node))[0];
    },
    enumerable: true
  },
  value: {
    get() {
      const {
        key: key57,
        children
      } = this;
      const excludeKeyPredicate = (node) => node !== key57;
      const valuePredicate = (node) => isScalar(node) || isMapping(node) || isSequence(node) || isAlias(node);
      return children.filter((node) => excludeKeyPredicate(node) && valuePredicate(node))[0];
    },
    enumerable: true
  }
});

// node_modules/@swagger-api/apidom-ast/src/yaml/nodes/YamlMapping.mjs
var YamlMapping = class extends YamlCollection_default {
};
__publicField(YamlMapping, "type", "mapping");
Object.defineProperty(YamlMapping.prototype, "content", {
  get() {
    return Array.isArray(this.children) ? this.children.filter(isKeyValuePair) : [];
  },
  enumerable: true
});

// node_modules/@swagger-api/apidom-ast/src/yaml/nodes/YamlSequence.mjs
var YamlSequence = class extends YamlCollection_default {
};
__publicField(YamlSequence, "type", "sequence");
Object.defineProperty(YamlSequence.prototype, "content", {
  get() {
    const {
      children
    } = this;
    return Array.isArray(children) ? children.filter((node) => isSequence(node) || isMapping(node) || isScalar(node) || isAlias(node)) : [];
  },
  enumerable: true
});

// node_modules/@swagger-api/apidom-ast/src/yaml/nodes/YamlStream.mjs
var YamlStream = class extends Node_default {
};
__publicField(YamlStream, "type", "stream");
Object.defineProperty(YamlStream.prototype, "content", {
  get() {
    return Array.isArray(this.children) ? this.children.filter((node) => isDocument(node) || isComment(node)) : [];
  },
  enumerable: true
});

// node_modules/@swagger-api/apidom-ast/src/yaml/nodes/YamlTag.mjs
var YamlNodeKind = function(YamlNodeKind2) {
  YamlNodeKind2["Scalar"] = "Scalar";
  YamlNodeKind2["Sequence"] = "Sequence";
  YamlNodeKind2["Mapping"] = "Mapping";
  return YamlNodeKind2;
}({});

// node_modules/@swagger-api/apidom-ast/src/yaml/nodes/YamlStyle.mjs
var YamlStyle = function(YamlStyle2) {
  YamlStyle2["Plain"] = "Plain";
  YamlStyle2["SingleQuoted"] = "SingleQuoted";
  YamlStyle2["DoubleQuoted"] = "DoubleQuoted";
  YamlStyle2["Literal"] = "Literal";
  YamlStyle2["Folded"] = "Folded";
  YamlStyle2["Explicit"] = "Explicit";
  YamlStyle2["SinglePair"] = "SinglePair";
  YamlStyle2["NextLine"] = "NextLine";
  YamlStyle2["InLine"] = "InLine";
  return YamlStyle2;
}({});
var YamlStyleGroup = function(YamlStyleGroup2) {
  YamlStyleGroup2["Flow"] = "Flow";
  YamlStyleGroup2["Block"] = "Block";
  return YamlStyleGroup2;
}({});

// node_modules/@swagger-api/apidom-ast/src/yaml/schemas/canonical-format.mjs
var import_unraw = __toESM(require_dist3(), 1);
var normalizeLineBreaks = (val) => val.replace(/\r\n/g, "\n");
var preventLineBreakCollapseToSpace = (val) => val.replace(/\\\n\s*/g, "");
var collapseLineBreakToSpace = (val) => {
  return val.replace(/(\n)?\n([^\n]+)/g, (match3, p1, p2) => p1 ? match3 : ` ${p2.trimStart()}`).replace(/[\n]{2}/g, "\n");
};
var removeQuotes = curry_default((quoteType, val) => val.replace(new RegExp(`^${quoteType}`), "").replace(new RegExp(`${quoteType}$`), ""));
var formatFlowPlain = pipe(normalizeLineBreaks, trim_default, collapseLineBreakToSpace, split_default("\n"), map_default(trimStart_default), join_default("\n"));
var formatFlowSingleQuoted = pipe(normalizeLineBreaks, trim_default, collapseLineBreakToSpace, split_default("\n"), map_default(trimStart_default), join_default("\n"), removeQuotes("'"));
var formatFlowDoubleQuoted = pipe(normalizeLineBreaks, trim_default, preventLineBreakCollapseToSpace, collapseLineBreakToSpace, import_unraw.unraw, split_default("\n"), map_default(trimStart_default), join_default("\n"), removeQuotes('"'));

// node_modules/@swagger-api/apidom-ast/src/traversal/visitor.mjs
var getVisitFn = (visitor2, type5, isLeaving) => {
  const typeVisitor = visitor2[type5];
  if (typeVisitor != null) {
    if (!isLeaving && typeof typeVisitor === "function") {
      return typeVisitor;
    }
    const typeSpecificVisitor = isLeaving ? typeVisitor.leave : typeVisitor.enter;
    if (typeof typeSpecificVisitor === "function") {
      return typeSpecificVisitor;
    }
  } else {
    const specificVisitor = isLeaving ? visitor2.leave : visitor2.enter;
    if (specificVisitor != null) {
      if (typeof specificVisitor === "function") {
        return specificVisitor;
      }
      const specificTypeVisitor = specificVisitor[type5];
      if (typeof specificTypeVisitor === "function") {
        return specificTypeVisitor;
      }
    }
  }
  return null;
};
var BREAK = {};
var getNodeType = (node) => node === null || node === void 0 ? void 0 : node.type;
var isNode = (node) => typeof getNodeType(node) === "string";
var cloneNode = (node) => Object.create(Object.getPrototypeOf(node), Object.getOwnPropertyDescriptors(node));
var mergeAll3 = (visitors, {
  visitFnGetter = getVisitFn,
  nodeTypeGetter: nodeTypeGetter2 = getNodeType,
  breakSymbol = BREAK,
  deleteNodeSymbol = null,
  skipVisitingNodeSymbol = false,
  exposeEdits = false
} = {}) => {
  const skipSymbol = Symbol("skip");
  const skipping = new Array(visitors.length).fill(skipSymbol);
  return {
    enter(node, key57, parent, path4, ancestors, link) {
      let currentNode = node;
      let hasChanged = false;
      const linkProxy = {
        ...link,
        replaceWith(newNode, replacer) {
          link.replaceWith(newNode, replacer);
          currentNode = newNode;
        }
      };
      for (let i2 = 0; i2 < visitors.length; i2 += 1) {
        if (skipping[i2] === skipSymbol) {
          const visitFn = visitFnGetter(visitors[i2], nodeTypeGetter2(currentNode), false);
          if (typeof visitFn === "function") {
            const result = visitFn.call(visitors[i2], currentNode, key57, parent, path4, ancestors, linkProxy);
            if (typeof (result === null || result === void 0 ? void 0 : result.then) === "function") {
              throw new ApiDOMStructuredError_default("Async visitor not supported in sync mode", {
                visitor: visitors[i2],
                visitFn
              });
            }
            if (result === skipVisitingNodeSymbol) {
              skipping[i2] = currentNode;
            } else if (result === breakSymbol) {
              skipping[i2] = breakSymbol;
            } else if (result === deleteNodeSymbol) {
              return result;
            } else if (result !== void 0) {
              if (exposeEdits) {
                currentNode = result;
                hasChanged = true;
              } else {
                return result;
              }
            }
          }
        }
      }
      return hasChanged ? currentNode : void 0;
    },
    leave(node, key57, parent, path4, ancestors, link) {
      let currentNode = node;
      const linkProxy = {
        ...link,
        replaceWith(newNode, replacer) {
          link.replaceWith(newNode, replacer);
          currentNode = newNode;
        }
      };
      for (let i2 = 0; i2 < visitors.length; i2 += 1) {
        if (skipping[i2] === skipSymbol) {
          const visitFn = visitFnGetter(visitors[i2], nodeTypeGetter2(currentNode), true);
          if (typeof visitFn === "function") {
            const result = visitFn.call(visitors[i2], currentNode, key57, parent, path4, ancestors, linkProxy);
            if (typeof (result === null || result === void 0 ? void 0 : result.then) === "function") {
              throw new ApiDOMStructuredError_default("Async visitor not supported in sync mode", {
                visitor: visitors[i2],
                visitFn
              });
            }
            if (result === breakSymbol) {
              skipping[i2] = breakSymbol;
            } else if (result !== void 0 && result !== skipVisitingNodeSymbol) {
              return result;
            }
          }
        } else if (skipping[i2] === currentNode) {
          skipping[i2] = skipSymbol;
        }
      }
      return void 0;
    }
  };
};
var mergeAllAsync = (visitors, {
  visitFnGetter = getVisitFn,
  nodeTypeGetter: nodeTypeGetter2 = getNodeType,
  breakSymbol = BREAK,
  deleteNodeSymbol = null,
  skipVisitingNodeSymbol = false,
  exposeEdits = false
} = {}) => {
  const skipSymbol = Symbol("skip");
  const skipping = new Array(visitors.length).fill(skipSymbol);
  return {
    async enter(node, key57, parent, path4, ancestors, link) {
      let currentNode = node;
      let hasChanged = false;
      const linkProxy = {
        ...link,
        replaceWith(newNode, replacer) {
          link.replaceWith(newNode, replacer);
          currentNode = newNode;
        }
      };
      for (let i2 = 0; i2 < visitors.length; i2 += 1) {
        if (skipping[i2] === skipSymbol) {
          const visitFn = visitFnGetter(visitors[i2], nodeTypeGetter2(currentNode), false);
          if (typeof visitFn === "function") {
            const result = await visitFn.call(visitors[i2], currentNode, key57, parent, path4, ancestors, linkProxy);
            if (result === skipVisitingNodeSymbol) {
              skipping[i2] = currentNode;
            } else if (result === breakSymbol) {
              skipping[i2] = breakSymbol;
            } else if (result === deleteNodeSymbol) {
              return result;
            } else if (result !== void 0) {
              if (exposeEdits) {
                currentNode = result;
                hasChanged = true;
              } else {
                return result;
              }
            }
          }
        }
      }
      return hasChanged ? currentNode : void 0;
    },
    async leave(node, key57, parent, path4, ancestors, link) {
      let currentNode = node;
      const linkProxy = {
        ...link,
        replaceWith(newNode, replacer) {
          link.replaceWith(newNode, replacer);
          currentNode = newNode;
        }
      };
      for (let i2 = 0; i2 < visitors.length; i2 += 1) {
        if (skipping[i2] === skipSymbol) {
          const visitFn = visitFnGetter(visitors[i2], nodeTypeGetter2(currentNode), true);
          if (typeof visitFn === "function") {
            const result = await visitFn.call(visitors[i2], currentNode, key57, parent, path4, ancestors, linkProxy);
            if (result === breakSymbol) {
              skipping[i2] = breakSymbol;
            } else if (result !== void 0 && result !== skipVisitingNodeSymbol) {
              return result;
            }
          }
        } else if (skipping[i2] === currentNode) {
          skipping[i2] = skipSymbol;
        }
      }
      return void 0;
    }
  };
};
mergeAll3[Symbol.for("nodejs.util.promisify.custom")] = mergeAllAsync;
var visit = (root, visitor2, {
  keyMap: keyMap4 = null,
  state: state2 = {},
  breakSymbol = BREAK,
  deleteNodeSymbol = null,
  skipVisitingNodeSymbol = false,
  visitFnGetter = getVisitFn,
  nodeTypeGetter: nodeTypeGetter2 = getNodeType,
  nodePredicate = isNode,
  nodeCloneFn = cloneNode,
  detectCycles = true
} = {}) => {
  const visitorKeys = keyMap4 || {};
  let stack;
  let inArray = Array.isArray(root);
  let keys4 = [root];
  let index = -1;
  let parent;
  let edits = [];
  let node = root;
  const path4 = [];
  const ancestors = [];
  do {
    index += 1;
    const isLeaving = index === keys4.length;
    let key57;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key57 = ancestors.length === 0 ? void 0 : path4.pop();
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === deleteNodeSymbol) {
              node.splice(arrayKey, 1);
              editOffset += 1;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = nodeCloneFn(node);
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys4 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent !== deleteNodeSymbol && parent !== void 0) {
      key57 = inArray ? index : keys4[index];
      node = parent[key57];
      if (node === deleteNodeSymbol || node === void 0) {
        continue;
      }
      path4.push(key57);
    }
    let result;
    if (!Array.isArray(node)) {
      var _result;
      if (!nodePredicate(node)) {
        throw new ApiDOMStructuredError_default(`Invalid AST Node:  ${String(node)}`, {
          node
        });
      }
      if (detectCycles && ancestors.includes(node)) {
        path4.pop();
        continue;
      }
      const visitFn = visitFnGetter(visitor2, nodeTypeGetter2(node), isLeaving);
      if (visitFn) {
        for (const [stateKey, stateValue] of Object.entries(state2)) {
          visitor2[stateKey] = stateValue;
        }
        const link = {
          // eslint-disable-next-line @typescript-eslint/no-loop-func
          replaceWith(newNode, replacer) {
            if (typeof replacer === "function") {
              replacer(newNode, node, key57, parent, path4, ancestors);
            } else if (parent) {
              parent[key57] = newNode;
            }
            if (!isLeaving) {
              node = newNode;
            }
          }
        };
        result = visitFn.call(visitor2, node, key57, parent, path4, ancestors, link);
      }
      if (typeof ((_result = result) === null || _result === void 0 ? void 0 : _result.then) === "function") {
        throw new ApiDOMStructuredError_default("Async visitor not supported in sync mode", {
          visitor: visitor2,
          visitFn
        });
      }
      if (result === breakSymbol) {
        break;
      }
      if (result === skipVisitingNodeSymbol) {
        if (!isLeaving) {
          path4.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key57, result]);
        if (!isLeaving) {
          if (nodePredicate(result)) {
            node = result;
          } else {
            path4.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key57, node]);
    }
    if (!isLeaving) {
      var _visitorKeys$nodeType;
      stack = {
        inArray,
        index,
        keys: keys4,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys4 = inArray ? node : (_visitorKeys$nodeType = visitorKeys[nodeTypeGetter2(node)]) !== null && _visitorKeys$nodeType !== void 0 ? _visitorKeys$nodeType : [];
      index = -1;
      edits = [];
      if (parent !== deleteNodeSymbol && parent !== void 0) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
};
visit[Symbol.for("nodejs.util.promisify.custom")] = async (root, visitor2, {
  keyMap: keyMap4 = null,
  state: state2 = {},
  breakSymbol = BREAK,
  deleteNodeSymbol = null,
  skipVisitingNodeSymbol = false,
  visitFnGetter = getVisitFn,
  nodeTypeGetter: nodeTypeGetter2 = getNodeType,
  nodePredicate = isNode,
  nodeCloneFn = cloneNode,
  detectCycles = true
} = {}) => {
  const visitorKeys = keyMap4 || {};
  let stack;
  let inArray = Array.isArray(root);
  let keys4 = [root];
  let index = -1;
  let parent;
  let edits = [];
  let node = root;
  const path4 = [];
  const ancestors = [];
  do {
    index += 1;
    const isLeaving = index === keys4.length;
    let key57;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key57 = ancestors.length === 0 ? void 0 : path4.pop();
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === deleteNodeSymbol) {
              node.splice(arrayKey, 1);
              editOffset += 1;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = nodeCloneFn(node);
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys4 = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent !== deleteNodeSymbol && parent !== void 0) {
      key57 = inArray ? index : keys4[index];
      node = parent[key57];
      if (node === deleteNodeSymbol || node === void 0) {
        continue;
      }
      path4.push(key57);
    }
    let result;
    if (!Array.isArray(node)) {
      if (!nodePredicate(node)) {
        throw new ApiDOMStructuredError_default(`Invalid AST Node: ${String(node)}`, {
          node
        });
      }
      if (detectCycles && ancestors.includes(node)) {
        path4.pop();
        continue;
      }
      const visitFn = visitFnGetter(visitor2, nodeTypeGetter2(node), isLeaving);
      if (visitFn) {
        for (const [stateKey, stateValue] of Object.entries(state2)) {
          visitor2[stateKey] = stateValue;
        }
        const link = {
          // eslint-disable-next-line @typescript-eslint/no-loop-func
          replaceWith(newNode, replacer) {
            if (typeof replacer === "function") {
              replacer(newNode, node, key57, parent, path4, ancestors);
            } else if (parent) {
              parent[key57] = newNode;
            }
            if (!isLeaving) {
              node = newNode;
            }
          }
        };
        result = await visitFn.call(visitor2, node, key57, parent, path4, ancestors, link);
      }
      if (result === breakSymbol) {
        break;
      }
      if (result === skipVisitingNodeSymbol) {
        if (!isLeaving) {
          path4.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key57, result]);
        if (!isLeaving) {
          if (nodePredicate(result)) {
            node = result;
          } else {
            path4.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key57, node]);
    }
    if (!isLeaving) {
      var _visitorKeys$nodeType2;
      stack = {
        inArray,
        index,
        keys: keys4,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys4 = inArray ? node : (_visitorKeys$nodeType2 = visitorKeys[nodeTypeGetter2(node)]) !== null && _visitorKeys$nodeType2 !== void 0 ? _visitorKeys$nodeType2 : [];
      index = -1;
      edits = [];
      if (parent !== deleteNodeSymbol && parent !== void 0) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
};

// node_modules/@swagger-api/apidom-core/src/clone/index.mjs
var import_minim8 = __toESM(require_minim(), 1);

// node_modules/@swagger-api/apidom-core/src/clone/errors/CloneError.mjs
var CloneError = class extends ApiDOMStructuredError_default {
  constructor(message, structuredOptions) {
    super(message, structuredOptions);
    __publicField(this, "value");
    if (typeof structuredOptions !== "undefined") {
      this.value = structuredOptions.value;
    }
  }
};
var CloneError_default = CloneError;

// node_modules/@swagger-api/apidom-core/src/clone/errors/DeepCloneError.mjs
var DeepCloneError = class extends CloneError_default {
};
var DeepCloneError_default = DeepCloneError;

// node_modules/@swagger-api/apidom-core/src/clone/errors/ShallowCloneError.mjs
var ShallowCloneError = class extends CloneError_default {
};
var ShallowCloneError_default = ShallowCloneError;

// node_modules/@swagger-api/apidom-core/src/clone/index.mjs
var cloneDeep = (value, options = {}) => {
  const {
    visited = /* @__PURE__ */ new WeakMap()
  } = options;
  const passThroughOptions = {
    ...options,
    visited
  };
  if (visited.has(value)) {
    return visited.get(value);
  }
  if (value instanceof import_minim8.KeyValuePair) {
    const {
      key: key57,
      value: val
    } = value;
    const keyCopy = isElement(key57) ? cloneDeep(key57, passThroughOptions) : key57;
    const valueCopy = isElement(val) ? cloneDeep(val, passThroughOptions) : val;
    const copy3 = new import_minim8.KeyValuePair(keyCopy, valueCopy);
    visited.set(value, copy3);
    return copy3;
  }
  if (value instanceof import_minim8.ObjectSlice) {
    const mapper = (element) => cloneDeep(element, passThroughOptions);
    const items = [...value].map(mapper);
    const copy3 = new import_minim8.ObjectSlice(items);
    visited.set(value, copy3);
    return copy3;
  }
  if (value instanceof import_minim8.ArraySlice) {
    const mapper = (element) => cloneDeep(element, passThroughOptions);
    const items = [...value].map(mapper);
    const copy3 = new import_minim8.ArraySlice(items);
    visited.set(value, copy3);
    return copy3;
  }
  if (isElement(value)) {
    const copy3 = cloneShallow(value);
    visited.set(value, copy3);
    if (value.content) {
      if (isElement(value.content)) {
        copy3.content = cloneDeep(value.content, passThroughOptions);
      } else if (value.content instanceof import_minim8.KeyValuePair) {
        copy3.content = cloneDeep(value.content, passThroughOptions);
      } else if (Array.isArray(value.content)) {
        const mapper = (element) => cloneDeep(element, passThroughOptions);
        copy3.content = value.content.map(mapper);
      } else {
        copy3.content = value.content;
      }
    } else {
      copy3.content = value.content;
    }
    return copy3;
  }
  throw new DeepCloneError_default("Value provided to cloneDeep function couldn't be cloned", {
    value
  });
};
cloneDeep.safe = (value) => {
  try {
    return cloneDeep(value);
  } catch {
    return value;
  }
};
var cloneShallowKeyValuePair = (keyValuePair) => {
  const {
    key: key57,
    value
  } = keyValuePair;
  return new import_minim8.KeyValuePair(key57, value);
};
var cloneShallowArraySlice = (arraySlice) => {
  const items = [...arraySlice];
  return new import_minim8.ArraySlice(items);
};
var cloneShallowObjectSlice = (objectSlice) => {
  const items = [...objectSlice];
  return new import_minim8.ObjectSlice(items);
};
var cloneShallowElement = (element) => {
  const copy3 = new element.constructor();
  copy3.element = element.element;
  if (element.meta.length > 0) {
    copy3._meta = cloneDeep(element.meta);
  }
  if (element.attributes.length > 0) {
    copy3._attributes = cloneDeep(element.attributes);
  }
  if (isElement(element.content)) {
    const content = element.content;
    copy3.content = cloneShallowElement(content);
  } else if (Array.isArray(element.content)) {
    copy3.content = [...element.content];
  } else if (element.content instanceof import_minim8.KeyValuePair) {
    copy3.content = cloneShallowKeyValuePair(element.content);
  } else {
    copy3.content = element.content;
  }
  return copy3;
};
var cloneShallow = (value) => {
  if (value instanceof import_minim8.KeyValuePair) {
    return cloneShallowKeyValuePair(value);
  }
  if (value instanceof import_minim8.ObjectSlice) {
    return cloneShallowObjectSlice(value);
  }
  if (value instanceof import_minim8.ArraySlice) {
    return cloneShallowArraySlice(value);
  }
  if (isElement(value)) {
    return cloneShallowElement(value);
  }
  throw new ShallowCloneError_default("Value provided to cloneShallow function couldn't be cloned", {
    value
  });
};
cloneShallow.safe = (value) => {
  try {
    return cloneShallow(value);
  } catch {
    return value;
  }
};

// node_modules/@swagger-api/apidom-core/src/traversal/visitor.mjs
var getNodeType2 = (element) => {
  return isObjectElement(element) ? "ObjectElement" : isArrayElement(element) ? "ArrayElement" : isMemberElement(element) ? "MemberElement" : isStringElement(element) ? "StringElement" : isBooleanElement(element) ? "BooleanElement" : isNumberElement(element) ? "NumberElement" : isNullElement(element) ? "NullElement" : isLinkElement(element) ? "LinkElement" : isRefElement(element) ? "RefElement" : void 0;
};
var cloneNode2 = (node) => {
  if (isElement(node)) {
    return cloneShallow(node);
  }
  return cloneNode(node);
};
var isNode2 = pipe(getNodeType2, isString_default);
var keyMapDefault = {
  ObjectElement: ["content"],
  ArrayElement: ["content"],
  MemberElement: ["key", "value"],
  StringElement: [],
  BooleanElement: [],
  NumberElement: [],
  NullElement: [],
  RefElement: [],
  LinkElement: [],
  Annotation: [],
  Comment: [],
  ParseResultElement: ["content"],
  SourceMap: ["content"]
};
var PredicateVisitor = class {
  constructor({
    predicate = F_default,
    returnOnTrue,
    returnOnFalse
  } = {}) {
    __publicField(this, "result");
    __publicField(this, "predicate");
    __publicField(this, "returnOnTrue");
    __publicField(this, "returnOnFalse");
    this.result = [];
    this.predicate = predicate;
    this.returnOnTrue = returnOnTrue;
    this.returnOnFalse = returnOnFalse;
  }
  enter(element) {
    if (this.predicate(element)) {
      this.result.push(element);
      return this.returnOnTrue;
    }
    return this.returnOnFalse;
  }
};
var visit2 = (root, visitor2, {
  keyMap: keyMap4 = keyMapDefault,
  ...rest
} = {}) => {
  return visit(root, visitor2, {
    // @ts-ignore
    keyMap: keyMap4,
    // @ts-ignore
    nodeTypeGetter: getNodeType2,
    nodePredicate: isNode2,
    nodeCloneFn: cloneNode2,
    ...rest
  });
};
visit2[Symbol.for("nodejs.util.promisify.custom")] = async (root, visitor2, {
  keyMap: keyMap4 = keyMapDefault,
  ...rest
} = {}) => {
  return visit[Symbol.for("nodejs.util.promisify.custom")](root, visitor2, {
    // @ts-ignore
    keyMap: keyMap4,
    // @ts-ignore
    nodeTypeGetter: getNodeType2,
    nodePredicate: isNode2,
    nodeCloneFn: cloneNode2,
    ...rest
  });
};

// node_modules/@swagger-api/apidom-core/src/refractor/plugins/dispatcher/index.mjs
var defaultDispatchPluginsOptions = {
  toolboxCreator: toolbox_default,
  visitorOptions: {
    nodeTypeGetter: getNodeType2,
    exposeEdits: true
  }
};
var dispatchPluginsSync = (element, plugins2, options = {}) => {
  if (plugins2.length === 0) return element;
  const mergedOptions = mergeDeepRight_default(defaultDispatchPluginsOptions, options);
  const {
    toolboxCreator,
    visitorOptions
  } = mergedOptions;
  const toolbox = toolboxCreator();
  const pluginsSpecs = plugins2.map((plugin7) => plugin7(toolbox));
  const mergedPluginsVisitor = mergeAll3(pluginsSpecs.map(propOr_default({}, "visitor")), {
    ...visitorOptions
  });
  pluginsSpecs.forEach(invokeArgs_default(["pre"], []));
  const newElement = visit2(element, mergedPluginsVisitor, visitorOptions);
  pluginsSpecs.forEach(invokeArgs_default(["post"], []));
  return newElement;
};
var dispatchPluginsAsync = async (element, plugins2, options = {}) => {
  if (plugins2.length === 0) return element;
  const mergedOptions = mergeDeepRight_default(defaultDispatchPluginsOptions, options);
  const {
    toolboxCreator,
    visitorOptions
  } = mergedOptions;
  const toolbox = toolboxCreator();
  const pluginsSpecs = plugins2.map((plugin7) => plugin7(toolbox));
  const mergeAllVisitorsAsync2 = mergeAll3[Symbol.for("nodejs.util.promisify.custom")];
  const visitAsync5 = visit2[Symbol.for("nodejs.util.promisify.custom")];
  const mergedPluginsVisitor = mergeAllVisitorsAsync2(pluginsSpecs.map(propOr_default({}, "visitor")), {
    ...visitorOptions
  });
  await Promise.allSettled(pluginsSpecs.map(invokeArgs_default(["pre"], [])));
  const newElement = await visitAsync5(element, mergedPluginsVisitor, visitorOptions);
  await Promise.allSettled(pluginsSpecs.map(invokeArgs_default(["post"], [])));
  return newElement;
};
dispatchPluginsSync[Symbol.for("nodejs.util.promisify.custom")] = dispatchPluginsAsync;

// node_modules/@swagger-api/apidom-core/src/identity/index.mjs
var import_minim9 = __toESM(require_minim(), 1);
var import_short_unique_id = __toESM(require_short_unique_id(), 1);

// node_modules/@swagger-api/apidom-core/src/identity/errors/ElementIdentityError.mjs
var ElementIdentityError = class extends ApiDOMStructuredError_default {
  constructor(message, structuredOptions) {
    super(message, structuredOptions);
    __publicField(this, "value");
    if (typeof structuredOptions !== "undefined") {
      this.value = structuredOptions.value;
    }
  }
};
var ElementIdentityError_default = ElementIdentityError;

// node_modules/@swagger-api/apidom-core/src/identity/index.mjs
var IdentityManager = class {
  constructor({
    length: length3 = 6
  } = {}) {
    __publicField(this, "uuid");
    __publicField(this, "identityMap");
    this.uuid = new import_short_unique_id.default({
      length: length3
    });
    this.identityMap = /* @__PURE__ */ new WeakMap();
  }
  identify(element) {
    if (!isElement(element)) {
      throw new ElementIdentityError_default("Cannot not identify the element. `element` is neither structurally compatible nor a subclass of an Element class.", {
        value: element
      });
    }
    if (element.meta.hasKey("id") && isStringElement(element.meta.get("id")) && !element.meta.get("id").equals("")) {
      return element.id;
    }
    if (this.identityMap.has(element)) {
      return this.identityMap.get(element);
    }
    const id = new import_minim9.StringElement(this.generateId());
    this.identityMap.set(element, id);
    return id;
  }
  forget(element) {
    if (this.identityMap.has(element)) {
      this.identityMap.delete(element);
      return true;
    }
    return false;
  }
  generateId() {
    return this.uuid.randomUUID();
  }
};
var defaultIdentityManager = new IdentityManager();

// node_modules/@swagger-api/apidom-core/src/media-types.mjs
var MediaTypes = class extends Array {
  constructor() {
    super(...arguments);
    __publicField(this, "unknownMediaType", "application/octet-stream");
  }
  // eslint-disable-next-line class-methods-use-this
  filterByFormat() {
    throw new NotImplementedError_default("filterByFormat method in MediaTypes class is not yet implemented.");
  }
  // eslint-disable-next-line class-methods-use-this
  findBy() {
    throw new NotImplementedError_default("findBy method in MediaTypes class is not yet implemented.");
  }
  // eslint-disable-next-line class-methods-use-this
  latest() {
    throw new NotImplementedError_default("latest method in MediaTypes class is not yet implemented.");
  }
};
var media_types_default = MediaTypes;

// node_modules/@swagger-api/apidom-core/src/index.mjs
var import_minim14 = __toESM(require_minim(), 1);

// node_modules/@swagger-api/apidom-core/src/refractor/registration.mjs
var import_minim10 = __toESM(require_minim(), 1);

// node_modules/@swagger-api/apidom-core/src/refractor/index.mjs
var refract = (value, {
  Type: Type2,
  plugins: plugins2 = []
}) => {
  const element = new Type2(value);
  if (isElement(value)) {
    if (value.meta.length > 0) {
      element.meta = cloneDeep(value.meta);
    }
    if (value.attributes.length > 0) {
      element.attributes = cloneDeep(value.attributes);
    }
  }
  return dispatchPluginsSync(element, plugins2, {
    toolboxCreator: toolbox_default,
    visitorOptions: {
      nodeTypeGetter: getNodeType2
    }
  });
};
var createRefractor = (Type2) => (value, options = {}) => refract(value, {
  ...options,
  Type: Type2
});

// node_modules/@swagger-api/apidom-core/src/refractor/registration.mjs
import_minim10.ObjectElement.refract = createRefractor(import_minim10.ObjectElement);
import_minim10.ArrayElement.refract = createRefractor(import_minim10.ArrayElement);
import_minim10.StringElement.refract = createRefractor(import_minim10.StringElement);
import_minim10.BooleanElement.refract = createRefractor(import_minim10.BooleanElement);
import_minim10.NullElement.refract = createRefractor(import_minim10.NullElement);
import_minim10.NumberElement.refract = createRefractor(import_minim10.NumberElement);
import_minim10.LinkElement.refract = createRefractor(import_minim10.LinkElement);
import_minim10.RefElement.refract = createRefractor(import_minim10.RefElement);
Annotation_default.refract = createRefractor(Annotation_default);
Comment_default.refract = createRefractor(Comment_default);
ParseResult_default.refract = createRefractor(ParseResult_default);
SourceMap_default.refract = createRefractor(SourceMap_default);

// node_modules/@swagger-api/apidom-core/src/traversal/filter.mjs
var import_minim11 = __toESM(require_minim(), 1);
var filter3 = (predicate, element) => {
  const visitor2 = new PredicateVisitor({
    predicate
  });
  visit2(element, visitor2);
  return new import_minim11.ArraySlice(visitor2.result);
};
var filter_default2 = filter3;

// node_modules/@swagger-api/apidom-core/src/traversal/find.mjs
var find3 = (predicate, element) => {
  const visitor2 = new PredicateVisitor({
    predicate,
    returnOnTrue: BREAK
  });
  visit2(element, visitor2);
  return pathOr_default(void 0, [0], visitor2.result);
};
var find_default2 = find3;

// node_modules/@swagger-api/apidom-core/src/transformers/serializers/value/visitor.mjs
var nodeTypeGetter = (node) => {
  if (typeof (node === null || node === void 0 ? void 0 : node.type) === "string") {
    return node.type;
  }
  return getNodeType2(node);
};
var keyMapDefault2 = {
  EphemeralObject: ["content"],
  EphemeralArray: ["content"],
  ...keyMapDefault
};
var visit3 = (root, visitor2, {
  keyMap: keyMap4 = keyMapDefault2,
  ...rest
} = {}) => {
  return visit2(root, visitor2, {
    keyMap: keyMap4,
    // @ts-ignore
    nodeTypeGetter,
    nodePredicate: T_default,
    detectCycles: false,
    deleteNodeSymbol: Symbol.for("delete-node"),
    skipVisitingNodeSymbol: Symbol.for("skip-visiting-node"),
    ...rest
  });
};
visit3[Symbol.for("nodejs.util.promisify.custom")] = async (root, {
  keyMap: keyMap4 = keyMapDefault2,
  ...rest
} = {}) => {
  return visit2[Symbol.for("nodejs.util.promisify.custom")](root, visitor, {
    keyMap: keyMap4,
    nodeTypeGetter,
    nodePredicate: T_default,
    detectCycles: false,
    deleteNodeSymbol: Symbol.for("delete-node"),
    skipVisitingNodeSymbol: Symbol.for("skip-visiting-node"),
    ...rest
  });
};

// node_modules/@swagger-api/apidom-core/src/transformers/serializers/value/ast/ephemeral-array.mjs
var EphemeralArray = class {
  constructor(content) {
    __publicField(this, "type", "EphemeralArray");
    __publicField(this, "content", []);
    __publicField(this, "reference");
    this.content = content;
    this.reference = [];
  }
  toReference() {
    return this.reference;
  }
  toArray() {
    this.reference.push(...this.content);
    return this.reference;
  }
};
var ephemeral_array_default = EphemeralArray;

// node_modules/@swagger-api/apidom-core/src/transformers/serializers/value/ast/ephemeral-object.mjs
var EphemeralObject = class {
  constructor(content) {
    __publicField(this, "type", "EphemeralObject");
    __publicField(this, "content", []);
    __publicField(this, "reference");
    this.content = content;
    this.reference = {};
  }
  toReference() {
    return this.reference;
  }
  toObject() {
    return Object.assign(this.reference, Object.fromEntries(this.content));
  }
};
var ephemeral_object_default = EphemeralObject;

// node_modules/@swagger-api/apidom-core/src/transformers/serializers/value/index.mjs
var Visitor = class {
  constructor() {
    __publicField(this, "ObjectElement", {
      enter: (element) => {
        if (this.references.has(element)) {
          return this.references.get(element).toReference();
        }
        const ephemeral = new ephemeral_object_default(element.content);
        this.references.set(element, ephemeral);
        return ephemeral;
      }
    });
    __publicField(this, "EphemeralObject", {
      leave: (ephemeral) => {
        return ephemeral.toObject();
      }
    });
    __publicField(this, "MemberElement", {
      enter: (element) => {
        return [element.key, element.value];
      }
    });
    __publicField(this, "ArrayElement", {
      enter: (element) => {
        if (this.references.has(element)) {
          return this.references.get(element).toReference();
        }
        const ephemeral = new ephemeral_array_default(element.content);
        this.references.set(element, ephemeral);
        return ephemeral;
      }
    });
    __publicField(this, "EphemeralArray", {
      leave: (ephemeral) => {
        return ephemeral.toArray();
      }
    });
    __publicField(this, "references", /* @__PURE__ */ new WeakMap());
  }
  BooleanElement(element) {
    return element.toValue();
  }
  NumberElement(element) {
    return element.toValue();
  }
  StringElement(element) {
    return element.toValue();
  }
  NullElement() {
    return null;
  }
  RefElement(element, ...rest) {
    var _ancestors;
    const ancestors = rest[3];
    if (((_ancestors = ancestors[ancestors.length - 1]) === null || _ancestors === void 0 ? void 0 : _ancestors.type) === "EphemeralObject") {
      return Symbol.for("delete-node");
    }
    return String(element.toValue());
  }
  LinkElement(element) {
    if (isStringElement(element.href)) {
      return element.href.toValue();
    }
    return "";
  }
};
var serializer = (element) => {
  if (!isElement(element)) return element;
  if (isStringElement(element) || isNumberElement(element) || isBooleanElement(element) || isNullElement(element)) {
    return element.toValue();
  }
  return visit3(element, new Visitor());
};
var value_default = serializer;

// node_modules/@swagger-api/apidom-core/src/transcluder/Transcluder.mjs
var computeEdges = (element, edges = /* @__PURE__ */ new WeakMap()) => {
  if (isMemberElement(element)) {
    edges.set(element.key, element);
    computeEdges(element.key, edges);
    edges.set(element.value, element);
    computeEdges(element.value, edges);
  } else {
    element.children.forEach((childElement) => {
      edges.set(childElement, element);
      computeEdges(childElement, edges);
    });
  }
  return edges;
};
var transcludeChildOfMemberElement = (search, replace5, edges) => {
  const memberElement = edges.get(search);
  if (!isMemberElement(memberElement)) {
    return;
  }
  if (memberElement.key === search) {
    memberElement.key = replace5;
    edges.delete(search);
    edges.set(replace5, memberElement);
  }
  if (memberElement.value === search) {
    memberElement.value = replace5;
    edges.delete(search);
    edges.set(replace5, memberElement);
  }
};
var transcludeChildOfObjectElement = (search, replace5, edges) => {
  const objectElement = edges.get(search);
  if (!isObjectElement(objectElement)) {
    return;
  }
  objectElement.content = objectElement.map((value, key57, member) => {
    if (member === search) {
      edges.delete(search);
      edges.set(replace5, objectElement);
      return replace5;
    }
    return member;
  });
};
var transcludeChildOfArrayElement = (search, replace5, edges) => {
  const arrayElement = edges.get(search);
  if (!isArrayElement(arrayElement)) {
    return;
  }
  arrayElement.content = arrayElement.map((element) => {
    if (element === search) {
      edges.delete(search);
      edges.set(replace5, arrayElement);
      return replace5;
    }
    return element;
  });
};
var Transcluder = class {
  constructor({
    element
  }) {
    __publicField(this, "element");
    __publicField(this, "edges");
    this.element = element;
  }
  transclude(search, replace5) {
    var _this$edges;
    if (search === this.element) return replace5;
    if (search === replace5) return this.element;
    this.edges = (_this$edges = this.edges) !== null && _this$edges !== void 0 ? _this$edges : computeEdges(this.element);
    const parent = this.edges.get(search);
    if (isUndefined_default(parent)) {
      return void 0;
    }
    if (isObjectElement(parent)) {
      transcludeChildOfObjectElement(search, replace5, this.edges);
    } else if (isArrayElement(parent)) {
      transcludeChildOfArrayElement(search, replace5, this.edges);
    } else if (isMemberElement(parent)) {
      transcludeChildOfMemberElement(search, replace5, this.edges);
    }
    return this.element;
  }
};
var Transcluder_default = Transcluder;

// node_modules/@swagger-api/apidom-core/src/transcluder/index.mjs
var transclude = (search, replace5, element) => {
  const transcluder = new Transcluder_default({
    element
  });
  return transcluder.transclude(search, replace5);
};

// node_modules/@swagger-api/apidom-core/src/util.mjs
var dereference = (object2, root) => {
  const rootObject = defaultTo_default(object2, root);
  return mapObjIndexed_default((val) => {
    if (isPlainObj_default(val) && has_default("$ref", val) && propSatisfies_default(isString_default, "$ref", val)) {
      const $ref = path_default(["$ref"], val);
      const pointer = trimCharsStart_default("#/", $ref);
      return path_default(pointer.split("/"), rootObject);
    }
    if (isPlainObj_default(val)) {
      return dereference(val, rootObject);
    }
    return val;
  }, object2);
};

// node_modules/@swagger-api/apidom-core/src/transformers/from.mjs
var fromFn = (data, namespace2 = namespace_default) => {
  if (isString_default(data)) {
    try {
      return namespace2.fromRefract(JSON.parse(data));
    } catch {
    }
  }
  if (isPlainObj_default(data) && has_default("element", data)) {
    return namespace2.fromRefract(data);
  }
  return namespace2.toElement(data);
};
var from_default = fromFn;

// node_modules/@swagger-api/apidom-core/src/merge/deepmerge.mjs
var import_minim12 = __toESM(require_minim(), 1);
var emptyElement = (element) => {
  const meta = element.meta.length > 0 ? cloneDeep(element.meta) : void 0;
  const attributes = element.attributes.length > 0 ? cloneDeep(element.attributes) : void 0;
  return new element.constructor(void 0, meta, attributes);
};
var cloneUnlessOtherwiseSpecified = (element, options) => options.clone && options.isMergeableElement(element) ? deepmerge2(emptyElement(element), element, options) : element;
var getMergeFunction = (keyElement, options) => {
  if (typeof options.customMerge !== "function") {
    return deepmerge2;
  }
  const customMerge = options.customMerge(keyElement, options);
  return typeof customMerge === "function" ? customMerge : deepmerge2;
};
var getMetaMergeFunction = (options) => {
  if (typeof options.customMetaMerge !== "function") {
    return (targetMeta) => cloneDeep(targetMeta);
  }
  return options.customMetaMerge;
};
var getAttributesMergeFunction = (options) => {
  if (typeof options.customAttributesMerge !== "function") {
    return (targetAttributes) => cloneDeep(targetAttributes);
  }
  return options.customAttributesMerge;
};
var mergeArrayElement = (targetElement, sourceElement, options) => targetElement.concat(sourceElement)["fantasy-land/map"]((item) => cloneUnlessOtherwiseSpecified(item, options));
var mergeObjectElement = (targetElement, sourceElement, options) => {
  const destination = isObjectElement(targetElement) ? emptyElement(targetElement) : emptyElement(sourceElement);
  if (isObjectElement(targetElement)) {
    targetElement.forEach((value, key57, member) => {
      const clonedMember = cloneShallow(member);
      clonedMember.value = cloneUnlessOtherwiseSpecified(value, options);
      destination.content.push(clonedMember);
    });
  }
  sourceElement.forEach((value, key57, member) => {
    const keyValue = value_default(key57);
    let clonedMember;
    if (isObjectElement(targetElement) && targetElement.hasKey(keyValue) && options.isMergeableElement(value)) {
      const targetValue = targetElement.get(keyValue);
      clonedMember = cloneShallow(member);
      clonedMember.value = getMergeFunction(key57, options)(targetValue, value);
    } else {
      clonedMember = cloneShallow(member);
      clonedMember.value = cloneUnlessOtherwiseSpecified(value, options);
    }
    destination.remove(keyValue);
    destination.content.push(clonedMember);
  });
  return destination;
};
var defaultOptions2 = {
  clone: true,
  isMergeableElement: (element) => isObjectElement(element) || isArrayElement(element),
  arrayElementMerge: mergeArrayElement,
  objectElementMerge: mergeObjectElement,
  customMerge: void 0,
  customMetaMerge: void 0,
  customAttributesMerge: void 0
};
var deepmerge2 = (targetElement, sourceElement, options) => {
  var _mergedOptions$isMerg, _mergedOptions$arrayE, _mergedOptions$object;
  const mergedOptions = {
    ...defaultOptions2,
    ...options
  };
  mergedOptions.isMergeableElement = (_mergedOptions$isMerg = mergedOptions.isMergeableElement) !== null && _mergedOptions$isMerg !== void 0 ? _mergedOptions$isMerg : defaultOptions2.isMergeableElement;
  mergedOptions.arrayElementMerge = (_mergedOptions$arrayE = mergedOptions.arrayElementMerge) !== null && _mergedOptions$arrayE !== void 0 ? _mergedOptions$arrayE : defaultOptions2.arrayElementMerge;
  mergedOptions.objectElementMerge = (_mergedOptions$object = mergedOptions.objectElementMerge) !== null && _mergedOptions$object !== void 0 ? _mergedOptions$object : defaultOptions2.objectElementMerge;
  const sourceIsArrayElement = isArrayElement(sourceElement);
  const targetIsArrayElement = isArrayElement(targetElement);
  const sourceAndTargetTypesMatch = sourceIsArrayElement === targetIsArrayElement;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(sourceElement, mergedOptions);
  }
  const mergedElement = sourceIsArrayElement && typeof mergedOptions.arrayElementMerge === "function" ? mergedOptions.arrayElementMerge(targetElement, sourceElement, mergedOptions) : mergedOptions.objectElementMerge(targetElement, sourceElement, mergedOptions);
  mergedElement.meta = getMetaMergeFunction(mergedOptions)(targetElement.meta, sourceElement.meta);
  mergedElement.attributes = getAttributesMergeFunction(mergedOptions)(targetElement.attributes, sourceElement.attributes);
  return mergedElement;
};
deepmerge2.all = (list4, options) => {
  if (!Array.isArray(list4)) {
    throw new TypeError("First argument of deepmerge should be an array.");
  }
  if (list4.length === 0) {
    return new import_minim12.ObjectElement();
  }
  return list4.reduce((target, source) => {
    return deepmerge2(target, source, options);
  }, emptyElement(list4[0]));
};
var deepmerge_default = deepmerge2;

// node_modules/@swagger-api/apidom-core/src/merge/merge-right.mjs
var import_minim13 = __toESM(require_minim(), 1);
var mergeRight3 = (targetElement, sourceElement, options) => {
  const mergedOptions = {
    ...defaultOptions2,
    ...options,
    customMerge: () => (target, source) => source,
    clone: false
  };
  return deepmerge_default(targetElement, sourceElement, mergedOptions);
};
mergeRight3.all = (list4, options) => {
  if (!Array.isArray(list4)) {
    throw new TypeError("First argument of mergeRight should be an array.");
  }
  if (list4.length === 0) {
    return new import_minim13.ObjectElement();
  }
  return list4.reduce((target, source) => {
    return mergeRight3(target, source, options);
  }, emptyElement(list4[0]));
};
var merge_right_default = mergeRight3;

// node_modules/@swagger-api/apidom-core/src/merge/merge-left.mjs
var mergeLeft3 = (...[sourceElement, targetElement, options]) => {
  return merge_right_default(targetElement, sourceElement, options);
};
mergeLeft3.all = (...[list4, options]) => {
  return merge_right_default.all([...list4].reverse(), options);
};

// node_modules/@swagger-api/apidom-reference/src/errors/DereferenceError.mjs
var DereferenceError = class extends ApiDOMError_default {
};
var DereferenceError_default = DereferenceError;

// node_modules/@swagger-api/apidom-reference/src/errors/UnmatchedDereferenceStrategyError.mjs
var UnmatchedDereferenceStrategyError = class extends DereferenceError_default {
};
var UnmatchedDereferenceStrategyError_default = UnmatchedDereferenceStrategyError;

// node_modules/@swagger-api/apidom-reference/src/dereference/index.mjs
var dereferenceApiDOM = async (element, options) => {
  let parseResult = element;
  let surrogateWrapping = false;
  if (!isParseResultElement(element)) {
    const elementClone = cloneShallow(element);
    elementClone.classes.push("result");
    parseResult = new ParseResult_default([elementClone]);
    surrogateWrapping = true;
  }
  const file = new File_default({
    uri: options.resolve.baseURI,
    parseResult,
    mediaType: options.parse.mediaType
  });
  const dereferenceStrategies = await filter2("canDereference", [file, options], options.dereference.strategies);
  if (isEmpty_default(dereferenceStrategies)) {
    throw new UnmatchedDereferenceStrategyError_default(file.uri);
  }
  try {
    const {
      result
    } = await run("dereference", [file, options], dereferenceStrategies);
    return surrogateWrapping ? result.get(0) : result;
  } catch (error) {
    throw new DereferenceError_default(`Error while dereferencing file "${file.uri}"`, {
      cause: error
    });
  }
};

// node_modules/@swagger-api/apidom-reference/src/parse/parsers/Parser.mjs
var Parser = class {
  constructor({
    name: name2,
    allowEmpty = true,
    sourceMap = false,
    fileExtensions = [],
    mediaTypes: mediaTypes4 = []
  }) {
    __publicField(this, "name");
    /**
     * Whether to allow "empty" files. This includes zero-byte files.
     */
    __publicField(this, "allowEmpty");
    /**
     * Whether to generate source map during parsing.
     */
    __publicField(this, "sourceMap");
    /**
     * List of supported file extensions.
     */
    __publicField(this, "fileExtensions");
    /**
     * List of supported media types.
     */
    __publicField(this, "mediaTypes");
    this.name = name2;
    this.allowEmpty = allowEmpty;
    this.sourceMap = sourceMap;
    this.fileExtensions = fileExtensions;
    this.mediaTypes = mediaTypes4;
  }
};
var Parser_default = Parser;

// node_modules/@swagger-api/apidom-reference/src/resolve/resolvers/Resolver.mjs
var Resolver = class {
  constructor({
    name: name2
  }) {
    __publicField(this, "name");
    this.name = name2;
  }
};
var Resolver_default = Resolver;

// node_modules/@swagger-api/apidom-reference/src/resolve/resolvers/HTTPResolver.mjs
var HTTPResolver = class extends Resolver_default {
  constructor(options) {
    const {
      name: name2 = "http-resolver",
      timeout = 5e3,
      redirects = 5,
      withCredentials = false
    } = options !== null && options !== void 0 ? options : {};
    super({
      name: name2
    });
    __publicField(this, "timeout");
    __publicField(this, "redirects");
    __publicField(this, "withCredentials");
    this.timeout = timeout;
    this.redirects = redirects;
    this.withCredentials = withCredentials;
  }
  // eslint-disable-next-line class-methods-use-this
  canRead(file) {
    return isHttpUrl(file.uri);
  }
};
var HTTPResolver_default = HTTPResolver;

// node_modules/@swagger-api/apidom-reference/src/resolve/strategies/ResolveStrategy.mjs
var ResolveStrategy = class {
  constructor({
    name: name2
  }) {
    __publicField(this, "name");
    this.name = name2;
  }
};
var ResolveStrategy_default = ResolveStrategy;

// node_modules/@swagger-api/apidom-reference/src/dereference/strategies/DereferenceStrategy.mjs
var DereferenceStrategy = class {
  constructor({
    name: name2
  }) {
    __publicField(this, "name");
    this.name = name2;
  }
};
var DereferenceStrategy_default = DereferenceStrategy;

// node_modules/@swagger-api/apidom-reference/src/dereference/util.mjs
var AncestorLineage = class extends Array {
  includesCycle(element) {
    return this.filter((ancestors) => ancestors.has(element)).length > 1;
  }
  includes(searchElement, fromIndex) {
    if (searchElement instanceof Set) {
      return super.includes(searchElement, fromIndex);
    }
    return this.some((ancestors) => ancestors.has(searchElement));
  }
  findItem(predicate) {
    for (const set4 of this) {
      for (const item of set4) {
        if (isElement(item) && predicate(item)) {
          return item;
        }
      }
    }
    return void 0;
  }
};

// node_modules/@swagger-api/apidom-reference/src/Reference.mjs
var Reference = class {
  constructor({
    uri: uri2,
    depth = 0,
    refSet,
    value
  }) {
    __publicField(this, "uri");
    __publicField(this, "depth");
    __publicField(this, "value");
    __publicField(this, "refSet");
    __publicField(this, "errors");
    this.uri = uri2;
    this.value = value;
    this.depth = depth;
    this.refSet = refSet;
    this.errors = [];
  }
};
var Reference_default = Reference;

// node_modules/@swagger-api/apidom-reference/src/errors/JsonSchema$anchorError.mjs
var JsonSchema$anchorError = class extends ApiDOMError_default {
};
var JsonSchema_anchorError_default = JsonSchema$anchorError;

// node_modules/@swagger-api/apidom-reference/src/errors/EvaluationJsonSchema$anchorError.mjs
var EvaluationJsonSchema$anchorError = class extends JsonSchema_anchorError_default {
};
var EvaluationJsonSchema_anchorError_default = EvaluationJsonSchema$anchorError;

// node_modules/@swagger-api/apidom-reference/src/errors/JsonSchemaUriError.mjs
var JsonSchemaUriError = class extends ApiDOMError_default {
};
var JsonSchemaUriError_default = JsonSchemaUriError;

// node_modules/@swagger-api/apidom-reference/src/errors/EvaluationJsonSchemaUriError.mjs
var EvaluationJsonSchemaUriError = class extends JsonSchemaUriError_default {
};
var EvaluationJsonSchemaUriError_default = EvaluationJsonSchemaUriError;

// node_modules/@swagger-api/apidom-reference/src/errors/InvalidJsonSchema$anchorError.mjs
var InvalidJsonSchema$anchorError = class extends JsonSchema_anchorError_default {
  constructor(anchor) {
    super(`Invalid JSON Schema $anchor "${anchor}".`);
  }
};
var InvalidJsonSchema_anchorError_default = InvalidJsonSchema$anchorError;

// node_modules/@swagger-api/apidom-reference/src/errors/MaximumDereferenceDepthError.mjs
var MaximumDereferenceDepthError = class extends DereferenceError_default {
};
var MaximumDereferenceDepthError_default = MaximumDereferenceDepthError;

// node_modules/@swagger-api/apidom-reference/src/errors/MaximumResolveDepthError.mjs
var MaximumResolveDepthError = class extends ResolveError_default {
};
var MaximumResolveDepthError_default = MaximumResolveDepthError;

// node_modules/@swagger-api/apidom-reference/src/errors/ParserError.mjs
var ParserError = class extends ParseError_default {
};
var ParserError_default = ParserError;

// node_modules/@swagger-api/apidom-reference/src/index.mjs
var dereferenceApiDOM2 = async (element, options = {}) => {
  const mergedOptions = merge3(options_default, options);
  return dereferenceApiDOM(element, mergedOptions);
};

// node_modules/swagger-client/es/helpers/fetch-ponyfill.browser.js
var {
  fetch: fetch2,
  Response: Response2,
  Headers: Headers2,
  Request,
  FormData: FormData2,
  File: File3,
  Blob: Blob2
} = globalThis;

// node_modules/swagger-client/es/helpers/fetch-polyfill.browser.js
if (typeof globalThis.fetch === "undefined") {
  globalThis.fetch = fetch2;
}
if (typeof globalThis.Headers === "undefined") {
  globalThis.Headers = Headers2;
}
if (typeof globalThis.Request === "undefined") {
  globalThis.Request = Request;
}
if (typeof globalThis.Response === "undefined") {
  globalThis.Response = Response2;
}
if (typeof globalThis.FormData === "undefined") {
  globalThis.FormData = FormData2;
}
if (typeof globalThis.File === "undefined") {
  globalThis.File = File3;
}
if (typeof globalThis.Blob === "undefined") {
  globalThis.Blob = Blob2;
}

// node_modules/neotraverse/dist/legacy/legacy.mjs
function _array_like_to_array(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties4(target, props3) {
  for (var i2 = 0; i2 < props3.length; i2++) {
    var descriptor = props3[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties4(Constructor, staticProps);
  return Constructor;
}
function _instanceof(left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return !!right[Symbol.hasInstance](left);
  } else {
    return left instanceof right;
  }
}
function _iterable_to_array_limit(arr, i2) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null) return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s2, _e6;
  try {
    for (_i = _i.call(arr); !(_n2 = (_s2 = _i.next()).done); _n2 = true) {
      _arr.push(_s2.value);
      if (i2 && _arr.length === i2) break;
    }
  } catch (err2) {
    _d = true;
    _e6 = err2;
  } finally {
    try {
      if (!_n2 && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e6;
    }
  }
  return _arr;
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i2) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i2) || _unsupported_iterable_to_array(arr, i2) || _non_iterable_rest();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o4, minLen) {
  if (!o4) return;
  if (typeof o4 === "string") return _array_like_to_array(o4, minLen);
  var n = Object.prototype.toString.call(o4).slice(8, -1);
  if (n === "Object" && o4.constructor) n = o4.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o4, minLen);
}
var __typeError = function(msg) {
  throw TypeError(msg);
};
var __accessCheck = function(obj, member, msg) {
  return member.has(obj) || __typeError("Cannot " + msg);
};
var __privateGet2 = function(obj, member, getter) {
  return __accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = function(obj, member, value) {
  return member.has(obj) ? __typeError("Cannot add the same private member more than once") : _instanceof(member, WeakSet) ? member.add(obj) : member.set(obj, value);
};
var __privateSet2 = function(obj, member, value, setter) {
  return __accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value;
};
var to_string = function(obj) {
  return Object.prototype.toString.call(obj);
};
var is_typed_array = function(value) {
  return ArrayBuffer.isView(value) && !_instanceof(value, DataView);
};
var is_date = function(obj) {
  return to_string(obj) === "[object Date]";
};
var is_regexp = function(obj) {
  return to_string(obj) === "[object RegExp]";
};
var is_error = function(obj) {
  return to_string(obj) === "[object Error]";
};
var is_boolean = function(obj) {
  return to_string(obj) === "[object Boolean]";
};
var is_number = function(obj) {
  return to_string(obj) === "[object Number]";
};
var is_string = function(obj) {
  return to_string(obj) === "[object String]";
};
var is_array = Array.isArray;
var gopd = Object.getOwnPropertyDescriptor;
var is_property_enumerable = Object.prototype.propertyIsEnumerable;
var get_own_property_symbols = Object.getOwnPropertySymbols;
var has_own_property = Object.prototype.hasOwnProperty;
function own_enumerable_keys(obj) {
  var res = Object.keys(obj);
  var symbols = get_own_property_symbols(obj);
  for (var i2 = 0; i2 < symbols.length; i2++) {
    if (is_property_enumerable.call(obj, symbols[i2])) {
      res.push(symbols[i2]);
    }
  }
  return res;
}
function is_writable(object2, key57) {
  var _gopd;
  return !((_gopd = gopd(object2, key57)) === null || _gopd === void 0 ? void 0 : _gopd.writable);
}
function copy(src, options) {
  if ((typeof src === "undefined" ? "undefined" : _type_of(src)) === "object" && src !== null) {
    var dst;
    if (is_array(src)) {
      dst = [];
    } else if (is_date(src)) {
      dst = new Date(src.getTime ? src.getTime() : src);
    } else if (is_regexp(src)) {
      dst = new RegExp(src);
    } else if (is_error(src)) {
      dst = {
        message: src.message
      };
    } else if (is_boolean(src) || is_number(src) || is_string(src)) {
      dst = Object(src);
    } else if (is_typed_array(src)) {
      return src.slice();
    } else {
      dst = Object.create(Object.getPrototypeOf(src));
    }
    var iterator_function = options.includeSymbols ? own_enumerable_keys : Object.keys;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
    try {
      for (var _iterator = iterator_function(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key57 = _step.value;
        dst[key57] = src[key57];
      }
    } catch (err2) {
      _didIteratorError = true;
      _iteratorError = err2;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return dst;
  }
  return src;
}
var empty_null = {
  includeSymbols: false,
  immutable: false
};
function walk(root, cb) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : empty_null;
  var path4 = [];
  var parents = [];
  var alive = true;
  var iterator_function = options.includeSymbols ? own_enumerable_keys : Object.keys;
  var immutable = !!options.immutable;
  return function walker(node_) {
    var node = immutable ? copy(node_, options) : node_;
    var modifiers = {};
    var keep_going = true;
    var state2 = {
      node,
      node_,
      path: [].concat(path4),
      parent: parents[parents.length - 1],
      parents,
      key: path4[path4.length - 1],
      isRoot: path4.length === 0,
      level: path4.length,
      circular: void 0,
      isLeaf: false,
      notLeaf: true,
      notRoot: true,
      isFirst: false,
      isLast: false,
      update: function update4(x2) {
        var stopHere = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!state2.isRoot) {
          state2.parent.node[state2.key] = x2;
        }
        state2.node = x2;
        if (stopHere) {
          keep_going = false;
        }
      },
      delete: function _delete(stopHere) {
        delete state2.parent.node[state2.key];
        if (stopHere) {
          keep_going = false;
        }
      },
      remove: function remove5(stopHere) {
        if (is_array(state2.parent.node)) {
          state2.parent.node.splice(state2.key, 1);
        } else {
          delete state2.parent.node[state2.key];
        }
        if (stopHere) {
          keep_going = false;
        }
      },
      keys: null,
      before: function before(f2) {
        modifiers.before = f2;
      },
      after: function after(f2) {
        modifiers.after = f2;
      },
      pre: function pre(f2) {
        modifiers.pre = f2;
      },
      post: function post(f2) {
        modifiers.post = f2;
      },
      stop: function stop() {
        alive = false;
      },
      block: function block2() {
        keep_going = false;
      }
    };
    if (!alive) {
      return state2;
    }
    function update_state() {
      if (_type_of(state2.node) === "object" && state2.node !== null) {
        if (!state2.keys || state2.node_ !== state2.node) {
          state2.keys = iterator_function(state2.node);
        }
        state2.isLeaf = state2.keys.length === 0;
        for (var i2 = 0; i2 < parents.length; i2++) {
          if (parents[i2].node_ === node_) {
            state2.circular = parents[i2];
            break;
          }
        }
      } else {
        state2.isLeaf = true;
        state2.keys = null;
      }
      state2.notLeaf = !state2.isLeaf;
      state2.notRoot = !state2.isRoot;
    }
    update_state();
    var ret = cb.call(state2, state2.node);
    if (ret !== void 0 && state2.update) {
      state2.update(ret);
    }
    if (modifiers.before) {
      modifiers.before.call(state2, state2.node);
    }
    if (!keep_going) {
      return state2;
    }
    if (_type_of(state2.node) === "object" && state2.node !== null && !state2.circular) {
      parents.push(state2);
      update_state();
      var _state_keys;
      var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
      try {
        for (var _iterator = Object.entries((_state_keys = state2.keys) !== null && _state_keys !== void 0 ? _state_keys : [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step_value = _sliced_to_array(_step.value, 2), index = _step_value[0], key57 = _step_value[1];
          var _state_keys1;
          path4.push(key57);
          if (modifiers.pre) {
            modifiers.pre.call(state2, state2.node[key57], key57);
          }
          var child = walker(state2.node[key57]);
          if (immutable && has_own_property.call(state2.node, key57) && !is_writable(state2.node, key57)) {
            state2.node[key57] = child.node;
          }
          child.isLast = ((_state_keys1 = state2.keys) === null || _state_keys1 === void 0 ? void 0 : _state_keys1.length) ? +index === state2.keys.length - 1 : false;
          child.isFirst = +index === 0;
          if (modifiers.post) {
            modifiers.post.call(state2, child);
          }
          path4.pop();
        }
      } catch (err2) {
        _didIteratorError = true;
        _iteratorError = err2;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      parents.pop();
    }
    if (modifiers.after) {
      modifiers.after.call(state2, state2.node);
    }
    return state2;
  }(root).node;
}
var _value;
var _options;
var Traverse = function() {
  "use strict";
  function Traverse2(obj) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : empty_null;
    _class_call_check(this, Traverse2);
    __privateAdd2(this, _value);
    __privateAdd2(this, _options);
    __privateSet2(this, _value, obj);
    __privateSet2(this, _options, options);
  }
  _create_class(Traverse2, [
    {
      /**
      * Get the element at the array `path`.
      */
      key: "get",
      value: function get3(paths4) {
        var node = __privateGet2(this, _value);
        for (var i2 = 0; node && i2 < paths4.length; i2++) {
          var key57 = paths4[i2];
          if (!has_own_property.call(node, key57) || !__privateGet2(this, _options).includeSymbols && (typeof key57 === "undefined" ? "undefined" : _type_of(key57)) === "symbol") {
            return void 0;
          }
          node = node[key57];
        }
        return node;
      }
    },
    {
      /**
      * Return whether the element at the array `path` exists.
      */
      key: "has",
      value: function has4(paths4) {
        var node = __privateGet2(this, _value);
        for (var i2 = 0; node && i2 < paths4.length; i2++) {
          var key57 = paths4[i2];
          if (!has_own_property.call(node, key57) || !__privateGet2(this, _options).includeSymbols && (typeof key57 === "undefined" ? "undefined" : _type_of(key57)) === "symbol") {
            return false;
          }
          node = node[key57];
        }
        return true;
      }
    },
    {
      /**
      * Set the element at the array `path` to `value`.
      */
      key: "set",
      value: function set4(path4, value) {
        var node = __privateGet2(this, _value);
        var i2 = 0;
        for (i2 = 0; i2 < path4.length - 1; i2++) {
          var key57 = path4[i2];
          if (!has_own_property.call(node, key57)) {
            node[key57] = {};
          }
          node = node[key57];
        }
        node[path4[i2]] = value;
        return value;
      }
    },
    {
      /**
      * Execute `fn` for each node in the object and return a new object with the results of the walk. To update nodes in the result use `this.update(value)`.
      */
      key: "map",
      value: function map5(cb) {
        return walk(__privateGet2(this, _value), cb, {
          immutable: true,
          includeSymbols: !!__privateGet2(this, _options).includeSymbols
        });
      }
    },
    {
      /**
      * Execute `fn` for each node in the object but unlike `.map()`, when `this.update()` is called it updates the object in-place.
      */
      key: "forEach",
      value: function forEach4(cb) {
        __privateSet2(this, _value, walk(__privateGet2(this, _value), cb, __privateGet2(this, _options)));
        return __privateGet2(this, _value);
      }
    },
    {
      /**
      * For each node in the object, perform a [left-fold](http://en.wikipedia.org/wiki/Fold_(higher-order_function)) with the return value of `fn(acc, node)`.
      *
      * If `init` isn't specified, `init` is set to the root object for the first step and the root element is skipped.
      */
      key: "reduce",
      value: function reduce2(cb, init2) {
        var skip = arguments.length === 1;
        var acc = skip ? __privateGet2(this, _value) : init2;
        this.forEach(function(x2) {
          if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x2);
          }
        });
        return acc;
      }
    },
    {
      /**
      * Return an `Array` of every possible non-cyclic path in the object.
      * Paths are `Array`s of string keys.
      */
      key: "paths",
      value: function paths4() {
        var acc = [];
        this.forEach(function() {
          acc.push(this.path);
        });
        return acc;
      }
    },
    {
      /**
      * Return an `Array` of every node in the object.
      */
      key: "nodes",
      value: function nodes() {
        var acc = [];
        this.forEach(function() {
          acc.push(this.node);
        });
        return acc;
      }
    },
    {
      /**
      * Create a deep clone of the object.
      */
      key: "clone",
      value: function clone4() {
        var parents = [];
        var nodes = [];
        var options = __privateGet2(this, _options);
        if (is_typed_array(__privateGet2(this, _value))) {
          return __privateGet2(this, _value).slice();
        }
        return function clone5(src) {
          for (var i2 = 0; i2 < parents.length; i2++) {
            if (parents[i2] === src) {
              return nodes[i2];
            }
          }
          if ((typeof src === "undefined" ? "undefined" : _type_of(src)) === "object" && src !== null) {
            var dst = copy(src, options);
            parents.push(src);
            nodes.push(dst);
            var iteratorFunction = options.includeSymbols ? own_enumerable_keys : Object.keys;
            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
            try {
              for (var _iterator = iteratorFunction(src)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var key57 = _step.value;
                dst[key57] = clone5(src[key57]);
              }
            } catch (err2) {
              _didIteratorError = true;
              _iteratorError = err2;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            parents.pop();
            nodes.pop();
            return dst;
          }
          return src;
        }(__privateGet2(this, _value));
      }
    }
  ]);
  return Traverse2;
}();
_value = /* @__PURE__ */ new WeakMap();
_options = /* @__PURE__ */ new WeakMap();
var traverse3 = function(obj, options) {
  return new Traverse(obj, options);
};
traverse3.get = function(obj, paths4, options) {
  return new Traverse(obj, options).get(paths4);
};
traverse3.set = function(obj, path4, value, options) {
  return new Traverse(obj, options).set(path4, value);
};
traverse3.has = function(obj, paths4, options) {
  return new Traverse(obj, options).has(paths4);
};
traverse3.map = function(obj, cb, options) {
  return new Traverse(obj, options).map(cb);
};
traverse3.forEach = function(obj, cb, options) {
  return new Traverse(obj, options).forEach(cb);
};
traverse3.reduce = function(obj, cb, init2, options) {
  return new Traverse(obj, options).reduce(cb, init2);
};
traverse3.paths = function(obj, options) {
  return new Traverse(obj, options).paths();
};
traverse3.nodes = function(obj, options) {
  return new Traverse(obj, options).nodes();
};
traverse3.clone = function(obj, options) {
  return new Traverse(obj, options).clone();
};
var src_default = traverse3;

// node_modules/swagger-client/es/constants.js
var ACCEPT_HEADER_VALUE_FOR_DOCUMENTS = "application/json, application/yaml";
var DEFAULT_BASE_URL = "https://swagger.io";
var DEFAULT_OPENAPI_3_SERVER = Object.freeze({
  url: "/"
});

// node_modules/swagger-client/es/resolver/specmap/helpers.js
var freelyNamedKeyParents = ["properties"];
var nonFreelyNamedKeyGrandparents = ["properties"];
var freelyNamedPaths = [
  // Swagger 2.0
  "definitions",
  "parameters",
  "responses",
  "securityDefinitions",
  // OpenAPI 3.0
  "components/schemas",
  "components/responses",
  "components/parameters",
  "components/securitySchemes"
];
var freelyNamedAncestors = ["schema/example", "items/example"];
function isFreelyNamed(parentPath) {
  const parentKey = parentPath[parentPath.length - 1];
  const grandparentKey = parentPath[parentPath.length - 2];
  const parentStr = parentPath.join("/");
  return (
    // eslint-disable-next-line max-len
    freelyNamedKeyParents.indexOf(parentKey) > -1 && nonFreelyNamedKeyGrandparents.indexOf(grandparentKey) === -1 || freelyNamedPaths.indexOf(parentStr) > -1 || freelyNamedAncestors.some((el2) => parentStr.indexOf(el2) > -1)
  );
}
function generateAbsoluteRefPatches(obj, basePath, {
  specmap,
  getBaseUrlForNodePath = (path4) => specmap.getContext([...basePath, ...path4]).baseDoc,
  targetKeys = ["$ref", "$$ref"]
} = {}) {
  const patches = [];
  src_default(obj).forEach(function callback() {
    if (targetKeys.includes(this.key) && typeof this.node === "string") {
      const nodePath = this.path;
      const fullPath = basePath.concat(this.path);
      const absolutifiedRefValue = absolutifyPointer(this.node, getBaseUrlForNodePath(nodePath));
      patches.push(specmap.replace(fullPath, absolutifiedRefValue));
    }
  });
  return patches;
}
function absolutifyPointer(pointer, baseUrl2) {
  const [urlPart, fragmentPart] = pointer.split("#");
  const safeBaseUrl = baseUrl2 !== null && baseUrl2 !== void 0 ? baseUrl2 : "";
  const safeUrlPart = urlPart !== null && urlPart !== void 0 ? urlPart : "";
  let newRefUrlPart;
  if (!url_exports.isHttpUrl(safeBaseUrl)) {
    const absoluteBaseUrl = url_exports.resolve(DEFAULT_BASE_URL, safeBaseUrl);
    const absoluteRefUrlPart = url_exports.resolve(absoluteBaseUrl, safeUrlPart);
    const rawRefUrlPart = absoluteRefUrlPart.replace(DEFAULT_BASE_URL, "");
    newRefUrlPart = safeUrlPart.startsWith("/") ? rawRefUrlPart : rawRefUrlPart.substring(1);
  } else {
    newRefUrlPart = url_exports.resolve(safeBaseUrl, safeUrlPart);
  }
  return fragmentPart ? `${newRefUrlPart}#${fragmentPart}` : newRefUrlPart;
}

// node_modules/swagger-client/es/resolver/specmap/lib/refs.js
var ABSOLUTE_URL_REGEXP = /^([a-z]+:\/\/|\/\/)/i;
var JSONRefError = class extends ApiDOMStructuredError_default {
};
var docCache = {};
var specmapRefs = /* @__PURE__ */ new WeakMap();
var skipResolutionTestFns = [
  // OpenAPI 2.0 response examples
  (path4) => (
    // ["paths", *, *, "responses", *, "examples"]
    path4[0] === "paths" && path4[3] === "responses" && path4[5] === "examples"
  ),
  // OpenAPI 3.0 Response Media Type Examples
  (path4) => (
    // ["paths", *, *, "responses", *, "content", *, "example"]
    path4[0] === "paths" && path4[3] === "responses" && path4[5] === "content" && path4[7] === "example"
  ),
  (path4) => (
    // ["paths", *, *, "responses", *, "content", *, "examples", *, "value"]
    path4[0] === "paths" && path4[3] === "responses" && path4[5] === "content" && path4[7] === "examples" && path4[9] === "value"
  ),
  // OpenAPI 3.0 Request Body Media Type Examples
  (path4) => (
    // ["paths", *, *, "requestBody", "content", *, "example"]
    path4[0] === "paths" && path4[3] === "requestBody" && path4[4] === "content" && path4[6] === "example"
  ),
  (path4) => (
    // ["paths", *, *, "requestBody", "content", *, "examples", *, "value"]
    path4[0] === "paths" && path4[3] === "requestBody" && path4[4] === "content" && path4[6] === "examples" && path4[8] === "value"
  ),
  // OAS 3.0 Parameter Examples
  (path4) => (
    // ["paths", *, "parameters", *, "example"]
    path4[0] === "paths" && path4[2] === "parameters" && path4[4] === "example"
  ),
  (path4) => (
    // ["paths", *, *, "parameters", *, "example"]
    path4[0] === "paths" && path4[3] === "parameters" && path4[5] === "example"
  ),
  (path4) => (
    // ["paths", *, "parameters", *, "examples", *, "value"]
    path4[0] === "paths" && path4[2] === "parameters" && path4[4] === "examples" && path4[6] === "value"
  ),
  (path4) => (
    // ["paths", *, *, "parameters", *, "examples", *, "value"]
    path4[0] === "paths" && path4[3] === "parameters" && path4[5] === "examples" && path4[7] === "value"
  ),
  (path4) => (
    // ["paths", *, "parameters", *, "content", *, "example"]
    path4[0] === "paths" && path4[2] === "parameters" && path4[4] === "content" && path4[6] === "example"
  ),
  (path4) => (
    // ["paths", *, "parameters", *, "content", *, "examples", *, "value"]
    path4[0] === "paths" && path4[2] === "parameters" && path4[4] === "content" && path4[6] === "examples" && path4[8] === "value"
  ),
  (path4) => (
    // ["paths", *, *, "parameters", *, "content", *, "example"]
    path4[0] === "paths" && path4[3] === "parameters" && path4[4] === "content" && path4[7] === "example"
  ),
  (path4) => (
    // ["paths", *, *, "parameters", *, "content", *, "examples", *, "value"]
    path4[0] === "paths" && path4[3] === "parameters" && path4[5] === "content" && path4[7] === "examples" && path4[9] === "value"
  )
];
var shouldSkipResolution = (path4) => skipResolutionTestFns.some((fn2) => fn2(path4));
var plugin = {
  key: "$ref",
  plugin: (ref, key57, fullPath, specmap) => {
    const specmapInstance = specmap.getInstance();
    const parent = fullPath.slice(0, -1);
    if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {
      return void 0;
    }
    const {
      baseDoc
    } = specmap.getContext(fullPath);
    if (typeof ref !== "string") {
      return new JSONRefError("$ref: must be a string (JSON-Ref)", {
        $ref: ref,
        baseDoc,
        fullPath
      });
    }
    const splitString = split2(ref);
    const refPath = splitString[0];
    const pointer = splitString[1] || "";
    let basePath;
    try {
      basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;
    } catch (e2) {
      return wrapError(e2, {
        pointer,
        $ref: ref,
        basePath,
        fullPath
      });
    }
    let promOrVal;
    let tokens;
    if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {
      if (!specmapInstance.useCircularStructures) {
        const absolutifiedRef2 = absolutifyPointer(ref, basePath);
        if (ref === absolutifiedRef2) {
          return null;
        }
        return lib_default.replace(fullPath, absolutifiedRef2);
      }
    }
    if (basePath == null) {
      tokens = jsonPointerToArray(pointer);
      promOrVal = specmap.get(tokens);
      if (typeof promOrVal === "undefined") {
        promOrVal = new JSONRefError(`Could not resolve reference: ${ref}`, {
          pointer,
          $ref: ref,
          baseDoc,
          fullPath
        });
      }
    } else {
      promOrVal = extractFromDoc(basePath, pointer);
      if (promOrVal.__value != null) {
        promOrVal = promOrVal.__value;
      } else {
        promOrVal = promOrVal.catch((e2) => {
          throw wrapError(e2, {
            pointer,
            $ref: ref,
            baseDoc,
            fullPath
          });
        });
      }
    }
    if (promOrVal instanceof Error) {
      return [lib_default.remove(fullPath), promOrVal];
    }
    const absolutifiedRef = absolutifyPointer(ref, basePath);
    const patch = lib_default.replace(parent, promOrVal, {
      $$ref: absolutifiedRef
    });
    if (basePath && basePath !== baseDoc) {
      return [patch, lib_default.context(parent, {
        baseDoc: basePath
      })];
    }
    try {
      if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {
        return patch;
      }
    } catch (e2) {
      return null;
    }
    return void 0;
  }
};
var mod = Object.assign(plugin, {
  docCache,
  absoluteify,
  clearCache,
  JSONRefError,
  wrapError,
  getDoc,
  split: split2,
  extractFromDoc,
  fetchJSON,
  extract,
  jsonPointerToArray,
  unescapeJsonPointerToken
});
var refs_default = mod;
function absoluteify(path4, basePath) {
  if (!ABSOLUTE_URL_REGEXP.test(path4)) {
    if (!basePath) {
      throw new JSONRefError(`Tried to resolve a relative URL, without having a basePath. path: '${path4}' basePath: '${basePath}'`);
    }
    return url_exports.resolve(basePath, path4);
  }
  return path4;
}
function wrapError(e2, extra) {
  let message;
  if (e2 && e2.response && e2.response.body) {
    message = `${e2.response.body.code} ${e2.response.body.message}`;
  } else {
    message = e2.message;
  }
  return new JSONRefError(`Could not resolve reference: ${message}`, {
    ...extra,
    cause: e2
  });
}
function split2(ref) {
  return (ref + "").split("#");
}
function extractFromDoc(docPath, pointer) {
  const doc = docCache[docPath];
  if (doc && !lib_default.isPromise(doc)) {
    try {
      const v2 = extract(pointer, doc);
      return Object.assign(Promise.resolve(v2), {
        __value: v2
      });
    } catch (e2) {
      return Promise.reject(e2);
    }
  }
  return getDoc(docPath).then((_doc) => extract(pointer, _doc));
}
function clearCache(item) {
  if (typeof item !== "undefined") {
    delete docCache[item];
  } else {
    Object.keys(docCache).forEach((key57) => {
      delete docCache[key57];
    });
  }
}
function getDoc(docPath) {
  const val = docCache[docPath];
  if (val) {
    return lib_default.isPromise(val) ? val : Promise.resolve(val);
  }
  docCache[docPath] = mod.fetchJSON(docPath).then((doc) => {
    docCache[docPath] = doc;
    return doc;
  });
  return docCache[docPath];
}
function fetchJSON(docPath) {
  return fetch(docPath, {
    headers: {
      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS
    },
    loadSpec: true
  }).then((res) => res.text()).then((text3) => js_yaml_default.load(text3));
}
function extract(pointer, obj) {
  const tokens = jsonPointerToArray(pointer);
  if (tokens.length < 1) {
    return obj;
  }
  const val = lib_default.getIn(obj, tokens);
  if (typeof val === "undefined") {
    throw new JSONRefError(`Could not resolve pointer: ${pointer} does not exist in document`, {
      pointer
    });
  }
  return val;
}
function jsonPointerToArray(pointer) {
  if (typeof pointer !== "string") {
    throw new TypeError(`Expected a string, got a ${typeof pointer}`);
  }
  if (pointer[0] === "/") {
    pointer = pointer.substr(1);
  }
  if (pointer === "") {
    return [];
  }
  return pointer.split("/").map(unescapeJsonPointerToken);
}
function unescapeJsonPointerToken(token) {
  if (typeof token !== "string") {
    return token;
  }
  const params = new URLSearchParams(`=${token.replace(/~1/g, "/").replace(/~0/g, "~")}`);
  return params.get("");
}
function escapeJsonPointerToken(token) {
  const params = new URLSearchParams([["", token.replace(/~/g, "~0").replace(/\//g, "~1")]]);
  return params.toString().slice(1);
}
function arrayToJsonPointer(arr) {
  if (arr.length === 0) {
    return "";
  }
  return `/${arr.map(escapeJsonPointerToken).join("/")}`;
}
var pointerBoundaryChar = (c2) => !c2 || c2 === "/" || c2 === "#";
function pointerIsAParent(pointer, parentPointer) {
  if (pointerBoundaryChar(parentPointer)) {
    return true;
  }
  const nextChar = pointer.charAt(parentPointer.length);
  const lastParentChar = parentPointer.slice(-1);
  return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === "/" || nextChar === "#") && lastParentChar !== "#";
}
function pointerAlreadyInPath(pointer, basePath, parent, specmap) {
  let refs = specmapRefs.get(specmap);
  if (!refs) {
    refs = {};
    specmapRefs.set(specmap, refs);
  }
  const parentPointer = arrayToJsonPointer(parent);
  const fullyQualifiedPointer = `${basePath || "<specmap-base>"}#${pointer}`;
  const safeParentPointer = parentPointer.replace(/allOf\/\d+\/?/g, "");
  const rootDoc = specmap.contextTree.get([]).baseDoc;
  if (basePath === rootDoc && pointerIsAParent(safeParentPointer, pointer)) {
    return true;
  }
  let currPath = "";
  const hasIndirectCycle = parent.some((token) => {
    currPath = `${currPath}/${escapeJsonPointerToken(token)}`;
    return refs[currPath] && refs[currPath].some((ref) => pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref));
  });
  if (hasIndirectCycle) {
    return true;
  }
  refs[safeParentPointer] = (refs[safeParentPointer] || []).concat(fullyQualifiedPointer);
  return void 0;
}
function patchValueAlreadyInPath(root, patch) {
  const ancestors = [root];
  patch.path.reduce((parent, p2) => {
    ancestors.push(parent[p2]);
    return parent[p2];
  }, root);
  return pointToAncestor(patch.value);
  function pointToAncestor(obj) {
    return lib_default.isObject(obj) && (ancestors.indexOf(obj) >= 0 || Object.keys(obj).some((k) => pointToAncestor(obj[k])));
  }
}

// node_modules/swagger-client/es/resolver/specmap/lib/all-of.js
var all_of_default = {
  key: "allOf",
  plugin: (val, key57, fullPath, specmap, patch) => {
    if (patch.meta && patch.meta.$$ref) {
      return void 0;
    }
    const parent = fullPath.slice(0, -1);
    if (isFreelyNamed(parent)) {
      return void 0;
    }
    if (!Array.isArray(val)) {
      const err2 = new TypeError("allOf must be an array");
      err2.fullPath = fullPath;
      return err2;
    }
    let alreadyAddError = false;
    let originalDefinitionObj = patch.value;
    parent.forEach((part) => {
      if (!originalDefinitionObj) return;
      originalDefinitionObj = originalDefinitionObj[part];
    });
    originalDefinitionObj = {
      ...originalDefinitionObj
    };
    if (Object.keys(originalDefinitionObj).length === 0) {
      return void 0;
    }
    delete originalDefinitionObj.allOf;
    const patches = [];
    patches.push(specmap.replace(parent, {}));
    val.forEach((toMerge, i2) => {
      if (!specmap.isObject(toMerge)) {
        if (alreadyAddError) {
          return null;
        }
        alreadyAddError = true;
        const err2 = new TypeError("Elements in allOf must be objects");
        err2.fullPath = fullPath;
        return patches.push(err2);
      }
      patches.push(specmap.mergeDeep(parent, toMerge));
      const collapsedFullPath = fullPath.slice(0, -1);
      const absoluteRefPatches = generateAbsoluteRefPatches(toMerge, collapsedFullPath, {
        getBaseUrlForNodePath: (nodePath) => specmap.getContext([...fullPath, i2, ...nodePath]).baseDoc,
        specmap
      });
      patches.push(...absoluteRefPatches);
      return void 0;
    });
    if (originalDefinitionObj.example) {
      patches.push(specmap.remove([].concat(parent, "example")));
    }
    patches.push(specmap.mergeDeep(parent, originalDefinitionObj));
    if (!originalDefinitionObj.$$ref) {
      patches.push(specmap.remove([].concat(parent, "$$ref")));
    }
    return patches;
  }
};

// node_modules/swagger-client/es/resolver/specmap/lib/parameters.js
var parameters_default = {
  key: "parameters",
  plugin: (parameters, key57, fullPath, specmap) => {
    if (Array.isArray(parameters) && parameters.length) {
      const val = Object.assign([], parameters);
      const opPath = fullPath.slice(0, -1);
      const op = {
        ...lib_default.getIn(specmap.spec, opPath)
      };
      for (let i2 = 0; i2 < parameters.length; i2 += 1) {
        const param = parameters[i2];
        try {
          val[i2].default = specmap.parameterMacro(op, param);
        } catch (e2) {
          const err2 = new Error(e2);
          err2.fullPath = fullPath;
          return err2;
        }
      }
      return lib_default.replace(fullPath, val);
    }
    return lib_default.replace(fullPath, parameters);
  }
};

// node_modules/swagger-client/es/resolver/specmap/lib/properties.js
var properties_default = {
  key: "properties",
  plugin: (properties, key57, fullPath, specmap) => {
    const val = {
      ...properties
    };
    for (const k in properties) {
      try {
        val[k].default = specmap.modelPropertyMacro(val[k]);
      } catch (e2) {
        const err2 = new Error(e2);
        err2.fullPath = fullPath;
        return err2;
      }
    }
    const patch = lib_default.replace(fullPath, val);
    return patch;
  }
};

// node_modules/swagger-client/es/resolver/specmap/lib/context-tree.js
var ContextTree = class {
  constructor(value) {
    this.root = createNode(value || {});
  }
  set(path4, value) {
    const parent = this.getParent(path4, true);
    if (!parent) {
      updateNode(this.root, value, null);
      return;
    }
    const key57 = path4[path4.length - 1];
    const {
      children
    } = parent;
    if (children[key57]) {
      updateNode(children[key57], value, parent);
      return;
    }
    children[key57] = createNode(value, parent);
  }
  // Get the "best" node (node or nearest parent) and return its value.
  get(path4) {
    path4 = path4 || [];
    if (path4.length < 1) {
      return this.root.value;
    }
    let branch = this.root;
    let child;
    let token;
    for (let i2 = 0; i2 < path4.length; i2 += 1) {
      token = path4[i2];
      child = branch.children;
      if (!child[token]) {
        break;
      }
      branch = child[token];
    }
    return branch && branch.protoValue;
  }
  getParent(path4, ensureExists) {
    if (!path4 || path4.length < 1) {
      return null;
    }
    if (path4.length < 2) {
      return this.root;
    }
    return path4.slice(0, -1).reduce((branch, token) => {
      if (!branch) {
        return branch;
      }
      const {
        children
      } = branch;
      if (!children[token] && ensureExists) {
        children[token] = createNode(null, branch);
      }
      return children[token];
    }, this.root);
  }
};
function createNode(value, parent) {
  return updateNode({
    children: {}
  }, value, parent);
}
function updateNode(node, value, parent) {
  node.value = value || {};
  node.protoValue = parent ? {
    ...parent.protoValue,
    ...node.value
  } : node.value;
  Object.keys(node.children).forEach((prop3) => {
    const child = node.children[prop3];
    node.children[prop3] = updateNode(child, child.value, node);
  });
  return node;
}

// node_modules/swagger-client/es/resolver/specmap/index.js
var PLUGIN_DISPATCH_LIMIT = 100;
var TRAVERSE_LIMIT = 3e3;
var noop2 = () => {
};
var SpecMap = class {
  static getPluginName(plugin7) {
    return plugin7.pluginName;
  }
  static getPatchesOfType(patches, fn2) {
    return patches.filter(fn2);
  }
  constructor(opts) {
    Object.assign(this, {
      spec: "",
      debugLevel: "info",
      plugins: [],
      pluginHistory: {},
      errors: [],
      mutations: [],
      promisedPatches: [],
      state: {},
      patches: [],
      context: {},
      contextTree: new ContextTree(),
      showDebug: false,
      allPatches: [],
      // only populated if showDebug is true
      pluginProp: "specMap",
      libMethods: Object.assign(Object.create(this), lib_default, {
        getInstance: () => this
      }),
      allowMetaPatches: false
    }, opts);
    this.get = this._get.bind(this);
    this.getContext = this._getContext.bind(this);
    this.hasRun = this._hasRun.bind(this);
    this.wrappedPlugins = this.plugins.map(this.wrapPlugin.bind(this)).filter(lib_default.isFunction);
    this.patches.push(lib_default.add([], this.spec));
    this.patches.push(lib_default.context([], this.context));
    this.updatePatches(this.patches);
  }
  debug(level, ...args) {
    if (this.debugLevel === level) {
      console.log(...args);
    }
  }
  verbose(header2, ...args) {
    if (this.debugLevel === "verbose") {
      console.log(`[${header2}]   `, ...args);
    }
  }
  wrapPlugin(plugin7, name2) {
    const {
      pathDiscriminator
    } = this;
    let ctx = null;
    let fn2;
    if (plugin7[this.pluginProp]) {
      ctx = plugin7;
      fn2 = plugin7[this.pluginProp];
    } else if (lib_default.isFunction(plugin7)) {
      fn2 = plugin7;
    } else if (lib_default.isObject(plugin7)) {
      fn2 = createKeyBasedPlugin(plugin7);
    }
    return Object.assign(fn2.bind(ctx), {
      pluginName: plugin7.name || name2,
      isGenerator: lib_default.isGenerator(fn2)
    });
    function createKeyBasedPlugin(pluginObj) {
      const isSubPath = (path4, tested) => {
        if (!Array.isArray(path4)) {
          return true;
        }
        return path4.every((val, i2) => val === tested[i2]);
      };
      return function* generator(patches, specmap) {
        const refCache = {};
        for (const [i2, patch] of patches.filter(lib_default.isAdditiveMutation).entries()) {
          if (i2 < TRAVERSE_LIMIT) {
            yield* traverse4(patch.value, patch.path, patch);
          } else {
            return;
          }
        }
        function* traverse4(obj, path4, patch) {
          if (!lib_default.isObject(obj)) {
            if (pluginObj.key === path4[path4.length - 1]) {
              yield pluginObj.plugin(obj, pluginObj.key, path4, specmap);
            }
          } else {
            const parentIndex = path4.length - 1;
            const parent = path4[parentIndex];
            const indexOfFirstProperties = path4.indexOf("properties");
            const isRootProperties = parent === "properties" && parentIndex === indexOfFirstProperties;
            const traversed = specmap.allowMetaPatches && refCache[obj.$$ref];
            for (const key57 of Object.keys(obj)) {
              const val = obj[key57];
              const updatedPath = path4.concat(key57);
              const isObj2 = lib_default.isObject(val);
              const objRef = obj.$$ref;
              if (!traversed) {
                if (isObj2) {
                  if (specmap.allowMetaPatches && objRef) {
                    refCache[objRef] = true;
                  }
                  yield* traverse4(val, updatedPath, patch);
                }
              }
              if (!isRootProperties && key57 === pluginObj.key) {
                const isWithinPathDiscriminator = isSubPath(pathDiscriminator, path4);
                if (!pathDiscriminator || isWithinPathDiscriminator) {
                  yield pluginObj.plugin(val, key57, updatedPath, specmap, patch);
                }
              }
            }
          }
        }
      };
    }
  }
  nextPlugin() {
    return this.wrappedPlugins.find((plugin7) => {
      const mutations = this.getMutationsForPlugin(plugin7);
      return mutations.length > 0;
    });
  }
  nextPromisedPatch() {
    if (this.promisedPatches.length > 0) {
      return Promise.race(this.promisedPatches.map((patch) => patch.value));
    }
    return void 0;
  }
  getPluginHistory(plugin7) {
    const name2 = this.constructor.getPluginName(plugin7);
    return this.pluginHistory[name2] || [];
  }
  getPluginRunCount(plugin7) {
    return this.getPluginHistory(plugin7).length;
  }
  getPluginHistoryTip(plugin7) {
    const history2 = this.getPluginHistory(plugin7);
    const val = history2 && history2[history2.length - 1];
    return val || {};
  }
  getPluginMutationIndex(plugin7) {
    const mi = this.getPluginHistoryTip(plugin7).mutationIndex;
    return typeof mi !== "number" ? -1 : mi;
  }
  updatePluginHistory(plugin7, val) {
    const name2 = this.constructor.getPluginName(plugin7);
    this.pluginHistory[name2] = this.pluginHistory[name2] || [];
    this.pluginHistory[name2].push(val);
  }
  updatePatches(patches) {
    lib_default.normalizeArray(patches).forEach((patch) => {
      if (patch instanceof Error) {
        this.errors.push(patch);
        return;
      }
      try {
        if (!lib_default.isObject(patch)) {
          this.debug("updatePatches", "Got a non-object patch", patch);
          return;
        }
        if (this.showDebug) {
          this.allPatches.push(patch);
        }
        if (lib_default.isPromise(patch.value)) {
          this.promisedPatches.push(patch);
          this.promisedPatchThen(patch);
          return;
        }
        if (lib_default.isContextPatch(patch)) {
          this.setContext(patch.path, patch.value);
          return;
        }
        if (lib_default.isMutation(patch)) {
          this.updateMutations(patch);
        }
      } catch (e2) {
        console.error(e2);
        this.errors.push(e2);
      }
    });
  }
  updateMutations(patch) {
    if (typeof patch.value === "object" && !Array.isArray(patch.value) && this.allowMetaPatches) {
      patch.value = {
        ...patch.value
      };
    }
    const result = lib_default.applyPatch(this.state, patch, {
      allowMetaPatches: this.allowMetaPatches
    });
    if (result) {
      this.mutations.push(patch);
      this.state = result;
    }
  }
  removePromisedPatch(patch) {
    const index = this.promisedPatches.indexOf(patch);
    if (index < 0) {
      this.debug("Tried to remove a promisedPatch that isn't there!");
      return;
    }
    this.promisedPatches.splice(index, 1);
  }
  promisedPatchThen(patch) {
    patch.value = patch.value.then((val) => {
      const promisedPatch = {
        ...patch,
        value: val
      };
      this.removePromisedPatch(patch);
      this.updatePatches(promisedPatch);
    }).catch((e2) => {
      this.removePromisedPatch(patch);
      this.updatePatches(e2);
    });
    return patch.value;
  }
  getMutations(from2, to2) {
    from2 = from2 || 0;
    if (typeof to2 !== "number") {
      to2 = this.mutations.length;
    }
    return this.mutations.slice(from2, to2);
  }
  getCurrentMutations() {
    return this.getMutationsForPlugin(this.getCurrentPlugin());
  }
  getMutationsForPlugin(plugin7) {
    const tip = this.getPluginMutationIndex(plugin7);
    return this.getMutations(tip + 1);
  }
  getCurrentPlugin() {
    return this.currentPlugin;
  }
  getLib() {
    return this.libMethods;
  }
  // eslint-disable-next-line no-underscore-dangle
  _get(path4) {
    return lib_default.getIn(this.state, path4);
  }
  // eslint-disable-next-line no-underscore-dangle
  _getContext(path4) {
    return this.contextTree.get(path4);
  }
  setContext(path4, value) {
    return this.contextTree.set(path4, value);
  }
  // eslint-disable-next-line no-underscore-dangle
  _hasRun(count2) {
    const times3 = this.getPluginRunCount(this.getCurrentPlugin());
    return times3 > (count2 || 0);
  }
  dispatch() {
    const that = this;
    const plugin7 = this.nextPlugin();
    if (!plugin7) {
      const nextPromise = this.nextPromisedPatch();
      if (nextPromise) {
        return nextPromise.then(() => this.dispatch()).catch(() => this.dispatch());
      }
      const result = {
        spec: this.state,
        errors: this.errors
      };
      if (this.showDebug) {
        result.patches = this.allPatches;
      }
      return Promise.resolve(result);
    }
    that.pluginCount = that.pluginCount || /* @__PURE__ */ new WeakMap();
    that.pluginCount.set(plugin7, (that.pluginCount.get(plugin7) || 0) + 1);
    if (that.pluginCount[plugin7] > PLUGIN_DISPATCH_LIMIT) {
      return Promise.resolve({
        spec: that.state,
        errors: that.errors.concat(new Error(`We've reached a hard limit of ${PLUGIN_DISPATCH_LIMIT} plugin runs`))
      });
    }
    if (plugin7 !== this.currentPlugin && this.promisedPatches.length) {
      const promises = this.promisedPatches.map((p2) => p2.value);
      return Promise.all(promises.map((promise) => promise.then(noop2, noop2))).then(() => this.dispatch());
    }
    return executePlugin();
    function executePlugin() {
      that.currentPlugin = plugin7;
      const mutations = that.getCurrentMutations();
      const lastMutationIndex = that.mutations.length - 1;
      try {
        if (plugin7.isGenerator) {
          for (const yieldedPatches of plugin7(mutations, that.getLib())) {
            updatePatches(yieldedPatches);
          }
        } else {
          const newPatches = plugin7(mutations, that.getLib());
          updatePatches(newPatches);
        }
      } catch (e2) {
        console.error(e2);
        updatePatches([Object.assign(Object.create(e2), {
          plugin: plugin7
        })]);
      } finally {
        that.updatePluginHistory(plugin7, {
          mutationIndex: lastMutationIndex
        });
      }
      return that.dispatch();
    }
    function updatePatches(patches) {
      if (patches) {
        patches = lib_default.fullyNormalizeArray(patches);
        that.updatePatches(patches, plugin7);
      }
    }
  }
};
function mapSpec(opts) {
  return new SpecMap(opts).dispatch();
}
var plugins = {
  refs: refs_default,
  allOf: all_of_default,
  parameters: parameters_default,
  properties: properties_default
};

// node_modules/swagger-client/es/resolver/utils/index.js
function makeFetchJSON(http3, opts = {}) {
  const {
    requestInterceptor,
    responseInterceptor
  } = opts;
  const credentials = http3.withCredentials ? "include" : "same-origin";
  return (docPath) => http3({
    url: docPath,
    loadSpec: true,
    requestInterceptor,
    responseInterceptor,
    headers: {
      Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS
    },
    credentials
  }).then((res) => res.body);
}

// node_modules/swagger-client/es/http/serializers/request/file.js
function isFile(obj, navigatorObj) {
  if (!navigatorObj && typeof navigator !== "undefined") {
    navigatorObj = navigator;
  }
  if (navigatorObj && navigatorObj.product === "ReactNative") {
    if (obj && typeof obj === "object" && typeof obj.uri === "string") {
      return true;
    }
    return false;
  }
  if (typeof File !== "undefined" && obj instanceof File) {
    return true;
  }
  if (typeof Blob !== "undefined" && obj instanceof Blob) {
    return true;
  }
  if (ArrayBuffer.isView(obj)) {
    return true;
  }
  return obj !== null && typeof obj === "object" && typeof obj.pipe === "function";
}
function isArrayOfFile(obj, navigatorObj) {
  return Array.isArray(obj) && obj.some((v2) => isFile(v2, navigatorObj));
}
var FileWithData = class extends File {
  constructor(data, name2 = "", options = {}) {
    super([data], name2, options);
    this.data = data;
  }
  valueOf() {
    return this.data;
  }
  toString() {
    return this.valueOf();
  }
};

// node_modules/swagger-client/es/execute/oas3/style-serializer.js
var isRfc3986Reserved = (char) => ":/?#[]@!$&'()*+,;=".indexOf(char) > -1;
var isRfc3986Unreserved = (char) => /^[a-z0-9\-._~]+$/i.test(char);
function encodeCharacters(str2, characterSet = "reserved") {
  return [...str2].map((char) => {
    if (isRfc3986Unreserved(char)) {
      return char;
    }
    if (isRfc3986Reserved(char) && characterSet === "unsafe") {
      return char;
    }
    const encoder = new TextEncoder();
    const encoded = Array.from(encoder.encode(char)).map((byte) => `0${byte.toString(16).toUpperCase()}`.slice(-2)).map((encodedByte) => `%${encodedByte}`).join("");
    return encoded;
  }).join("");
}
function stylize(config2) {
  const {
    value
  } = config2;
  if (Array.isArray(value)) {
    return encodeArray(config2);
  }
  if (typeof value === "object") {
    return encodeObject(config2);
  }
  return encodePrimitive(config2);
}
function valueEncoder(value, escape3 = false) {
  if (Array.isArray(value) || value !== null && typeof value === "object") {
    value = JSON.stringify(value);
  } else if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (escape3 && value.length > 0) {
    return encodeCharacters(value, escape3);
  }
  return value;
}
function encodeArray({
  key: key57,
  value,
  style,
  explode,
  escape: escape3
}) {
  if (style === "simple") {
    return value.map((val) => valueEncoder(val, escape3)).join(",");
  }
  if (style === "label") {
    return `.${value.map((val) => valueEncoder(val, escape3)).join(".")}`;
  }
  if (style === "matrix") {
    return value.map((val) => valueEncoder(val, escape3)).reduce((prev, curr) => {
      if (!prev || explode) {
        return `${prev || ""};${key57}=${curr}`;
      }
      return `${prev},${curr}`;
    }, "");
  }
  if (style === "form") {
    const after = explode ? `&${key57}=` : ",";
    return value.map((val) => valueEncoder(val, escape3)).join(after);
  }
  if (style === "spaceDelimited") {
    const after = explode ? `${key57}=` : "";
    return value.map((val) => valueEncoder(val, escape3)).join(` ${after}`);
  }
  if (style === "pipeDelimited") {
    const after = explode ? `${key57}=` : "";
    return value.map((val) => valueEncoder(val, escape3)).join(`|${after}`);
  }
  return void 0;
}
function encodeObject({
  key: key57,
  value,
  style,
  explode,
  escape: escape3
}) {
  const valueKeys = Object.keys(value);
  if (style === "simple") {
    return valueKeys.reduce((prev, curr) => {
      const val = valueEncoder(value[curr], escape3);
      const middleChar = explode ? "=" : ",";
      const prefix = prev ? `${prev},` : "";
      return `${prefix}${curr}${middleChar}${val}`;
    }, "");
  }
  if (style === "label") {
    return valueKeys.reduce((prev, curr) => {
      const val = valueEncoder(value[curr], escape3);
      const middleChar = explode ? "=" : ".";
      const prefix = prev ? `${prev}.` : ".";
      return `${prefix}${curr}${middleChar}${val}`;
    }, "");
  }
  if (style === "matrix" && explode) {
    return valueKeys.reduce((prev, curr) => {
      const val = valueEncoder(value[curr], escape3);
      const prefix = prev ? `${prev};` : ";";
      return `${prefix}${curr}=${val}`;
    }, "");
  }
  if (style === "matrix") {
    return valueKeys.reduce((prev, curr) => {
      const val = valueEncoder(value[curr], escape3);
      const prefix = prev ? `${prev},` : `;${key57}=`;
      return `${prefix}${curr},${val}`;
    }, "");
  }
  if (style === "form") {
    return valueKeys.reduce((prev, curr) => {
      const val = valueEncoder(value[curr], escape3);
      const prefix = prev ? `${prev}${explode ? "&" : ","}` : "";
      const separator = explode ? "=" : ",";
      return `${prefix}${curr}${separator}${val}`;
    }, "");
  }
  return void 0;
}
function encodePrimitive({
  key: key57,
  value,
  style,
  escape: escape3
}) {
  if (style === "simple") {
    return valueEncoder(value, escape3);
  }
  if (style === "label") {
    return `.${valueEncoder(value, escape3)}`;
  }
  if (style === "matrix") {
    return `;${key57}=${valueEncoder(value, escape3)}`;
  }
  if (style === "form") {
    return valueEncoder(value, escape3);
  }
  if (style === "deepObject") {
    return valueEncoder(value, escape3);
  }
  return void 0;
}

// node_modules/swagger-client/es/http/serializers/request/format.js
var STYLE_SEPARATORS = {
  form: ",",
  spaceDelimited: "%20",
  pipeDelimited: "|"
};
var SEPARATORS = {
  csv: ",",
  ssv: "%20",
  tsv: "%09",
  pipes: "|"
};
function formatKeyValue(key57, input, skipEncoding = false) {
  const {
    collectionFormat,
    allowEmptyValue,
    serializationOption,
    encoding
  } = input;
  const value = typeof input === "object" && !Array.isArray(input) ? input.value : input;
  const encodeFn = skipEncoding ? (k) => k.toString() : (k) => encodeURIComponent(k);
  const encodedKey = encodeFn(key57);
  if (typeof value === "undefined" && allowEmptyValue) {
    return [[encodedKey, ""]];
  }
  if (isFile(value) || isArrayOfFile(value)) {
    return [[encodedKey, value]];
  }
  if (serializationOption) {
    return formatKeyValueBySerializationOption(key57, value, skipEncoding, serializationOption);
  }
  if (encoding) {
    if ([typeof encoding.style, typeof encoding.explode, typeof encoding.allowReserved].some((type5) => type5 !== "undefined")) {
      const {
        style,
        explode,
        allowReserved
      } = encoding;
      return formatKeyValueBySerializationOption(key57, value, skipEncoding, {
        style,
        explode,
        allowReserved
      });
    }
    if (typeof encoding.contentType === "string") {
      if (encoding.contentType.startsWith("application/json")) {
        const json3 = typeof value === "string" ? value : JSON.stringify(value);
        const encodedJson = encodeFn(json3);
        const file = new FileWithData(encodedJson, "blob", {
          type: encoding.contentType
        });
        return [[encodedKey, file]];
      }
      const encodedData = encodeFn(String(value));
      const blob = new FileWithData(encodedData, "blob", {
        type: encoding.contentType
      });
      return [[encodedKey, blob]];
    }
    if (typeof value !== "object") {
      return [[encodedKey, encodeFn(value)]];
    }
    if (Array.isArray(value) && value.every((v2) => typeof v2 !== "object")) {
      return [[encodedKey, value.map(encodeFn).join(",")]];
    }
    return [[encodedKey, encodeFn(JSON.stringify(value))]];
  }
  if (typeof value !== "object") {
    return [[encodedKey, encodeFn(value)]];
  }
  if (Array.isArray(value)) {
    if (collectionFormat === "multi") {
      return [[encodedKey, value.map(encodeFn)]];
    }
    return [[encodedKey, value.map(encodeFn).join(SEPARATORS[collectionFormat || "csv"])]];
  }
  return [[encodedKey, ""]];
}
function formatKeyValueBySerializationOption(key57, value, skipEncoding, serializationOption) {
  const style = serializationOption.style || "form";
  const explode = typeof serializationOption.explode === "undefined" ? style === "form" : serializationOption.explode;
  const escape3 = skipEncoding ? false : serializationOption && serializationOption.allowReserved ? "unsafe" : "reserved";
  const encodeFn = (v2) => valueEncoder(v2, escape3);
  const encodeKeyFn = skipEncoding ? (k) => k : (k) => encodeFn(k);
  if (typeof value !== "object") {
    return [[encodeKeyFn(key57), encodeFn(value)]];
  }
  if (Array.isArray(value)) {
    if (explode) {
      return [[encodeKeyFn(key57), value.map(encodeFn)]];
    }
    return [[encodeKeyFn(key57), value.map(encodeFn).join(STYLE_SEPARATORS[style])]];
  }
  if (style === "deepObject") {
    return Object.keys(value).map((valueKey) => [encodeKeyFn(`${key57}[${valueKey}]`), encodeFn(value[valueKey])]);
  }
  if (explode) {
    return Object.keys(value).map((valueKey) => [encodeKeyFn(valueKey), encodeFn(value[valueKey])]);
  }
  return [[encodeKeyFn(key57), Object.keys(value).map((valueKey) => [`${encodeKeyFn(valueKey)},${encodeFn(value[valueKey])}`]).join(",")]];
}

// node_modules/swagger-client/es/http/serializers/request/index.js
function buildFormData(reqForm) {
  return Object.entries(reqForm).reduce((formData, [name2, input]) => {
    for (const [key57, value] of formatKeyValue(name2, input, true)) {
      if (Array.isArray(value)) {
        for (const v2 of value) {
          if (ArrayBuffer.isView(v2)) {
            const blob = new Blob([v2]);
            formData.append(key57, blob);
          } else {
            formData.append(key57, v2);
          }
        }
      } else if (ArrayBuffer.isView(value)) {
        const blob = new Blob([value]);
        formData.append(key57, blob);
      } else {
        formData.append(key57, value);
      }
    }
    return formData;
  }, new FormData());
}
var stringifyQuery = (queryObject, {
  encode = true
} = {}) => {
  const buildNestedParams = (params2, key57, value) => {
    if (value == null) {
      params2.append(key57, "");
    } else if (Array.isArray(value)) {
      value.reduce((acc, v2) => buildNestedParams(params2, key57, v2), params2);
    } else if (value instanceof Date) {
      params2.append(key57, value.toISOString());
    } else if (typeof value === "object") {
      Object.entries(value).reduce((acc, [k, v2]) => buildNestedParams(params2, `${key57}[${k}]`, v2), params2);
    } else {
      params2.append(key57, value);
    }
    return params2;
  };
  const params = Object.entries(queryObject).reduce((acc, [key57, value]) => buildNestedParams(acc, key57, value), new URLSearchParams());
  const queryString = String(params);
  return encode ? queryString : decodeURIComponent(queryString);
};
function encodeFormOrQuery(data) {
  const encodedQueryObj = Object.keys(data).reduce((result, parameterName) => {
    for (const [key57, value] of formatKeyValue(parameterName, data[parameterName])) {
      if (value instanceof FileWithData) {
        result[key57] = value.valueOf();
      } else {
        result[key57] = value;
      }
    }
    return result;
  }, {});
  return stringifyQuery(encodedQueryObj, {
    encode: false
  });
}
function serializeRequest(req = {}) {
  const {
    url = "",
    query: query4,
    form
  } = req;
  const joinSearch = (...strs) => {
    const search = strs.filter((a2) => a2).join("&");
    return search ? `?${search}` : "";
  };
  if (form) {
    const hasFile = Object.keys(form).some((key57) => {
      const {
        value
      } = form[key57];
      return isFile(value) || isArrayOfFile(value);
    });
    const contentType = req.headers["content-type"] || req.headers["Content-Type"];
    if (hasFile || /multipart\/form-data/i.test(contentType)) {
      const formdata = buildFormData(req.form);
      req.formdata = formdata;
      req.body = formdata;
    } else {
      req.body = encodeFormOrQuery(form);
    }
    delete req.form;
  }
  if (query4) {
    const [baseUrl2, oriSearch] = url.split("?");
    let newStr = "";
    if (oriSearch) {
      const oriQuery = new URLSearchParams(oriSearch);
      const keysToRemove = Object.keys(query4);
      keysToRemove.forEach((key57) => oriQuery.delete(key57));
      newStr = String(oriQuery);
    }
    const finalStr = joinSearch(newStr, encodeFormOrQuery(query4));
    req.url = baseUrl2 + finalStr;
    delete req.query;
  }
  return req;
}

// node_modules/swagger-client/es/http/serializers/response/index.js
var shouldDownloadAsText = (contentType = "") => /(json|xml|yaml|text)\b/.test(contentType);
function parseBody(body, contentType) {
  if (contentType && (contentType.indexOf("application/json") === 0 || contentType.indexOf("+json") > 0)) {
    return JSON.parse(body);
  }
  return js_yaml_default.load(body);
}
function serializeHeaderValue(value) {
  const isMulti = value.includes(", ");
  return isMulti ? value.split(", ") : value;
}
function serializeHeaders(headers = {}) {
  if (typeof headers.entries !== "function") return {};
  return Array.from(headers.entries()).reduce((acc, [header2, value]) => {
    acc[header2] = serializeHeaderValue(value);
    return acc;
  }, {});
}
function serializeResponse(oriRes, url, {
  loadSpec = false
} = {}) {
  const res = {
    ok: oriRes.ok,
    url: oriRes.url || url,
    status: oriRes.status,
    statusText: oriRes.statusText,
    headers: serializeHeaders(oriRes.headers)
  };
  const contentType = res.headers["content-type"];
  const useText = loadSpec || shouldDownloadAsText(contentType);
  const getBody = useText ? oriRes.text : oriRes.blob || oriRes.buffer;
  return getBody.call(oriRes).then((body) => {
    res.text = body;
    res.data = body;
    if (useText) {
      try {
        const obj = parseBody(body, contentType);
        res.body = obj;
        res.obj = obj;
      } catch (e2) {
        res.parseError = e2;
      }
    }
    return res;
  });
}

// node_modules/swagger-client/es/http/index.js
async function http(url, request = {}) {
  if (typeof url === "object") {
    request = url;
    url = request.url;
  }
  request.headers = request.headers || {};
  request = serializeRequest(request);
  if (request.headers) {
    Object.keys(request.headers).forEach((headerName) => {
      const value = request.headers[headerName];
      if (typeof value === "string") {
        request.headers[headerName] = value.replace(/\n+/g, " ");
      }
    });
  }
  if (request.requestInterceptor) {
    request = await request.requestInterceptor(request) || request;
  }
  const contentType = request.headers["content-type"] || request.headers["Content-Type"];
  if (/multipart\/form-data/i.test(contentType)) {
    delete request.headers["content-type"];
    delete request.headers["Content-Type"];
  }
  let res;
  try {
    res = await (request.userFetch || fetch)(request.url, request);
    res = await serializeResponse(res, url, request);
    if (request.responseInterceptor) {
      res = await request.responseInterceptor(res) || res;
    }
  } catch (resError) {
    if (!res) {
      throw resError;
    }
    const error = new Error(res.statusText || `response status is ${res.status}`);
    error.status = res.status;
    error.statusCode = res.status;
    error.responseError = resError;
    throw error;
  }
  if (!res.ok) {
    const error = new Error(res.statusText || `response status is ${res.status}`);
    error.status = res.status;
    error.statusCode = res.status;
    error.response = res;
    throw error;
  }
  return res;
}
function makeHttp(httpFn, preFetch, postFetch) {
  postFetch = postFetch || ((a2) => a2);
  preFetch = preFetch || ((a2) => a2);
  return (req) => {
    if (typeof req === "string") {
      req = {
        url: req
      };
    }
    req = serializeRequest(req);
    req = preFetch(req);
    return postFetch(httpFn(req));
  };
}

// node_modules/swagger-client/es/resolver/utils/options.js
var retrievalURI = (options) => {
  var _ref, _globalThis$document;
  const {
    baseDoc,
    url
  } = options;
  const retrievalURL = (_ref = baseDoc !== null && baseDoc !== void 0 ? baseDoc : url) !== null && _ref !== void 0 ? _ref : "";
  return typeof ((_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.baseURI) === "string" ? String(new URL(retrievalURL, globalThis.document.baseURI)) : retrievalURL;
};
var httpClient = (options) => {
  const {
    fetch: fetch3,
    http: http3
  } = options;
  return fetch3 || http3 || http;
};

// node_modules/swagger-client/es/resolver/strategies/generic/resolve.js
async function resolveGenericStrategy(options) {
  const {
    spec: spec2,
    mode,
    allowMetaPatches = true,
    pathDiscriminator,
    modelPropertyMacro,
    parameterMacro,
    requestInterceptor,
    responseInterceptor,
    skipNormalization = false,
    useCircularStructures,
    strategies
  } = options;
  const retrievalURI2 = retrievalURI(options);
  const httpClient2 = httpClient(options);
  const strategy = strategies.find((strg) => strg.match(spec2));
  return doResolve(spec2);
  async function doResolve(_spec) {
    if (retrievalURI2) {
      plugins.refs.docCache[retrievalURI2] = _spec;
    }
    plugins.refs.fetchJSON = makeFetchJSON(httpClient2, {
      requestInterceptor,
      responseInterceptor
    });
    const plugs = [plugins.refs];
    if (typeof parameterMacro === "function") {
      plugs.push(plugins.parameters);
    }
    if (typeof modelPropertyMacro === "function") {
      plugs.push(plugins.properties);
    }
    if (mode !== "strict") {
      plugs.push(plugins.allOf);
    }
    const result = await mapSpec({
      spec: _spec,
      context: {
        baseDoc: retrievalURI2
      },
      plugins: plugs,
      allowMetaPatches,
      // allows adding .meta patches, which include adding `$$ref`s to the spec
      pathDiscriminator,
      // for lazy resolution
      parameterMacro,
      modelPropertyMacro,
      useCircularStructures
    });
    if (!skipNormalization) {
      result.spec = strategy.normalize(result.spec);
    }
    return result;
  }
}

// node_modules/swagger-client/es/helpers/replace-special-chars-with-underscore.js
var replaceSpecialCharsWithUnderscore = (operationId) => operationId.replace(/\W/gi, "_");
var replace_special_chars_with_underscore_default = replaceSpecialCharsWithUnderscore;

// node_modules/swagger-client/es/helpers/id-from-path-method/index.js
function idFromPathMethod(pathName, method, {
  v2OperationIdCompatibilityMode
} = {}) {
  if (v2OperationIdCompatibilityMode) {
    let res = `${method.toLowerCase()}_${pathName}`.replace(/[\s!@#$%^&*()_+=[{\]};:<>|./?,\\'""-]/g, "_");
    res = res || `${pathName.substring(1)}_${method}`;
    return res.replace(/((_){2,})/g, "_").replace(/^(_)*/g, "").replace(/([_])*$/g, "");
  }
  return `${method.toLowerCase()}${replace_special_chars_with_underscore_default(pathName)}`;
}

// node_modules/swagger-client/es/helpers/op-id.js
function opId(operation, pathName, method = "", {
  v2OperationIdCompatibilityMode
} = {}) {
  if (!operation || typeof operation !== "object") {
    return null;
  }
  const idWithoutWhitespace = (operation.operationId || "").replace(/\s/g, "");
  if (idWithoutWhitespace.length) {
    return replace_special_chars_with_underscore_default(operation.operationId);
  }
  return idFromPathMethod(pathName, method, {
    v2OperationIdCompatibilityMode
  });
}

// node_modules/swagger-client/es/resolver/strategies/generic/normalize.js
function normalize(parsedSpec) {
  const {
    spec: spec2
  } = parsedSpec;
  const {
    paths: paths4
  } = spec2;
  const map5 = {};
  if (!paths4 || spec2.$$normalized) {
    return parsedSpec;
  }
  for (const pathName in paths4) {
    const path4 = paths4[pathName];
    if (path4 == null || !["object", "function"].includes(typeof path4)) {
      continue;
    }
    const pathParameters = path4.parameters;
    for (const method in path4) {
      const operation = path4[method];
      if (operation == null || !["object", "function"].includes(typeof operation)) {
        continue;
      }
      const oid = opId(operation, pathName, method);
      if (oid) {
        if (map5[oid]) {
          map5[oid].push(operation);
        } else {
          map5[oid] = [operation];
        }
        const opList = map5[oid];
        if (opList.length > 1) {
          opList.forEach((o4, i2) => {
            o4.__originalOperationId = o4.__originalOperationId || o4.operationId;
            o4.operationId = `${oid}${i2 + 1}`;
          });
        } else if (typeof operation.operationId !== "undefined") {
          const obj = opList[0];
          obj.__originalOperationId = obj.__originalOperationId || operation.operationId;
          obj.operationId = oid;
        }
      }
      if (method !== "parameters") {
        const inheritsList = [];
        const toBeInherit = {};
        for (const key57 in spec2) {
          if (key57 === "produces" || key57 === "consumes" || key57 === "security") {
            toBeInherit[key57] = spec2[key57];
            inheritsList.push(toBeInherit);
          }
        }
        if (pathParameters) {
          toBeInherit.parameters = pathParameters;
          inheritsList.push(toBeInherit);
        }
        if (inheritsList.length) {
          for (const inherits of inheritsList) {
            for (const inheritName in inherits) {
              if (!operation[inheritName]) {
                operation[inheritName] = inherits[inheritName];
              } else if (inheritName === "parameters") {
                for (const param of inherits[inheritName]) {
                  const exists = operation[inheritName].some((opParam) => opParam.name && opParam.name === param.name || opParam.$ref && opParam.$ref === param.$ref || opParam.$$ref && opParam.$$ref === param.$$ref || opParam === param);
                  if (!exists) {
                    operation[inheritName].push(param);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  spec2.$$normalized = true;
  return parsedSpec;
}

// node_modules/swagger-client/es/resolver/strategies/generic/index.js
var genericStrategy = {
  name: "generic",
  match() {
    return true;
  },
  normalize(spec2) {
    const {
      spec: normalized
    } = normalize({
      spec: spec2
    });
    return normalized;
  },
  async resolve(options) {
    return resolveGenericStrategy(options);
  }
};
var generic_default = genericStrategy;

// node_modules/swagger-client/es/resolver/strategies/openapi-2/resolve.js
async function resolveOpenAPI2Strategy(options) {
  return resolveGenericStrategy(options);
}

// node_modules/swagger-client/es/helpers/openapi-predicates.js
var isOpenAPI2 = (spec2) => {
  try {
    const {
      swagger
    } = spec2;
    return swagger === "2.0";
  } catch {
    return false;
  }
};
var isOpenAPI30 = (spec2) => {
  try {
    const {
      openapi
    } = spec2;
    return typeof openapi === "string" && /^3\.0\.([0123])(?:-rc[012])?$/.test(openapi);
  } catch {
    return false;
  }
};
var isOpenAPI31 = (spec2) => {
  try {
    const {
      openapi
    } = spec2;
    return typeof openapi === "string" && /^3\.1\.(?:[1-9]\d*|0)$/.test(openapi);
  } catch {
    return false;
  }
};
var isOpenAPI3 = (spec2) => isOpenAPI30(spec2) || isOpenAPI31(spec2);

// node_modules/swagger-client/es/resolver/strategies/openapi-2/index.js
var openApi2Strategy = {
  name: "openapi-2",
  match(spec2) {
    return isOpenAPI2(spec2);
  },
  normalize(spec2) {
    const {
      spec: normalized
    } = normalize({
      spec: spec2
    });
    return normalized;
  },
  async resolve(options) {
    return resolveOpenAPI2Strategy(options);
  }
};
var openapi_2_default = openApi2Strategy;

// node_modules/swagger-client/es/resolver/strategies/openapi-3-0/resolve.js
async function resolveOpenAPI30Strategy(options) {
  return resolveGenericStrategy(options);
}

// node_modules/swagger-client/es/resolver/strategies/openapi-3-0/index.js
var openApi30Strategy = {
  name: "openapi-3-0",
  match(spec2) {
    return isOpenAPI30(spec2);
  },
  normalize(spec2) {
    const {
      spec: normalized
    } = normalize({
      spec: spec2
    });
    return normalized;
  },
  async resolve(options) {
    return resolveOpenAPI30Strategy(options);
  }
};
var openapi_3_0_default = openApi30Strategy;

// node_modules/@swagger-api/apidom-json-pointer/src/errors/JsonPointerError.mjs
var JsonPointerError = class extends ApiDOMStructuredError_default {
};
var JsonPointerError_default = JsonPointerError;

// node_modules/@swagger-api/apidom-json-pointer/src/errors/InvalidJsonPointerError.mjs
var InvalidJsonPointerError = class extends JsonPointerError_default {
  constructor(message, structuredOptions) {
    super(message, structuredOptions);
    __publicField(this, "pointer");
    if (typeof structuredOptions !== "undefined") {
      this.pointer = structuredOptions.pointer;
    }
  }
};
var InvalidJsonPointerError_default = InvalidJsonPointerError;

// node_modules/@swagger-api/apidom-json-pointer/src/errors/CompilationJsonPointerError.mjs
var CompilationJsonPointerError = class extends JsonPointerError_default {
  constructor(message, structuredOptions) {
    super(message, structuredOptions);
    __publicField(this, "tokens");
    if (typeof structuredOptions !== "undefined") {
      this.tokens = [...structuredOptions.tokens];
    }
  }
};
var CompilationJsonPointerError_default = CompilationJsonPointerError;

// node_modules/@swagger-api/apidom-json-pointer/src/errors/EvaluationJsonPointerError.mjs
var EvaluationJsonPointerError = class extends JsonPointerError_default {
  constructor(message, structuredOptions) {
    super(message, structuredOptions);
    __publicField(this, "pointer");
    __publicField(this, "tokens");
    __publicField(this, "failedToken");
    __publicField(this, "failedTokenPosition");
    __publicField(this, "element");
    if (typeof structuredOptions !== "undefined") {
      this.pointer = structuredOptions.pointer;
      if (Array.isArray(structuredOptions.tokens)) {
        this.tokens = [...structuredOptions.tokens];
      }
      this.failedToken = structuredOptions.failedToken;
      this.failedTokenPosition = structuredOptions.failedTokenPosition;
      this.element = structuredOptions.element;
    }
  }
};
var EvaluationJsonPointerError_default = EvaluationJsonPointerError;

// node_modules/@swagger-api/apidom-json-pointer/src/escape.mjs
var escape = pipe(replace_default(/~/g, "~0"), replace_default(/\//g, "~1"), encodeURIComponent);
var escape_default = escape;

// node_modules/@swagger-api/apidom-json-pointer/src/unescape.mjs
var safeDecodeURIComponent = (encodedURIComponent) => {
  try {
    return decodeURIComponent(encodedURIComponent);
  } catch {
    return encodedURIComponent;
  }
};
var unescape2 = pipe(replace_default(/~1/g, "/"), replace_default(/~0/g, "~"), safeDecodeURIComponent);
var unescape_default = unescape2;

// node_modules/@swagger-api/apidom-json-pointer/src/parse.mjs
var parse2 = (pointer) => {
  if (isEmptyString_default(pointer)) {
    return [];
  }
  if (!startsWith_default("/", pointer)) {
    throw new InvalidJsonPointerError_default(`Invalid JSON Pointer "${pointer}". JSON Pointers must begin with "/"`, {
      pointer
    });
  }
  try {
    const tokens = pipe(split_default("/"), map_default(unescape_default))(pointer);
    return tail_default(tokens);
  } catch (error) {
    throw new InvalidJsonPointerError_default(`JSON Pointer parsing of "${pointer}" encountered an error.`, {
      pointer,
      cause: error
    });
  }
};
var getHash2 = (uri2) => {
  const hashIndex = uri2.indexOf("#");
  if (hashIndex !== -1) {
    return uri2.substring(hashIndex);
  }
  return "#";
};
var uriToPointer = (uri2) => {
  const hash = getHash2(uri2);
  return trimCharsStart_default("#", hash);
};
var parse_default2 = parse2;

// node_modules/@swagger-api/apidom-json-pointer/src/compile.mjs
var compile = (tokens) => {
  try {
    if (tokens.length === 0) {
      return "";
    }
    return `/${tokens.map(escape_default).join("/")}`;
  } catch (error) {
    throw new CompilationJsonPointerError_default("JSON Pointer compilation of tokens encountered an error.", {
      tokens,
      cause: error
    });
  }
};
var compile_default = compile;

// node_modules/@swagger-api/apidom-json-pointer/src/evaluate.mjs
var evaluate = (pointer, element) => {
  let tokens;
  try {
    tokens = parse_default2(pointer);
  } catch (error) {
    throw new EvaluationJsonPointerError_default(`JSON Pointer evaluation failed while parsing the pointer "${pointer}".`, {
      pointer,
      element: cloneDeep(element),
      cause: error
    });
  }
  return tokens.reduce((acc, token, tokenPosition) => {
    if (isObjectElement(acc)) {
      if (!acc.hasKey(token)) {
        throw new EvaluationJsonPointerError_default(`JSON Pointer evaluation failed while evaluating token "${token}" against an ObjectElement`, {
          pointer,
          tokens,
          failedToken: token,
          failedTokenPosition: tokenPosition,
          element: cloneDeep(acc)
        });
      }
      return acc.get(token);
    }
    if (isArrayElement(acc)) {
      if (!(token in acc.content) || !isInteger_default2(Number(token))) {
        throw new EvaluationJsonPointerError_default(`JSON Pointer evaluation failed while evaluating token "${token}" against an ArrayElement`, {
          pointer,
          tokens,
          failedToken: token,
          failedTokenPosition: tokenPosition,
          element: cloneDeep(acc)
        });
      }
      return acc.get(Number(token));
    }
    throw new EvaluationJsonPointerError_default(`JSON Pointer evaluation failed while evaluating token "${token}" against an unexpected Element`, {
      pointer,
      tokens,
      failedToken: token,
      failedTokenPosition: tokenPosition,
      element: cloneDeep(acc)
    });
  }, element);
};
var evaluate_default = evaluate;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/media-types.mjs
var OpenAPIMediaTypes = class extends media_types_default {
  filterByFormat(format = "generic") {
    const effectiveFormat = format === "generic" ? "openapi;version" : format;
    return this.filter((mediaType) => mediaType.includes(effectiveFormat));
  }
  findBy(version2 = "3.1.0", format = "generic") {
    const search = format === "generic" ? `vnd.oai.openapi;version=${version2}` : `vnd.oai.openapi+${format};version=${version2}`;
    const found = this.find((mediaType) => mediaType.includes(search));
    return found || this.unknownMediaType;
  }
  latest(format = "generic") {
    return last_default(this.filterByFormat(format));
  }
};
var mediaTypes = new OpenAPIMediaTypes("application/vnd.oai.openapi;version=3.1.0", "application/vnd.oai.openapi+json;version=3.1.0", "application/vnd.oai.openapi+yaml;version=3.1.0");
var media_types_default2 = mediaTypes;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/media-types.mjs
var OpenAPIMediaTypes2 = class extends media_types_default {
  filterByFormat(format = "generic") {
    const effectiveFormat = format === "generic" ? "openapi;version" : format;
    return this.filter((mediaType) => mediaType.includes(effectiveFormat));
  }
  findBy(version2 = "3.0.3", format = "generic") {
    const search = format === "generic" ? `vnd.oai.openapi;version=${version2}` : `vnd.oai.openapi+${format};version=${version2}`;
    const found = this.find((mediaType) => mediaType.includes(search));
    return found || this.unknownMediaType;
  }
  latest(format = "generic") {
    return last_default(this.filterByFormat(format));
  }
};
var mediaTypes2 = new OpenAPIMediaTypes2("application/vnd.oai.openapi;version=3.0.0", "application/vnd.oai.openapi+json;version=3.0.0", "application/vnd.oai.openapi+yaml;version=3.0.0", "application/vnd.oai.openapi;version=3.0.1", "application/vnd.oai.openapi+json;version=3.0.1", "application/vnd.oai.openapi+yaml;version=3.0.1", "application/vnd.oai.openapi;version=3.0.2", "application/vnd.oai.openapi+json;version=3.0.2", "application/vnd.oai.openapi+yaml;version=3.0.2", "application/vnd.oai.openapi;version=3.0.3", "application/vnd.oai.openapi+json;version=3.0.3", "application/vnd.oai.openapi+yaml;version=3.0.3");

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Callback.mjs
var Callback = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "callback";
  }
};
var Callback_default = Callback;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Components.mjs
var Components = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "components";
  }
  get schemas() {
    return this.get("schemas");
  }
  set schemas(schemas) {
    this.set("schemas", schemas);
  }
  get responses() {
    return this.get("responses");
  }
  set responses(responses) {
    this.set("responses", responses);
  }
  get parameters() {
    return this.get("parameters");
  }
  set parameters(parameters) {
    this.set("parameters", parameters);
  }
  get examples() {
    return this.get("examples");
  }
  set examples(examples) {
    this.set("examples", examples);
  }
  get requestBodies() {
    return this.get("requestBodies");
  }
  set requestBodies(requestBodies) {
    this.set("requestBodies", requestBodies);
  }
  get headers() {
    return this.get("headers");
  }
  set headers(headers) {
    this.set("headers", headers);
  }
  get securitySchemes() {
    return this.get("securitySchemes");
  }
  set securitySchemes(securitySchemes) {
    this.set("securitySchemes", securitySchemes);
  }
  get links() {
    return this.get("links");
  }
  set links(links2) {
    this.set("links", links2);
  }
  get callbacks() {
    return this.get("callbacks");
  }
  set callbacks(callbacks2) {
    this.set("callbacks", callbacks2);
  }
};
var Components_default = Components;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Contact.mjs
var Contact = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "contact";
  }
  get name() {
    return this.get("name");
  }
  set name(name2) {
    this.set("name", name2);
  }
  get url() {
    return this.get("url");
  }
  set url(url) {
    this.set("url", url);
  }
  get email() {
    return this.get("email");
  }
  set email(email2) {
    this.set("email", email2);
  }
};
var Contact_default = Contact;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Discriminator.mjs
var Discriminator = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "discriminator";
  }
  get propertyName() {
    return this.get("propertyName");
  }
  set propertyName(propertyName) {
    this.set("propertyName", propertyName);
  }
  get mapping() {
    return this.get("mapping");
  }
  set mapping(mapping) {
    this.set("mapping", mapping);
  }
};
var Discriminator_default = Discriminator;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Encoding.mjs
var Encoding = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "encoding";
  }
  get contentType() {
    return this.get("contentType");
  }
  set contentType(contentType) {
    this.set("contentType", contentType);
  }
  get headers() {
    return this.get("headers");
  }
  set headers(headers) {
    this.set("headers", headers);
  }
  get style() {
    return this.get("style");
  }
  set style(style) {
    this.set("style", style);
  }
  get explode() {
    return this.get("explode");
  }
  set explode(explode) {
    this.set("explode", explode);
  }
  get allowedReserved() {
    return this.get("allowedReserved");
  }
  set allowedReserved(allowedReserved) {
    this.set("allowedReserved", allowedReserved);
  }
};
var Encoding_default = Encoding;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Example.mjs
var Example = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "example";
  }
  get summary() {
    return this.get("summary");
  }
  set summary(summary) {
    this.set("summary", summary);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get value() {
    return this.get("value");
  }
  set value(value) {
    this.set("value", value);
  }
  get externalValue() {
    return this.get("externalValue");
  }
  set externalValue(externalValue) {
    this.set("externalValue", externalValue);
  }
};
var Example_default = Example;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/ExternalDocumentation.mjs
var ExternalDocumentation = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "externalDocumentation";
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get url() {
    return this.get("url");
  }
  set url(url) {
    this.set("url", url);
  }
};
var ExternalDocumentation_default = ExternalDocumentation;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Header.mjs
var Header = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "header";
  }
  get required() {
    if (this.hasKey("required")) {
      return this.get("required");
    }
    return new import_minim10.BooleanElement(false);
  }
  set required(required) {
    this.set("required", required);
  }
  get deprecated() {
    if (this.hasKey("deprecated")) {
      return this.get("deprecated");
    }
    return new import_minim10.BooleanElement(false);
  }
  set deprecated(deprecated) {
    this.set("deprecated", deprecated);
  }
  get allowEmptyValue() {
    return this.get("allowEmptyValue");
  }
  set allowEmptyValue(allowEmptyValue) {
    this.set("allowEmptyValue", allowEmptyValue);
  }
  get style() {
    return this.get("style");
  }
  set style(style) {
    this.set("style", style);
  }
  get explode() {
    return this.get("explode");
  }
  set explode(explode) {
    this.set("explode", explode);
  }
  get allowReserved() {
    return this.get("allowReserved");
  }
  set allowReserved(allowReserved) {
    this.set("allowReserved", allowReserved);
  }
  get schema() {
    return this.get("schema");
  }
  set schema(schema4) {
    this.set("schema", schema4);
  }
  get example() {
    return this.get("example");
  }
  set example(example) {
    this.set("example", example);
  }
  get examples() {
    return this.get("examples");
  }
  set examples(examples) {
    this.set("examples", examples);
  }
  get contentProp() {
    return this.get("content");
  }
  set contentProp(content) {
    this.set("content", content);
  }
};
Object.defineProperty(Header.prototype, "description", {
  get() {
    return this.get("description");
  },
  set(description) {
    this.set("description", description);
  },
  enumerable: true
});
var Header_default = Header;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Info.mjs
var Info = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "info";
    this.classes.push("info");
  }
  get title() {
    return this.get("title");
  }
  set title(title) {
    this.set("title", title);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get termsOfService() {
    return this.get("termsOfService");
  }
  set termsOfService(tos) {
    this.set("termsOfService", tos);
  }
  get contact() {
    return this.get("contact");
  }
  set contact(contactElement) {
    this.set("contact", contactElement);
  }
  get license() {
    return this.get("license");
  }
  set license(licenseElement) {
    this.set("license", licenseElement);
  }
  get version() {
    return this.get("version");
  }
  set version(version2) {
    this.set("version", version2);
  }
};
var Info_default = Info;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/License.mjs
var License = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "license";
  }
  get name() {
    return this.get("name");
  }
  set name(name2) {
    this.set("name", name2);
  }
  get url() {
    return this.get("url");
  }
  set url(url) {
    this.set("url", url);
  }
};
var License_default = License;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Link.mjs
var Link = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "link";
  }
  get operationRef() {
    return this.get("operationRef");
  }
  set operationRef(operationRef) {
    this.set("operationRef", operationRef);
  }
  get operationId() {
    return this.get("operationId");
  }
  set operationId(operationId) {
    this.set("operationId", operationId);
  }
  get operation() {
    if (isStringElement(this.operationRef)) {
      var _this$operationRef;
      return (_this$operationRef = this.operationRef) === null || _this$operationRef === void 0 ? void 0 : _this$operationRef.meta.get("operation");
    }
    if (isStringElement(this.operationId)) {
      var _this$operationId;
      return (_this$operationId = this.operationId) === null || _this$operationId === void 0 ? void 0 : _this$operationId.meta.get("operation");
    }
    return void 0;
  }
  set operation(operation) {
    this.set("operation", operation);
  }
  get parameters() {
    return this.get("parameters");
  }
  set parameters(parameters) {
    this.set("parameters", parameters);
  }
  get requestBody() {
    return this.get("requestBody");
  }
  set requestBody(requestBody) {
    this.set("requestBody", requestBody);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get server() {
    return this.get("server");
  }
  set server(server) {
    this.set("server", server);
  }
};
var Link_default = Link;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/MediaType.mjs
var MediaType = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "mediaType";
  }
  get schema() {
    return this.get("schema");
  }
  set schema(schema4) {
    this.set("schema", schema4);
  }
  get example() {
    return this.get("example");
  }
  set example(example) {
    this.set("example", example);
  }
  get examples() {
    return this.get("examples");
  }
  set examples(examples) {
    this.set("examples", examples);
  }
  get encoding() {
    return this.get("encoding");
  }
  set encoding(encoding) {
    this.set("encoding", encoding);
  }
};
var MediaType_default = MediaType;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/OAuthFlow.mjs
var OAuthFlow = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "oAuthFlow";
  }
  get authorizationUrl() {
    return this.get("authorizationUrl");
  }
  set authorizationUrl(authorizationUrl) {
    this.set("authorizationUrl", authorizationUrl);
  }
  get tokenUrl() {
    return this.get("tokenUrl");
  }
  set tokenUrl(tokenUrl) {
    this.set("tokenUrl", tokenUrl);
  }
  get refreshUrl() {
    return this.get("refreshUrl");
  }
  set refreshUrl(refreshUrl) {
    this.set("refreshUrl", refreshUrl);
  }
  get scopes() {
    return this.get("scopes");
  }
  set scopes(scopes) {
    this.set("scopes", scopes);
  }
};
var OAuthFlow_default = OAuthFlow;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/OAuthFlows.mjs
var OAuthFlows = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "oAuthFlows";
  }
  get implicit() {
    return this.get("implicit");
  }
  set implicit(implicit) {
    this.set("implicit", implicit);
  }
  get password() {
    return this.get("password");
  }
  set password(password) {
    this.set("password", password);
  }
  get clientCredentials() {
    return this.get("clientCredentials");
  }
  set clientCredentials(clientCredentials) {
    this.set("clientCredentials", clientCredentials);
  }
  get authorizationCode() {
    return this.get("authorizationCode");
  }
  set authorizationCode(authorizationCode) {
    this.set("authorizationCode", authorizationCode);
  }
};
var OAuthFlows_default = OAuthFlows;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Openapi.mjs
var Openapi = class extends import_minim10.StringElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "openapi";
    this.classes.push("spec-version");
    this.classes.push("version");
  }
};
var Openapi_default = Openapi;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/OpenApi3-0.mjs
var OpenApi3_0 = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "openApi3_0";
    this.classes.push("api");
  }
  get openapi() {
    return this.get("openapi");
  }
  set openapi(openapi) {
    this.set("openapi", openapi);
  }
  get info() {
    return this.get("info");
  }
  set info(info) {
    this.set("info", info);
  }
  get servers() {
    return this.get("servers");
  }
  set servers(servers) {
    this.set("servers", servers);
  }
  get paths() {
    return this.get("paths");
  }
  set paths(paths4) {
    this.set("paths", paths4);
  }
  get components() {
    return this.get("components");
  }
  set components(components) {
    this.set("components", components);
  }
  get security() {
    return this.get("security");
  }
  set security(security) {
    this.set("security", security);
  }
  get tags() {
    return this.get("tags");
  }
  set tags(tags) {
    this.set("tags", tags);
  }
  get externalDocs() {
    return this.get("externalDocs");
  }
  set externalDocs(externalDocs) {
    this.set("externalDocs", externalDocs);
  }
};
var OpenApi3_0_default = OpenApi3_0;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Operation.mjs
var Operation = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "operation";
  }
  get tags() {
    return this.get("tags");
  }
  set tags(tags) {
    this.set("tags", tags);
  }
  get summary() {
    return this.get("summary");
  }
  set summary(description) {
    this.set("summary", description);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  set externalDocs(externalDocs) {
    this.set("externalDocs", externalDocs);
  }
  get externalDocs() {
    return this.get("externalDocs");
  }
  get operationId() {
    return this.get("operationId");
  }
  set operationId(operationId) {
    this.set("operationId", operationId);
  }
  get parameters() {
    return this.get("parameters");
  }
  set parameters(parameters) {
    this.set("parameters", parameters);
  }
  get requestBody() {
    return this.get("requestBody");
  }
  set requestBody(requestBody) {
    this.set("requestBody", requestBody);
  }
  get responses() {
    return this.get("responses");
  }
  set responses(responses) {
    this.set("responses", responses);
  }
  get callbacks() {
    return this.get("callbacks");
  }
  set callbacks(callbacks2) {
    this.set("callbacks", callbacks2);
  }
  get deprecated() {
    if (this.hasKey("deprecated")) {
      return this.get("deprecated");
    }
    return new import_minim10.BooleanElement(false);
  }
  set deprecated(deprecated) {
    this.set("deprecated", deprecated);
  }
  get security() {
    return this.get("security");
  }
  set security(security) {
    this.set("security", security);
  }
  get servers() {
    return this.get("severs");
  }
  set servers(servers) {
    this.set("servers", servers);
  }
};
var Operation_default = Operation;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Parameter.mjs
var Parameter = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "parameter";
  }
  get name() {
    return this.get("name");
  }
  set name(name2) {
    this.set("name", name2);
  }
  get in() {
    return this.get("in");
  }
  set in(val) {
    this.set("in", val);
  }
  get required() {
    if (this.hasKey("required")) {
      return this.get("required");
    }
    return new import_minim10.BooleanElement(false);
  }
  set required(required) {
    this.set("required", required);
  }
  get deprecated() {
    if (this.hasKey("deprecated")) {
      return this.get("deprecated");
    }
    return new import_minim10.BooleanElement(false);
  }
  set deprecated(deprecated) {
    this.set("deprecated", deprecated);
  }
  get allowEmptyValue() {
    return this.get("allowEmptyValue");
  }
  set allowEmptyValue(allowEmptyValue) {
    this.set("allowEmptyValue", allowEmptyValue);
  }
  get style() {
    return this.get("style");
  }
  set style(style) {
    this.set("style", style);
  }
  get explode() {
    return this.get("explode");
  }
  set explode(explode) {
    this.set("explode", explode);
  }
  get allowReserved() {
    return this.get("allowReserved");
  }
  set allowReserved(allowReserved) {
    this.set("allowReserved", allowReserved);
  }
  get schema() {
    return this.get("schema");
  }
  set schema(schema4) {
    this.set("schema", schema4);
  }
  get example() {
    return this.get("example");
  }
  set example(example) {
    this.set("example", example);
  }
  get examples() {
    return this.get("examples");
  }
  set examples(examples) {
    this.set("examples", examples);
  }
  get contentProp() {
    return this.get("content");
  }
  set contentProp(content) {
    this.set("content", content);
  }
};
Object.defineProperty(Parameter.prototype, "description", {
  get() {
    return this.get("description");
  },
  set(description) {
    this.set("description", description);
  },
  enumerable: true
});
var Parameter_default = Parameter;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/PathItem.mjs
var PathItem = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "pathItem";
  }
  get $ref() {
    return this.get("$ref");
  }
  set $ref($ref) {
    this.set("$ref", $ref);
  }
  get summary() {
    return this.get("summary");
  }
  set summary(summary) {
    this.set("summary", summary);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get GET() {
    return this.get("get");
  }
  set GET(operation) {
    this.set("GET", operation);
  }
  get PUT() {
    return this.get("put");
  }
  set PUT(operation) {
    this.set("PUT", operation);
  }
  get POST() {
    return this.get("post");
  }
  set POST(operation) {
    this.set("POST", operation);
  }
  get DELETE() {
    return this.get("delete");
  }
  set DELETE(operation) {
    this.set("DELETE", operation);
  }
  get OPTIONS() {
    return this.get("options");
  }
  set OPTIONS(operation) {
    this.set("OPTIONS", operation);
  }
  get HEAD() {
    return this.get("head");
  }
  set HEAD(operation) {
    this.set("HEAD", operation);
  }
  get PATCH() {
    return this.get("patch");
  }
  set PATCH(operation) {
    this.set("PATCH", operation);
  }
  get TRACE() {
    return this.get("trace");
  }
  set TRACE(operation) {
    this.set("TRACE", operation);
  }
  get servers() {
    return this.get("servers");
  }
  set servers(servers) {
    this.set("servers", servers);
  }
  get parameters() {
    return this.get("parameters");
  }
  set parameters(parameters) {
    this.set("parameters", parameters);
  }
};
var PathItem_default = PathItem;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Paths.mjs
var Paths = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "paths";
  }
};
var Paths_default = Paths;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Reference.mjs
var Reference2 = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "reference";
    this.classes.push("openapi-reference");
  }
  get $ref() {
    return this.get("$ref");
  }
  set $ref($ref) {
    this.set("$ref", $ref);
  }
};
var Reference_default2 = Reference2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/RequestBody.mjs
var RequestBody = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "requestBody";
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get contentProp() {
    return this.get("content");
  }
  set contentProp(content) {
    this.set("content", content);
  }
  get required() {
    if (this.hasKey("required")) {
      return this.get("required");
    }
    return new import_minim10.BooleanElement(false);
  }
  set required(required) {
    this.set("required", required);
  }
};
var RequestBody_default = RequestBody;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Response.mjs
var Response3 = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "response";
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get headers() {
    return this.get("headers");
  }
  set headers(headers) {
    this.set("headers", headers);
  }
  get contentProp() {
    return this.get("content");
  }
  set contentProp(contentProp) {
    this.set("content", contentProp);
  }
  get links() {
    return this.get("links");
  }
  set links(links2) {
    this.set("links", links2);
  }
};
var Response_default = Response3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Responses.mjs
var Responses = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "responses";
  }
  get default() {
    return this.get("default");
  }
  set default(defaultValue) {
    this.set("default", defaultValue);
  }
};
var Responses_default = Responses;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/media-types.mjs
var JSONSchemaDraft4MediaTypes = class extends media_types_default {
  filterByFormat(format = "generic") {
    const effectiveFormat = format === "generic" ? "schema;version" : format;
    return this.filter((mediaType) => mediaType.includes(effectiveFormat));
  }
  findBy(version2 = "draft-04", format = "generic") {
    const search = format === "generic" ? `schema;version=${version2}` : `schema+${format};version=${version2}`;
    const found = this.find((mediaType) => mediaType.includes(search));
    return found || this.unknownMediaType;
  }
  latest(format = "generic") {
    return last_default(this.filterByFormat(format));
  }
};
var mediaTypes3 = new JSONSchemaDraft4MediaTypes("application/schema;version=draft-04", "application/schema+json;version=draft-04", "application/schema+yaml;version=draft-04");

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/elements/JSONSchema.mjs
var JSONSchema = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "JSONSchemaDraft4";
  }
  /**
   * Core vocabulary
   *
   * URI: https://tools.ietf.org/html/draft-wright-json-schema-00
   */
  get idProp() {
    return this.get("id");
  }
  set idProp(idProp) {
    this.set("id", idProp);
  }
  get $schema() {
    return this.get("$schema");
  }
  set $schema($schema) {
    this.set("$schema", $schema);
  }
  /**
   * Validation vocabulary
   *
   * URI: https://tools.ietf.org/html/draft-wright-json-schema-validation-00
   */
  /**
   *  Validation keywords for numeric instances (number and integer)
   */
  get multipleOf() {
    return this.get("multipleOf");
  }
  set multipleOf(multipleOf) {
    this.set("multipleOf", multipleOf);
  }
  get maximum() {
    return this.get("maximum");
  }
  set maximum(maximum) {
    this.set("maximum", maximum);
  }
  get exclusiveMaximum() {
    return this.get("exclusiveMaximum");
  }
  set exclusiveMaximum(exclusiveMaximum) {
    this.set("exclusiveMaximum", exclusiveMaximum);
  }
  get minimum() {
    return this.get("minimum");
  }
  set minimum(minimum) {
    this.set("minimum", minimum);
  }
  get exclusiveMinimum() {
    return this.get("exclusiveMinimum");
  }
  set exclusiveMinimum(exclusiveMinimum) {
    this.set("exclusiveMinimum", exclusiveMinimum);
  }
  /**
   * Validation keywords for strings
   */
  get maxLength() {
    return this.get("maxLength");
  }
  set maxLength(maxLength) {
    this.set("maxLength", maxLength);
  }
  get minLength() {
    return this.get("minLength");
  }
  set minLength(minLength) {
    this.set("minLength", minLength);
  }
  get pattern() {
    return this.get("pattern");
  }
  set pattern(pattern) {
    this.set("pattern", pattern);
  }
  /**
   * Validation keywords for arrays
   */
  get additionalItems() {
    return this.get("additionalItems");
  }
  set additionalItems(additionalItems) {
    this.set("additionalItems", additionalItems);
  }
  get items() {
    return this.get("items");
  }
  set items(items) {
    this.set("items", items);
  }
  get maxItems() {
    return this.get("maxItems");
  }
  set maxItems(maxItems) {
    this.set("maxItems", maxItems);
  }
  get minItems() {
    return this.get("minItems");
  }
  set minItems(minItems) {
    this.set("minItems", minItems);
  }
  get uniqueItems() {
    return this.get("uniqueItems");
  }
  set uniqueItems(uniqueItems) {
    this.set("uniqueItems", uniqueItems);
  }
  /**
   * Validation keywords for objects
   */
  get maxProperties() {
    return this.get("maxProperties");
  }
  set maxProperties(maxProperties) {
    this.set("maxProperties", maxProperties);
  }
  get minProperties() {
    return this.get("minProperties");
  }
  set minProperties(minProperties) {
    this.set("minProperties", minProperties);
  }
  get required() {
    return this.get("required");
  }
  set required(required) {
    this.set("required", required);
  }
  get properties() {
    return this.get("properties");
  }
  set properties(properties) {
    this.set("properties", properties);
  }
  get additionalProperties() {
    return this.get("additionalProperties");
  }
  set additionalProperties(additionalProperties) {
    this.set("additionalProperties", additionalProperties);
  }
  get patternProperties() {
    return this.get("patternProperties");
  }
  set patternProperties(patternProperties) {
    this.set("patternProperties", patternProperties);
  }
  get dependencies() {
    return this.get("dependencies");
  }
  set dependencies(dependencies) {
    this.set("dependencies", dependencies);
  }
  /**
   *  Validation keywords for any instance type
   */
  get enum() {
    return this.get("enum");
  }
  set enum(enumValue) {
    this.set("enum", enumValue);
  }
  get type() {
    return this.get("type");
  }
  set type(type5) {
    this.set("type", type5);
  }
  get allOf() {
    return this.get("allOf");
  }
  set allOf(allOf) {
    this.set("allOf", allOf);
  }
  get anyOf() {
    return this.get("anyOf");
  }
  set anyOf(anyOf) {
    this.set("anyOf", anyOf);
  }
  get oneOf() {
    return this.get("oneOf");
  }
  set oneOf(oneOf) {
    this.set("oneOf", oneOf);
  }
  get not() {
    return this.get("not");
  }
  set not(not3) {
    this.set("not", not3);
  }
  get definitions() {
    return this.get("definitions");
  }
  set definitions(definitions) {
    this.set("definitions", definitions);
  }
  /**
   * Metadata keywords
   *
   * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-validation-00#section-6
   */
  get title() {
    return this.get("title");
  }
  set title(title) {
    this.set("title", title);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get default() {
    return this.get("default");
  }
  set default(defaultValue) {
    this.set("default", defaultValue);
  }
  /**
   * Semantic validation with "format"
   *
   * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-validation-00#section-7
   */
  get format() {
    return this.get("format");
  }
  set format(format) {
    this.set("format", format);
  }
  /**
   * JSON Hyper-Schema
   *
   * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-hyperschema-00
   */
  get base() {
    return this.get("base");
  }
  set base(base2) {
    this.set("base", base2);
  }
  get links() {
    return this.get("links");
  }
  set links(links2) {
    this.set("links", links2);
  }
  get media() {
    return this.get("media");
  }
  set media(media) {
    this.set("media", media);
  }
  get readOnly() {
    return this.get("readOnly");
  }
  set readOnly(readOnly) {
    this.set("readOnly", readOnly);
  }
};
var JSONSchema_default = JSONSchema;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/elements/JSONReference.mjs
var JSONReference = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "JSONReference";
    this.classes.push("json-reference");
  }
  get $ref() {
    return this.get("$ref");
  }
  set $ref($ref) {
    this.set("$ref", $ref);
  }
};
var JSONReference_default = JSONReference;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/elements/Media.mjs
var Media = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "media";
  }
  get binaryEncoding() {
    return this.get("binaryEncoding");
  }
  set binaryEncoding(binaryEncoding) {
    this.set("binaryEncoding", binaryEncoding);
  }
  get type() {
    return this.get("type");
  }
  set type(type5) {
    this.set("type", type5);
  }
};
var Media_default = Media;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/elements/LinkDescription.mjs
var LinkDescription = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "linkDescription";
  }
  get href() {
    return this.get("href");
  }
  set href(href) {
    this.set("href", href);
  }
  get rel() {
    return this.get("rel");
  }
  set rel(rel) {
    this.set("rel", rel);
  }
  get title() {
    return this.get("title");
  }
  set title(title) {
    this.set("title", title);
  }
  get targetSchema() {
    return this.get("targetSchema");
  }
  set targetSchema(targetSchema) {
    this.set("targetSchema", targetSchema);
  }
  get mediaType() {
    return this.get("mediaType");
  }
  set mediaType(mediaType) {
    this.set("mediaType", mediaType);
  }
  get method() {
    return this.get("method");
  }
  set method(method) {
    this.set("method", method);
  }
  get encType() {
    return this.get("encType");
  }
  set encType(encType) {
    this.set("encType", encType);
  }
  get schema() {
    return this.get("schema");
  }
  set schema(schema4) {
    this.set("schema", schema4);
  }
};
var LinkDescription_default = LinkDescription;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/namespace.mjs
var jsonSchemaDraft4 = {
  namespace: (options) => {
    const {
      base: base2
    } = options;
    base2.register("jSONSchemaDraft4", JSONSchema_default);
    base2.register("jSONReference", JSONReference_default);
    base2.register("media", Media_default);
    base2.register("linkDescription", LinkDescription_default);
    return base2;
  }
};
var namespace_default2 = jsonSchemaDraft4;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/traversal/visitor.mjs
var getNodeType3 = (element) => {
  if (!isElement(element)) {
    return void 0;
  }
  return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;
};
var keyMap = {
  JSONSchemaDraft4Element: ["content"],
  JSONReferenceElement: ["content"],
  MediaElement: ["content"],
  LinkDescriptionElement: ["content"],
  ...keyMapDefault
};

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/Visitor.mjs
var Visitor2 = class {
  constructor(options) {
    __publicField(this, "element");
    Object.assign(this, options);
  }
  // eslint-disable-next-line class-methods-use-this
  copyMetaAndAttributes(from2, to2) {
    if (from2.meta.length > 0 || to2.meta.length > 0) {
      to2.meta = deepmerge_default(to2.meta, from2.meta);
      if (hasElementSourceMap(from2)) {
        to2.meta.set("sourceMap", from2.meta.get("sourceMap"));
      }
    }
    if (from2.attributes.length > 0 || from2.meta.length > 0) {
      to2.attributes = deepmerge_default(to2.attributes, from2.attributes);
    }
  }
};
var Visitor_default = Visitor2;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/FallbackVisitor.mjs
var FallbackVisitor = class extends Visitor_default {
  enter(element) {
    this.element = cloneDeep(element);
    return BREAK;
  }
};
var FallbackVisitor_default = FallbackVisitor;

// node_modules/ts-mixer/dist/esm/index.js
var copyProps = (dest, src, exclude = []) => {
  const props3 = Object.getOwnPropertyDescriptors(src);
  for (let prop3 of exclude)
    delete props3[prop3];
  Object.defineProperties(dest, props3);
};
var protoChain = (obj, currentChain = [obj]) => {
  const proto2 = Object.getPrototypeOf(obj);
  if (proto2 === null)
    return currentChain;
  return protoChain(proto2, [...currentChain, proto2]);
};
var nearestCommonProto = (...objs) => {
  if (objs.length === 0)
    return void 0;
  let commonProto = void 0;
  const protoChains = objs.map((obj) => protoChain(obj));
  while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
    const protos = protoChains.map((protoChain2) => protoChain2.pop());
    const potentialCommonProto = protos[0];
    if (protos.every((proto2) => proto2 === potentialCommonProto))
      commonProto = potentialCommonProto;
    else
      break;
  }
  return commonProto;
};
var hardMixProtos = (ingredients, constructor, exclude = []) => {
  var _a6;
  const base2 = (_a6 = nearestCommonProto(...ingredients)) !== null && _a6 !== void 0 ? _a6 : Object.prototype;
  const mixedProto = Object.create(base2);
  const visitedProtos = protoChain(base2);
  for (let prototype of ingredients) {
    let protos = protoChain(prototype);
    for (let i2 = protos.length - 1; i2 >= 0; i2--) {
      let newProto = protos[i2];
      if (visitedProtos.indexOf(newProto) === -1) {
        copyProps(mixedProto, newProto, ["constructor", ...exclude]);
        visitedProtos.push(newProto);
      }
    }
  }
  mixedProto.constructor = constructor;
  return mixedProto;
};
var unique = (arr) => arr.filter((e2, i2) => arr.indexOf(e2) == i2);
var getIngredientWithProp = (prop3, ingredients) => {
  const protoChains = ingredients.map((ingredient) => protoChain(ingredient));
  let protoDepth = 0;
  let protosAreLeftToSearch = true;
  while (protosAreLeftToSearch) {
    protosAreLeftToSearch = false;
    for (let i2 = ingredients.length - 1; i2 >= 0; i2--) {
      const searchTarget = protoChains[i2][protoDepth];
      if (searchTarget !== void 0 && searchTarget !== null) {
        protosAreLeftToSearch = true;
        if (Object.getOwnPropertyDescriptor(searchTarget, prop3) != void 0) {
          return protoChains[i2][0];
        }
      }
    }
    protoDepth++;
  }
  return void 0;
};
var proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
  getPrototypeOf() {
    return prototype;
  },
  setPrototypeOf() {
    throw Error("Cannot set prototype of Proxies created by ts-mixer");
  },
  getOwnPropertyDescriptor(_2, prop3) {
    return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop3, ingredients) || {}, prop3);
  },
  defineProperty() {
    throw new Error("Cannot define new properties on Proxies created by ts-mixer");
  },
  has(_2, prop3) {
    return getIngredientWithProp(prop3, ingredients) !== void 0 || prototype[prop3] !== void 0;
  },
  get(_2, prop3) {
    return (getIngredientWithProp(prop3, ingredients) || prototype)[prop3];
  },
  set(_2, prop3, val) {
    const ingredientWithProp = getIngredientWithProp(prop3, ingredients);
    if (ingredientWithProp === void 0)
      throw new Error("Cannot set new properties on Proxies created by ts-mixer");
    ingredientWithProp[prop3] = val;
    return true;
  },
  deleteProperty() {
    throw new Error("Cannot delete properties on Proxies created by ts-mixer");
  },
  ownKeys() {
    return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key57) => curr.indexOf(key57) < 0)));
  }
});
var softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);
var settings = {
  initFunction: null,
  staticsStrategy: "copy",
  prototypeStrategy: "copy",
  decoratorInheritance: "deep"
};
var mixins = /* @__PURE__ */ new WeakMap();
var getMixinsForClass = (clazz) => mixins.get(clazz);
var registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
var mergeObjectsOfDecorators = (o1, o22) => {
  var _a6, _b;
  const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o22)]);
  const mergedObject = {};
  for (let key57 of allKeys)
    mergedObject[key57] = unique([...(_a6 = o1 === null || o1 === void 0 ? void 0 : o1[key57]) !== null && _a6 !== void 0 ? _a6 : [], ...(_b = o22 === null || o22 === void 0 ? void 0 : o22[key57]) !== null && _b !== void 0 ? _b : []]);
  return mergedObject;
};
var mergePropertyAndMethodDecorators = (d1, d2) => {
  var _a6, _b, _c, _d;
  return {
    property: mergeObjectsOfDecorators((_a6 = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a6 !== void 0 ? _a6 : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
    method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
  };
};
var mergeDecorators = (d1, d2) => {
  var _a6, _b, _c, _d, _e6, _f;
  return {
    class: unique([...(_a6 = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a6 !== void 0 ? _a6 : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
    static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
    instance: mergePropertyAndMethodDecorators((_e6 = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e6 !== void 0 ? _e6 : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
  };
};
var decorators = /* @__PURE__ */ new Map();
var findAllConstituentClasses = (...classes) => {
  var _a6;
  const allClasses = /* @__PURE__ */ new Set();
  const frontier = /* @__PURE__ */ new Set([...classes]);
  while (frontier.size > 0) {
    for (let clazz of frontier) {
      const protoChainClasses = protoChain(clazz.prototype).map((proto2) => proto2.constructor);
      const mixinClasses = (_a6 = getMixinsForClass(clazz)) !== null && _a6 !== void 0 ? _a6 : [];
      const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
      const newClasses = potentiallyNewClasses.filter((c2) => !allClasses.has(c2));
      for (let newClass of newClasses)
        frontier.add(newClass);
      allClasses.add(clazz);
      frontier.delete(clazz);
    }
  }
  return [...allClasses];
};
var deepDecoratorSearch = (...classes) => {
  const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
  if (decoratorsForClassChain.length == 0)
    return {};
  if (decoratorsForClassChain.length == 1)
    return decoratorsForClassChain[0];
  return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
};
var directDecoratorSearch = (...classes) => {
  const classDecorators = classes.map((clazz) => getDecoratorsForClass(clazz));
  if (classDecorators.length === 0)
    return {};
  if (classDecorators.length === 1)
    return classDecorators[0];
  return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
};
var getDecoratorsForClass = (clazz) => {
  let decoratorsForClass = decorators.get(clazz);
  if (!decoratorsForClass) {
    decoratorsForClass = {};
    decorators.set(clazz, decoratorsForClass);
  }
  return decoratorsForClass;
};
function Mixin(...constructors) {
  var _a6, _b, _c;
  const prototypes = constructors.map((constructor) => constructor.prototype);
  const initFunctionName = settings.initFunction;
  if (initFunctionName !== null) {
    const initFunctions = prototypes.map((proto2) => proto2[initFunctionName]).filter((func) => typeof func === "function");
    const combinedInitFunction = function(...args) {
      for (let initFunction of initFunctions)
        initFunction.apply(this, args);
    };
    const extraProto = { [initFunctionName]: combinedInitFunction };
    prototypes.push(extraProto);
  }
  function MixedClass(...args) {
    for (const constructor of constructors)
      copyProps(this, new constructor(...args));
    if (initFunctionName !== null && typeof this[initFunctionName] === "function")
      this[initFunctionName].apply(this, args);
  }
  MixedClass.prototype = settings.prototypeStrategy === "copy" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === "copy" ? hardMixProtos(constructors, null, ["prototype"]) : proxyMix(constructors, Function.prototype));
  let DecoratedMixedClass = MixedClass;
  if (settings.decoratorInheritance !== "none") {
    const classDecorators = settings.decoratorInheritance === "deep" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
    for (let decorator of (_a6 = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a6 !== void 0 ? _a6 : []) {
      const result = decorator(DecoratedMixedClass);
      if (result) {
        DecoratedMixedClass = result;
      }
    }
    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
  }
  registerMixins(DecoratedMixedClass, constructors);
  return DecoratedMixedClass;
}
var applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
  const propDecorators = propAndMethodDecorators.property;
  const methodDecorators = propAndMethodDecorators.method;
  if (propDecorators)
    for (let key57 in propDecorators)
      for (let decorator of propDecorators[key57])
        decorator(target, key57);
  if (methodDecorators)
    for (let key57 in methodDecorators)
      for (let decorator of methodDecorators[key57])
        decorator(target, key57, Object.getOwnPropertyDescriptor(target, key57));
};

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/SpecificationVisitor.mjs
var SpecificationVisitor = class extends Visitor_default {
  constructor({
    specObj,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "specObj");
    __publicField(this, "passingOptionsNames", ["specObj"]);
    this.specObj = specObj;
  }
  retrievePassingOptions() {
    return pick_default(this.passingOptionsNames, this);
  }
  retrieveFixedFields(specPath) {
    const fixedFields = path_default(["visitors", ...specPath, "fixedFields"], this.specObj);
    if (typeof fixedFields === "object" && fixedFields !== null) {
      return Object.keys(fixedFields);
    }
    return [];
  }
  retrieveVisitor(specPath) {
    if (pathSatisfies_default(isFunction_default, ["visitors", ...specPath], this.specObj)) {
      return path_default(["visitors", ...specPath], this.specObj);
    }
    return path_default(["visitors", ...specPath, "$visitor"], this.specObj);
  }
  retrieveVisitorInstance(specPath, options = {}) {
    const passingOpts = this.retrievePassingOptions();
    const VisitorClz = this.retrieveVisitor(specPath);
    const visitorOpts = {
      ...passingOpts,
      ...options
    };
    return new VisitorClz(visitorOpts);
  }
  toRefractedElement(specPath, element, options = {}) {
    const visitor2 = this.retrieveVisitorInstance(specPath, options);
    if (visitor2 instanceof FallbackVisitor_default && (visitor2 === null || visitor2 === void 0 ? void 0 : visitor2.constructor) === FallbackVisitor_default) {
      return cloneDeep(element);
    }
    visit2(element, visitor2, options);
    return visitor2.element;
  }
};
var SpecificationVisitor_default = SpecificationVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/generics/FixedFieldsVisitor.mjs
var FixedFieldsVisitor = class extends SpecificationVisitor_default {
  constructor({
    specPath,
    ignoredFields,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "specPath");
    __publicField(this, "ignoredFields");
    this.specPath = specPath;
    this.ignoredFields = ignoredFields || [];
  }
  ObjectElement(objectElement) {
    const specPath = this.specPath(objectElement);
    const fields = this.retrieveFixedFields(specPath);
    objectElement.forEach((value, key57, memberElement) => {
      if (isStringElement(key57) && fields.includes(value_default(key57)) && !this.ignoredFields.includes(value_default(key57))) {
        const fixedFieldElement = this.toRefractedElement([...specPath, "fixedFields", value_default(key57)], value);
        const newMemberElement = new import_minim14.MemberElement(cloneDeep(key57), fixedFieldElement);
        this.copyMetaAndAttributes(memberElement, newMemberElement);
        newMemberElement.classes.push("fixed-field");
        this.element.content.push(newMemberElement);
      } else if (!this.ignoredFields.includes(value_default(key57))) {
        this.element.content.push(cloneDeep(memberElement));
      }
    });
    this.copyMetaAndAttributes(objectElement, this.element);
    return BREAK;
  }
};
var FixedFieldsVisitor_default = FixedFieldsVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/index.mjs
var JSONSchemaVisitor = class extends Mixin(FixedFieldsVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new JSONSchema_default();
    this.specPath = always_default(["document", "objects", "JSONSchema"]);
  }
};
var json_schema_default = JSONSchemaVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/ParentSchemaAwareVisitor.mjs
var ParentSchemaAwareVisitor = class {
  constructor({
    parent
  }) {
    __publicField(this, "parent");
    this.parent = parent;
  }
};
var ParentSchemaAwareVisitor_default = ParentSchemaAwareVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/predicates.mjs
var isJSONReferenceLikeElement = (element) => {
  return isObjectElement(element) && element.hasKey("$ref");
};

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/ItemsVisitor.mjs
var ItemsVisitor = class extends Mixin(SpecificationVisitor_default, ParentSchemaAwareVisitor_default, FallbackVisitor_default) {
  ObjectElement(objectElement) {
    const specPath = isJSONReferenceLikeElement(objectElement) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
    this.element = this.toRefractedElement(specPath, objectElement);
    return BREAK;
  }
  ArrayElement(arrayElement) {
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("json-schema-items");
    arrayElement.forEach((item) => {
      const specPath = isJSONReferenceLikeElement(item) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
      const element = this.toRefractedElement(specPath, item);
      this.element.push(element);
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var ItemsVisitor_default = ItemsVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/RequiredVisitor.mjs
var RequiredVisitor = class extends FallbackVisitor_default {
  ArrayElement(arrayElement) {
    const result = this.enter(arrayElement);
    this.element.classes.push("json-schema-required");
    return result;
  }
};
var RequiredVisitor_default = RequiredVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/generics/PatternedFieldsVisitor.mjs
var PatternedFieldsVisitor = class extends SpecificationVisitor_default {
  constructor({
    specPath,
    ignoredFields,
    fieldPatternPredicate,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "specPath");
    __publicField(this, "ignoredFields");
    __publicField(this, "fieldPatternPredicate", F_default);
    this.specPath = specPath;
    this.ignoredFields = ignoredFields || [];
    if (typeof fieldPatternPredicate === "function") {
      this.fieldPatternPredicate = fieldPatternPredicate;
    }
  }
  ObjectElement(objectElement) {
    objectElement.forEach((value, key57, memberElement) => {
      if (!this.ignoredFields.includes(value_default(key57)) && this.fieldPatternPredicate(value_default(key57))) {
        const specPath = this.specPath(value);
        const patternedFieldElement = this.toRefractedElement(specPath, value);
        const newMemberElement = new import_minim14.MemberElement(cloneDeep(key57), patternedFieldElement);
        this.copyMetaAndAttributes(memberElement, newMemberElement);
        newMemberElement.classes.push("patterned-field");
        this.element.content.push(newMemberElement);
      } else if (!this.ignoredFields.includes(value_default(key57))) {
        this.element.content.push(cloneDeep(memberElement));
      }
    });
    this.copyMetaAndAttributes(objectElement, this.element);
    return BREAK;
  }
};
var PatternedFieldsVisitor_default = PatternedFieldsVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/generics/MapVisitor.mjs
var MapVisitor = class extends PatternedFieldsVisitor_default {
  constructor(options) {
    super(options);
    this.fieldPatternPredicate = isNonEmptyString_default;
  }
};
var MapVisitor_default = MapVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/PropertiesVisitor.mjs
var PropertiesVisitor = class extends Mixin(MapVisitor_default, ParentSchemaAwareVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("json-schema-properties");
    this.specPath = (element) => isJSONReferenceLikeElement(element) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
  }
};
var PropertiesVisitor_default = PropertiesVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/PatternPropertiesVisitor.mjs
var PatternPropertiesVisitor = class extends Mixin(MapVisitor_default, ParentSchemaAwareVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("json-schema-patternProperties");
    this.specPath = (element) => isJSONReferenceLikeElement(element) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
  }
};
var PatternPropertiesVisitor_default = PatternPropertiesVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/DependenciesVisitor.mjs
var DependenciesVisitor = class extends Mixin(MapVisitor_default, ParentSchemaAwareVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("json-schema-dependencies");
    this.specPath = (element) => isJSONReferenceLikeElement(element) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
  }
};
var DependenciesVisitor_default = DependenciesVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/EnumVisitor.mjs
var EnumVisitor = class extends FallbackVisitor_default {
  ArrayElement(arrayElement) {
    const result = this.enter(arrayElement);
    this.element.classes.push("json-schema-enum");
    return result;
  }
};
var EnumVisitor_default = EnumVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/TypeVisitor.mjs
var TypeVisitor = class extends FallbackVisitor_default {
  StringElement(stringElement) {
    const result = this.enter(stringElement);
    this.element.classes.push("json-schema-type");
    return result;
  }
  ArrayElement(arrayElement) {
    const result = this.enter(arrayElement);
    this.element.classes.push("json-schema-type");
    return result;
  }
};
var TypeVisitor_default = TypeVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/AllOfVisitor.mjs
var AllOfVisitor = class extends Mixin(SpecificationVisitor_default, ParentSchemaAwareVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("json-schema-allOf");
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      const specPath = isJSONReferenceLikeElement(item) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
      const element = this.toRefractedElement(specPath, item);
      this.element.push(element);
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var AllOfVisitor_default = AllOfVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/AnyOfVisitor.mjs
var AnyOfVisitor = class extends Mixin(SpecificationVisitor_default, ParentSchemaAwareVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("json-schema-anyOf");
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      const specPath = isJSONReferenceLikeElement(item) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
      const element = this.toRefractedElement(specPath, item);
      this.element.push(element);
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var AnyOfVisitor_default = AnyOfVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/OneOfVisitor.mjs
var OneOfVisitor = class extends Mixin(SpecificationVisitor_default, ParentSchemaAwareVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("json-schema-oneOf");
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      const specPath = isJSONReferenceLikeElement(item) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
      const element = this.toRefractedElement(specPath, item);
      this.element.push(element);
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var OneOfVisitor_default = OneOfVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/DefinitionsVisitor.mjs
var DefinitionsVisitor = class extends Mixin(MapVisitor_default, ParentSchemaAwareVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("json-schema-definitions");
    this.specPath = (element) => isJSONReferenceLikeElement(element) ? ["document", "objects", "JSONReference"] : ["document", "objects", "JSONSchema"];
  }
};
var DefinitionsVisitor_default = DefinitionsVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/LinksVisitor.mjs
var LinksVisitor = class extends Mixin(SpecificationVisitor_default, ParentSchemaAwareVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("json-schema-links");
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      const linkDescriptionElement = this.toRefractedElement(["document", "objects", "LinkDescription"], item);
      this.element.push(linkDescriptionElement);
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var LinksVisitor_default = LinksVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/json-reference/index.mjs
var JSONReferenceVisitor = class extends Mixin(FixedFieldsVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new JSONReference_default();
    this.specPath = always_default(["document", "objects", "JSONReference"]);
  }
  ObjectElement(objectElement) {
    const result = FixedFieldsVisitor_default.prototype.ObjectElement.call(this, objectElement);
    if (isStringElement(this.element.$ref)) {
      this.element.classes.push("reference-element");
    }
    return result;
  }
};
var json_reference_default = JSONReferenceVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/json-reference/$RefVisitor.mjs
var $RefVisitor = class extends FallbackVisitor_default {
  StringElement(stringElement) {
    const result = this.enter(stringElement);
    this.element.classes.push("reference-value");
    return result;
  }
};
var RefVisitor_default = $RefVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/generics/AlternatingVisitor.mjs
var AlternatingVisitor = class extends SpecificationVisitor_default {
  constructor({
    alternator,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "alternator");
    this.alternator = alternator;
  }
  enter(element) {
    const functions = this.alternator.map(({
      predicate,
      specPath: specPath2
    }) => ifElse_default(predicate, always_default(specPath2), stubUndefined_default));
    const specPath = dispatch_default(functions)(element);
    this.element = this.toRefractedElement(specPath, element);
    return BREAK;
  }
};
var AlternatingVisitor_default = AlternatingVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/JSONSchemaOrJSONReferenceVisitor.mjs
var SchemaOrReferenceVisitor = class extends AlternatingVisitor_default {
  constructor(options) {
    super(options);
    this.alternator = [{
      predicate: isJSONReferenceLikeElement,
      specPath: ["document", "objects", "JSONReference"]
    }, {
      predicate: T_default,
      specPath: ["document", "objects", "JSONSchema"]
    }];
  }
};
var JSONSchemaOrJSONReferenceVisitor_default = SchemaOrReferenceVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/media/index.mjs
var MediaVisitor = class extends Mixin(FixedFieldsVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new Media_default();
    this.specPath = always_default(["document", "objects", "Media"]);
  }
};
var media_default = MediaVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/visitors/json-schema/link-description/index.mjs
var LinkDescriptionVisitor = class extends Mixin(FixedFieldsVisitor_default, FallbackVisitor_default) {
  constructor(options) {
    super(options);
    this.element = new LinkDescription_default();
    this.specPath = always_default(["document", "objects", "LinkDescription"]);
  }
};
var link_description_default = LinkDescriptionVisitor;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/specification.mjs
var specification = {
  visitors: {
    value: FallbackVisitor_default,
    JSONSchemaOrJSONReferenceVisitor: JSONSchemaOrJSONReferenceVisitor_default,
    document: {
      objects: {
        JSONSchema: {
          $visitor: json_schema_default,
          fixedFields: {
            // core vocabulary
            id: {
              $ref: "#/visitors/value"
            },
            $schema: {
              $ref: "#/visitors/value"
            },
            // validation vocabulary
            // validation keywords for numeric instances (number and integer)
            multipleOf: {
              $ref: "#/visitors/value"
            },
            maximum: {
              $ref: "#/visitors/value"
            },
            exclusiveMaximum: {
              $ref: "#/visitors/value"
            },
            minimum: {
              $ref: "#/visitors/value"
            },
            exclusiveMinimum: {
              $ref: "#/visitors/value"
            },
            // validation keywords for strings
            maxLength: {
              $ref: "#/visitors/value"
            },
            minLength: {
              $ref: "#/visitors/value"
            },
            pattern: {
              $ref: "#/visitors/value"
            },
            // validation keywords for arrays
            additionalItems: JSONSchemaOrJSONReferenceVisitor_default,
            items: ItemsVisitor_default,
            maxItems: {
              $ref: "#/visitors/value"
            },
            minItems: {
              $ref: "#/visitors/value"
            },
            uniqueItems: {
              $ref: "#/visitors/value"
            },
            // validation keywords for objects
            maxProperties: {
              $ref: "#/visitors/value"
            },
            minProperties: {
              $ref: "#/visitors/value"
            },
            required: RequiredVisitor_default,
            properties: PropertiesVisitor_default,
            additionalProperties: JSONSchemaOrJSONReferenceVisitor_default,
            patternProperties: PatternPropertiesVisitor_default,
            dependencies: DependenciesVisitor_default,
            // validation keywords for any instance type
            enum: EnumVisitor_default,
            type: TypeVisitor_default,
            allOf: AllOfVisitor_default,
            anyOf: AnyOfVisitor_default,
            oneOf: OneOfVisitor_default,
            not: JSONSchemaOrJSONReferenceVisitor_default,
            definitions: DefinitionsVisitor_default,
            // metadata keywords
            title: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            default: {
              $ref: "#/visitors/value"
            },
            // semantic validation with "format"
            format: {
              $ref: "#/visitors/value"
            },
            // JSON Hyper-Schema
            base: {
              $ref: "#/visitors/value"
            },
            links: LinksVisitor_default,
            media: {
              $ref: "#/visitors/document/objects/Media"
            },
            readOnly: {
              $ref: "#/visitors/value"
            }
          }
        },
        JSONReference: {
          $visitor: json_reference_default,
          fixedFields: {
            $ref: RefVisitor_default
          }
        },
        Media: {
          $visitor: media_default,
          fixedFields: {
            binaryEncoding: {
              $ref: "#/visitors/value"
            },
            type: {
              $ref: "#/visitors/value"
            }
          }
        },
        LinkDescription: {
          $visitor: link_description_default,
          fixedFields: {
            href: {
              $ref: "#/visitors/value"
            },
            rel: {
              $ref: "#/visitors/value"
            },
            title: {
              $ref: "#/visitors/value"
            },
            targetSchema: JSONSchemaOrJSONReferenceVisitor_default,
            mediaType: {
              $ref: "#/visitors/value"
            },
            method: {
              $ref: "#/visitors/value"
            },
            encType: {
              $ref: "#/visitors/value"
            },
            schema: JSONSchemaOrJSONReferenceVisitor_default
          }
        }
      }
    }
  }
};
var specification_default = specification;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/predicates.mjs
var predicates_exports2 = {};
__export(predicates_exports2, {
  isJSONReferenceElement: () => isJSONReferenceElement,
  isJSONSchemaElement: () => isJSONSchemaElement,
  isLinkDescriptionElement: () => isLinkDescriptionElement,
  isMediaElement: () => isMediaElement
});
var isJSONSchemaElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof JSONSchema_default || hasBasicElementProps2(element) && isElementType2("JSONSchemaDraft4", element) && primitiveEq2("object", element);
});
var isJSONReferenceElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof JSONReference_default || hasBasicElementProps2(element) && isElementType2("JSONReference", element) && primitiveEq2("object", element);
});
var isMediaElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Media_default || hasBasicElementProps2(element) && isElementType2("media", element) && primitiveEq2("object", element);
});
var isLinkDescriptionElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof LinkDescription_default || hasBasicElementProps2(element) && isElementType2("linkDescription", element) && primitiveEq2("object", element);
});

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/toolbox.mjs
var createToolbox2 = () => {
  const namespace2 = createNamespace(namespace_default2);
  const predicates = {
    ...predicates_exports2,
    isStringElement
  };
  return {
    predicates,
    namespace: namespace2
  };
};
var toolbox_default2 = createToolbox2;

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/index.mjs
var refract3 = (value, {
  specPath = ["visitors", "document", "objects", "JSONSchema", "$visitor"],
  plugins: plugins2 = [],
  specificationObj = specification_default
} = {}) => {
  const element = (0, import_minim14.refract)(value);
  const resolvedSpec = dereference(specificationObj);
  const RootVisitorClass = path_default(specPath, resolvedSpec);
  const rootVisitor = new RootVisitorClass({
    specObj: resolvedSpec
  });
  visit2(element, rootVisitor);
  return dispatchPluginsSync(rootVisitor.element, plugins2, {
    toolboxCreator: toolbox_default2,
    visitorOptions: {
      keyMap,
      nodeTypeGetter: getNodeType3
    }
  });
};
var createRefractor2 = (specPath) => (value, options = {}) => refract3(value, {
  specPath,
  ...options
});

// node_modules/@swagger-api/apidom-ns-json-schema-draft-4/src/refractor/registration.mjs
JSONSchema_default.refract = createRefractor2(["visitors", "document", "objects", "JSONSchema", "$visitor"]);
JSONReference_default.refract = createRefractor2(["visitors", "document", "objects", "JSONReference", "$visitor"]);
Media_default.refract = createRefractor2(["visitors", "document", "objects", "Media", "$visitor"]);
LinkDescription_default.refract = createRefractor2(["visitors", "document", "objects", "LinkDescription", "$visitor"]);

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Schema.mjs
var Schema2 = class extends JSONSchema_default {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "schema";
    this.classes.push("json-schema-draft-4");
  }
  /**
   * Core vocabulary
   *
   * URI: https://tools.ietf.org/html/draft-wright-json-schema-00
   */
  get idProp() {
    throw new UnsupportedOperationError_default("idProp getter in Schema class is not not supported.");
  }
  set idProp(idProps) {
    throw new UnsupportedOperationError_default("idProp setter in Schema class is not not supported.");
  }
  get $schema() {
    throw new UnsupportedOperationError_default("$schema getter in Schema class is not not supported.");
  }
  set $schema($schema) {
    throw new UnsupportedOperationError_default("$schema setter in Schema class is not not supported.");
  }
  /**
   * Validation keywords for arrays
   */
  get additionalItems() {
    return this.get("additionalItems");
  }
  set additionalItems(additionalItems) {
    this.set("additionalItems", additionalItems);
  }
  get items() {
    return this.get("items");
  }
  set items(items) {
    this.set("items", items);
  }
  /**
   * Validation keywords for objects
   */
  get additionalProperties() {
    return this.get("additionalProperties");
  }
  set additionalProperties(additionalProperties) {
    this.set("additionalProperties", additionalProperties);
  }
  get patternProperties() {
    throw new UnsupportedOperationError_default("patternProperties getter in Schema class is not not supported.");
  }
  set patternProperties(patternProperties) {
    throw new UnsupportedOperationError_default("patternProperties setter in Schema class is not not supported.");
  }
  get dependencies() {
    throw new UnsupportedOperationError_default("dependencies getter in Schema class is not not supported.");
  }
  set dependencies(dependencies) {
    throw new UnsupportedOperationError_default("dependencies setter in Schema class is not not supported.");
  }
  /**
   *  Validation keywords for any instance type
   */
  get type() {
    return this.get("type");
  }
  set type(type5) {
    this.set("type", type5);
  }
  get not() {
    return this.get("not");
  }
  set not(not3) {
    this.set("not", not3);
  }
  get definitions() {
    throw new UnsupportedOperationError_default("definitions getter in Schema class is not not supported.");
  }
  set definitions(definitions) {
    throw new UnsupportedOperationError_default("definitions setter in Schema class is not not supported.");
  }
  /**
   * JSON Hyper-Schema
   *
   * URI: https://datatracker.ietf.org/doc/html/draft-wright-json-schema-hyperschema-00
   */
  get base() {
    throw new UnsupportedOperationError_default("base getter in Schema class is not not supported.");
  }
  set base(base2) {
    throw new UnsupportedOperationError_default("base setter in Schema class is not not supported.");
  }
  get links() {
    throw new UnsupportedOperationError_default("links getter in Schema class is not not supported.");
  }
  set links(links2) {
    throw new UnsupportedOperationError_default("links setter in Schema class is not not supported.");
  }
  get media() {
    throw new UnsupportedOperationError_default("media getter in Schema class is not not supported.");
  }
  set media(media) {
    throw new UnsupportedOperationError_default("media setter in Schema class is not not supported.");
  }
  /**
   * OpenAPI vocabulary
   */
  get nullable() {
    return this.get("nullable");
  }
  set nullable(nullable) {
    this.set("nullable", nullable);
  }
  get discriminator() {
    return this.get("discriminator");
  }
  set discriminator(discriminator) {
    this.set("discriminator", discriminator);
  }
  get writeOnly() {
    return this.get("writeOnly");
  }
  set writeOnly(writeOnly) {
    this.set("writeOnly", writeOnly);
  }
  get xml() {
    return this.get("xml");
  }
  set xml(xml3) {
    this.set("xml", xml3);
  }
  get externalDocs() {
    return this.get("externalDocs");
  }
  set externalDocs(externalDocs) {
    this.set("externalDocs", externalDocs);
  }
  get example() {
    return this.get("example");
  }
  set example(example) {
    this.set("example", example);
  }
  get deprecated() {
    return this.get("deprecated");
  }
  set deprecated(deprecated) {
    this.set("deprecated", deprecated);
  }
};
var Schema_default = Schema2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/SecurityRequirement.mjs
var SecurityRequirement = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "securityRequirement";
  }
};
var SecurityRequirement_default = SecurityRequirement;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/SecurityScheme.mjs
var SecurityScheme = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "securityScheme";
  }
  get type() {
    return this.get("type");
  }
  set type(type5) {
    this.set("type", type5);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get name() {
    return this.get("name");
  }
  set name(name2) {
    this.set("name", name2);
  }
  get in() {
    return this.get("in");
  }
  set in(inVal) {
    this.set("in", inVal);
  }
  get scheme() {
    return this.get("scheme");
  }
  set scheme(scheme) {
    this.set("scheme", scheme);
  }
  get bearerFormat() {
    return this.get("bearerFormat");
  }
  set bearerFormat(bearerFormat) {
    this.set("bearerFormat", bearerFormat);
  }
  get flows() {
    return this.get("flows");
  }
  set flows(flows) {
    this.set("flows", flows);
  }
  get openIdConnectUrl() {
    return this.get("openIdConnectUrl");
  }
  set openIdConnectUrl(openIdConnectUrl) {
    this.set("openIdConnectUrl", openIdConnectUrl);
  }
};
var SecurityScheme_default = SecurityScheme;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Server.mjs
var Server = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "server";
  }
  get url() {
    return this.get("url");
  }
  set url(url) {
    this.set("url", url);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get variables() {
    return this.get("variables");
  }
  set variables(variables) {
    this.set("variables", variables);
  }
};
var Server_default = Server;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/ServerVariable.mjs
var ServerVariable = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "serverVariable";
  }
  get enum() {
    return this.get("enum");
  }
  set enum(value) {
    this.set("enum", value);
  }
  get default() {
    return this.get("default");
  }
  set default(value) {
    this.set("default", value);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
};
var ServerVariable_default = ServerVariable;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Tag.mjs
var Tag = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "tag";
  }
  get name() {
    return this.get("name");
  }
  set name(name2) {
    this.set("name", name2);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get externalDocs() {
    return this.get("externalDocs");
  }
  set externalDocs(externalDocs) {
    this.set("externalDocs", externalDocs);
  }
};
var Tag_default2 = Tag;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/Xml.mjs
var Xml = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "xml";
  }
  get name() {
    return this.get("name");
  }
  set name(name2) {
    this.set("name", name2);
  }
  get namespace() {
    return this.get("namespace");
  }
  set namespace(namespace2) {
    this.set("namespace", namespace2);
  }
  get prefix() {
    return this.get("prefix");
  }
  set prefix(prefix) {
    this.set("prefix", prefix);
  }
  get attribute() {
    return this.get("attribute");
  }
  set attribute(attribute2) {
    this.set("attribute", attribute2);
  }
  get wrapped() {
    return this.get("wrapped");
  }
  set wrapped(wrapped) {
    this.set("wrapped", wrapped);
  }
};
var Xml_default = Xml;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/namespace.mjs
var openApi3_0 = {
  namespace: (options) => {
    const {
      base: base2
    } = options;
    base2.register("callback", Callback_default);
    base2.register("components", Components_default);
    base2.register("contact", Contact_default);
    base2.register("discriminator", Discriminator_default);
    base2.register("encoding", Encoding_default);
    base2.register("example", Example_default);
    base2.register("externalDocumentation", ExternalDocumentation_default);
    base2.register("header", Header_default);
    base2.register("info", Info_default);
    base2.register("license", License_default);
    base2.register("link", Link_default);
    base2.register("mediaType", MediaType_default);
    base2.register("oAuthFlow", OAuthFlow_default);
    base2.register("oAuthFlows", OAuthFlows_default);
    base2.register("openapi", Openapi_default);
    base2.register("openApi3_0", OpenApi3_0_default);
    base2.register("operation", Operation_default);
    base2.register("parameter", Parameter_default);
    base2.register("pathItem", PathItem_default);
    base2.register("paths", Paths_default);
    base2.register("reference", Reference_default2);
    base2.register("requestBody", RequestBody_default);
    base2.register("response", Response_default);
    base2.register("responses", Responses_default);
    base2.register("schema", Schema_default);
    base2.register("securityRequirement", SecurityRequirement_default);
    base2.register("securityScheme", SecurityScheme_default);
    base2.register("server", Server_default);
    base2.register("serverVariable", ServerVariable_default);
    base2.register("tag", Tag_default2);
    base2.register("xml", Xml_default);
    return base2;
  }
};
var namespace_default3 = openApi3_0;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/Servers.mjs
var _Servers = class _Servers extends import_minim10.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_Servers.primaryClass);
  }
};
__publicField(_Servers, "primaryClass", "servers");
var Servers = _Servers;
var Servers_default = Servers;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/Security.mjs
var _Security = class _Security extends import_minim10.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_Security.primaryClass);
  }
};
__publicField(_Security, "primaryClass", "security");
var Security = _Security;
var Security_default = Security;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/Tags.mjs
var _Tags = class _Tags extends import_minim10.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_Tags.primaryClass);
  }
};
__publicField(_Tags, "primaryClass", "tags");
var Tags = _Tags;
var Tags_default = Tags;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ServerVariables.mjs
var _ServerVariables = class _ServerVariables extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ServerVariables.primaryClass);
  }
};
__publicField(_ServerVariables, "primaryClass", "server-variables");
var ServerVariables = _ServerVariables;
var ServerVariables_default = ServerVariables;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ComponentsSchemas.mjs
var _ComponentsSchemas = class _ComponentsSchemas extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsSchemas.primaryClass);
  }
};
__publicField(_ComponentsSchemas, "primaryClass", "components-schemas");
var ComponentsSchemas = _ComponentsSchemas;
var ComponentsSchemas_default = ComponentsSchemas;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ComponentsResponses.mjs
var _ComponentsResponses = class _ComponentsResponses extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsResponses.primaryClass);
  }
};
__publicField(_ComponentsResponses, "primaryClass", "components-responses");
var ComponentsResponses = _ComponentsResponses;
var ComponentsResponses_default = ComponentsResponses;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ComponentsParameters.mjs
var _ComponentsParameters = class _ComponentsParameters extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsParameters.primaryClass);
    this.classes.push("parameters");
  }
};
__publicField(_ComponentsParameters, "primaryClass", "components-parameters");
var ComponentsParameters = _ComponentsParameters;
var ComponentsParameters_default = ComponentsParameters;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ComponentsExamples.mjs
var _ComponentsExamples = class _ComponentsExamples extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsExamples.primaryClass);
    this.classes.push("examples");
  }
};
__publicField(_ComponentsExamples, "primaryClass", "components-examples");
var ComponentsExamples = _ComponentsExamples;
var ComponentsExamples_default = ComponentsExamples;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ComponentsRequestBodies.mjs
var _ComponentsRequestBodies = class _ComponentsRequestBodies extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsRequestBodies.primaryClass);
  }
};
__publicField(_ComponentsRequestBodies, "primaryClass", "components-request-bodies");
var ComponentsRequestBodies = _ComponentsRequestBodies;
var ComponentsRequestBodies_default = ComponentsRequestBodies;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ComponentsHeaders.mjs
var _ComponentsHeaders = class _ComponentsHeaders extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsHeaders.primaryClass);
  }
};
__publicField(_ComponentsHeaders, "primaryClass", "components-headers");
var ComponentsHeaders = _ComponentsHeaders;
var ComponentsHeaders_default = ComponentsHeaders;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ComponentsSecuritySchemes.mjs
var _ComponentsSecuritySchemes = class _ComponentsSecuritySchemes extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsSecuritySchemes.primaryClass);
  }
};
__publicField(_ComponentsSecuritySchemes, "primaryClass", "components-security-schemes");
var ComponentsSecuritySchemes = _ComponentsSecuritySchemes;
var ComponentsSecuritySchemes_default = ComponentsSecuritySchemes;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ComponentsLinks.mjs
var _ComponentsLinks = class _ComponentsLinks extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsLinks.primaryClass);
  }
};
__publicField(_ComponentsLinks, "primaryClass", "components-links");
var ComponentsLinks = _ComponentsLinks;
var ComponentsLinks_default = ComponentsLinks;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ComponentsCallbacks.mjs
var _ComponentsCallbacks = class _ComponentsCallbacks extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsCallbacks.primaryClass);
  }
};
__publicField(_ComponentsCallbacks, "primaryClass", "components-callbacks");
var ComponentsCallbacks = _ComponentsCallbacks;
var ComponentsCallbacks_default = ComponentsCallbacks;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/PathItemServers.mjs
var _PathItemServers = class _PathItemServers extends import_minim10.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_PathItemServers.primaryClass);
    this.classes.push("servers");
  }
};
__publicField(_PathItemServers, "primaryClass", "path-item-servers");
var PathItemServers = _PathItemServers;
var PathItemServers_default = PathItemServers;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/PathItemParameters.mjs
var _PathItemParameters = class _PathItemParameters extends import_minim10.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_PathItemParameters.primaryClass);
    this.classes.push("parameters");
  }
};
__publicField(_PathItemParameters, "primaryClass", "path-item-parameters");
var PathItemParameters = _PathItemParameters;
var PathItemParameters_default = PathItemParameters;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/OperationParameters.mjs
var _OperationParameters = class _OperationParameters extends import_minim10.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_OperationParameters.primaryClass);
    this.classes.push("parameters");
  }
};
__publicField(_OperationParameters, "primaryClass", "operation-parameters");
var OperationParameters = _OperationParameters;
var OperationParameters_default = OperationParameters;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ParameterExamples.mjs
var _ParameterExamples = class _ParameterExamples extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ParameterExamples.primaryClass);
    this.classes.push("examples");
  }
};
__publicField(_ParameterExamples, "primaryClass", "parameter-examples");
var ParameterExamples = _ParameterExamples;
var ParameterExamples_default = ParameterExamples;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ParameterContent.mjs
var _ParameterContent = class _ParameterContent extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ParameterContent.primaryClass);
    this.classes.push("content");
  }
};
__publicField(_ParameterContent, "primaryClass", "parameter-content");
var ParameterContent = _ParameterContent;
var ParameterContent_default = ParameterContent;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/OperationTags.mjs
var _OperationTags = class _OperationTags extends import_minim10.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_OperationTags.primaryClass);
  }
};
__publicField(_OperationTags, "primaryClass", "operation-tags");
var OperationTags = _OperationTags;
var OperationTags_default = OperationTags;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/OperationCallbacks.mjs
var _OperationCallbacks = class _OperationCallbacks extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_OperationCallbacks.primaryClass);
  }
};
__publicField(_OperationCallbacks, "primaryClass", "operation-callbacks");
var OperationCallbacks = _OperationCallbacks;
var OperationCallbacks_default = OperationCallbacks;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/OperationSecurity.mjs
var _OperationSecurity = class _OperationSecurity extends import_minim10.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_OperationSecurity.primaryClass);
    this.classes.push("security");
  }
};
__publicField(_OperationSecurity, "primaryClass", "operation-security");
var OperationSecurity = _OperationSecurity;
var OperationSecurity_default = OperationSecurity;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/OperationServers.mjs
var _OperationServers = class _OperationServers extends import_minim10.ArrayElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_OperationServers.primaryClass);
    this.classes.push("servers");
  }
};
__publicField(_OperationServers, "primaryClass", "operation-servers");
var OperationServers = _OperationServers;
var OperationServers_default = OperationServers;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/RequestBodyContent.mjs
var _RequestBodyContent = class _RequestBodyContent extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_RequestBodyContent.primaryClass);
    this.classes.push("content");
  }
};
__publicField(_RequestBodyContent, "primaryClass", "request-body-content");
var RequestBodyContent = _RequestBodyContent;
var RequestBodyContent_default = RequestBodyContent;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/MediaTypeExamples.mjs
var _MediaTypeExamples = class _MediaTypeExamples extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_MediaTypeExamples.primaryClass);
    this.classes.push("examples");
  }
};
__publicField(_MediaTypeExamples, "primaryClass", "media-type-examples");
var MediaTypeExamples = _MediaTypeExamples;
var MediaTypeExamples_default = MediaTypeExamples;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/MediaTypeEncoding.mjs
var _MediaTypeEncoding = class _MediaTypeEncoding extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_MediaTypeEncoding.primaryClass);
  }
};
__publicField(_MediaTypeEncoding, "primaryClass", "media-type-encoding");
var MediaTypeEncoding = _MediaTypeEncoding;
var MediaTypeEncoding_default = MediaTypeEncoding;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/EncodingHeaders.mjs
var _EncodingHeaders = class _EncodingHeaders extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_EncodingHeaders.primaryClass);
  }
};
__publicField(_EncodingHeaders, "primaryClass", "encoding-headers");
var EncodingHeaders = _EncodingHeaders;
var EncodingHeaders_default = EncodingHeaders;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ResponseHeaders.mjs
var _ResponseHeaders = class _ResponseHeaders extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ResponseHeaders.primaryClass);
  }
};
__publicField(_ResponseHeaders, "primaryClass", "response-headers");
var ResponseHeaders = _ResponseHeaders;
var ResponseHeaders_default = ResponseHeaders;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ResponseContent.mjs
var _ResponseContent = class _ResponseContent extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ResponseContent.primaryClass);
    this.classes.push("content");
  }
};
__publicField(_ResponseContent, "primaryClass", "response-content");
var ResponseContent = _ResponseContent;
var ResponseContent_default = ResponseContent;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/ResponseLinks.mjs
var _ResponseLinks = class _ResponseLinks extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ResponseLinks.primaryClass);
  }
};
__publicField(_ResponseLinks, "primaryClass", "response-links");
var ResponseLinks = _ResponseLinks;
var ResponseLinks_default = ResponseLinks;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/DiscriminatorMapping.mjs
var _DiscriminatorMapping = class _DiscriminatorMapping extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_DiscriminatorMapping.primaryClass);
  }
};
__publicField(_DiscriminatorMapping, "primaryClass", "discriminator-mapping");
var DiscriminatorMapping = _DiscriminatorMapping;
var DiscriminatorMapping_default = DiscriminatorMapping;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/OAuthFlowScopes.mjs
var _OAuthFlowScopes = class _OAuthFlowScopes extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_OAuthFlowScopes.primaryClass);
  }
};
__publicField(_OAuthFlowScopes, "primaryClass", "oauth-flow-scopes");
var OAuthFlowScopes = _OAuthFlowScopes;
var OAuthFlowScopes_default = OAuthFlowScopes;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/LinkParameters.mjs
var _LinkParameters = class _LinkParameters extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_LinkParameters.primaryClass);
  }
};
__publicField(_LinkParameters, "primaryClass", "link-parameters");
var LinkParameters = _LinkParameters;
var LinkParameters_default = LinkParameters;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/HeaderExamples.mjs
var _HeaderExamples = class _HeaderExamples extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_HeaderExamples.primaryClass);
    this.classes.push("examples");
  }
};
__publicField(_HeaderExamples, "primaryClass", "header-examples");
var HeaderExamples = _HeaderExamples;
var HeaderExamples_default = HeaderExamples;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/elements/nces/HeaderContent.mjs
var _HeaderContent = class _HeaderContent extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_HeaderContent.primaryClass);
    this.classes.push("content");
  }
};
__publicField(_HeaderContent, "primaryClass", "header-content");
var HeaderContent = _HeaderContent;
var HeaderContent_default = HeaderContent;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/traversal/visitor.mjs
var getNodeType4 = (element) => {
  if (!isElement(element)) {
    return void 0;
  }
  return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;
};
var keyMap2 = {
  CallbackElement: ["content"],
  ComponentsElement: ["content"],
  ContactElement: ["content"],
  DiscriminatorElement: ["content"],
  Encoding: ["content"],
  Example: ["content"],
  ExternalDocumentationElement: ["content"],
  HeaderElement: ["content"],
  InfoElement: ["content"],
  LicenseElement: ["content"],
  MediaTypeElement: ["content"],
  OAuthFlowElement: ["content"],
  OAuthFlowsElement: ["content"],
  OpenApi3_0Element: ["content"],
  OperationElement: ["content"],
  ParameterElement: ["content"],
  PathItemElement: ["content"],
  PathsElement: ["content"],
  ReferenceElement: ["content"],
  RequestBodyElement: ["content"],
  ResponseElement: ["content"],
  ResponsesElement: ["content"],
  SchemaElement: ["content"],
  SecurityRequirementElement: ["content"],
  SecuritySchemeElement: ["content"],
  ServerElement: ["content"],
  ServerVariableElement: ["content"],
  TagElement: ["content"],
  ...keyMapDefault
};

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/plugins/replace-empty-element.mjs
var schema2 = {
  // concrete types handling (CTs)
  OpenApi3_0Element: {
    info(...args) {
      return new Info_default(...args);
    },
    servers(...args) {
      return new Servers_default(...args);
    },
    paths(...args) {
      return new Paths_default(...args);
    },
    components(...args) {
      return new Components_default(...args);
    },
    security(...args) {
      return new Security_default(...args);
    },
    tags(...args) {
      return new Tags_default(...args);
    },
    externalDocs(...args) {
      return new ExternalDocumentation_default(...args);
    }
  },
  InfoElement: {
    contact(...args) {
      return new Contact_default(...args);
    },
    license(...args) {
      return new License_default(...args);
    }
  },
  ServerElement: {
    variables(...args) {
      return new ServerVariables_default(...args);
    }
  },
  ServerVariableElement: {
    enum(...args) {
      return new import_minim10.ArrayElement(...args);
    }
  },
  PathsElement: {
    "[key: *]": function key(...args) {
      return new PathItem_default(...args);
    }
  },
  PathItemElement: {
    get(...args) {
      return new Operation_default(...args);
    },
    put(...args) {
      return new Operation_default(...args);
    },
    post(...args) {
      return new Operation_default(...args);
    },
    delete(...args) {
      return new Operation_default(...args);
    },
    options(...args) {
      return new Operation_default(...args);
    },
    head(...args) {
      return new Operation_default(...args);
    },
    patch(...args) {
      return new Operation_default(...args);
    },
    trace(...args) {
      return new Operation_default(...args);
    },
    servers(...args) {
      return new PathItemServers_default(...args);
    },
    parameters(...args) {
      return new PathItemParameters_default(...args);
    }
  },
  OperationElement: {
    tags(...args) {
      return new OperationTags_default(...args);
    },
    externalDocs(...args) {
      return new ExternalDocumentation_default(...args);
    },
    parameters(...args) {
      return new OperationParameters_default(...args);
    },
    requestBody(...args) {
      return new RequestBody_default(...args);
    },
    responses(...args) {
      return new Responses_default(...args);
    },
    callbacks(...args) {
      return new OperationCallbacks_default(...args);
    },
    security(...args) {
      return new OperationSecurity_default(...args);
    },
    servers(...args) {
      return new OperationServers_default(...args);
    }
  },
  ParameterElement: {
    schema(...args) {
      return new Schema_default(...args);
    },
    examples(...args) {
      return new ParameterExamples_default(...args);
    },
    content(...args) {
      return new ParameterContent_default(...args);
    }
  },
  RequestBodyElement: {
    content(...args) {
      return new RequestBodyContent_default(...args);
    }
  },
  MediaTypeElement: {
    schema(...args) {
      return new Schema_default(...args);
    },
    examples(...args) {
      return new MediaTypeExamples_default(...args);
    },
    encoding(...args) {
      return new MediaTypeEncoding_default(...args);
    }
  },
  EncodingElement: {
    headers(...args) {
      return new EncodingHeaders_default(...args);
    }
  },
  ResponsesElement: {
    "[key: *]": function key2(...args) {
      return new Response_default(...args);
    }
  },
  ResponseElement: {
    headers(...args) {
      return new ResponseHeaders_default(...args);
    },
    content(...args) {
      return new ResponseContent_default(...args);
    },
    links(...args) {
      return new ResponseLinks_default(...args);
    }
  },
  CallbackElement: {
    "[key: *]": function key3(...args) {
      return new PathItem_default(...args);
    }
  },
  LinkElement: {
    parameters(...args) {
      return new LinkParameters_default(...args);
    },
    server(...args) {
      return new Server_default(...args);
    }
  },
  HeaderElement: {
    schema(...args) {
      return new Schema_default(...args);
    },
    examples(...args) {
      return new HeaderExamples_default(...args);
    },
    content(...args) {
      return new HeaderContent_default(...args);
    }
  },
  ComponentsElement: {
    schemas(...args) {
      return new ComponentsSchemas_default(...args);
    },
    responses(...args) {
      return new ComponentsResponses_default(...args);
    },
    parameters(...args) {
      return new ComponentsParameters_default(...args);
    },
    examples(...args) {
      return new ComponentsExamples_default(...args);
    },
    requestBodies(...args) {
      return new ComponentsRequestBodies_default(...args);
    },
    headers(...args) {
      return new ComponentsHeaders_default(...args);
    },
    securitySchemes(...args) {
      return new ComponentsSecuritySchemes_default(...args);
    },
    links(...args) {
      return new ComponentsLinks_default(...args);
    },
    callbacks(...args) {
      return new ComponentsCallbacks_default(...args);
    }
  },
  SecurityRequirementElement: {
    "[key: *]": function key4(...args) {
      return new import_minim10.ArrayElement(...args);
    }
  },
  TagElement: {
    externalDocs(...args) {
      return new ExternalDocumentation_default(...args);
    }
  },
  SchemaElement: {
    definitions(...args) {
      const element = new import_minim10.ObjectElement(...args);
      element.classes.push("json-schema-definitions");
      return element;
    },
    allOf(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-allOf");
      return element;
    },
    anyOf(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-anyOf");
      return element;
    },
    oneOf(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-oneOf");
      return element;
    },
    not(...args) {
      return new Schema_default(...args);
    },
    items(...args) {
      return new Schema_default(...args);
    },
    properties(...args) {
      const element = new import_minim10.ObjectElement(...args);
      element.classes.push("json-schema-properties");
      return element;
    },
    patternProperties(...args) {
      const element = new import_minim10.ObjectElement(...args);
      element.classes.push("json-schema-patternProperties");
      return element;
    },
    additionalProperties(...args) {
      return new Schema_default(...args);
    },
    enum(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-enum");
      return element;
    },
    required(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-required");
      return element;
    },
    discriminator(...args) {
      return new Discriminator_default(...args);
    },
    xml(...args) {
      return new Xml_default(...args);
    },
    externalDocs(...args) {
      return new ExternalDocumentation_default(...args);
    }
  },
  DiscriminatorElement: {
    mapping(...args) {
      return new DiscriminatorMapping_default(...args);
    }
  },
  SecuritySchemeElement: {
    flows(...args) {
      return new OAuthFlows_default(...args);
    }
  },
  OAuthFlowsElement: {
    implicit(...args) {
      return new OAuthFlow_default(...args);
    },
    password(...args) {
      return new OAuthFlow_default(...args);
    },
    clientCredentials(...args) {
      return new OAuthFlow_default(...args);
    },
    authorizationCode(...args) {
      return new OAuthFlow_default(...args);
    }
  },
  OAuthFlowElement: {
    scopes(...args) {
      return new OAuthFlowScopes_default(...args);
    }
  },
  // non-concrete types handling (NCEs)
  [ServerVariables_default.primaryClass]: {
    "[key: *]": function key5(...args) {
      return new ServerVariable_default(...args);
    }
  },
  [ComponentsSchemas_default.primaryClass]: {
    "[key: *]": function key6(...args) {
      return new Schema_default(...args);
    }
  },
  [ComponentsResponses_default.primaryClass]: {
    "[key: *]": function key7(...args) {
      return new Response_default(...args);
    }
  },
  [ComponentsParameters_default.primaryClass]: {
    "[key: *]": function key8(...args) {
      return new Parameter_default(...args);
    }
  },
  [ComponentsExamples_default.primaryClass]: {
    "[key: *]": function key9(...args) {
      return new Example_default(...args);
    }
  },
  [ComponentsRequestBodies_default.primaryClass]: {
    "[key: *]": function key10(...args) {
      return new RequestBody_default(...args);
    }
  },
  [ComponentsHeaders_default.primaryClass]: {
    "[key: *]": function key11(...args) {
      return new Header_default(...args);
    }
  },
  [ComponentsSecuritySchemes_default.primaryClass]: {
    "[key: *]": function key12(...args) {
      return new SecurityScheme_default(...args);
    }
  },
  [ComponentsLinks_default.primaryClass]: {
    "[key: *]": function key13(...args) {
      return new Link_default(...args);
    }
  },
  [ComponentsCallbacks_default.primaryClass]: {
    "[key: *]": function key14(...args) {
      return new Callback_default(...args);
    }
  },
  [OperationCallbacks_default.primaryClass]: {
    "[key: *]": function key15(...args) {
      return new Callback_default(...args);
    }
  },
  [ParameterExamples_default.primaryClass]: {
    "[key: *]": function key16(...args) {
      return new Example_default(...args);
    }
  },
  [ParameterContent_default.primaryClass]: {
    "[key: *]": function key17(...args) {
      return new MediaType_default(...args);
    }
  },
  [RequestBodyContent_default.primaryClass]: {
    "[key: *]": function key18(...args) {
      return new MediaType_default(...args);
    }
  },
  [MediaTypeExamples_default.primaryClass]: {
    "[key: *]": function key19(...args) {
      return new Example_default(...args);
    }
  },
  [MediaTypeEncoding_default.primaryClass]: {
    "[key: *]": function key20(...args) {
      return new Encoding_default(...args);
    }
  },
  [EncodingHeaders_default.primaryClass]: {
    "[key: *]": function key21(...args) {
      return new Header_default(...args);
    }
  },
  [ResponseHeaders_default.primaryClass]: {
    "[key: *]": function key22(...args) {
      return new Header_default(...args);
    }
  },
  [ResponseContent_default.primaryClass]: {
    "[key: *]": function key23(...args) {
      return new MediaType_default(...args);
    }
  },
  [ResponseLinks_default.primaryClass]: {
    "[key: *]": function key24(...args) {
      return new Link_default(...args);
    }
  },
  "json-schema-$defs": {
    "[key: *]": function key25(...args) {
      return new Schema_default(...args);
    }
  },
  "json-schema-dependentSchemas": {
    "[key: *]": function key26(...args) {
      return new Schema_default(...args);
    }
  },
  "json-schema-properties": {
    "[key: *]": function key27(...args) {
      return new Schema_default(...args);
    }
  },
  [Servers_default.primaryClass]: {
    "<*>": function asterisk(...args) {
      return new Server_default(...args);
    }
  },
  [Security_default.primaryClass]: {
    "<*>": function asterisk2(...args) {
      return new SecurityRequirement_default(...args);
    }
  },
  [Tags_default.primaryClass]: {
    "<*>": function asterisk3(...args) {
      return new Tag_default2(...args);
    }
  },
  [PathItemServers_default.primaryClass]: {
    "<*>": function asterisk4(...args) {
      return new Server_default(...args);
    }
  },
  [PathItemParameters_default.primaryClass]: {
    "<*>": function asterisk5(...args) {
      return new Parameter_default(...args);
    }
  },
  [OperationParameters_default.primaryClass]: {
    "<*>": function asterisk6(...args) {
      return new Parameter_default(...args);
    }
  },
  [OperationSecurity_default.primaryClass]: {
    "<*>": function asterisk7(...args) {
      return new SecurityRequirement_default(...args);
    }
  },
  [OperationServers_default.primaryClass]: {
    "<*>": function asterisk8(...args) {
      return new Server_default(...args);
    }
  },
  "json-schema-allOf": {
    "<*>": function asterisk9(...args) {
      return new Schema_default(...args);
    }
  },
  "json-schema-anyOf": {
    "<*>": function asterisk10(...args) {
      return new Schema_default(...args);
    }
  },
  "json-schema-oneOf": {
    "<*>": function asterisk11(...args) {
      return new Schema_default(...args);
    }
  },
  "json-schema-prefixItems": {
    "<*>": function asterisk12(...args) {
      return new Schema_default(...args);
    }
  }
};

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/Visitor.mjs
var Visitor3 = class {
  constructor(options = {}) {
    __publicField(this, "element");
    Object.assign(this, options);
  }
  /* eslint-disable class-methods-use-this, no-param-reassign */
  copyMetaAndAttributes(from2, to2) {
    if (from2.meta.length > 0 || to2.meta.length > 0) {
      to2.meta = deepmerge_default(to2.meta, from2.meta);
      if (hasElementSourceMap(from2)) {
        to2.meta.set("sourceMap", from2.meta.get("sourceMap"));
      }
    }
    if (from2.attributes.length > 0 || from2.meta.length > 0) {
      to2.attributes = deepmerge_default(to2.attributes, from2.attributes);
    }
  }
  /* eslint-enable class-methods-use-this, no-param-reassign */
};
var Visitor_default2 = Visitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/FallbackVisitor.mjs
var FallbackVisitor2 = class extends Visitor_default2 {
  enter(element) {
    this.element = cloneDeep(element);
    return BREAK;
  }
};
var FallbackVisitor_default2 = FallbackVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/SpecificationVisitor.mjs
var SpecificationVisitor2 = class extends Visitor_default2 {
  constructor({
    specObj,
    passingOptionsNames,
    openApiGenericElement,
    openApiSemanticElement,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "specObj");
    __publicField(this, "passingOptionsNames", ["specObj", "openApiGenericElement", "openApiSemanticElement"]);
    __publicField(this, "openApiGenericElement");
    __publicField(this, "openApiSemanticElement");
    this.specObj = specObj;
    this.openApiGenericElement = openApiGenericElement;
    this.openApiSemanticElement = openApiSemanticElement;
    if (Array.isArray(passingOptionsNames)) {
      this.passingOptionsNames = passingOptionsNames;
    }
  }
  retrievePassingOptions() {
    return pick_default(this.passingOptionsNames, this);
  }
  retrieveFixedFields(specPath) {
    const fixedFields = path_default(["visitors", ...specPath, "fixedFields"], this.specObj);
    if (typeof fixedFields === "object" && fixedFields !== null) {
      return Object.keys(fixedFields);
    }
    return [];
  }
  retrieveVisitor(specPath) {
    if (pathSatisfies_default(isFunction_default, ["visitors", ...specPath], this.specObj)) {
      return path_default(["visitors", ...specPath], this.specObj);
    }
    return path_default(["visitors", ...specPath, "$visitor"], this.specObj);
  }
  retrieveVisitorInstance(specPath, options = {}) {
    const passingOpts = this.retrievePassingOptions();
    const VisitorClz = this.retrieveVisitor(specPath);
    const visitorOpts = {
      ...passingOpts,
      ...options
    };
    return new VisitorClz(visitorOpts);
  }
  toRefractedElement(specPath, element, options = {}) {
    const visitor2 = this.retrieveVisitorInstance(specPath, options);
    if (visitor2 instanceof FallbackVisitor_default2 && (visitor2 === null || visitor2 === void 0 ? void 0 : visitor2.constructor) === FallbackVisitor_default2) {
      return cloneDeep(element);
    }
    visit2(element, visitor2, options);
    return visitor2.element;
  }
};
var SpecificationVisitor_default2 = SpecificationVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/predicates.mjs
var isReferenceLikeElement = (element) => {
  return isObjectElement(element) && element.hasKey("$ref");
};
var isServerLikeElement = isObjectElement;
var isTagLikeElement = isObjectElement;
var isOpenApiExtension = (element) => {
  return isStringElement(element.key) && startsWith_default("x-", value_default(element.key));
};

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/generics/FixedFieldsVisitor.mjs
var FixedFieldsVisitor2 = class extends SpecificationVisitor_default2 {
  constructor({
    specPath,
    ignoredFields,
    canSupportSpecificationExtensions,
    specificationExtensionPredicate,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "specPath");
    __publicField(this, "ignoredFields");
    __publicField(this, "canSupportSpecificationExtensions", true);
    __publicField(this, "specificationExtensionPredicate", isOpenApiExtension);
    this.specPath = specPath;
    this.ignoredFields = ignoredFields || [];
    if (typeof canSupportSpecificationExtensions === "boolean") {
      this.canSupportSpecificationExtensions = canSupportSpecificationExtensions;
    }
    if (typeof specificationExtensionPredicate === "function") {
      this.specificationExtensionPredicate = specificationExtensionPredicate;
    }
  }
  ObjectElement(objectElement) {
    const specPath = this.specPath(objectElement);
    const fields = this.retrieveFixedFields(specPath);
    objectElement.forEach((value, key57, memberElement) => {
      if (isStringElement(key57) && fields.includes(value_default(key57)) && !this.ignoredFields.includes(value_default(key57))) {
        const fixedFieldElement = this.toRefractedElement([...specPath, "fixedFields", value_default(key57)], value);
        const newMemberElement = new import_minim14.MemberElement(cloneDeep(key57), fixedFieldElement);
        this.copyMetaAndAttributes(memberElement, newMemberElement);
        newMemberElement.classes.push("fixed-field");
        this.element.content.push(newMemberElement);
      } else if (this.canSupportSpecificationExtensions && this.specificationExtensionPredicate(memberElement)) {
        const extensionElement = this.toRefractedElement(["document", "extension"], memberElement);
        this.element.content.push(extensionElement);
      } else if (!this.ignoredFields.includes(value_default(key57))) {
        this.element.content.push(cloneDeep(memberElement));
      }
    });
    this.copyMetaAndAttributes(objectElement, this.element);
    return BREAK;
  }
};
var FixedFieldsVisitor_default2 = FixedFieldsVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/index.mjs
var OpenApi3_0Visitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new OpenApi3_0_default();
    this.specPath = always_default(["document", "objects", "OpenApi"]);
    this.canSupportSpecificationExtensions = true;
  }
  ObjectElement(objectElement) {
    return FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
  }
};
var open_api_3_0_default = OpenApi3_0Visitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/OpenapiVisitor.mjs
var OpenapiVisitor = class extends Mixin(SpecificationVisitor_default2, FallbackVisitor_default2) {
  StringElement(stringElement) {
    const openapiElement = new Openapi_default(value_default(stringElement));
    this.copyMetaAndAttributes(stringElement, openapiElement);
    this.element = openapiElement;
    return BREAK;
  }
};
var OpenapiVisitor_default = OpenapiVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/SpecificationExtensionVisitor.mjs
var SpecificationExtensionVisitor = class extends SpecificationVisitor_default2 {
  MemberElement(memberElement) {
    this.element = cloneDeep(memberElement);
    this.element.classes.push("specification-extension");
    return BREAK;
  }
};
var SpecificationExtensionVisitor_default = SpecificationExtensionVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/info/index.mjs
var InfoVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Info_default();
    this.specPath = always_default(["document", "objects", "Info"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var info_default = InfoVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/info/VersionVisitor.mjs
var VersionVisitor = class extends FallbackVisitor_default2 {
  StringElement(stringElement) {
    const result = super.enter(stringElement);
    this.element.classes.push("api-version");
    this.element.classes.push("version");
    return result;
  }
};
var VersionVisitor_default = VersionVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/contact/index.mjs
var ContactVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Contact_default();
    this.specPath = always_default(["document", "objects", "Contact"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var contact_default = ContactVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/license/index.mjs
var LicenseVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new License_default();
    this.specPath = always_default(["document", "objects", "License"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var license_default = LicenseVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/link/index.mjs
var LinkVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Link_default();
    this.specPath = always_default(["document", "objects", "Link"]);
    this.canSupportSpecificationExtensions = true;
  }
  ObjectElement(objectElement) {
    const result = FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    if (isStringElement(this.element.operationId) || isStringElement(this.element.operationRef)) {
      this.element.classes.push("reference-element");
    }
    return result;
  }
};
var link_default = LinkVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/link/OperationRefVisitor.mjs
var OperationRefVisitor = class extends FallbackVisitor_default2 {
  StringElement(stringElement) {
    const result = super.enter(stringElement);
    this.element.classes.push("reference-value");
    return result;
  }
};
var OperationRefVisitor_default = OperationRefVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/link/OperationIdVisitor.mjs
var OperationIdVisitor = class extends FallbackVisitor_default2 {
  StringElement(stringElement) {
    const result = super.enter(stringElement);
    this.element.classes.push("reference-value");
    return result;
  }
};
var OperationIdVisitor_default = OperationIdVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/generics/PatternedFieldsVisitor.mjs
var PatternedFieldsVisitor2 = class extends SpecificationVisitor_default2 {
  constructor({
    specPath,
    ignoredFields,
    fieldPatternPredicate,
    canSupportSpecificationExtensions,
    specificationExtensionPredicate,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "specPath");
    __publicField(this, "ignoredFields");
    __publicField(this, "fieldPatternPredicate", F_default);
    __publicField(this, "canSupportSpecificationExtensions", false);
    __publicField(this, "specificationExtensionPredicate", isOpenApiExtension);
    this.specPath = specPath;
    this.ignoredFields = ignoredFields || [];
    if (typeof fieldPatternPredicate === "function") {
      this.fieldPatternPredicate = fieldPatternPredicate;
    }
    if (typeof canSupportSpecificationExtensions === "boolean") {
      this.canSupportSpecificationExtensions = canSupportSpecificationExtensions;
    }
    if (typeof specificationExtensionPredicate === "function") {
      this.specificationExtensionPredicate = specificationExtensionPredicate;
    }
  }
  ObjectElement(objectElement) {
    objectElement.forEach((value, key57, memberElement) => {
      if (this.canSupportSpecificationExtensions && this.specificationExtensionPredicate(memberElement)) {
        const extensionElement = this.toRefractedElement(["document", "extension"], memberElement);
        this.element.content.push(extensionElement);
      } else if (!this.ignoredFields.includes(value_default(key57)) && this.fieldPatternPredicate(value_default(key57))) {
        const specPath = this.specPath(value);
        const patternedFieldElement = this.toRefractedElement(specPath, value);
        const newMemberElement = new import_minim14.MemberElement(cloneDeep(key57), patternedFieldElement);
        this.copyMetaAndAttributes(memberElement, newMemberElement);
        newMemberElement.classes.push("patterned-field");
        this.element.content.push(newMemberElement);
      } else if (!this.ignoredFields.includes(value_default(key57))) {
        this.element.content.push(cloneDeep(memberElement));
      }
    });
    this.copyMetaAndAttributes(objectElement, this.element);
    return BREAK;
  }
};
var PatternedFieldsVisitor_default2 = PatternedFieldsVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/generics/MapVisitor.mjs
var MapVisitor2 = class extends PatternedFieldsVisitor_default2 {
  constructor(options) {
    super(options);
    this.fieldPatternPredicate = isNonEmptyString_default;
  }
};
var MapVisitor_default2 = MapVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/link/ParametersVisitor.mjs
var ParametersVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new LinkParameters_default();
    this.specPath = always_default(["value"]);
  }
};
var ParametersVisitor_default = ParametersVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/server/index.mjs
var ServerVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Server_default();
    this.specPath = always_default(["document", "objects", "Server"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var server_default = ServerVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/server/UrlVisitor.mjs
var UrlVisitor = class extends FallbackVisitor_default2 {
  StringElement(stringElement) {
    const result = super.enter(stringElement);
    this.element.classes.push("server-url");
    return result;
  }
};
var UrlVisitor_default = UrlVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/ServersVisitor.mjs
var ServersVisitor = class extends Mixin(SpecificationVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Servers_default();
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      const specPath = isServerLikeElement(item) ? ["document", "objects", "Server"] : ["value"];
      const element = this.toRefractedElement(specPath, item);
      this.element.push(element);
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var ServersVisitor_default = ServersVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/server-variable/index.mjs
var ServerVariableVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ServerVariable_default();
    this.specPath = always_default(["document", "objects", "ServerVariable"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var server_variable_default = ServerVariableVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/server/VariablesVisitor.mjs
var VariablesVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ServerVariables_default();
    this.specPath = always_default(["document", "objects", "ServerVariable"]);
  }
};
var VariablesVisitor_default = VariablesVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/media-type/index.mjs
var MediaTypeVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new MediaType_default();
    this.specPath = always_default(["document", "objects", "MediaType"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var media_type_default = MediaTypeVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/generics/AlternatingVisitor.mjs
var AlternatingVisitor2 = class extends SpecificationVisitor_default2 {
  constructor({
    alternator,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "alternator");
    this.alternator = alternator || [];
  }
  enter(element) {
    const functions = this.alternator.map(({
      predicate,
      specPath: specPath2
    }) => ifElse_default(predicate, always_default(specPath2), stubUndefined_default));
    const specPath = dispatch_default(functions)(element);
    this.element = this.toRefractedElement(specPath, element);
    return BREAK;
  }
};
var AlternatingVisitor_default2 = AlternatingVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/predicates.mjs
var predicates_exports3 = {};
__export(predicates_exports3, {
  isBooleanJsonSchemaElement: () => isBooleanJsonSchemaElement,
  isCallbackElement: () => isCallbackElement,
  isComponentsElement: () => isComponentsElement,
  isContactElement: () => isContactElement,
  isExampleElement: () => isExampleElement,
  isExternalDocumentationElement: () => isExternalDocumentationElement,
  isHeaderElement: () => isHeaderElement,
  isInfoElement: () => isInfoElement,
  isLicenseElement: () => isLicenseElement,
  isLinkElement: () => isLinkElement2,
  isMediaTypeElement: () => isMediaTypeElement,
  isOpenApi3_0Element: () => isOpenApi3_0Element,
  isOpenapiElement: () => isOpenapiElement,
  isOperationElement: () => isOperationElement,
  isParameterElement: () => isParameterElement,
  isPathItemElement: () => isPathItemElement,
  isPathsElement: () => isPathsElement,
  isReferenceElement: () => isReferenceElement,
  isRequestBodyElement: () => isRequestBodyElement,
  isResponseElement: () => isResponseElement,
  isResponsesElement: () => isResponsesElement,
  isSchemaElement: () => isSchemaElement,
  isSecurityRequirementElement: () => isSecurityRequirementElement,
  isSecuritySchemeElement: () => isSecuritySchemeElement,
  isServerElement: () => isServerElement,
  isServerVariableElement: () => isServerVariableElement,
  isServersElement: () => isServersElement
});
var isCallbackElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Callback_default || hasBasicElementProps2(element) && isElementType2("callback", element) && primitiveEq2("object", element);
});
var isComponentsElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Components_default || hasBasicElementProps2(element) && isElementType2("components", element) && primitiveEq2("object", element);
});
var isContactElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Contact_default || hasBasicElementProps2(element) && isElementType2("contact", element) && primitiveEq2("object", element);
});
var isExampleElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Example_default || hasBasicElementProps2(element) && isElementType2("example", element) && primitiveEq2("object", element);
});
var isExternalDocumentationElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof ExternalDocumentation_default || hasBasicElementProps2(element) && isElementType2("externalDocumentation", element) && primitiveEq2("object", element);
});
var isHeaderElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Header_default || hasBasicElementProps2(element) && isElementType2("header", element) && primitiveEq2("object", element);
});
var isInfoElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Info_default || hasBasicElementProps2(element) && isElementType2("info", element) && primitiveEq2("object", element);
});
var isLicenseElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof License_default || hasBasicElementProps2(element) && isElementType2("license", element) && primitiveEq2("object", element);
});
var isLinkElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Link_default || hasBasicElementProps2(element) && isElementType2("link", element) && primitiveEq2("object", element);
});
var isOpenapiElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Openapi_default || hasBasicElementProps2(element) && isElementType2("openapi", element) && primitiveEq2("string", element);
});
var isOpenApi3_0Element = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2,
  hasClass: hasClass2
}) => {
  return (element) => element instanceof OpenApi3_0_default || hasBasicElementProps2(element) && isElementType2("openApi3_0", element) && primitiveEq2("object", element) && hasClass2("api", element);
});
var isOperationElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Operation_default || hasBasicElementProps2(element) && isElementType2("operation", element) && primitiveEq2("object", element);
});
var isParameterElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Parameter_default || hasBasicElementProps2(element) && isElementType2("parameter", element) && primitiveEq2("object", element);
});
var isPathItemElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof PathItem_default || hasBasicElementProps2(element) && isElementType2("pathItem", element) && primitiveEq2("object", element);
});
var isPathsElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Paths_default || hasBasicElementProps2(element) && isElementType2("paths", element) && primitiveEq2("object", element);
});
var isReferenceElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Reference_default2 || hasBasicElementProps2(element) && isElementType2("reference", element) && primitiveEq2("object", element);
});
var isRequestBodyElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof RequestBody_default || hasBasicElementProps2(element) && isElementType2("requestBody", element) && primitiveEq2("object", element);
});
var isResponseElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Response_default || hasBasicElementProps2(element) && isElementType2("response", element) && primitiveEq2("object", element);
});
var isResponsesElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Responses_default || hasBasicElementProps2(element) && isElementType2("responses", element) && primitiveEq2("object", element);
});
var isSchemaElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Schema_default || hasBasicElementProps2(element) && isElementType2("schema", element) && primitiveEq2("object", element);
});
var isBooleanJsonSchemaElement = (element) => {
  return isBooleanElement(element) && element.classes.includes("boolean-json-schema");
};
var isSecurityRequirementElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof SecurityRequirement_default || hasBasicElementProps2(element) && isElementType2("securityRequirement", element) && primitiveEq2("object", element);
});
var isSecuritySchemeElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof SecurityScheme_default || hasBasicElementProps2(element) && isElementType2("securityScheme", element) && primitiveEq2("object", element);
});
var isServerElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Server_default || hasBasicElementProps2(element) && isElementType2("server", element) && primitiveEq2("object", element);
});
var isServerVariableElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof ServerVariable_default || hasBasicElementProps2(element) && isElementType2("serverVariable", element) && primitiveEq2("object", element);
});
var isMediaTypeElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof MediaType_default || hasBasicElementProps2(element) && isElementType2("mediaType", element) && primitiveEq2("object", element);
});
var isServersElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2,
  hasClass: hasClass2
}) => {
  return (element) => element instanceof Servers_default || hasBasicElementProps2(element) && isElementType2("array", element) && primitiveEq2("array", element) && hasClass2("servers", element);
});

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/media-type/SchemaVisitor.mjs
var SchemaVisitor = class extends Mixin(AlternatingVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.alternator = [{
      predicate: isReferenceLikeElement,
      specPath: ["document", "objects", "Reference"]
    }, {
      predicate: T_default,
      specPath: ["document", "objects", "Schema"]
    }];
  }
  ObjectElement(objectElement) {
    const result = AlternatingVisitor_default2.prototype.enter.call(this, objectElement);
    if (isReferenceElement(this.element)) {
      this.element.setMetaProperty("referenced-element", "schema");
    }
    return result;
  }
};
var SchemaVisitor_default = SchemaVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/ExamplesVisitor.mjs
var ExamplesVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("examples");
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Example"];
    this.canSupportSpecificationExtensions = true;
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "example");
    });
    return result;
  }
};
var ExamplesVisitor_default = ExamplesVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/media-type/ExamplesVisitor.mjs
var ExamplesVisitor2 = class extends ExamplesVisitor_default {
  constructor(options) {
    super(options);
    this.element = new MediaTypeExamples_default();
  }
};
var ExamplesVisitor_default2 = ExamplesVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/media-type/EncodingVisitor.mjs
var EncodingVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new MediaTypeEncoding_default();
    this.specPath = always_default(["document", "objects", "Encoding"]);
  }
};
var EncodingVisitor_default = EncodingVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/security-requirement/index.mjs
var SecurityRequirementVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new SecurityRequirement_default();
    this.specPath = always_default(["value"]);
  }
};
var security_requirement_default = SecurityRequirementVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/SecurityVisitor.mjs
var SecurityVisitor = class extends Mixin(SpecificationVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Security_default();
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      if (isObjectElement(item)) {
        const element = this.toRefractedElement(["document", "objects", "SecurityRequirement"], item);
        this.element.push(element);
      } else {
        this.element.push(cloneDeep(item));
      }
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var SecurityVisitor_default = SecurityVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/index.mjs
var ComponentsVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Components_default();
    this.specPath = always_default(["document", "objects", "Components"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var components_default = ComponentsVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/tag/index.mjs
var TagVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Tag_default2();
    this.specPath = always_default(["document", "objects", "Tag"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var tag_default = TagVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/reference/index.mjs
var ReferenceVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Reference_default2();
    this.specPath = always_default(["document", "objects", "Reference"]);
    this.canSupportSpecificationExtensions = false;
  }
  ObjectElement(objectElement) {
    const result = FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    if (isStringElement(this.element.$ref)) {
      this.element.classes.push("reference-element");
    }
    return result;
  }
};
var reference_default = ReferenceVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/reference/$RefVisitor.mjs
var $RefVisitor2 = class extends FallbackVisitor_default2 {
  StringElement(stringElement) {
    const result = super.enter(stringElement);
    this.element.classes.push("reference-value");
    return result;
  }
};
var RefVisitor_default2 = $RefVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/parameter/index.mjs
var ParameterVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Parameter_default();
    this.specPath = always_default(["document", "objects", "Parameter"]);
    this.canSupportSpecificationExtensions = true;
  }
  ObjectElement(objectElement) {
    const result = FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    if (isObjectElement(this.element.contentProp)) {
      this.element.contentProp.filter(isMediaTypeElement).forEach((mediaTypeElement, key57) => {
        mediaTypeElement.setMetaProperty("media-type", value_default(key57));
      });
    }
    return result;
  }
};
var parameter_default = ParameterVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/parameter/SchemaVisitor.mjs
var SchemaVisitor2 = class extends Mixin(AlternatingVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.alternator = [{
      predicate: isReferenceLikeElement,
      specPath: ["document", "objects", "Reference"]
    }, {
      predicate: T_default,
      specPath: ["document", "objects", "Schema"]
    }];
  }
  ObjectElement(objectElement) {
    const result = AlternatingVisitor_default2.prototype.enter.call(this, objectElement);
    if (isReferenceElement(this.element)) {
      this.element.setMetaProperty("referenced-element", "schema");
    }
    return result;
  }
};
var SchemaVisitor_default2 = SchemaVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/header/index.mjs
var HeaderVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Header_default();
    this.specPath = always_default(["document", "objects", "Header"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var header_default = HeaderVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/header/SchemaVisitor.mjs
var SchemaVisitor3 = class extends Mixin(AlternatingVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.alternator = [{
      predicate: isReferenceLikeElement,
      specPath: ["document", "objects", "Reference"]
    }, {
      predicate: T_default,
      specPath: ["document", "objects", "Schema"]
    }];
  }
  ObjectElement(objectElement) {
    const result = AlternatingVisitor_default2.prototype.enter.call(this, objectElement);
    if (isReferenceElement(this.element)) {
      this.element.setMetaProperty("referenced-element", "schema");
    }
    return result;
  }
};
var SchemaVisitor_default3 = SchemaVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/header/ExamplesVisitor.mjs
var ExamplesVisitor3 = class extends ExamplesVisitor_default {
  constructor(options) {
    super(options);
    this.element = new HeaderExamples_default();
  }
};
var ExamplesVisitor_default3 = ExamplesVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/ContentVisitor.mjs
var ContentVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("content");
    this.specPath = always_default(["document", "objects", "MediaType"]);
  }
};
var ContentVisitor_default = ContentVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/header/ContentVisitor.mjs
var ContentVisitor2 = class extends ContentVisitor_default {
  constructor(options) {
    super(options);
    this.element = new HeaderContent_default();
  }
};
var ContentVisitor_default2 = ContentVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/schema/index.mjs
var SchemaVisitor4 = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Schema_default();
    this.specPath = always_default(["document", "objects", "Schema"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var schema_default = SchemaVisitor4;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/schema/AllOfVisitor.mjs
var JSONSchemaAllOfVisitor = specification_default.visitors.document.objects.JSONSchema.fixedFields.allOf;
var AllOfVisitor2 = class extends JSONSchemaAllOfVisitor {
  ArrayElement(arrayElement) {
    const result = JSONSchemaAllOfVisitor.prototype.ArrayElement.call(this, arrayElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "schema");
    });
    return result;
  }
};
var AllOfVisitor_default2 = AllOfVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/schema/AnyOfVisitor.mjs
var JSONSchemaAnyOfVisitor = specification_default.visitors.document.objects.JSONSchema.fixedFields.anyOf;
var AnyOfVisitor2 = class extends JSONSchemaAnyOfVisitor {
  ArrayElement(arrayElement) {
    const result = JSONSchemaAnyOfVisitor.prototype.ArrayElement.call(this, arrayElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "schema");
    });
    return result;
  }
};
var AnyOfVisitor_default2 = AnyOfVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/schema/OneOfVisitor.mjs
var JSONSchemaOneOfVisitor = specification_default.visitors.document.objects.JSONSchema.fixedFields.oneOf;
var OneOfVisitor2 = class extends JSONSchemaOneOfVisitor {
  ArrayElement(arrayElement) {
    const result = JSONSchemaOneOfVisitor.prototype.ArrayElement.call(this, arrayElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "schema");
    });
    return result;
  }
};
var OneOfVisitor_default2 = OneOfVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/schema/ItemsVisitor.mjs
var JSONSchemaItemsVisitor = specification_default.visitors.document.objects.JSONSchema.fixedFields.items;
var ItemsVisitor2 = class extends JSONSchemaItemsVisitor {
  ObjectElement(objectElement) {
    const result = JSONSchemaItemsVisitor.prototype.ObjectElement.call(this, objectElement);
    if (isReferenceElement(this.element)) {
      this.element.setMetaProperty("referenced-element", "schema");
    }
    return result;
  }
  ArrayElement(arrayElement) {
    const result = this.enter(arrayElement);
    return result;
  }
};
var ItemsVisitor_default2 = ItemsVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/schema/PropertiesVisitor.mjs
var JSONSchemaPropertiesVisitor = specification_default.visitors.document.objects.JSONSchema.fixedFields.properties;
var PropertiesVisitor2 = class extends JSONSchemaPropertiesVisitor {
  ObjectElement(objectElement) {
    const result = JSONSchemaPropertiesVisitor.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "schema");
    });
    return result;
  }
};
var PropertiesVisitor_default2 = PropertiesVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/schema/TypeVisitor.mjs
var JSONSchemaTypeVisitor = specification_default.visitors.document.objects.JSONSchema.fixedFields.type;
var TypeVisitor2 = class extends JSONSchemaTypeVisitor {
  ArrayElement(arrayElement) {
    const result = this.enter(arrayElement);
    return result;
  }
};
var TypeVisitor_default2 = TypeVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/schema/SchemaOrReferenceVisitor.mjs
var JSONSchemaOrJSONReferenceVisitor = specification_default.visitors.JSONSchemaOrJSONReferenceVisitor;
var SchemaOrReferenceVisitor2 = class extends JSONSchemaOrJSONReferenceVisitor {
  ObjectElement(objectElement) {
    const result = JSONSchemaOrJSONReferenceVisitor.prototype.enter.call(this, objectElement);
    if (isReferenceElement(this.element)) {
      this.element.setMetaProperty("referenced-element", "schema");
    }
    return result;
  }
};
var SchemaOrReferenceVisitor_default = SchemaOrReferenceVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/distriminator/index.mjs
var DiscriminatorVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Discriminator_default();
    this.specPath = always_default(["document", "objects", "Discriminator"]);
    this.canSupportSpecificationExtensions = false;
  }
};
var distriminator_default = DiscriminatorVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/distriminator/MappingVisitor.mjs
var MappingVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new DiscriminatorMapping_default();
    this.specPath = always_default(["value"]);
  }
};
var MappingVisitor_default = MappingVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/xml/index.mjs
var XmlVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Xml_default();
    this.specPath = always_default(["document", "objects", "XML"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var xml_default = XmlVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/parameter/ExamplesVisitor.mjs
var ExamplesVisitor4 = class extends ExamplesVisitor_default {
  constructor(options) {
    super(options);
    this.element = new ParameterExamples_default();
  }
};
var ExamplesVisitor_default4 = ExamplesVisitor4;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/parameter/ContentVisitor.mjs
var ContentVisitor3 = class extends ContentVisitor_default {
  constructor(options) {
    super(options);
    this.element = new ParameterContent_default();
  }
};
var ContentVisitor_default3 = ContentVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/SchemasVisitor.mjs
var SchemasVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsSchemas_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Schema"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "schema");
    });
    return result;
  }
};
var SchemasVisitor_default = SchemasVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/ResponsesVisitor.mjs
var ResponsesVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsResponses_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Response"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "response");
    });
    this.element.filter(isResponseElement).forEach((value, key57) => {
      value.setMetaProperty("http-status-code", value_default(key57));
    });
    return result;
  }
};
var ResponsesVisitor_default = ResponsesVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/ParametersVisitor.mjs
var ParametersVisitor2 = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsParameters_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Parameter"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "parameter");
    });
    return result;
  }
};
var ParametersVisitor_default2 = ParametersVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/ExamplesVisitor.mjs
var ExamplesVisitor5 = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsExamples_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Example"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "example");
    });
    return result;
  }
};
var ExamplesVisitor_default5 = ExamplesVisitor5;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/RequestBodiesVisitor.mjs
var RequestBodiesVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsRequestBodies_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "RequestBody"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "requestBody");
    });
    return result;
  }
};
var RequestBodiesVisitor_default = RequestBodiesVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/HeadersVisitor.mjs
var HeadersVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsHeaders_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Header"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "header");
    });
    this.element.filter(isHeaderElement).forEach((value, key57) => {
      value.setMetaProperty("header-name", value_default(key57));
    });
    return result;
  }
};
var HeadersVisitor_default = HeadersVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/SecuritySchemesVisitor.mjs
var SecuritySchemesVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsSecuritySchemes_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "SecurityScheme"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "securityScheme");
    });
    return result;
  }
};
var SecuritySchemesVisitor_default = SecuritySchemesVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/LinksVisitor.mjs
var LinksVisitor2 = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsLinks_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Link"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "link");
    });
    return result;
  }
};
var LinksVisitor_default2 = LinksVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/components/CallbacksVisitor.mjs
var CallbacksVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsCallbacks_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Callback"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "callback");
    });
    return result;
  }
};
var CallbacksVisitor_default = CallbacksVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/example/index.mjs
var ExampleVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Example_default();
    this.specPath = always_default(["document", "objects", "Example"]);
    this.canSupportSpecificationExtensions = true;
  }
  ObjectElement(objectElement) {
    const result = FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    if (isStringElement(this.element.externalValue)) {
      this.element.classes.push("reference-element");
    }
    return result;
  }
};
var example_default = ExampleVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/example/ExternalValueVisitor.mjs
var ExternalValueVisitor = class extends FallbackVisitor_default2 {
  StringElement(stringElement) {
    const result = super.enter(stringElement);
    this.element.classes.push("reference-value");
    return result;
  }
};
var ExternalValueVisitor_default = ExternalValueVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/external-documentation/index.mjs
var ExternalDocumentationVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ExternalDocumentation_default();
    this.specPath = always_default(["document", "objects", "ExternalDocumentation"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var external_documentation_default = ExternalDocumentationVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/encoding/index.mjs
var EncodingVisitor2 = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Encoding_default();
    this.specPath = always_default(["document", "objects", "Encoding"]);
    this.canSupportSpecificationExtensions = true;
  }
  ObjectElement(objectElement) {
    const result = FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    if (isObjectElement(this.element.headers)) {
      this.element.headers.filter(isHeaderElement).forEach((headerElement, key57) => {
        headerElement.setMetaProperty("header-name", value_default(key57));
      });
    }
    return result;
  }
};
var encoding_default = EncodingVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/encoding/HeadersVisitor.mjs
var HeadersVisitor2 = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new EncodingHeaders_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Header"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "header");
    });
    this.element.forEach((value, key57) => {
      if (!isHeaderElement(value)) return;
      const headerName = value_default(key57);
      value.setMetaProperty("headerName", headerName);
    });
    return result;
  }
};
var HeadersVisitor_default2 = HeadersVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/paths/index.mjs
var PathsVisitor = class extends Mixin(PatternedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Paths_default();
    this.specPath = always_default(["document", "objects", "PathItem"]);
    this.canSupportSpecificationExtensions = true;
    this.fieldPatternPredicate = T_default;
  }
  ObjectElement(objectElement) {
    const result = PatternedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isPathItemElement).forEach((pathItemElement, key57) => {
      key57.classes.push("openapi-path-template");
      key57.classes.push("path-template");
      pathItemElement.setMetaProperty("path", cloneDeep(key57));
    });
    return result;
  }
};
var paths_default3 = PathsVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/request-body/index.mjs
var RequestBodyVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new RequestBody_default();
    this.specPath = always_default(["document", "objects", "RequestBody"]);
  }
  ObjectElement(objectElement) {
    const result = FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    if (isObjectElement(this.element.contentProp)) {
      this.element.contentProp.filter(isMediaTypeElement).forEach((mediaTypeElement, key57) => {
        mediaTypeElement.setMetaProperty("media-type", value_default(key57));
      });
    }
    return result;
  }
};
var request_body_default = RequestBodyVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/request-body/ContentVisitor.mjs
var ContentVisitor4 = class extends ContentVisitor_default {
  constructor(options) {
    super(options);
    this.element = new RequestBodyContent_default();
  }
};
var ContentVisitor_default4 = ContentVisitor4;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/callback/index.mjs
var CallbackVisitor = class extends Mixin(PatternedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Callback_default();
    this.specPath = always_default(["document", "objects", "PathItem"]);
    this.canSupportSpecificationExtensions = true;
    this.fieldPatternPredicate = (value) => /{(?<expression>[^}]{1,2083})}/.test(String(value));
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isPathItemElement).forEach((pathItemElement, key57) => {
      pathItemElement.setMetaProperty("runtime-expression", value_default(key57));
    });
    return result;
  }
};
var callback_default = CallbackVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/response/index.mjs
var ResponseVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Response_default();
    this.specPath = always_default(["document", "objects", "Response"]);
  }
  ObjectElement(objectElement) {
    const result = FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    if (isObjectElement(this.element.contentProp)) {
      this.element.contentProp.filter(isMediaTypeElement).forEach((mediaTypeElement, key57) => {
        mediaTypeElement.setMetaProperty("media-type", value_default(key57));
      });
    }
    if (isObjectElement(this.element.headers)) {
      this.element.headers.filter(isHeaderElement).forEach((headerElement, key57) => {
        headerElement.setMetaProperty("header-name", value_default(key57));
      });
    }
    return result;
  }
};
var response_default = ResponseVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/response/HeadersVisitor.mjs
var HeadersVisitor3 = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ResponseHeaders_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Header"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "header");
    });
    this.element.forEach((value, key57) => {
      if (!isHeaderElement(value)) return;
      const headerName = value_default(key57);
      value.setMetaProperty("header-name", headerName);
    });
    return result;
  }
};
var HeadersVisitor_default3 = HeadersVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/response/ContentVisitor.mjs
var ContentVisitor5 = class extends ContentVisitor_default {
  constructor(options) {
    super(options);
    this.element = new ResponseContent_default();
  }
};
var ContentVisitor_default5 = ContentVisitor5;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/response/LinksVisitor.mjs
var LinksVisitor3 = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ResponseLinks_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Link"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "link");
    });
    return result;
  }
};
var LinksVisitor_default3 = LinksVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/generics/MixedFieldsVisitor.mjs
var MixedFieldsVisitor = class extends Mixin(FixedFieldsVisitor_default2, PatternedFieldsVisitor_default2) {
  constructor({
    specPathFixedFields,
    specPathPatternedFields,
    ...rest
  }) {
    super({
      ...rest
    });
    __publicField(this, "specPathFixedFields");
    __publicField(this, "specPathPatternedFields");
    this.specPathFixedFields = specPathFixedFields;
    this.specPathPatternedFields = specPathPatternedFields;
  }
  ObjectElement(objectElement) {
    const {
      specPath,
      ignoredFields
    } = this;
    try {
      this.specPath = this.specPathFixedFields;
      const fixedFields = this.retrieveFixedFields(this.specPath(objectElement));
      this.ignoredFields = [...ignoredFields, ...difference_default(objectElement.keys(), fixedFields)];
      FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
      this.specPath = this.specPathPatternedFields;
      this.ignoredFields = fixedFields;
      PatternedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    } catch (e2) {
      this.specPath = specPath;
      throw e2;
    }
    return BREAK;
  }
};
var MixedFieldsVisitor_default = MixedFieldsVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/responses/index.mjs
var ResponsesVisitor2 = class extends Mixin(MixedFieldsVisitor_default, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Responses_default();
    this.specPathFixedFields = always_default(["document", "objects", "Responses"]);
    this.canSupportSpecificationExtensions = true;
    this.specPathPatternedFields = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Response"];
    this.fieldPatternPredicate = (value) => new RegExp(`^(1XX|2XX|3XX|4XX|5XX|${range_default(100, 600).join("|")})$`).test(String(value));
  }
  ObjectElement(objectElement) {
    const result = MixedFieldsVisitor_default.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "response");
    });
    this.element.filter(isResponseElement).forEach((value, key57) => {
      const httpStatusCode = cloneDeep(key57);
      if (!this.fieldPatternPredicate(value_default(httpStatusCode))) return;
      value.setMetaProperty("http-status-code", httpStatusCode);
    });
    return result;
  }
};
var responses_default = ResponsesVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/responses/DefaultVisitor.mjs
var DefaultVisitor = class extends Mixin(AlternatingVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.alternator = [{
      predicate: isReferenceLikeElement,
      specPath: ["document", "objects", "Reference"]
    }, {
      predicate: T_default,
      specPath: ["document", "objects", "Response"]
    }];
  }
  ObjectElement(objectElement) {
    const result = AlternatingVisitor_default2.prototype.enter.call(this, objectElement);
    if (isReferenceElement(this.element)) {
      this.element.setMetaProperty("referenced-element", "response");
    } else if (isResponseElement(this.element)) {
      this.element.setMetaProperty("http-status-code", "default");
    }
    return result;
  }
};
var DefaultVisitor_default = DefaultVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/operation/index.mjs
var OperationVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Operation_default();
    this.specPath = always_default(["document", "objects", "Operation"]);
  }
};
var operation_default = OperationVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/operation/TagsVisitor.mjs
var TagsVisitor = class extends FallbackVisitor_default2 {
  constructor(options) {
    super(options);
    this.element = new OperationTags_default();
  }
  ArrayElement(arrayElement) {
    this.element = this.element.concat(cloneDeep(arrayElement));
    return BREAK;
  }
};
var TagsVisitor_default = TagsVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/ParametersVisitor.mjs
var ParametersVisitor3 = class extends Mixin(SpecificationVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("parameters");
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      const specPath = isReferenceLikeElement(item) ? ["document", "objects", "Reference"] : ["document", "objects", "Parameter"];
      const element = this.toRefractedElement(specPath, item);
      if (isReferenceElement(element)) {
        element.setMetaProperty("referenced-element", "parameter");
      }
      this.element.push(element);
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var ParametersVisitor_default3 = ParametersVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/operation/ParametersVisitor.mjs
var ParametersVisitor4 = class extends ParametersVisitor_default3 {
  constructor(options) {
    super(options);
    this.element = new OperationParameters_default();
  }
};
var ParametersVisitor_default4 = ParametersVisitor4;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/operation/RequestBodyVisitor.mjs
var RequestBodyVisitor2 = class extends AlternatingVisitor_default2 {
  constructor(options) {
    super(options);
    this.alternator = [{
      predicate: isReferenceLikeElement,
      specPath: ["document", "objects", "Reference"]
    }, {
      predicate: T_default,
      specPath: ["document", "objects", "RequestBody"]
    }];
  }
  ObjectElement(objectElement) {
    const result = AlternatingVisitor_default2.prototype.enter.call(this, objectElement);
    if (isReferenceElement(this.element)) {
      this.element.setMetaProperty("referenced-element", "requestBody");
    }
    return result;
  }
};
var RequestBodyVisitor_default = RequestBodyVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/operation/CallbacksVisitor.mjs
var CallbacksVisitor2 = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    __publicField(this, "specPath");
    this.element = new OperationCallbacks_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "Callback"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "callback");
    });
    return result;
  }
};
var CallbacksVisitor_default2 = CallbacksVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/operation/SecurityVisitor.mjs
var SecurityVisitor2 = class extends Mixin(SpecificationVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new OperationSecurity_default();
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      const specPath = isObjectElement(item) ? ["document", "objects", "SecurityRequirement"] : ["value"];
      const element = this.toRefractedElement(specPath, item);
      this.element.push(element);
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var SecurityVisitor_default2 = SecurityVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/operation/ServersVisitor.mjs
var ServersVisitor2 = class extends ServersVisitor_default {
  constructor(options) {
    super(options);
    this.element = new OperationServers_default();
  }
};
var ServersVisitor_default2 = ServersVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/path-item/index.mjs
var PathItemVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new PathItem_default();
    this.specPath = always_default(["document", "objects", "PathItem"]);
  }
  ObjectElement(objectElement) {
    const result = FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isOperationElement).forEach((operationElement, httpMethodElementCI) => {
      const httpMethodElementCS = cloneDeep(httpMethodElementCI);
      httpMethodElementCS.content = value_default(httpMethodElementCS).toUpperCase();
      operationElement.setMetaProperty("http-method", httpMethodElementCS);
    });
    if (isStringElement(this.element.$ref)) {
      this.element.classes.push("reference-element");
    }
    return result;
  }
};
var path_item_default = PathItemVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/path-item/$RefVisitor.mjs
var $RefVisitor3 = class extends FallbackVisitor_default2 {
  StringElement(stringElement) {
    const result = super.enter(stringElement);
    this.element.classes.push("reference-value");
    return result;
  }
};
var RefVisitor_default3 = $RefVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/path-item/ServersVisitor.mjs
var ServersVisitor3 = class extends ServersVisitor_default {
  constructor(options) {
    super(options);
    this.element = new PathItemServers_default();
  }
};
var ServersVisitor_default3 = ServersVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/path-item/ParametersVisitor.mjs
var ParametersVisitor5 = class extends ParametersVisitor_default3 {
  constructor(options) {
    super(options);
    this.element = new PathItemParameters_default();
  }
};
var ParametersVisitor_default5 = ParametersVisitor5;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/security-scheme/index.mjs
var SecuritySchemeVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new SecurityScheme_default();
    this.specPath = always_default(["document", "objects", "SecurityScheme"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var security_scheme_default = SecuritySchemeVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/oauth-flows/index.mjs
var OAuthFlowsVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new OAuthFlows_default();
    this.specPath = always_default(["document", "objects", "OAuthFlows"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var oauth_flows_default = OAuthFlowsVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/oauth-flow/index.mjs
var OAuthFlowVisitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new OAuthFlow_default();
    this.specPath = always_default(["document", "objects", "OAuthFlow"]);
    this.canSupportSpecificationExtensions = true;
  }
};
var oauth_flow_default = OAuthFlowVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/oauth-flow/ScopesVisitor.mjs
var ScopesVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new OAuthFlowScopes_default();
    this.specPath = always_default(["value"]);
  }
};
var ScopesVisitor_default = ScopesVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/visitors/open-api-3-0/TagsVisitor.mjs
var TagsVisitor2 = class extends Mixin(SpecificationVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Tags_default();
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      const specPath = isTagLikeElement(item) ? ["document", "objects", "Tag"] : ["value"];
      const element = this.toRefractedElement(specPath, item);
      this.element.push(element);
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var TagsVisitor_default2 = TagsVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/specification.mjs
var {
  fixedFields: jsonSchemaFixedFields
} = specification_default.visitors.document.objects.JSONSchema;
var specification2 = {
  visitors: {
    value: FallbackVisitor_default2,
    document: {
      objects: {
        OpenApi: {
          $visitor: open_api_3_0_default,
          fixedFields: {
            openapi: OpenapiVisitor_default,
            info: {
              $ref: "#/visitors/document/objects/Info"
            },
            servers: ServersVisitor_default,
            paths: {
              $ref: "#/visitors/document/objects/Paths"
            },
            components: {
              $ref: "#/visitors/document/objects/Components"
            },
            security: SecurityVisitor_default,
            tags: TagsVisitor_default2,
            externalDocs: {
              $ref: "#/visitors/document/objects/ExternalDocumentation"
            }
          }
        },
        Info: {
          $visitor: info_default,
          fixedFields: {
            title: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            termsOfService: {
              $ref: "#/visitors/value"
            },
            contact: {
              $ref: "#/visitors/document/objects/Contact"
            },
            license: {
              $ref: "#/visitors/document/objects/License"
            },
            version: VersionVisitor_default
          }
        },
        Contact: {
          $visitor: contact_default,
          fixedFields: {
            name: {
              $ref: "#/visitors/value"
            },
            url: {
              $ref: "#/visitors/value"
            },
            email: {
              $ref: "#/visitors/value"
            }
          }
        },
        License: {
          $visitor: license_default,
          fixedFields: {
            name: {
              $ref: "#/visitors/value"
            },
            url: {
              $ref: "#/visitors/value"
            }
          }
        },
        Server: {
          $visitor: server_default,
          fixedFields: {
            url: UrlVisitor_default,
            description: {
              $ref: "#/visitors/value"
            },
            variables: VariablesVisitor_default
          }
        },
        ServerVariable: {
          $visitor: server_variable_default,
          fixedFields: {
            enum: {
              $ref: "#/visitors/value"
            },
            default: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            }
          }
        },
        Components: {
          $visitor: components_default,
          fixedFields: {
            schemas: SchemasVisitor_default,
            responses: ResponsesVisitor_default,
            parameters: ParametersVisitor_default2,
            examples: ExamplesVisitor_default5,
            requestBodies: RequestBodiesVisitor_default,
            headers: HeadersVisitor_default,
            securitySchemes: SecuritySchemesVisitor_default,
            links: LinksVisitor_default2,
            callbacks: CallbacksVisitor_default
          }
        },
        Paths: {
          $visitor: paths_default3
        },
        PathItem: {
          $visitor: path_item_default,
          fixedFields: {
            $ref: RefVisitor_default3,
            summary: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            get: {
              $ref: "#/visitors/document/objects/Operation"
            },
            put: {
              $ref: "#/visitors/document/objects/Operation"
            },
            post: {
              $ref: "#/visitors/document/objects/Operation"
            },
            delete: {
              $ref: "#/visitors/document/objects/Operation"
            },
            options: {
              $ref: "#/visitors/document/objects/Operation"
            },
            head: {
              $ref: "#/visitors/document/objects/Operation"
            },
            patch: {
              $ref: "#/visitors/document/objects/Operation"
            },
            trace: {
              $ref: "#/visitors/document/objects/Operation"
            },
            servers: ServersVisitor_default3,
            parameters: ParametersVisitor_default5
          }
        },
        Operation: {
          $visitor: operation_default,
          fixedFields: {
            tags: TagsVisitor_default,
            summary: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            externalDocs: {
              $ref: "#/visitors/document/objects/ExternalDocumentation"
            },
            operationId: {
              $ref: "#/visitors/value"
            },
            parameters: ParametersVisitor_default4,
            requestBody: RequestBodyVisitor_default,
            responses: {
              $ref: "#/visitors/document/objects/Responses"
            },
            callbacks: CallbacksVisitor_default2,
            deprecated: {
              $ref: "#/visitors/value"
            },
            security: SecurityVisitor_default2,
            servers: ServersVisitor_default2
          }
        },
        ExternalDocumentation: {
          $visitor: external_documentation_default,
          fixedFields: {
            description: {
              $ref: "#/visitors/value"
            },
            url: {
              $ref: "#/visitors/value"
            }
          }
        },
        Parameter: {
          $visitor: parameter_default,
          fixedFields: {
            name: {
              $ref: "#/visitors/value"
            },
            in: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            required: {
              $ref: "#/visitors/value"
            },
            deprecated: {
              $ref: "#/visitors/value"
            },
            allowEmptyValue: {
              $ref: "#/visitors/value"
            },
            style: {
              $ref: "#/visitors/value"
            },
            explode: {
              $ref: "#/visitors/value"
            },
            allowReserved: {
              $ref: "#/visitors/value"
            },
            schema: SchemaVisitor_default2,
            example: {
              $ref: "#/visitors/value"
            },
            examples: ExamplesVisitor_default4,
            content: ContentVisitor_default3
          }
        },
        RequestBody: {
          $visitor: request_body_default,
          fixedFields: {
            description: {
              $ref: "#/visitors/value"
            },
            content: ContentVisitor_default4,
            required: {
              $ref: "#/visitors/value"
            }
          }
        },
        MediaType: {
          $visitor: media_type_default,
          fixedFields: {
            schema: SchemaVisitor_default,
            example: {
              $ref: "#/visitors/value"
            },
            examples: ExamplesVisitor_default2,
            encoding: EncodingVisitor_default
          }
        },
        Encoding: {
          $visitor: encoding_default,
          fixedFields: {
            contentType: {
              $ref: "#/visitors/value"
            },
            headers: HeadersVisitor_default2,
            style: {
              $ref: "#/visitors/value"
            },
            explode: {
              $ref: "#/visitors/value"
            },
            allowReserved: {
              $ref: "#/visitors/value"
            }
          }
        },
        Responses: {
          $visitor: responses_default,
          fixedFields: {
            default: DefaultVisitor_default
          }
        },
        Response: {
          $visitor: response_default,
          fixedFields: {
            description: {
              $ref: "#/visitors/value"
            },
            headers: HeadersVisitor_default3,
            content: ContentVisitor_default5,
            links: LinksVisitor_default3
          }
        },
        Callback: {
          $visitor: callback_default
        },
        Example: {
          $visitor: example_default,
          fixedFields: {
            summary: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            value: {
              $ref: "#/visitors/value"
            },
            externalValue: ExternalValueVisitor_default
          }
        },
        Link: {
          $visitor: link_default,
          fixedFields: {
            operationRef: OperationRefVisitor_default,
            operationId: OperationIdVisitor_default,
            parameters: ParametersVisitor_default,
            requestBody: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            server: {
              $ref: "#/visitors/document/objects/Server"
            }
          }
        },
        Header: {
          $visitor: header_default,
          fixedFields: {
            description: {
              $ref: "#/visitors/value"
            },
            required: {
              $ref: "#/visitors/value"
            },
            deprecated: {
              $ref: "#/visitors/value"
            },
            allowEmptyValue: {
              $ref: "#/visitors/value"
            },
            style: {
              $ref: "#/visitors/value"
            },
            explode: {
              $ref: "#/visitors/value"
            },
            allowReserved: {
              $ref: "#/visitors/value"
            },
            schema: SchemaVisitor_default3,
            example: {
              $ref: "#/visitors/value"
            },
            examples: ExamplesVisitor_default3,
            content: ContentVisitor_default2
          }
        },
        Tag: {
          $visitor: tag_default,
          fixedFields: {
            name: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            externalDocs: {
              $ref: "#/visitors/document/objects/ExternalDocumentation"
            }
          }
        },
        Reference: {
          $visitor: reference_default,
          fixedFields: {
            $ref: RefVisitor_default2
          }
        },
        JSONSchema: {
          $ref: "#/visitors/document/objects/Schema"
        },
        JSONReference: {
          $ref: "#/visitors/document/objects/Reference"
        },
        Schema: {
          $visitor: schema_default,
          fixedFields: {
            // the following properties are taken directly from the JSON Schema definition and follow the same specifications
            title: jsonSchemaFixedFields.title,
            multipleOf: jsonSchemaFixedFields.multipleOf,
            maximum: jsonSchemaFixedFields.maximum,
            exclusiveMaximum: jsonSchemaFixedFields.exclusiveMaximum,
            minimum: jsonSchemaFixedFields.minimum,
            exclusiveMinimum: jsonSchemaFixedFields.exclusiveMinimum,
            maxLength: jsonSchemaFixedFields.maxLength,
            minLength: jsonSchemaFixedFields.minLength,
            pattern: jsonSchemaFixedFields.pattern,
            maxItems: jsonSchemaFixedFields.maxItems,
            minItems: jsonSchemaFixedFields.minItems,
            uniqueItems: jsonSchemaFixedFields.uniqueItems,
            maxProperties: jsonSchemaFixedFields.maxProperties,
            minProperties: jsonSchemaFixedFields.minProperties,
            required: jsonSchemaFixedFields.required,
            enum: jsonSchemaFixedFields.enum,
            // the following properties are taken from the JSON Schema definition but their definitions were adjusted to the OpenAPI Specification
            type: TypeVisitor_default2,
            allOf: AllOfVisitor_default2,
            anyOf: AnyOfVisitor_default2,
            oneOf: OneOfVisitor_default2,
            not: SchemaOrReferenceVisitor_default,
            items: ItemsVisitor_default2,
            properties: PropertiesVisitor_default2,
            additionalProperties: SchemaOrReferenceVisitor_default,
            description: jsonSchemaFixedFields.description,
            format: jsonSchemaFixedFields.format,
            default: jsonSchemaFixedFields.default,
            // OpenAPI vocabulary
            nullable: {
              $ref: "#/visitors/value"
            },
            discriminator: {
              $ref: "#/visitors/document/objects/Discriminator"
            },
            writeOnly: {
              $ref: "#/visitors/value"
            },
            xml: {
              $ref: "#/visitors/document/objects/XML"
            },
            externalDocs: {
              $ref: "#/visitors/document/objects/ExternalDocumentation"
            },
            example: {
              $ref: "#/visitors/value"
            },
            deprecated: {
              $ref: "#/visitors/value"
            }
          }
        },
        Discriminator: {
          $visitor: distriminator_default,
          fixedFields: {
            propertyName: {
              $ref: "#/visitors/value"
            },
            mapping: MappingVisitor_default
          }
        },
        XML: {
          $visitor: xml_default,
          fixedFields: {
            name: {
              $ref: "#/visitors/value"
            },
            namespace: {
              $ref: "#/visitors/value"
            },
            prefix: {
              $ref: "#/visitors/value"
            },
            attribute: {
              $ref: "#/visitors/value"
            },
            wrapped: {
              $ref: "#/visitors/value"
            }
          }
        },
        SecurityScheme: {
          $visitor: security_scheme_default,
          fixedFields: {
            type: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            name: {
              $ref: "#/visitors/value"
            },
            in: {
              $ref: "#/visitors/value"
            },
            scheme: {
              $ref: "#/visitors/value"
            },
            bearerFormat: {
              $ref: "#/visitors/value"
            },
            flows: {
              $ref: "#/visitors/document/objects/OAuthFlows"
            },
            openIdConnectUrl: {
              $ref: "#/visitors/value"
            }
          }
        },
        OAuthFlows: {
          $visitor: oauth_flows_default,
          fixedFields: {
            implicit: {
              $ref: "#/visitors/document/objects/OAuthFlow"
            },
            password: {
              $ref: "#/visitors/document/objects/OAuthFlow"
            },
            clientCredentials: {
              $ref: "#/visitors/document/objects/OAuthFlow"
            },
            authorizationCode: {
              $ref: "#/visitors/document/objects/OAuthFlow"
            }
          }
        },
        OAuthFlow: {
          $visitor: oauth_flow_default,
          fixedFields: {
            authorizationUrl: {
              $ref: "#/visitors/value"
            },
            tokenUrl: {
              $ref: "#/visitors/value"
            },
            refreshUrl: {
              $ref: "#/visitors/value"
            },
            scopes: ScopesVisitor_default
          }
        },
        SecurityRequirement: {
          $visitor: security_requirement_default
        }
      },
      extension: {
        $visitor: SpecificationExtensionVisitor_default
      }
    }
  }
};
var specification_default2 = specification2;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/toolbox.mjs
var createToolbox3 = () => {
  const namespace2 = createNamespace(namespace_default3);
  const predicates = {
    ...predicates_exports3,
    isElement,
    isStringElement,
    isArrayElement,
    isObjectElement,
    isMemberElement,
    includesClasses,
    hasElementSourceMap
  };
  return {
    predicates,
    namespace: namespace2
  };
};
var toolbox_default3 = createToolbox3;

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/index.mjs
var refract4 = (value, {
  specPath = ["visitors", "document", "objects", "OpenApi", "$visitor"],
  plugins: plugins2 = []
} = {}) => {
  const element = (0, import_minim14.refract)(value);
  const resolvedSpec = dereference(specification_default2);
  const RootVisitorClass = path_default(specPath, resolvedSpec);
  const rootVisitor = new RootVisitorClass({
    specObj: resolvedSpec
  });
  visit2(element, rootVisitor);
  return dispatchPluginsSync(rootVisitor.element, plugins2, {
    toolboxCreator: toolbox_default3,
    visitorOptions: {
      keyMap: keyMap2,
      nodeTypeGetter: getNodeType4
    }
  });
};
var createRefractor3 = (specPath) => (value, options = {}) => refract4(value, {
  specPath,
  ...options
});

// node_modules/@swagger-api/apidom-ns-openapi-3-0/src/refractor/registration.mjs
Callback_default.refract = createRefractor3(["visitors", "document", "objects", "Callback", "$visitor"]);
Components_default.refract = createRefractor3(["visitors", "document", "objects", "Components", "$visitor"]);
Contact_default.refract = createRefractor3(["visitors", "document", "objects", "Contact", "$visitor"]);
Example_default.refract = createRefractor3(["visitors", "document", "objects", "Example", "$visitor"]);
Discriminator_default.refract = createRefractor3(["visitors", "document", "objects", "Discriminator", "$visitor"]);
Encoding_default.refract = createRefractor3(["visitors", "document", "objects", "Encoding", "$visitor"]);
ExternalDocumentation_default.refract = createRefractor3(["visitors", "document", "objects", "ExternalDocumentation", "$visitor"]);
Header_default.refract = createRefractor3(["visitors", "document", "objects", "Header", "$visitor"]);
Info_default.refract = createRefractor3(["visitors", "document", "objects", "Info", "$visitor"]);
License_default.refract = createRefractor3(["visitors", "document", "objects", "License", "$visitor"]);
Link_default.refract = createRefractor3(["visitors", "document", "objects", "Link", "$visitor"]);
MediaType_default.refract = createRefractor3(["visitors", "document", "objects", "MediaType", "$visitor"]);
OAuthFlow_default.refract = createRefractor3(["visitors", "document", "objects", "OAuthFlow", "$visitor"]);
OAuthFlows_default.refract = createRefractor3(["visitors", "document", "objects", "OAuthFlows", "$visitor"]);
Openapi_default.refract = createRefractor3(["visitors", "document", "objects", "OpenApi", "fixedFields", "openapi"]);
OpenApi3_0_default.refract = createRefractor3(["visitors", "document", "objects", "OpenApi", "$visitor"]);
Operation_default.refract = createRefractor3(["visitors", "document", "objects", "Operation", "$visitor"]);
Parameter_default.refract = createRefractor3(["visitors", "document", "objects", "Parameter", "$visitor"]);
PathItem_default.refract = createRefractor3(["visitors", "document", "objects", "PathItem", "$visitor"]);
Paths_default.refract = createRefractor3(["visitors", "document", "objects", "Paths", "$visitor"]);
Reference_default2.refract = createRefractor3(["visitors", "document", "objects", "Reference", "$visitor"]);
RequestBody_default.refract = createRefractor3(["visitors", "document", "objects", "RequestBody", "$visitor"]);
Response_default.refract = createRefractor3(["visitors", "document", "objects", "Response", "$visitor"]);
Responses_default.refract = createRefractor3(["visitors", "document", "objects", "Responses", "$visitor"]);
Schema_default.refract = createRefractor3(["visitors", "document", "objects", "Schema", "$visitor"]);
SecurityRequirement_default.refract = createRefractor3(["visitors", "document", "objects", "SecurityRequirement", "$visitor"]);
SecurityScheme_default.refract = createRefractor3(["visitors", "document", "objects", "SecurityScheme", "$visitor"]);
Server_default.refract = createRefractor3(["visitors", "document", "objects", "Server", "$visitor"]);
ServerVariable_default.refract = createRefractor3(["visitors", "document", "objects", "ServerVariable", "$visitor"]);
Tag_default2.refract = createRefractor3(["visitors", "document", "objects", "Tag", "$visitor"]);
Xml_default.refract = createRefractor3(["visitors", "document", "objects", "XML", "$visitor"]);

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Callback.mjs
var Callback2 = class extends Callback_default {
};
var Callback_default2 = Callback2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Components.mjs
var Components2 = class extends Components_default {
  get pathItems() {
    return this.get("pathItems");
  }
  set pathItems(pathItems) {
    this.set("pathItems", pathItems);
  }
};
var Components_default2 = Components2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Contact.mjs
var Contact2 = class extends Contact_default {
};
var Contact_default2 = Contact2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Discriminator.mjs
var Discriminator2 = class extends Discriminator_default {
};
var Discriminator_default2 = Discriminator2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Encoding.mjs
var Encoding2 = class extends Encoding_default {
};
var Encoding_default2 = Encoding2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Example.mjs
var Example2 = class extends Example_default {
};
var Example_default2 = Example2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/ExternalDocumentation.mjs
var ExternalDocumentation2 = class extends ExternalDocumentation_default {
};
var ExternalDocumentation_default2 = ExternalDocumentation2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Header.mjs
var Header2 = class extends Header_default {
  get schema() {
    return this.get("schema");
  }
  set schema(schema4) {
    this.set("schema", schema4);
  }
};
var Header_default2 = Header2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Info.mjs
var Info2 = class extends Info_default {
  get license() {
    return this.get("license");
  }
  set license(licenseElement) {
    this.set("license", licenseElement);
  }
  get summary() {
    return this.get("summary");
  }
  set summary(summary) {
    this.set("summary", summary);
  }
};
var Info_default2 = Info2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/JsonSchemaDialect.mjs
var _JsonSchemaDialect = class _JsonSchemaDialect extends import_minim10.StringElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "jsonSchemaDialect";
  }
};
__publicField(_JsonSchemaDialect, "default", new _JsonSchemaDialect("https://spec.openapis.org/oas/3.1/dialect/base"));
var JsonSchemaDialect = _JsonSchemaDialect;
var JsonSchemaDialect_default = JsonSchemaDialect;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/License.mjs
var License2 = class extends License_default {
  get identifier() {
    return this.get("identifier");
  }
  set identifier(name2) {
    this.set("identifier", name2);
  }
};
var License_default2 = License2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Link.mjs
var Link2 = class extends Link_default {
};
var Link_default2 = Link2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/MediaType.mjs
var MediaType2 = class extends MediaType_default {
  get schema() {
    return this.get("schema");
  }
  set schema(schema4) {
    this.set("schema", schema4);
  }
};
var MediaType_default2 = MediaType2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/OAuthFlow.mjs
var OAuthFlow2 = class extends OAuthFlow_default {
};
var OAuthFlow_default2 = OAuthFlow2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/OAuthFlows.mjs
var OAuthFlows2 = class extends OAuthFlows_default {
};
var OAuthFlows_default2 = OAuthFlows2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Openapi.mjs
var Openapi2 = class extends Openapi_default {
};
var Openapi_default2 = Openapi2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/OpenApi3-1.mjs
var OpenApi3_1 = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "openApi3_1";
    this.classes.push("api");
  }
  get openapi() {
    return this.get("openapi");
  }
  set openapi(openapi) {
    this.set("openapi", openapi);
  }
  get info() {
    return this.get("info");
  }
  set info(info) {
    this.set("info", info);
  }
  get jsonSchemaDialect() {
    return this.get("jsonSchemaDialect");
  }
  set jsonSchemaDialect(jsonSchemaDialect) {
    this.set("jsonSchemaDialect", jsonSchemaDialect);
  }
  get servers() {
    return this.get("servers");
  }
  set servers(servers) {
    this.set("servers", servers);
  }
  get paths() {
    return this.get("paths");
  }
  set paths(paths4) {
    this.set("paths", paths4);
  }
  get components() {
    return this.get("components");
  }
  set components(components) {
    this.set("components", components);
  }
  get security() {
    return this.get("security");
  }
  set security(security) {
    this.set("security", security);
  }
  get tags() {
    return this.get("tags");
  }
  set tags(tags) {
    this.set("tags", tags);
  }
  get externalDocs() {
    return this.get("externalDocs");
  }
  set externalDocs(externalDocs) {
    this.set("externalDocs", externalDocs);
  }
  get webhooks() {
    return this.get("webhooks");
  }
  set webhooks(webhooks2) {
    this.set("webhooks", webhooks2);
  }
};
var OpenApi3_1_default = OpenApi3_1;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Operation.mjs
var Operation2 = class extends Operation_default {
  get requestBody() {
    return this.get("requestBody");
  }
  set requestBody(requestBody) {
    this.set("requestBody", requestBody);
  }
};
var Operation_default2 = Operation2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Parameter.mjs
var Parameter2 = class extends Parameter_default {
  get schema() {
    return this.get("schema");
  }
  set schema(schema4) {
    this.set("schema", schema4);
  }
};
var Parameter_default2 = Parameter2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/PathItem.mjs
var PathItem2 = class extends PathItem_default {
  get GET() {
    return this.get("get");
  }
  set GET(operation) {
    this.set("GET", operation);
  }
  get PUT() {
    return this.get("put");
  }
  set PUT(operation) {
    this.set("PUT", operation);
  }
  get POST() {
    return this.get("post");
  }
  set POST(operation) {
    this.set("POST", operation);
  }
  get DELETE() {
    return this.get("delete");
  }
  set DELETE(operation) {
    this.set("DELETE", operation);
  }
  get OPTIONS() {
    return this.get("options");
  }
  set OPTIONS(operation) {
    this.set("OPTIONS", operation);
  }
  get HEAD() {
    return this.get("head");
  }
  set HEAD(operation) {
    this.set("HEAD", operation);
  }
  get PATCH() {
    return this.get("patch");
  }
  set PATCH(operation) {
    this.set("PATCH", operation);
  }
  get TRACE() {
    return this.get("trace");
  }
  set TRACE(operation) {
    this.set("TRACE", operation);
  }
};
var PathItem_default2 = PathItem2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Paths.mjs
var Paths2 = class extends Paths_default {
};
var Paths_default2 = Paths2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Reference.mjs
var Reference3 = class extends Reference_default2 {
};
Object.defineProperty(Reference3.prototype, "description", {
  get() {
    return this.get("description");
  },
  set(description) {
    this.set("description", description);
  },
  enumerable: true
});
Object.defineProperty(Reference3.prototype, "summary", {
  get() {
    return this.get("summary");
  },
  set(description) {
    this.set("summary", description);
  },
  enumerable: true
});
var Reference_default3 = Reference3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/RequestBody.mjs
var RequestBody2 = class extends RequestBody_default {
};
var RequestBody_default2 = RequestBody2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Response.mjs
var Response4 = class extends Response_default {
};
var Response_default2 = Response4;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Responses.mjs
var Responses2 = class extends Responses_default {
};
var Responses_default2 = Responses2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Schema.mjs
var Schema3 = class extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.element = "schema";
  }
  /**
   * Core vocabulary
   *
   * URI: https://json-schema.org/draft/2020-12/vocab/core
   */
  get $schema() {
    return this.get("$schema");
  }
  set $schema($schema) {
    this.set("$schema", $schema);
  }
  get $vocabulary() {
    return this.get("$vocabulary");
  }
  set $vocabulary($vocabulary) {
    this.set("$vocabulary", $vocabulary);
  }
  get $id() {
    return this.get("$id");
  }
  set $id($id) {
    this.set("$id", $id);
  }
  get $anchor() {
    return this.get("$anchor");
  }
  set $anchor($anchor) {
    this.set("$anchor", $anchor);
  }
  get $dynamicAnchor() {
    return this.get("$dynamicAnchor");
  }
  set $dynamicAnchor($dynamicAnchor) {
    this.set("$dynamicAnchor", $dynamicAnchor);
  }
  get $dynamicRef() {
    return this.get("$dynamicRef");
  }
  set $dynamicRef($dynamicRef) {
    this.set("$dynamicRef", $dynamicRef);
  }
  get $ref() {
    return this.get("$ref");
  }
  set $ref($ref) {
    this.set("$ref", $ref);
  }
  get $defs() {
    return this.get("$defs");
  }
  set $defs($defs) {
    this.set("$defs", $defs);
  }
  get $comment() {
    return this.get("$comment");
  }
  set $comment($comment) {
    this.set("$comment", $comment);
  }
  /**
   * Applicator vocabulary
   *
   * URI: https://json-schema.org/draft/2020-12/vocab/applicator
   */
  get allOf() {
    return this.get("allOf");
  }
  set allOf(allOf) {
    this.set("allOf", allOf);
  }
  get anyOf() {
    return this.get("anyOf");
  }
  set anyOf(anyOf) {
    this.set("anyOf", anyOf);
  }
  get oneOf() {
    return this.get("oneOf");
  }
  set oneOf(oneOf) {
    this.set("oneOf", oneOf);
  }
  get not() {
    return this.get("not");
  }
  set not(not3) {
    this.set("not", not3);
  }
  get if() {
    return this.get("if");
  }
  set if(ifSchema) {
    this.set("if", ifSchema);
  }
  get then() {
    return this.get("then");
  }
  set then(thenSchema) {
    this.set("then", thenSchema);
  }
  get else() {
    return this.get("else");
  }
  set else(elseSchema) {
    this.set("else", elseSchema);
  }
  get dependentSchemas() {
    return this.get("dependentSchemas");
  }
  set dependentSchemas(dependentSchemas) {
    this.set("dependentSchemas", dependentSchemas);
  }
  get prefixItems() {
    return this.get("prefixItems");
  }
  set prefixItems(prefixItems) {
    this.set("prefixItems", prefixItems);
  }
  get items() {
    return this.get("items");
  }
  set items(items) {
    this.set("items", items);
  }
  get containsProp() {
    return this.get("contains");
  }
  set containsProp(containsProp) {
    this.set("contains", containsProp);
  }
  get properties() {
    return this.get("properties");
  }
  set properties(properties) {
    this.set("properties", properties);
  }
  get patternProperties() {
    return this.get("patternProperties");
  }
  set patternProperties(patternProperties) {
    this.set("patternProperties", patternProperties);
  }
  get additionalProperties() {
    return this.get("additionalProperties");
  }
  set additionalProperties(additionalProperties) {
    this.set("additionalProperties", additionalProperties);
  }
  get propertyNames() {
    return this.get("propertyNames");
  }
  set propertyNames(propertyNames) {
    this.set("propertyNames", propertyNames);
  }
  /**
   * Unevaluated Locations vocabulary
   *
   * URI: https://json-schema.org/draft/2020-12/vocab/unevaluated
   */
  get unevaluatedItems() {
    return this.get("unevaluatedItems");
  }
  set unevaluatedItems(unevaluatedItems) {
    this.set("unevaluatedItems", unevaluatedItems);
  }
  get unevaluatedProperties() {
    return this.get("unevaluatedProperties");
  }
  set unevaluatedProperties(unevaluatedProperties) {
    this.set("unevaluatedProperties", unevaluatedProperties);
  }
  /**
   * Validation vocabulary
   *
   * URI: https://json-schema.org/draft/2020-12/vocab/validation
   */
  /**
   *  Validation Keywords for Any Instance Type
   *
   *  URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.6.1
   */
  get type() {
    return this.get("type");
  }
  set type(type5) {
    this.set("type", type5);
  }
  get enum() {
    return this.get("enum");
  }
  set enum(enumVal) {
    this.set("enum", enumVal);
  }
  get const() {
    return this.get("const");
  }
  set const(constVal) {
    this.set("const", constVal);
  }
  /**
   * Validation Keywords for Numeric Instances (number and integer)
   *
   * URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#numeric
   */
  get multipleOf() {
    return this.get("multipleOf");
  }
  set multipleOf(multipleOf) {
    this.set("multipleOf", multipleOf);
  }
  get maximum() {
    return this.get("maximum");
  }
  set maximum(maximum) {
    this.set("maximum", maximum);
  }
  get exclusiveMaximum() {
    return this.get("exclusiveMaximum");
  }
  set exclusiveMaximum(exclusiveMaximum) {
    this.set("exclusiveMaximum", exclusiveMaximum);
  }
  get minimum() {
    return this.get("minimum");
  }
  set minimum(minimum) {
    this.set("minimum", minimum);
  }
  get exclusiveMinimum() {
    return this.get("exclusiveMinimum");
  }
  set exclusiveMinimum(exclusiveMinimum) {
    this.set("exclusiveMinimum", exclusiveMinimum);
  }
  /**
   * Validation Keywords for Strings
   *
   * URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#string
   */
  get maxLength() {
    return this.get("maxLength");
  }
  set maxLength(maxLength) {
    this.set("maxLength", maxLength);
  }
  get minLength() {
    return this.get("minLength");
  }
  set minLength(minLength) {
    this.set("minLength", minLength);
  }
  get pattern() {
    return this.get("pattern");
  }
  set pattern(pattern) {
    this.set("pattern", pattern);
  }
  /**
   * Validation Keywords for Arrays
   *
   * URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.6.4
   */
  get maxItems() {
    return this.get("maxItems");
  }
  set maxItems(maxItems) {
    this.set("maxItems", maxItems);
  }
  get minItems() {
    return this.get("minItems");
  }
  set minItems(minItems) {
    this.set("minItems", minItems);
  }
  get uniqueItems() {
    return this.get("uniqueItems");
  }
  set uniqueItems(uniqueItems) {
    this.set("uniqueItems", uniqueItems);
  }
  get maxContains() {
    return this.get("maxContains");
  }
  set maxContains(maxContains) {
    this.set("maxContains", maxContains);
  }
  get minContains() {
    return this.get("minContains");
  }
  set minContains(minContains) {
    this.set("minContains", minContains);
  }
  /**
   * Validation Keywords for Objects
   *
   * URI: https://json-schema.org/draft/2020-12/json-schema-validation.html#rfc.section.6.5
   */
  get maxProperties() {
    return this.get("maxProperties");
  }
  set maxProperties(maxProperties) {
    this.set("maxProperties", maxProperties);
  }
  get minProperties() {
    return this.get("minProperties");
  }
  set minProperties(minProperties) {
    this.set("minProperties", minProperties);
  }
  get required() {
    return this.get("required");
  }
  set required(required) {
    this.set("required", required);
  }
  get dependentRequired() {
    return this.get("dependentRequired");
  }
  set dependentRequired(dependentRequired) {
    this.set("dependentRequired", dependentRequired);
  }
  /**
   * Vocabulary for Basic Meta-Data Annotations
   *
   * URI: https://json-schema.org/draft/2020-12/vocab/meta-data
   */
  get title() {
    return this.get("title");
  }
  set title(title) {
    this.set("title", title);
  }
  get description() {
    return this.get("description");
  }
  set description(description) {
    this.set("description", description);
  }
  get default() {
    return this.get("default");
  }
  set default(defaultVal) {
    this.set("default", defaultVal);
  }
  get deprecated() {
    return this.get("deprecated");
  }
  set deprecated(deprecated) {
    this.set("deprecated", deprecated);
  }
  get readOnly() {
    return this.get("readOnly");
  }
  set readOnly(readOnly) {
    this.set("readOnly", readOnly);
  }
  get writeOnly() {
    return this.get("writeOnly");
  }
  set writeOnly(writeOnly) {
    this.set("writeOnly", writeOnly);
  }
  get examples() {
    return this.get("examples");
  }
  set examples(examples) {
    this.set("examples", examples);
  }
  /**
   * Vocabularies for Semantic Content With "format"
   *
   * URI: https://json-schema.org/draft/2020-12/vocab/format-annotation
   */
  get format() {
    return this.get("format");
  }
  set format(format) {
    this.set("format", format);
  }
  /**
   * Vocabulary for the Contents of String-Encoded Data
   *
   * URI: https://json-schema.org/draft/2020-12/vocab/content
   */
  get contentEncoding() {
    return this.get("contentEncoding");
  }
  set contentEncoding(contentEncoding) {
    this.set("contentEncoding", contentEncoding);
  }
  get contentMediaType() {
    return this.get("contentMediaType");
  }
  set contentMediaType(contentMediaType) {
    this.set("contentMediaType", contentMediaType);
  }
  get contentSchema() {
    return this.get("contentSchema");
  }
  set contentSchema(contentSchema) {
    this.set("contentSchema", contentSchema);
  }
  /**
   * OAS base vocabulary
   *
   * URI: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md#baseVocabulary
   */
  get discriminator() {
    return this.get("discriminator");
  }
  set discriminator(discriminator) {
    this.set("discriminator", discriminator);
  }
  get xml() {
    return this.get("xml");
  }
  set xml(xml3) {
    this.set("xml", xml3);
  }
  get externalDocs() {
    return this.get("externalDocs");
  }
  set externalDocs(externalDocs) {
    this.set("externalDocs", externalDocs);
  }
  /**
   * @deprecated The example property has been deprecated in favor of the JSON Schema examples keyword. Use of example is discouraged, and later versions of this specification may remove it.
   */
  get example() {
    return this.get("example");
  }
  set example(example) {
    this.set("example", example);
  }
};
var Schema_default2 = Schema3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/SecurityRequirement.mjs
var SecurityRequirement2 = class extends SecurityRequirement_default {
};
var SecurityRequirement_default2 = SecurityRequirement2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/SecurityScheme.mjs
var SecurityScheme2 = class extends SecurityScheme_default {
};
var SecurityScheme_default2 = SecurityScheme2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Server.mjs
var Server2 = class extends Server_default {
};
var Server_default2 = Server2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/ServerVariable.mjs
var ServerVariable2 = class extends ServerVariable_default {
};
var ServerVariable_default2 = ServerVariable2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Tag.mjs
var Tag2 = class extends Tag_default2 {
};
var Tag_default3 = Tag2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/Xml.mjs
var Xml2 = class extends Xml_default {
};
var Xml_default2 = Xml2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/namespace.mjs
var openApi3_1 = {
  namespace: (options) => {
    const {
      base: base2
    } = options;
    base2.register("callback", Callback_default2);
    base2.register("components", Components_default2);
    base2.register("contact", Contact_default2);
    base2.register("discriminator", Discriminator_default2);
    base2.register("encoding", Encoding_default2);
    base2.register("example", Example_default2);
    base2.register("externalDocumentation", ExternalDocumentation_default2);
    base2.register("header", Header_default2);
    base2.register("info", Info_default2);
    base2.register("jsonSchemaDialect", JsonSchemaDialect_default);
    base2.register("license", License_default2);
    base2.register("link", Link_default2);
    base2.register("mediaType", MediaType_default2);
    base2.register("oAuthFlow", OAuthFlow_default2);
    base2.register("oAuthFlows", OAuthFlows_default2);
    base2.register("openapi", Openapi_default2);
    base2.register("openApi3_1", OpenApi3_1_default);
    base2.register("operation", Operation_default2);
    base2.register("parameter", Parameter_default2);
    base2.register("pathItem", PathItem_default2);
    base2.register("paths", Paths_default2);
    base2.register("reference", Reference_default3);
    base2.register("requestBody", RequestBody_default2);
    base2.register("response", Response_default2);
    base2.register("responses", Responses_default2);
    base2.register("schema", Schema_default2);
    base2.register("securityRequirement", SecurityRequirement_default2);
    base2.register("securityScheme", SecurityScheme_default2);
    base2.register("server", Server_default2);
    base2.register("serverVariable", ServerVariable_default2);
    base2.register("tag", Tag_default3);
    base2.register("xml", Xml_default2);
    return base2;
  }
};
var namespace_default4 = openApi3_1;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/nces/ComponentsPathItems.mjs
var _ComponentsPathItems = class _ComponentsPathItems extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_ComponentsPathItems.primaryClass);
  }
};
__publicField(_ComponentsPathItems, "primaryClass", "components-path-items");
var ComponentsPathItems = _ComponentsPathItems;
var ComponentsPathItems_default = ComponentsPathItems;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/elements/nces/Webhooks.mjs
var _Webhooks = class _Webhooks extends import_minim10.ObjectElement {
  constructor(content, meta, attributes) {
    super(content, meta, attributes);
    this.classes.push(_Webhooks.primaryClass);
  }
};
__publicField(_Webhooks, "primaryClass", "webhooks");
var Webhooks = _Webhooks;
var Webhooks_default = Webhooks;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/traversal/visitor.mjs
var getNodeType5 = (element) => {
  if (!isElement(element)) {
    return void 0;
  }
  return `${element.element.charAt(0).toUpperCase() + element.element.slice(1)}Element`;
};
var keyMap3 = {
  CallbackElement: ["content"],
  ComponentsElement: ["content"],
  ContactElement: ["content"],
  DiscriminatorElement: ["content"],
  Encoding: ["content"],
  Example: ["content"],
  ExternalDocumentationElement: ["content"],
  HeaderElement: ["content"],
  InfoElement: ["content"],
  LicenseElement: ["content"],
  MediaTypeElement: ["content"],
  OAuthFlowElement: ["content"],
  OAuthFlowsElement: ["content"],
  OpenApi3_1Element: ["content"],
  OperationElement: ["content"],
  ParameterElement: ["content"],
  PathItemElement: ["content"],
  PathsElement: ["content"],
  ReferenceElement: ["content"],
  RequestBodyElement: ["content"],
  ResponseElement: ["content"],
  ResponsesElement: ["content"],
  SchemaElement: ["content"],
  SecurityRequirementElement: ["content"],
  SecuritySchemeElement: ["content"],
  ServerElement: ["content"],
  ServerVariableElement: ["content"],
  TagElement: ["content"],
  ...keyMapDefault
};

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/plugins/replace-empty-element.mjs
var schema3 = {
  // concrete types handling (CTs)
  OpenApi3_1Element: {
    info(...args) {
      return new Info_default2(...args);
    },
    servers(...args) {
      return new Servers_default(...args);
    },
    paths(...args) {
      return new Paths_default2(...args);
    },
    webhooks(...args) {
      return new Webhooks_default(...args);
    },
    components(...args) {
      return new Components_default2(...args);
    },
    security(...args) {
      return new Security_default(...args);
    },
    tags(...args) {
      return new Tags_default(...args);
    },
    externalDocs(...args) {
      return new ExternalDocumentation_default2(...args);
    }
  },
  InfoElement: {
    contact(...args) {
      return new Contact_default2(...args);
    },
    license(...args) {
      return new License_default2(...args);
    }
  },
  ServerElement: {
    variables(...args) {
      return new ServerVariables_default(...args);
    }
  },
  ServerVariableElement: {
    enum(...args) {
      return new import_minim10.ArrayElement(...args);
    }
  },
  PathsElement: {
    "[key: *]": function key28(...args) {
      return new PathItem_default2(...args);
    }
  },
  PathItemElement: {
    get(...args) {
      return new Operation_default2(...args);
    },
    put(...args) {
      return new Operation_default2(...args);
    },
    post(...args) {
      return new Operation_default2(...args);
    },
    delete(...args) {
      return new Operation_default2(...args);
    },
    options(...args) {
      return new Operation_default2(...args);
    },
    head(...args) {
      return new Operation_default2(...args);
    },
    patch(...args) {
      return new Operation_default2(...args);
    },
    trace(...args) {
      return new Operation_default2(...args);
    },
    servers(...args) {
      return new PathItemServers_default(...args);
    },
    parameters(...args) {
      return new PathItemParameters_default(...args);
    }
  },
  OperationElement: {
    tags(...args) {
      return new OperationTags_default(...args);
    },
    externalDocs(...args) {
      return new ExternalDocumentation_default2(...args);
    },
    parameters(...args) {
      return new OperationParameters_default(...args);
    },
    requestBody(...args) {
      return new RequestBody_default2(...args);
    },
    responses(...args) {
      return new Responses_default2(...args);
    },
    callbacks(...args) {
      return new OperationCallbacks_default(...args);
    },
    security(...args) {
      return new OperationSecurity_default(...args);
    },
    servers(...args) {
      return new OperationServers_default(...args);
    }
  },
  ParameterElement: {
    schema(...args) {
      return new Schema_default2(...args);
    },
    examples(...args) {
      return new ParameterExamples_default(...args);
    },
    content(...args) {
      return new ParameterContent_default(...args);
    }
  },
  RequestBodyElement: {
    content(...args) {
      return new RequestBodyContent_default(...args);
    }
  },
  MediaTypeElement: {
    schema(...args) {
      return new Schema_default2(...args);
    },
    examples(...args) {
      return new MediaTypeExamples_default(...args);
    },
    encoding(...args) {
      return new MediaTypeEncoding_default(...args);
    }
  },
  EncodingElement: {
    headers(...args) {
      return new EncodingHeaders_default(...args);
    }
  },
  ResponsesElement: {
    "[key: *]": function key29(...args) {
      return new Response_default2(...args);
    }
  },
  ResponseElement: {
    headers(...args) {
      return new ResponseHeaders_default(...args);
    },
    content(...args) {
      return new ResponseContent_default(...args);
    },
    links(...args) {
      return new ResponseLinks_default(...args);
    }
  },
  CallbackElement: {
    "[key: *]": function key30(...args) {
      return new PathItem_default2(...args);
    }
  },
  LinkElement: {
    server(...args) {
      return new Server_default2(...args);
    }
  },
  HeaderElement: {
    schema(...args) {
      return new Schema_default2(...args);
    },
    examples(...args) {
      return new HeaderExamples_default(...args);
    },
    content(...args) {
      return new HeaderContent_default(...args);
    }
  },
  ComponentsElement: {
    schemas(...args) {
      return new ComponentsSchemas_default(...args);
    },
    responses(...args) {
      return new ComponentsResponses_default(...args);
    },
    parameters(...args) {
      return new ComponentsParameters_default(...args);
    },
    examples(...args) {
      return new ComponentsExamples_default(...args);
    },
    requestBodies(...args) {
      return new ComponentsRequestBodies_default(...args);
    },
    headers(...args) {
      return new ComponentsHeaders_default(...args);
    },
    securitySchemes(...args) {
      return new ComponentsSecuritySchemes_default(...args);
    },
    links(...args) {
      return new ComponentsLinks_default(...args);
    },
    callbacks(...args) {
      return new ComponentsCallbacks_default(...args);
    },
    pathItems(...args) {
      return new ComponentsPathItems_default(...args);
    }
  },
  SecurityRequirementElement: {
    "[key: *]": function key31(...args) {
      return new import_minim10.ArrayElement(...args);
    }
  },
  TagElement: {
    externalDocs(...args) {
      return new ExternalDocumentation_default2(...args);
    }
  },
  SchemaElement: {
    $vocabulary(...args) {
      const element = new import_minim10.ObjectElement(...args);
      element.classes.push("json-schema-$vocabulary");
      return element;
    },
    $defs(...args) {
      const element = new import_minim10.ObjectElement(...args);
      element.classes.push("json-schema-$defs");
      return element;
    },
    allOf(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-allOf");
      return element;
    },
    anyOf(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-anyOf");
      return element;
    },
    oneOf(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-oneOf");
      return element;
    },
    not(...args) {
      return new Schema_default2(...args);
    },
    if(...args) {
      return new Schema_default2(...args);
    },
    then(...args) {
      return new Schema_default2(...args);
    },
    else(...args) {
      return new Schema_default2(...args);
    },
    dependentSchemas(...args) {
      const element = new import_minim10.ObjectElement(...args);
      element.classes.push("json-schema-dependentSchemas");
      return element;
    },
    prefixItems(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-prefixItems");
      return element;
    },
    items(...args) {
      return new Schema_default2(...args);
    },
    contains(...args) {
      return new Schema_default2(...args);
    },
    properties(...args) {
      const element = new import_minim10.ObjectElement(...args);
      element.classes.push("json-schema-properties");
      return element;
    },
    patternProperties(...args) {
      const element = new import_minim10.ObjectElement(...args);
      element.classes.push("json-schema-patternProperties");
      return element;
    },
    additionalProperties(...args) {
      return new Schema_default2(...args);
    },
    propertyNames(...args) {
      return new Schema_default2(...args);
    },
    unevaluatedItems(...args) {
      return new Schema_default2(...args);
    },
    unevaluatedProperties(...args) {
      return new Schema_default2(...args);
    },
    type(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-type");
      return element;
    },
    enum(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-enum");
      return element;
    },
    required(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-required");
      return element;
    },
    dependentRequired(...args) {
      const element = new import_minim10.ObjectElement(...args);
      element.classes.push("json-schema-dependentRequired");
      return element;
    },
    examples(...args) {
      const element = new import_minim10.ArrayElement(...args);
      element.classes.push("json-schema-examples");
      return element;
    },
    contentSchema(...args) {
      return new Schema_default2(...args);
    },
    discriminator(...args) {
      return new Discriminator_default2(...args);
    },
    xml(...args) {
      return new Xml_default2(...args);
    },
    externalDocs(...args) {
      return new ExternalDocumentation_default2(...args);
    }
  },
  DiscriminatorElement: {
    mapping(...args) {
      return new DiscriminatorMapping_default(...args);
    }
  },
  SecuritySchemeElement: {
    flows(...args) {
      return new OAuthFlows_default2(...args);
    }
  },
  OAuthFlowsElement: {
    implicit(...args) {
      return new OAuthFlow_default2(...args);
    },
    password(...args) {
      return new OAuthFlow_default2(...args);
    },
    clientCredentials(...args) {
      return new OAuthFlow_default2(...args);
    },
    authorizationCode(...args) {
      return new OAuthFlow_default2(...args);
    }
  },
  OAuthFlowElement: {
    scopes(...args) {
      return new OAuthFlowScopes_default(...args);
    }
  },
  // non-concrete types handling (NCEs)
  [Webhooks_default.primaryClass]: {
    "[key: *]": function key32(...args) {
      return new PathItem_default2(...args);
    }
  },
  [ServerVariables_default.primaryClass]: {
    "[key: *]": function key33(...args) {
      return new ServerVariable_default2(...args);
    }
  },
  [ComponentsSchemas_default.primaryClass]: {
    "[key: *]": function key34(...args) {
      return new Schema_default2(...args);
    }
  },
  [ComponentsResponses_default.primaryClass]: {
    "[key: *]": function key35(...args) {
      return new Response_default2(...args);
    }
  },
  [ComponentsParameters_default.primaryClass]: {
    "[key: *]": function key36(...args) {
      return new Parameter_default2(...args);
    }
  },
  [ComponentsExamples_default.primaryClass]: {
    "[key: *]": function key37(...args) {
      return new Example_default2(...args);
    }
  },
  [ComponentsRequestBodies_default.primaryClass]: {
    "[key: *]": function key38(...args) {
      return new RequestBody_default2(...args);
    }
  },
  [ComponentsHeaders_default.primaryClass]: {
    "[key: *]": function key39(...args) {
      return new Header_default2(...args);
    }
  },
  [ComponentsSecuritySchemes_default.primaryClass]: {
    "[key: *]": function key40(...args) {
      return new SecurityScheme_default2(...args);
    }
  },
  [ComponentsLinks_default.primaryClass]: {
    "[key: *]": function key41(...args) {
      return new Link_default2(...args);
    }
  },
  [ComponentsCallbacks_default.primaryClass]: {
    "[key: *]": function key42(...args) {
      return new Callback_default2(...args);
    }
  },
  [ComponentsPathItems_default.primaryClass]: {
    "[key: *]": function key43(...args) {
      return new PathItem_default2(...args);
    }
  },
  [OperationCallbacks_default.primaryClass]: {
    "[key: *]": function key44(...args) {
      return new Callback_default2(...args);
    }
  },
  [ParameterExamples_default.primaryClass]: {
    "[key: *]": function key45(...args) {
      return new Example_default2(...args);
    }
  },
  [ParameterContent_default.primaryClass]: {
    "[key: *]": function key46(...args) {
      return new MediaType_default2(...args);
    }
  },
  [RequestBodyContent_default.primaryClass]: {
    "[key: *]": function key47(...args) {
      return new MediaType_default2(...args);
    }
  },
  [MediaTypeExamples_default.primaryClass]: {
    "[key: *]": function key48(...args) {
      return new Example_default2(...args);
    }
  },
  [MediaTypeEncoding_default.primaryClass]: {
    "[key: *]": function key49(...args) {
      return new Encoding_default2(...args);
    }
  },
  [EncodingHeaders_default.primaryClass]: {
    "[key: *]": function key50(...args) {
      return new Header_default2(...args);
    }
  },
  [ResponseHeaders_default.primaryClass]: {
    "[key: *]": function key51(...args) {
      return new Header_default2(...args);
    }
  },
  [ResponseContent_default.primaryClass]: {
    "[key: *]": function key52(...args) {
      return new MediaType_default2(...args);
    }
  },
  [ResponseLinks_default.primaryClass]: {
    "[key: *]": function key53(...args) {
      return new Link_default2(...args);
    }
  },
  "json-schema-$defs": {
    "[key: *]": function key54(...args) {
      return new Schema_default2(...args);
    }
  },
  "json-schema-dependentSchemas": {
    "[key: *]": function key55(...args) {
      return new Schema_default2(...args);
    }
  },
  "json-schema-properties": {
    "[key: *]": function key56(...args) {
      return new Schema_default2(...args);
    }
  },
  [Servers_default.primaryClass]: {
    "<*>": (...args) => new Server_default2(...args)
  },
  [Security_default.primaryClass]: {
    "<*>": function asterisk13(...args) {
      return new SecurityRequirement_default2(...args);
    }
  },
  [Tags_default.primaryClass]: {
    "<*>": function asterisk14(...args) {
      return new Tag_default3(...args);
    }
  },
  [PathItemServers_default.primaryClass]: {
    "<*>": function asterisk15(...args) {
      return new Server_default2(...args);
    }
  },
  [PathItemParameters_default.primaryClass]: {
    "<*>": function asterisk16(...args) {
      return new Parameter_default2(...args);
    }
  },
  [OperationParameters_default.primaryClass]: {
    "<*>": function asterisk17(...args) {
      return new Parameter_default2(...args);
    }
  },
  [OperationSecurity_default.primaryClass]: {
    "<*>": function asterisk18(...args) {
      return new SecurityRequirement_default2(...args);
    }
  },
  [OperationServers_default.primaryClass]: {
    "<*>": function asterisk19(...args) {
      return new Server_default2(...args);
    }
  },
  "json-schema-allOf": {
    "<*>": function asterisk20(...args) {
      return new Schema_default2(...args);
    }
  },
  "json-schema-anyOf": {
    "<*>": function asterisk21(...args) {
      return new Schema_default2(...args);
    }
  },
  "json-schema-oneOf": {
    "<*>": function asterisk22(...args) {
      return new Schema_default2(...args);
    }
  },
  "json-schema-prefixItems": {
    "<*>": function asterisk23(...args) {
      return new Schema_default2(...args);
    }
  }
};

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/plugins/normalize-header-examples/NormalizeStorage.mjs
var NormalizeStorage = class {
  constructor(storageElement, storageField, storageSubField) {
    __publicField(this, "internalStore");
    this.storageElement = storageElement;
    this.storageField = storageField;
    this.storageSubField = storageSubField;
  }
  get store() {
    if (!this.internalStore) {
      let rootStore = this.storageElement.get(this.storageField);
      if (!isObjectElement(rootStore)) {
        rootStore = new import_minim10.ObjectElement();
        this.storageElement.set(this.storageField, rootStore);
      }
      let store = rootStore.get(this.storageSubField);
      if (!isArrayElement(store)) {
        store = new import_minim10.ArrayElement();
        rootStore.set(this.storageSubField, store);
      }
      this.internalStore = store;
    }
    return this.internalStore;
  }
  append(pointer) {
    if (!this.includes(pointer)) {
      this.store.push(pointer);
    }
  }
  includes(pointer) {
    return this.store.includes(pointer);
  }
};
var NormalizeStorage_default = NormalizeStorage;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/plugins/normalize-parameters.mjs
var plugin2 = ({
  storageField = "x-normalized"
} = {}) => (toolbox) => {
  const {
    predicates,
    ancestorLineageToJSONPointer: ancestorLineageToJSONPointer2
  } = toolbox;
  const parameterEquals = (parameter1, parameter2) => {
    if (!predicates.isParameterElement(parameter1)) return false;
    if (!predicates.isParameterElement(parameter2)) return false;
    if (!predicates.isStringElement(parameter1.name)) return false;
    if (!predicates.isStringElement(parameter1.in)) return false;
    if (!predicates.isStringElement(parameter2.name)) return false;
    if (!predicates.isStringElement(parameter2.in)) return false;
    return value_default(parameter1.name) === value_default(parameter2.name) && value_default(parameter1.in) === value_default(parameter2.in);
  };
  const pathItemParameters = [];
  let storage;
  return {
    visitor: {
      OpenApi3_1Element: {
        enter(element) {
          storage = new NormalizeStorage_default(element, storageField, "parameters");
        },
        leave() {
          storage = void 0;
        }
      },
      PathItemElement: {
        enter(pathItemElement, key57, parent, path4, ancestors) {
          if (ancestors.some(predicates.isComponentsElement)) {
            return;
          }
          const {
            parameters
          } = pathItemElement;
          if (predicates.isArrayElement(parameters)) {
            pathItemParameters.push([...parameters.content]);
          } else {
            pathItemParameters.push([]);
          }
        },
        leave() {
          pathItemParameters.pop();
        }
      },
      OperationElement: {
        leave(operationElement, key57, parent, path4, ancestors) {
          const parentPathItemParameters = last_default(pathItemParameters);
          if (!Array.isArray(parentPathItemParameters) || parentPathItemParameters.length === 0) {
            return;
          }
          const operationJSONPointer = ancestorLineageToJSONPointer2([...ancestors, parent, operationElement]);
          if (storage.includes(operationJSONPointer)) {
            return;
          }
          const operationParameters = pathOr_default([], ["parameters", "content"], operationElement);
          const mergedParameters = uniqWith_default(parameterEquals, [...operationParameters, ...parentPathItemParameters]);
          operationElement.parameters = new OperationParameters_default(mergedParameters);
          storage.append(operationJSONPointer);
        }
      }
    }
  };
};
var normalize_parameters_default = plugin2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/plugins/normalize-security-requirements.mjs
var plugin3 = ({
  storageField = "x-normalized"
} = {}) => (toolbox) => {
  const {
    predicates,
    ancestorLineageToJSONPointer: ancestorLineageToJSONPointer2
  } = toolbox;
  let topLevelSecurity;
  let storage;
  return {
    visitor: {
      OpenApi3_1Element: {
        enter(openapiElement) {
          storage = new NormalizeStorage_default(openapiElement, storageField, "security-requirements");
          if (predicates.isArrayElement(openapiElement.security)) {
            topLevelSecurity = openapiElement.security;
          }
        },
        leave() {
          storage = void 0;
          topLevelSecurity = void 0;
        }
      },
      OperationElement: {
        leave(operationElement, key57, parent, path4, ancestors) {
          if (ancestors.some(predicates.isComponentsElement)) {
            return;
          }
          const operationJSONPointer = ancestorLineageToJSONPointer2([...ancestors, parent, operationElement]);
          if (storage.includes(operationJSONPointer)) {
            return;
          }
          const missingOperationLevelSecurity = typeof operationElement.security === "undefined";
          const hasTopLevelSecurity = typeof topLevelSecurity !== "undefined";
          if (missingOperationLevelSecurity && hasTopLevelSecurity) {
            var _topLevelSecurity;
            operationElement.security = new OperationSecurity_default((_topLevelSecurity = topLevelSecurity) === null || _topLevelSecurity === void 0 ? void 0 : _topLevelSecurity.content);
            storage.append(operationJSONPointer);
          }
        }
      }
    }
  };
};
var normalize_security_requirements_default = plugin3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/plugins/normalize-operation-ids.mjs
var removeSpaces = (operationId) => {
  return operationId.replace(/\s/g, "");
};
var replaceSpecialCharsWithUnderscore2 = (operationId) => {
  return operationId.replace(/\W/gi, "_");
};
var createNormalizedOperationId = (path4, method) => {
  const normalizedMethod = replaceSpecialCharsWithUnderscore2(removeSpaces(method.toLowerCase()));
  const normalizedPath = replaceSpecialCharsWithUnderscore2(removeSpaces(path4));
  return `${normalizedMethod}${normalizedPath}`;
};
var normalizeOperationId = (operationId, path4, method) => {
  const withoutSpaces = removeSpaces(operationId);
  if (withoutSpaces.length > 0) {
    return replaceSpecialCharsWithUnderscore2(withoutSpaces);
  }
  return createNormalizedOperationId(path4, method);
};
var plugin4 = ({
  storageField = "x-normalized",
  operationIdNormalizer = normalizeOperationId
} = {}) => (toolbox) => {
  const {
    predicates,
    ancestorLineageToJSONPointer: ancestorLineageToJSONPointer2,
    namespace: namespace2
  } = toolbox;
  const pathTemplates = [];
  const normalizedOperations = [];
  const links2 = [];
  let storage;
  return {
    visitor: {
      OpenApi3_1Element: {
        enter(element) {
          storage = new NormalizeStorage_default(element, storageField, "operation-ids");
        },
        leave() {
          const normalizedOperationGroups = groupBy_default((operationElement) => {
            return value_default(operationElement.operationId);
          }, normalizedOperations);
          Object.entries(normalizedOperationGroups).forEach(([normalizedOperationId, operationElements]) => {
            if (!Array.isArray(operationElements)) return;
            if (operationElements.length <= 1) return;
            operationElements.forEach((operationElement, index) => {
              const indexedNormalizedOperationId = `${normalizedOperationId}${index + 1}`;
              operationElement.operationId = new namespace2.elements.String(indexedNormalizedOperationId);
            });
          });
          links2.forEach((linkElement) => {
            if (typeof linkElement.operationId === "undefined") return;
            const linkOperationId = String(value_default(linkElement.operationId));
            const operationElement = normalizedOperations.find((normalizedOperationElement) => {
              const originalOperationId = value_default(normalizedOperationElement.meta.get("originalOperationId"));
              return originalOperationId === linkOperationId;
            });
            if (typeof operationElement === "undefined") return;
            linkElement.operationId = cloneDeep.safe(operationElement.operationId);
            linkElement.meta.set("originalOperationId", linkOperationId);
            linkElement.set("__originalOperationId", linkOperationId);
          });
          normalizedOperations.length = 0;
          links2.length = 0;
          storage = void 0;
        }
      },
      PathItemElement: {
        enter(pathItemElement) {
          const pathTemplate2 = defaultTo_default("path", value_default(pathItemElement.meta.get("path")));
          pathTemplates.push(pathTemplate2);
        },
        leave() {
          pathTemplates.pop();
        }
      },
      OperationElement: {
        enter(operationElement, key57, parent, path4, ancestors) {
          if (typeof operationElement.operationId === "undefined") return;
          const operationJSONPointer = ancestorLineageToJSONPointer2([...ancestors, parent, operationElement]);
          if (storage.includes(operationJSONPointer)) {
            return;
          }
          const originalOperationId = String(value_default(operationElement.operationId));
          const pathTemplate2 = last_default(pathTemplates);
          const method = defaultTo_default("method", value_default(operationElement.meta.get("http-method")));
          const normalizedOperationId = operationIdNormalizer(originalOperationId, pathTemplate2, method);
          if (originalOperationId === normalizedOperationId) return;
          operationElement.operationId = new namespace2.elements.String(normalizedOperationId);
          operationElement.set("__originalOperationId", originalOperationId);
          operationElement.meta.set("originalOperationId", originalOperationId);
          normalizedOperations.push(operationElement);
          storage.append(operationJSONPointer);
        }
      },
      LinkElement: {
        leave(linkElement) {
          if (!predicates.isLinkElement(linkElement)) return;
          if (typeof linkElement.operationId === "undefined") return;
          links2.push(linkElement);
        }
      }
    }
  };
};
var normalize_operation_ids_default = plugin4;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/plugins/normalize-parameter-examples.mjs
var plugin5 = ({
  storageField = "x-normalized"
} = {}) => (toolbox) => {
  const {
    predicates,
    ancestorLineageToJSONPointer: ancestorLineageToJSONPointer2
  } = toolbox;
  let storage;
  return {
    visitor: {
      OpenApi3_1Element: {
        enter(element) {
          storage = new NormalizeStorage_default(element, storageField, "parameter-examples");
        },
        leave() {
          storage = void 0;
        }
      },
      ParameterElement: {
        leave(parameterElement, key57, parent, path4, ancestors) {
          var _parameterElement$sch, _parameterElement$sch2;
          if (ancestors.some(predicates.isComponentsElement)) {
            return;
          }
          if (typeof parameterElement.schema === "undefined" || !predicates.isSchemaElement(parameterElement.schema)) {
            return;
          }
          if (typeof ((_parameterElement$sch = parameterElement.schema) === null || _parameterElement$sch === void 0 ? void 0 : _parameterElement$sch.example) === "undefined" && typeof ((_parameterElement$sch2 = parameterElement.schema) === null || _parameterElement$sch2 === void 0 ? void 0 : _parameterElement$sch2.examples) === "undefined") {
            return;
          }
          const parameterJSONPointer = ancestorLineageToJSONPointer2([...ancestors, parent, parameterElement]);
          if (storage.includes(parameterJSONPointer)) {
            return;
          }
          if (typeof parameterElement.examples !== "undefined" && predicates.isObjectElement(parameterElement.examples)) {
            const examples = parameterElement.examples.map((example) => {
              return cloneDeep.safe(example.value);
            });
            if (typeof parameterElement.schema.examples !== "undefined") {
              parameterElement.schema.set("examples", examples);
              storage.append(parameterJSONPointer);
            }
            if (typeof parameterElement.schema.example !== "undefined") {
              parameterElement.schema.set("example", examples[0]);
              storage.append(parameterJSONPointer);
            }
            return;
          }
          if (typeof parameterElement.example !== "undefined") {
            if (typeof parameterElement.schema.examples !== "undefined") {
              parameterElement.schema.set("examples", [cloneDeep(parameterElement.example)]);
              storage.append(parameterJSONPointer);
            }
            if (typeof parameterElement.schema.example !== "undefined") {
              parameterElement.schema.set("example", cloneDeep(parameterElement.example));
              storage.append(parameterJSONPointer);
            }
          }
        }
      }
    }
  };
};
var normalize_parameter_examples_default = plugin5;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/plugins/normalize-header-examples/index.mjs
var plugin6 = ({
  storageField = "x-normalized"
} = {}) => (toolbox) => {
  const {
    predicates,
    ancestorLineageToJSONPointer: ancestorLineageToJSONPointer2
  } = toolbox;
  let storage;
  return {
    visitor: {
      OpenApi3_1Element: {
        enter(element) {
          storage = new NormalizeStorage_default(element, storageField, "header-examples");
        },
        leave() {
          storage = void 0;
        }
      },
      HeaderElement: {
        leave(headerElement, key57, parent, path4, ancestors) {
          var _headerElement$schema, _headerElement$schema2;
          if (ancestors.some(predicates.isComponentsElement)) {
            return;
          }
          if (typeof headerElement.schema === "undefined" || !predicates.isSchemaElement(headerElement.schema)) {
            return;
          }
          if (typeof ((_headerElement$schema = headerElement.schema) === null || _headerElement$schema === void 0 ? void 0 : _headerElement$schema.example) === "undefined" && typeof ((_headerElement$schema2 = headerElement.schema) === null || _headerElement$schema2 === void 0 ? void 0 : _headerElement$schema2.examples) === "undefined") {
            return;
          }
          const headerJSONPointer = ancestorLineageToJSONPointer2([...ancestors, parent, headerElement]);
          if (storage.includes(headerJSONPointer)) {
            return;
          }
          if (typeof headerElement.examples !== "undefined" && predicates.isObjectElement(headerElement.examples)) {
            const examples = headerElement.examples.map((example) => {
              return cloneDeep.safe(example.value);
            });
            if (typeof headerElement.schema.examples !== "undefined") {
              headerElement.schema.set("examples", examples);
              storage.append(headerJSONPointer);
            }
            if (typeof headerElement.schema.example !== "undefined") {
              headerElement.schema.set("example", examples[0]);
              storage.append(headerJSONPointer);
            }
            return;
          }
          if (typeof headerElement.example !== "undefined") {
            if (typeof headerElement.schema.examples !== "undefined") {
              headerElement.schema.set("examples", [cloneDeep(headerElement.example)]);
              storage.append(headerJSONPointer);
            }
            if (typeof headerElement.schema.example !== "undefined") {
              headerElement.schema.set("example", cloneDeep(headerElement.example));
              storage.append(headerJSONPointer);
            }
          }
        }
      }
    }
  };
};
var normalize_header_examples_default = plugin6;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/predicates.mjs
var predicates_exports4 = {};
__export(predicates_exports4, {
  isBooleanJsonSchemaElement: () => isBooleanJsonSchemaElement2,
  isCallbackElement: () => isCallbackElement2,
  isComponentsElement: () => isComponentsElement2,
  isContactElement: () => isContactElement2,
  isExampleElement: () => isExampleElement2,
  isExternalDocumentationElement: () => isExternalDocumentationElement2,
  isHeaderElement: () => isHeaderElement2,
  isInfoElement: () => isInfoElement2,
  isJsonSchemaDialectElement: () => isJsonSchemaDialectElement,
  isLicenseElement: () => isLicenseElement2,
  isLinkElement: () => isLinkElement3,
  isMediaTypeElement: () => isMediaTypeElement2,
  isOpenApi3_1Element: () => isOpenApi3_1Element,
  isOpenapiElement: () => isOpenapiElement2,
  isOperationElement: () => isOperationElement2,
  isParameterElement: () => isParameterElement2,
  isPathItemElement: () => isPathItemElement2,
  isPathItemElementExternal: () => isPathItemElementExternal,
  isPathsElement: () => isPathsElement2,
  isReferenceElement: () => isReferenceElement2,
  isReferenceElementExternal: () => isReferenceElementExternal,
  isRequestBodyElement: () => isRequestBodyElement2,
  isResponseElement: () => isResponseElement2,
  isResponsesElement: () => isResponsesElement2,
  isSchemaElement: () => isSchemaElement2,
  isSecurityRequirementElement: () => isSecurityRequirementElement2,
  isSecuritySchemeElement: () => isSecuritySchemeElement2,
  isServerElement: () => isServerElement2,
  isServerVariableElement: () => isServerVariableElement2
});
var isCallbackElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Callback_default2 || hasBasicElementProps2(element) && isElementType2("callback", element) && primitiveEq2("object", element);
});
var isComponentsElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Components_default2 || hasBasicElementProps2(element) && isElementType2("components", element) && primitiveEq2("object", element);
});
var isContactElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Contact_default2 || hasBasicElementProps2(element) && isElementType2("contact", element) && primitiveEq2("object", element);
});
var isExampleElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Example_default2 || hasBasicElementProps2(element) && isElementType2("example", element) && primitiveEq2("object", element);
});
var isExternalDocumentationElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof ExternalDocumentation_default2 || hasBasicElementProps2(element) && isElementType2("externalDocumentation", element) && primitiveEq2("object", element);
});
var isHeaderElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Header_default2 || hasBasicElementProps2(element) && isElementType2("header", element) && primitiveEq2("object", element);
});
var isInfoElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Info_default2 || hasBasicElementProps2(element) && isElementType2("info", element) && primitiveEq2("object", element);
});
var isJsonSchemaDialectElement = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof JsonSchemaDialect_default || hasBasicElementProps2(element) && isElementType2("jsonSchemaDialect", element) && primitiveEq2("string", element);
});
var isLicenseElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof License_default2 || hasBasicElementProps2(element) && isElementType2("license", element) && primitiveEq2("object", element);
});
var isLinkElement3 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Link_default2 || hasBasicElementProps2(element) && isElementType2("link", element) && primitiveEq2("object", element);
});
var isOpenapiElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Openapi_default2 || hasBasicElementProps2(element) && isElementType2("openapi", element) && primitiveEq2("string", element);
});
var isOpenApi3_1Element = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2,
  hasClass: hasClass2
}) => {
  return (element) => element instanceof OpenApi3_1_default || hasBasicElementProps2(element) && isElementType2("openApi3_1", element) && primitiveEq2("object", element) && hasClass2("api", element);
});
var isOperationElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Operation_default2 || hasBasicElementProps2(element) && isElementType2("operation", element) && primitiveEq2("object", element);
});
var isParameterElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Parameter_default2 || hasBasicElementProps2(element) && isElementType2("parameter", element) && primitiveEq2("object", element);
});
var isPathItemElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof PathItem_default2 || hasBasicElementProps2(element) && isElementType2("pathItem", element) && primitiveEq2("object", element);
});
var isPathItemElementExternal = (element) => {
  if (!isPathItemElement2(element)) {
    return false;
  }
  if (!isStringElement(element.$ref)) {
    return false;
  }
  const value = value_default(element.$ref);
  return typeof value === "string" && value.length > 0 && !value.startsWith("#");
};
var isPathsElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Paths_default2 || hasBasicElementProps2(element) && isElementType2("paths", element) && primitiveEq2("object", element);
});
var isReferenceElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Reference_default3 || hasBasicElementProps2(element) && isElementType2("reference", element) && primitiveEq2("object", element);
});
var isReferenceElementExternal = (element) => {
  if (!isReferenceElement2(element)) {
    return false;
  }
  if (!isStringElement(element.$ref)) {
    return false;
  }
  const value = value_default(element.$ref);
  return typeof value === "string" && value.length > 0 && !value.startsWith("#");
};
var isRequestBodyElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof RequestBody_default2 || hasBasicElementProps2(element) && isElementType2("requestBody", element) && primitiveEq2("object", element);
});
var isResponseElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Response_default2 || hasBasicElementProps2(element) && isElementType2("response", element) && primitiveEq2("object", element);
});
var isResponsesElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Responses_default2 || hasBasicElementProps2(element) && isElementType2("responses", element) && primitiveEq2("object", element);
});
var isSchemaElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Schema_default2 || hasBasicElementProps2(element) && isElementType2("schema", element) && primitiveEq2("object", element);
});
var isBooleanJsonSchemaElement2 = (element) => {
  return isBooleanElement(element) && element.classes.includes("boolean-json-schema");
};
var isSecurityRequirementElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof SecurityRequirement_default2 || hasBasicElementProps2(element) && isElementType2("securityRequirement", element) && primitiveEq2("object", element);
});
var isSecuritySchemeElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof SecurityScheme_default2 || hasBasicElementProps2(element) && isElementType2("securityScheme", element) && primitiveEq2("object", element);
});
var isServerElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof Server_default2 || hasBasicElementProps2(element) && isElementType2("server", element) && primitiveEq2("object", element);
});
var isServerVariableElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof ServerVariable_default2 || hasBasicElementProps2(element) && isElementType2("serverVariable", element) && primitiveEq2("object", element);
});
var isMediaTypeElement2 = helpers_default(({
  hasBasicElementProps: hasBasicElementProps2,
  isElementType: isElementType2,
  primitiveEq: primitiveEq2
}) => {
  return (element) => element instanceof MediaType_default2 || hasBasicElementProps2(element) && isElementType2("mediaType", element) && primitiveEq2("object", element);
});

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/toolbox.mjs
var ancestorLineageToJSONPointer = (elementPath) => {
  const jsonPointerTokens = elementPath.reduce((path4, element, index) => {
    if (isMemberElement(element)) {
      const token = String(value_default(element.key));
      path4.push(token);
    } else if (isArrayElement(elementPath[index - 2])) {
      const token = String(elementPath[index - 2].content.indexOf(element));
      path4.push(token);
    }
    return path4;
  }, []);
  return compile_default(jsonPointerTokens);
};
var createToolbox4 = () => {
  const namespace2 = createNamespace(namespace_default4);
  const predicates = {
    ...predicates_exports4,
    isElement,
    isStringElement,
    isArrayElement,
    isObjectElement,
    isMemberElement,
    isServersElement,
    includesClasses,
    hasElementSourceMap
  };
  return {
    predicates,
    ancestorLineageToJSONPointer,
    namespace: namespace2
  };
};
var toolbox_default4 = createToolbox4;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/index.mjs
var OpenApi3_1Visitor = class extends Mixin(FixedFieldsVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new OpenApi3_1_default();
    this.specPath = always_default(["document", "objects", "OpenApi"]);
    this.canSupportSpecificationExtensions = true;
    this.openApiSemanticElement = this.element;
  }
  ObjectElement(objectElement) {
    this.openApiGenericElement = objectElement;
    return FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
  }
};
var open_api_3_1_default = OpenApi3_1Visitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/info/index.mjs
var BaseInfoVisitor = specification_default2.visitors.document.objects.Info.$visitor;
var InfoVisitor2 = class extends BaseInfoVisitor {
  constructor(options) {
    super(options);
    this.element = new Info_default2();
  }
};
var info_default2 = InfoVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/contact/index.mjs
var BaseContactVisitor = specification_default2.visitors.document.objects.Contact.$visitor;
var ContactVisitor2 = class extends BaseContactVisitor {
  constructor(options) {
    super(options);
    this.element = new Contact_default2();
  }
};
var contact_default2 = ContactVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/license/index.mjs
var BaseLicenseVisitor = specification_default2.visitors.document.objects.License.$visitor;
var LicenseVisitor2 = class extends BaseLicenseVisitor {
  constructor(options) {
    super(options);
    this.element = new License_default2();
  }
};
var license_default2 = LicenseVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/link/index.mjs
var BaseLinkVisitor = specification_default2.visitors.document.objects.Link.$visitor;
var LinkVisitor2 = class extends BaseLinkVisitor {
  constructor(options) {
    super(options);
    this.element = new Link_default2();
  }
};
var link_default2 = LinkVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/JsonSchemaDialectVisitor.mjs
var JsonSchemaDialectVisitor = class extends Mixin(SpecificationVisitor_default2, FallbackVisitor_default2) {
  StringElement(stringElement) {
    const jsonSchemaDialectElement = new JsonSchemaDialect_default(value_default(stringElement));
    this.copyMetaAndAttributes(stringElement, jsonSchemaDialectElement);
    this.element = jsonSchemaDialectElement;
    return BREAK;
  }
};
var JsonSchemaDialectVisitor_default = JsonSchemaDialectVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/server/index.mjs
var BaseServerVisitor = specification_default2.visitors.document.objects.Server.$visitor;
var ServerVisitor2 = class extends BaseServerVisitor {
  constructor(options) {
    super(options);
    this.element = new Server_default2();
  }
};
var server_default2 = ServerVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/server-variable/index.mjs
var BaseServerVariableVisitor = specification_default2.visitors.document.objects.ServerVariable.$visitor;
var ServerVariableVisitor2 = class extends BaseServerVariableVisitor {
  constructor(options) {
    super(options);
    this.element = new ServerVariable_default2();
  }
};
var server_variable_default2 = ServerVariableVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/media-type/index.mjs
var BaseMediaTypeVisitor = specification_default2.visitors.document.objects.MediaType.$visitor;
var MediaTypeVisitor2 = class extends BaseMediaTypeVisitor {
  constructor(options) {
    super(options);
    this.element = new MediaType_default2();
  }
};
var media_type_default2 = MediaTypeVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/security-requirement/index.mjs
var BaseSecurityRequirementVisitor = specification_default2.visitors.document.objects.SecurityRequirement.$visitor;
var SecurityRequirementVisitor2 = class extends BaseSecurityRequirementVisitor {
  constructor(options) {
    super(options);
    this.element = new SecurityRequirement_default2();
  }
};
var security_requirement_default2 = SecurityRequirementVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/components/index.mjs
var BaseComponentsVisitor = specification_default2.visitors.document.objects.Components.$visitor;
var ComponentsVisitor2 = class extends BaseComponentsVisitor {
  constructor(options) {
    super(options);
    this.element = new Components_default2();
  }
};
var components_default2 = ComponentsVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/tag/index.mjs
var BaseTagVisitor = specification_default2.visitors.document.objects.Tag.$visitor;
var TagVisitor2 = class extends BaseTagVisitor {
  constructor(options) {
    super(options);
    this.element = new Tag_default3();
  }
};
var tag_default2 = TagVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/reference/index.mjs
var BaseReferenceVisitor = specification_default2.visitors.document.objects.Reference.$visitor;
var ReferenceVisitor2 = class extends BaseReferenceVisitor {
  constructor(options) {
    super(options);
    this.element = new Reference_default3();
  }
};
var reference_default2 = ReferenceVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/parameter/index.mjs
var BaseParameterVisitor = specification_default2.visitors.document.objects.Parameter.$visitor;
var ParameterVisitor2 = class extends BaseParameterVisitor {
  constructor(options) {
    super(options);
    this.element = new Parameter_default2();
  }
};
var parameter_default2 = ParameterVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/header/index.mjs
var BaseHeaderVisitor = specification_default2.visitors.document.objects.Header.$visitor;
var HeaderVisitor2 = class extends BaseHeaderVisitor {
  constructor(options) {
    super(options);
    this.element = new Header_default2();
  }
};
var header_default2 = HeaderVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/ParentSchemaAwareVisitor.mjs
var ParentSchemaAwareVisitor2 = class {
  constructor({
    parent
  }) {
    __publicField(this, "parent");
    this.parent = parent;
  }
};
var ParentSchemaAwareVisitor_default2 = ParentSchemaAwareVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/index.mjs
var SchemaVisitor5 = class extends Mixin(FixedFieldsVisitor_default2, ParentSchemaAwareVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Schema_default2();
    this.specPath = always_default(["document", "objects", "Schema"]);
    this.canSupportSpecificationExtensions = true;
    this.jsonSchemaDefaultDialect = JsonSchemaDialect_default.default;
    this.passingOptionsNames.push("parent");
  }
  ObjectElement(objectElement) {
    this.handle$schema(objectElement);
    this.handle$id(objectElement);
    this.parent = this.element;
    const result = FixedFieldsVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    if (isStringElement(this.element.$ref)) {
      this.element.classes.push("reference-element");
      this.element.setMetaProperty("referenced-element", "schema");
    }
    return result;
  }
  BooleanElement(booleanElement) {
    const result = super.enter(booleanElement);
    this.element.classes.push("boolean-json-schema");
    return result;
  }
  /**
   * This function depends on some external context, so we need to make sure this function
   * works even when no context is provided like when directly refracting generic Object Element
   * into Schema Element: `SchemaElement.refract(new ObjectElement({ type: 'object' });`
   */
  getJsonSchemaDialect() {
    let jsonSchemaDialect;
    if (this.openApiSemanticElement !== void 0 && // @ts-ignore
    isJsonSchemaDialectElement(this.openApiSemanticElement.jsonSchemaDialect)) {
      jsonSchemaDialect = value_default(this.openApiSemanticElement.jsonSchemaDialect);
    } else if (this.openApiGenericElement !== void 0 && isStringElement(this.openApiGenericElement.get("jsonSchemaDialect"))) {
      jsonSchemaDialect = value_default(this.openApiGenericElement.get("jsonSchemaDialect"));
    } else {
      jsonSchemaDialect = value_default(this.jsonSchemaDefaultDialect);
    }
    return jsonSchemaDialect;
  }
  handle$schema(objectElement) {
    if (isUndefined_default(this.parent) && !isStringElement(objectElement.get("$schema"))) {
      this.element.setMetaProperty("inherited$schema", this.getJsonSchemaDialect());
    } else if (isSchemaElement2(this.parent) && !isStringElement(objectElement.get("$schema"))) {
      const inherited$schema = defaultTo_default(value_default(this.parent.meta.get("inherited$schema")), value_default(this.parent.$schema));
      this.element.setMetaProperty("inherited$schema", inherited$schema);
    }
  }
  handle$id(objectElement) {
    const inherited$id = this.parent !== void 0 ? cloneDeep(this.parent.getMetaProperty("inherited$id", [])) : new import_minim10.ArrayElement();
    const $id = value_default(objectElement.get("$id"));
    if (isNonEmptyString_default($id)) {
      inherited$id.push($id);
    }
    this.element.setMetaProperty("inherited$id", inherited$id);
  }
};
var schema_default2 = SchemaVisitor5;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/$vocabularyVisitor.mjs
var $vocabularyVisitor = class extends FallbackVisitor_default2 {
  ObjectElement(objectElement) {
    const result = super.enter(objectElement);
    this.element.classes.push("json-schema-$vocabulary");
    return result;
  }
};
var vocabularyVisitor_default = $vocabularyVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/$refVisitor.mjs
var $refVisitor = class extends FallbackVisitor_default2 {
  StringElement(stringElement) {
    const result = super.enter(stringElement);
    this.element.classes.push("reference-value");
    return result;
  }
};
var refVisitor_default = $refVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/$defsVisitor.mjs
var $defsVisitor = class extends Mixin(MapVisitor_default2, ParentSchemaAwareVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("json-schema-$defs");
    this.specPath = always_default(["document", "objects", "Schema"]);
    this.passingOptionsNames.push("parent");
  }
};
var defsVisitor_default = $defsVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/AllOfVisitor.mjs
var AllOfVisitor3 = class extends Mixin(SpecificationVisitor_default2, ParentSchemaAwareVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("json-schema-allOf");
    this.passingOptionsNames.push("parent");
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      if (isObjectElement(item)) {
        const schemaElement = this.toRefractedElement(["document", "objects", "Schema"], item);
        this.element.push(schemaElement);
      } else {
        const element = cloneDeep(item);
        this.element.push(element);
      }
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var AllOfVisitor_default3 = AllOfVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/AnyOfVisitor.mjs
var AnyOfVisitor3 = class extends Mixin(SpecificationVisitor_default2, ParentSchemaAwareVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("json-schema-anyOf");
    this.passingOptionsNames.push("parent");
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      if (isObjectElement(item)) {
        const schemaElement = this.toRefractedElement(["document", "objects", "Schema"], item);
        this.element.push(schemaElement);
      } else {
        const element = cloneDeep(item);
        this.element.push(element);
      }
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var AnyOfVisitor_default3 = AnyOfVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/OneOfVisitor.mjs
var OneOfVisitor3 = class extends Mixin(SpecificationVisitor_default2, ParentSchemaAwareVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("json-schema-oneOf");
    this.passingOptionsNames.push("parent");
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      if (isObjectElement(item)) {
        const schemaElement = this.toRefractedElement(["document", "objects", "Schema"], item);
        this.element.push(schemaElement);
      } else {
        const element = cloneDeep(item);
        this.element.push(element);
      }
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var OneOfVisitor_default3 = OneOfVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/DependentSchemasVisitor.mjs
var DependentSchemasVisitor = class extends Mixin(MapVisitor_default2, ParentSchemaAwareVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("json-schema-dependentSchemas");
    this.specPath = always_default(["document", "objects", "Schema"]);
    this.passingOptionsNames.push("parent");
  }
};
var DependentSchemasVisitor_default = DependentSchemasVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/PrefixItemsVisitor.mjs
var PrefixItemsVisitor = class extends Mixin(SpecificationVisitor_default2, ParentSchemaAwareVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ArrayElement();
    this.element.classes.push("json-schema-prefixItems");
    this.passingOptionsNames.push("parent");
  }
  ArrayElement(arrayElement) {
    arrayElement.forEach((item) => {
      if (isObjectElement(item)) {
        const schemaElement = this.toRefractedElement(["document", "objects", "Schema"], item);
        this.element.push(schemaElement);
      } else {
        const element = cloneDeep(item);
        this.element.push(element);
      }
    });
    this.copyMetaAndAttributes(arrayElement, this.element);
    return BREAK;
  }
};
var PrefixItemsVisitor_default = PrefixItemsVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/PropertiesVisitor.mjs
var PropertiesVisitor3 = class extends Mixin(MapVisitor_default2, ParentSchemaAwareVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("json-schema-properties");
    this.specPath = always_default(["document", "objects", "Schema"]);
    this.passingOptionsNames.push("parent");
  }
};
var PropertiesVisitor_default3 = PropertiesVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/PatternPropertiesVisitor.mjs
var PatternPropertiesVisitor2 = class extends Mixin(MapVisitor_default2, ParentSchemaAwareVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new import_minim10.ObjectElement();
    this.element.classes.push("json-schema-patternProperties");
    this.specPath = always_default(["document", "objects", "Schema"]);
    this.passingOptionsNames.push("parent");
  }
};
var PatternPropertiesVisitor_default2 = PatternPropertiesVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/TypeVisitor.mjs
var TypeVisitor3 = class extends FallbackVisitor_default2 {
  StringElement(stringElement) {
    const result = super.enter(stringElement);
    this.element.classes.push("json-schema-type");
    return result;
  }
  ArrayElement(arrayElement) {
    const result = super.enter(arrayElement);
    this.element.classes.push("json-schema-type");
    return result;
  }
};
var TypeVisitor_default3 = TypeVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/EnumVisitor.mjs
var EnumVisitor2 = class extends FallbackVisitor_default2 {
  ArrayElement(arrayElement) {
    const result = super.enter(arrayElement);
    this.element.classes.push("json-schema-enum");
    return result;
  }
};
var EnumVisitor_default2 = EnumVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/DependentRequiredVisitor.mjs
var DependentRequiredVisitor = class extends FallbackVisitor_default2 {
  ObjectElement(objectElement) {
    const result = super.enter(objectElement);
    this.element.classes.push("json-schema-dependentRequired");
    return result;
  }
};
var DependentRequiredVisitor_default = DependentRequiredVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/schema/ExamplesVisitor.mjs
var ExamplesVisitor6 = class extends FallbackVisitor_default2 {
  ArrayElement(arrayElement) {
    const result = super.enter(arrayElement);
    this.element.classes.push("json-schema-examples");
    return result;
  }
};
var ExamplesVisitor_default6 = ExamplesVisitor6;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/distriminator/index.mjs
var BaseDiscriminatorVisitor = specification_default2.visitors.document.objects.Discriminator.$visitor;
var DiscriminatorVisitor2 = class extends BaseDiscriminatorVisitor {
  constructor(options) {
    super(options);
    this.element = new Discriminator_default2();
    this.canSupportSpecificationExtensions = true;
  }
};
var distriminator_default2 = DiscriminatorVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/xml/index.mjs
var BaseXMLVisitor = specification_default2.visitors.document.objects.XML.$visitor;
var XmlVisitor2 = class extends BaseXMLVisitor {
  constructor(options) {
    super(options);
    this.element = new Xml_default2();
  }
};
var xml_default2 = XmlVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/components/SchemasVisitor.mjs
var SchemasVisitor2 = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsSchemas_default();
    this.specPath = always_default(["document", "objects", "Schema"]);
  }
};
var SchemasVisitor_default2 = SchemasVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/components/PathItemsVisitor.mjs
var PathItemsVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new ComponentsPathItems_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "PathItem"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement2).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "pathItem");
    });
    return result;
  }
};
var PathItemsVisitor_default = PathItemsVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/example/index.mjs
var BaseExampleVisitor = specification_default2.visitors.document.objects.Example.$visitor;
var ExampleVisitor2 = class extends BaseExampleVisitor {
  constructor(options) {
    super(options);
    this.element = new Example_default2();
  }
};
var example_default2 = ExampleVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/external-documentation/index.mjs
var BaseExternalDocumentationVisitor = specification_default2.visitors.document.objects.ExternalDocumentation.$visitor;
var ExternalDocumentationVisitor2 = class extends BaseExternalDocumentationVisitor {
  constructor(options) {
    super(options);
    this.element = new ExternalDocumentation_default2();
  }
};
var external_documentation_default2 = ExternalDocumentationVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/encoding/index.mjs
var BaseEncodingVisitor = specification_default2.visitors.document.objects.Encoding.$visitor;
var EncodingVisitor3 = class extends BaseEncodingVisitor {
  constructor(options) {
    super(options);
    this.element = new Encoding_default2();
  }
};
var encoding_default2 = EncodingVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/paths/index.mjs
var BasePathsVisitor = specification_default2.visitors.document.objects.Paths.$visitor;
var PathsVisitor2 = class extends BasePathsVisitor {
  constructor(options) {
    super(options);
    this.element = new Paths_default2();
  }
};
var paths_default4 = PathsVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/request-body/index.mjs
var BaseRequestBodyVisitor = specification_default2.visitors.document.objects.RequestBody.$visitor;
var RequestBodyVisitor3 = class extends BaseRequestBodyVisitor {
  constructor(options) {
    super(options);
    this.element = new RequestBody_default2();
  }
};
var request_body_default2 = RequestBodyVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/callback/index.mjs
var BaseCallbackVisitor = specification_default2.visitors.document.objects.Callback.$visitor;
var CallbackVisitor2 = class extends BaseCallbackVisitor {
  constructor(options) {
    super(options);
    this.element = new Callback_default2();
    this.specPath = (element) => {
      return isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "PathItem"];
    };
  }
  ObjectElement(objectElement) {
    const result = BaseCallbackVisitor.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement2).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "pathItem");
    });
    return result;
  }
};
var callback_default2 = CallbackVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/response/index.mjs
var BaseResponseVisitor = specification_default2.visitors.document.objects.Response.$visitor;
var ResponseVisitor2 = class extends BaseResponseVisitor {
  constructor(options) {
    super(options);
    this.element = new Response_default2();
  }
};
var response_default2 = ResponseVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/responses/index.mjs
var BaseResponsesVisitor = specification_default2.visitors.document.objects.Responses.$visitor;
var ResponsesVisitor3 = class extends BaseResponsesVisitor {
  constructor(options) {
    super(options);
    this.element = new Responses_default2();
  }
};
var responses_default2 = ResponsesVisitor3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/operation/index.mjs
var BaseOperationVisitor = specification_default2.visitors.document.objects.Operation.$visitor;
var OperationVisitor2 = class extends BaseOperationVisitor {
  constructor(options) {
    super(options);
    this.element = new Operation_default2();
  }
};
var operation_default2 = OperationVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/path-item/index.mjs
var BasePathItemVisitor = specification_default2.visitors.document.objects.PathItem.$visitor;
var PathItemVisitor2 = class extends BasePathItemVisitor {
  constructor(options) {
    super(options);
    this.element = new PathItem_default2();
  }
};
var path_item_default2 = PathItemVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/security-scheme/index.mjs
var BaseSecuritySchemeVisitor = specification_default2.visitors.document.objects.SecurityScheme.$visitor;
var SecuritySchemeVisitor2 = class extends BaseSecuritySchemeVisitor {
  constructor(options) {
    super(options);
    this.element = new SecurityScheme_default2();
  }
};
var security_scheme_default2 = SecuritySchemeVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/oauth-flows/index.mjs
var BaseOAuthFlowsVisitor = specification_default2.visitors.document.objects.OAuthFlows.$visitor;
var OAuthFlowsVisitor2 = class extends BaseOAuthFlowsVisitor {
  constructor(options) {
    super(options);
    this.element = new OAuthFlows_default2();
  }
};
var oauth_flows_default2 = OAuthFlowsVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/oauth-flow/index.mjs
var BaseOAuthFlowVisitor = specification_default2.visitors.document.objects.OAuthFlow.$visitor;
var OAuthFlowVisitor2 = class extends BaseOAuthFlowVisitor {
  constructor(options) {
    super(options);
    this.element = new OAuthFlow_default2();
  }
};
var oauth_flow_default2 = OAuthFlowVisitor2;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/visitors/open-api-3-1/WebhooksVisitor.mjs
var WebhooksVisitor = class extends Mixin(MapVisitor_default2, FallbackVisitor_default2) {
  constructor(options) {
    super(options);
    this.element = new Webhooks_default();
    this.specPath = (element) => isReferenceLikeElement(element) ? ["document", "objects", "Reference"] : ["document", "objects", "PathItem"];
  }
  ObjectElement(objectElement) {
    const result = MapVisitor_default2.prototype.ObjectElement.call(this, objectElement);
    this.element.filter(isReferenceElement2).forEach((referenceElement) => {
      referenceElement.setMetaProperty("referenced-element", "pathItem");
    });
    this.element.filter(isPathItemElement2).forEach((pathItemElement, key57) => {
      pathItemElement.setMetaProperty("webhook-name", value_default(key57));
    });
    return result;
  }
};
var WebhooksVisitor_default = WebhooksVisitor;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/specification.mjs
var specification3 = {
  visitors: {
    value: specification_default2.visitors.value,
    document: {
      objects: {
        OpenApi: {
          $visitor: open_api_3_1_default,
          fixedFields: {
            openapi: specification_default2.visitors.document.objects.OpenApi.fixedFields.openapi,
            info: {
              $ref: "#/visitors/document/objects/Info"
            },
            jsonSchemaDialect: JsonSchemaDialectVisitor_default,
            servers: specification_default2.visitors.document.objects.OpenApi.fixedFields.servers,
            paths: {
              $ref: "#/visitors/document/objects/Paths"
            },
            webhooks: WebhooksVisitor_default,
            components: {
              $ref: "#/visitors/document/objects/Components"
            },
            security: specification_default2.visitors.document.objects.OpenApi.fixedFields.security,
            tags: specification_default2.visitors.document.objects.OpenApi.fixedFields.tags,
            externalDocs: {
              $ref: "#/visitors/document/objects/ExternalDocumentation"
            }
          }
        },
        Info: {
          $visitor: info_default2,
          fixedFields: {
            title: specification_default2.visitors.document.objects.Info.fixedFields.title,
            description: specification_default2.visitors.document.objects.Info.fixedFields.description,
            summary: {
              $ref: "#/visitors/value"
            },
            termsOfService: specification_default2.visitors.document.objects.Info.fixedFields.termsOfService,
            contact: {
              $ref: "#/visitors/document/objects/Contact"
            },
            license: {
              $ref: "#/visitors/document/objects/License"
            },
            version: specification_default2.visitors.document.objects.Info.fixedFields.version
          }
        },
        Contact: {
          $visitor: contact_default2,
          fixedFields: {
            name: specification_default2.visitors.document.objects.Contact.fixedFields.name,
            url: specification_default2.visitors.document.objects.Contact.fixedFields.url,
            email: specification_default2.visitors.document.objects.Contact.fixedFields.email
          }
        },
        License: {
          $visitor: license_default2,
          fixedFields: {
            name: specification_default2.visitors.document.objects.License.fixedFields.name,
            identifier: {
              $ref: "#/visitors/value"
            },
            url: specification_default2.visitors.document.objects.License.fixedFields.url
          }
        },
        Server: {
          $visitor: server_default2,
          fixedFields: {
            url: specification_default2.visitors.document.objects.Server.fixedFields.url,
            description: specification_default2.visitors.document.objects.Server.fixedFields.description,
            variables: specification_default2.visitors.document.objects.Server.fixedFields.variables
          }
        },
        ServerVariable: {
          $visitor: server_variable_default2,
          fixedFields: {
            enum: specification_default2.visitors.document.objects.ServerVariable.fixedFields.enum,
            default: specification_default2.visitors.document.objects.ServerVariable.fixedFields.default,
            description: specification_default2.visitors.document.objects.ServerVariable.fixedFields.description
          }
        },
        Components: {
          $visitor: components_default2,
          fixedFields: {
            schemas: SchemasVisitor_default2,
            responses: specification_default2.visitors.document.objects.Components.fixedFields.responses,
            parameters: specification_default2.visitors.document.objects.Components.fixedFields.parameters,
            examples: specification_default2.visitors.document.objects.Components.fixedFields.examples,
            requestBodies: specification_default2.visitors.document.objects.Components.fixedFields.requestBodies,
            headers: specification_default2.visitors.document.objects.Components.fixedFields.headers,
            securitySchemes: specification_default2.visitors.document.objects.Components.fixedFields.securitySchemes,
            links: specification_default2.visitors.document.objects.Components.fixedFields.links,
            callbacks: specification_default2.visitors.document.objects.Components.fixedFields.callbacks,
            pathItems: PathItemsVisitor_default
          }
        },
        Paths: {
          $visitor: paths_default4
        },
        PathItem: {
          $visitor: path_item_default2,
          fixedFields: {
            $ref: specification_default2.visitors.document.objects.PathItem.fixedFields.$ref,
            summary: specification_default2.visitors.document.objects.PathItem.fixedFields.summary,
            description: specification_default2.visitors.document.objects.PathItem.fixedFields.description,
            get: {
              $ref: "#/visitors/document/objects/Operation"
            },
            put: {
              $ref: "#/visitors/document/objects/Operation"
            },
            post: {
              $ref: "#/visitors/document/objects/Operation"
            },
            delete: {
              $ref: "#/visitors/document/objects/Operation"
            },
            options: {
              $ref: "#/visitors/document/objects/Operation"
            },
            head: {
              $ref: "#/visitors/document/objects/Operation"
            },
            patch: {
              $ref: "#/visitors/document/objects/Operation"
            },
            trace: {
              $ref: "#/visitors/document/objects/Operation"
            },
            servers: specification_default2.visitors.document.objects.PathItem.fixedFields.servers,
            parameters: specification_default2.visitors.document.objects.PathItem.fixedFields.parameters
          }
        },
        Operation: {
          $visitor: operation_default2,
          fixedFields: {
            tags: specification_default2.visitors.document.objects.Operation.fixedFields.tags,
            summary: specification_default2.visitors.document.objects.Operation.fixedFields.summary,
            description: specification_default2.visitors.document.objects.Operation.fixedFields.description,
            externalDocs: {
              $ref: "#/visitors/document/objects/ExternalDocumentation"
            },
            operationId: specification_default2.visitors.document.objects.Operation.fixedFields.operationId,
            parameters: specification_default2.visitors.document.objects.Operation.fixedFields.parameters,
            requestBody: specification_default2.visitors.document.objects.Operation.fixedFields.requestBody,
            responses: {
              $ref: "#/visitors/document/objects/Responses"
            },
            callbacks: specification_default2.visitors.document.objects.Operation.fixedFields.callbacks,
            deprecated: specification_default2.visitors.document.objects.Operation.fixedFields.deprecated,
            security: specification_default2.visitors.document.objects.Operation.fixedFields.security,
            servers: specification_default2.visitors.document.objects.Operation.fixedFields.servers
          }
        },
        ExternalDocumentation: {
          $visitor: external_documentation_default2,
          fixedFields: {
            description: specification_default2.visitors.document.objects.ExternalDocumentation.fixedFields.description,
            url: specification_default2.visitors.document.objects.ExternalDocumentation.fixedFields.url
          }
        },
        Parameter: {
          $visitor: parameter_default2,
          fixedFields: {
            name: specification_default2.visitors.document.objects.Parameter.fixedFields.name,
            in: specification_default2.visitors.document.objects.Parameter.fixedFields.in,
            description: specification_default2.visitors.document.objects.Parameter.fixedFields.description,
            required: specification_default2.visitors.document.objects.Parameter.fixedFields.required,
            deprecated: specification_default2.visitors.document.objects.Parameter.fixedFields.deprecated,
            allowEmptyValue: specification_default2.visitors.document.objects.Parameter.fixedFields.allowEmptyValue,
            style: specification_default2.visitors.document.objects.Parameter.fixedFields.style,
            explode: specification_default2.visitors.document.objects.Parameter.fixedFields.explode,
            allowReserved: specification_default2.visitors.document.objects.Parameter.fixedFields.allowReserved,
            schema: {
              $ref: "#/visitors/document/objects/Schema"
            },
            example: specification_default2.visitors.document.objects.Parameter.fixedFields.example,
            examples: specification_default2.visitors.document.objects.Parameter.fixedFields.examples,
            content: specification_default2.visitors.document.objects.Parameter.fixedFields.content
          }
        },
        RequestBody: {
          $visitor: request_body_default2,
          fixedFields: {
            description: specification_default2.visitors.document.objects.RequestBody.fixedFields.description,
            content: specification_default2.visitors.document.objects.RequestBody.fixedFields.content,
            required: specification_default2.visitors.document.objects.RequestBody.fixedFields.required
          }
        },
        MediaType: {
          $visitor: media_type_default2,
          fixedFields: {
            schema: {
              $ref: "#/visitors/document/objects/Schema"
            },
            example: specification_default2.visitors.document.objects.MediaType.fixedFields.example,
            examples: specification_default2.visitors.document.objects.MediaType.fixedFields.examples,
            encoding: specification_default2.visitors.document.objects.MediaType.fixedFields.encoding
          }
        },
        Encoding: {
          $visitor: encoding_default2,
          fixedFields: {
            contentType: specification_default2.visitors.document.objects.Encoding.fixedFields.contentType,
            headers: specification_default2.visitors.document.objects.Encoding.fixedFields.headers,
            style: specification_default2.visitors.document.objects.Encoding.fixedFields.style,
            explode: specification_default2.visitors.document.objects.Encoding.fixedFields.explode,
            allowReserved: specification_default2.visitors.document.objects.Encoding.fixedFields.allowReserved
          }
        },
        Responses: {
          $visitor: responses_default2,
          fixedFields: {
            default: specification_default2.visitors.document.objects.Responses.fixedFields.default
          }
        },
        Response: {
          $visitor: response_default2,
          fixedFields: {
            description: specification_default2.visitors.document.objects.Response.fixedFields.description,
            headers: specification_default2.visitors.document.objects.Response.fixedFields.headers,
            content: specification_default2.visitors.document.objects.Response.fixedFields.content,
            links: specification_default2.visitors.document.objects.Response.fixedFields.links
          }
        },
        Callback: {
          $visitor: callback_default2
        },
        Example: {
          $visitor: example_default2,
          fixedFields: {
            summary: specification_default2.visitors.document.objects.Example.fixedFields.summary,
            description: specification_default2.visitors.document.objects.Example.fixedFields.description,
            value: specification_default2.visitors.document.objects.Example.fixedFields.value,
            externalValue: specification_default2.visitors.document.objects.Example.fixedFields.externalValue
          }
        },
        Link: {
          $visitor: link_default2,
          fixedFields: {
            operationRef: specification_default2.visitors.document.objects.Link.fixedFields.operationRef,
            operationId: specification_default2.visitors.document.objects.Link.fixedFields.operationId,
            parameters: specification_default2.visitors.document.objects.Link.fixedFields.parameters,
            requestBody: specification_default2.visitors.document.objects.Link.fixedFields.requestBody,
            description: specification_default2.visitors.document.objects.Link.fixedFields.description,
            server: {
              $ref: "#/visitors/document/objects/Server"
            }
          }
        },
        Header: {
          $visitor: header_default2,
          fixedFields: {
            description: specification_default2.visitors.document.objects.Header.fixedFields.description,
            required: specification_default2.visitors.document.objects.Header.fixedFields.required,
            deprecated: specification_default2.visitors.document.objects.Header.fixedFields.deprecated,
            allowEmptyValue: specification_default2.visitors.document.objects.Header.fixedFields.allowEmptyValue,
            style: specification_default2.visitors.document.objects.Header.fixedFields.style,
            explode: specification_default2.visitors.document.objects.Header.fixedFields.explode,
            allowReserved: specification_default2.visitors.document.objects.Header.fixedFields.allowReserved,
            schema: {
              $ref: "#/visitors/document/objects/Schema"
            },
            example: specification_default2.visitors.document.objects.Header.fixedFields.example,
            examples: specification_default2.visitors.document.objects.Header.fixedFields.examples,
            content: specification_default2.visitors.document.objects.Header.fixedFields.content
          }
        },
        Tag: {
          $visitor: tag_default2,
          fixedFields: {
            name: specification_default2.visitors.document.objects.Tag.fixedFields.name,
            description: specification_default2.visitors.document.objects.Tag.fixedFields.description,
            externalDocs: {
              $ref: "#/visitors/document/objects/ExternalDocumentation"
            }
          }
        },
        Reference: {
          $visitor: reference_default2,
          fixedFields: {
            $ref: specification_default2.visitors.document.objects.Reference.fixedFields.$ref,
            summary: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            }
          }
        },
        Schema: {
          $visitor: schema_default2,
          fixedFields: {
            // core vocabulary
            $schema: {
              $ref: "#/visitors/value"
            },
            $vocabulary: vocabularyVisitor_default,
            $id: {
              $ref: "#/visitors/value"
            },
            $anchor: {
              $ref: "#/visitors/value"
            },
            $dynamicAnchor: {
              $ref: "#/visitors/value"
            },
            $dynamicRef: {
              $ref: "#/visitors/value"
            },
            $ref: refVisitor_default,
            $defs: defsVisitor_default,
            $comment: {
              $ref: "#/visitors/value"
            },
            // applicator vocabulary
            allOf: AllOfVisitor_default3,
            anyOf: AnyOfVisitor_default3,
            oneOf: OneOfVisitor_default3,
            not: {
              $ref: "#/visitors/document/objects/Schema"
            },
            if: {
              $ref: "#/visitors/document/objects/Schema"
            },
            then: {
              $ref: "#/visitors/document/objects/Schema"
            },
            else: {
              $ref: "#/visitors/document/objects/Schema"
            },
            dependentSchemas: DependentSchemasVisitor_default,
            prefixItems: PrefixItemsVisitor_default,
            items: {
              $ref: "#/visitors/document/objects/Schema"
            },
            contains: {
              $ref: "#/visitors/document/objects/Schema"
            },
            properties: PropertiesVisitor_default3,
            patternProperties: PatternPropertiesVisitor_default2,
            additionalProperties: {
              $ref: "#/visitors/document/objects/Schema"
            },
            propertyNames: {
              $ref: "#/visitors/document/objects/Schema"
            },
            // unevaluated Locations vocabulary
            unevaluatedItems: {
              $ref: "#/visitors/document/objects/Schema"
            },
            unevaluatedProperties: {
              $ref: "#/visitors/document/objects/Schema"
            },
            // validation vocabulary
            // validation Keywords for Any Instance Type
            type: TypeVisitor_default3,
            enum: EnumVisitor_default2,
            const: {
              $ref: "#/visitors/value"
            },
            // validation Keywords for Numeric Instances (number and integer)
            multipleOf: {
              $ref: "#/visitors/value"
            },
            maximum: {
              $ref: "#/visitors/value"
            },
            exclusiveMaximum: {
              $ref: "#/visitors/value"
            },
            minimum: {
              $ref: "#/visitors/value"
            },
            exclusiveMinimum: {
              $ref: "#/visitors/value"
            },
            // validation Keywords for Strings
            maxLength: {
              $ref: "#/visitors/value"
            },
            minLength: {
              $ref: "#/visitors/value"
            },
            pattern: {
              $ref: "#/visitors/value"
            },
            // validation Keywords for Arrays
            maxItems: {
              $ref: "#/visitors/value"
            },
            minItems: {
              $ref: "#/visitors/value"
            },
            uniqueItems: {
              $ref: "#/visitors/value"
            },
            maxContains: {
              $ref: "#/visitors/value"
            },
            minContains: {
              $ref: "#/visitors/value"
            },
            // validation Keywords for Objects
            maxProperties: {
              $ref: "#/visitors/value"
            },
            minProperties: {
              $ref: "#/visitors/value"
            },
            required: {
              $ref: "#/visitors/value"
            },
            dependentRequired: DependentRequiredVisitor_default,
            // basic Meta-Data Annotations vocabulary
            title: {
              $ref: "#/visitors/value"
            },
            description: {
              $ref: "#/visitors/value"
            },
            default: {
              $ref: "#/visitors/value"
            },
            deprecated: {
              $ref: "#/visitors/value"
            },
            readOnly: {
              $ref: "#/visitors/value"
            },
            writeOnly: {
              $ref: "#/visitors/value"
            },
            examples: ExamplesVisitor_default6,
            // semantic Content With "format" vocabulary
            format: {
              $ref: "#/visitors/value"
            },
            // contents of String-Encoded Data vocabulary
            contentEncoding: {
              $ref: "#/visitors/value"
            },
            contentMediaType: {
              $ref: "#/visitors/value"
            },
            contentSchema: {
              $ref: "#/visitors/document/objects/Schema"
            },
            // OAS base vocabulary
            discriminator: {
              $ref: "#/visitors/document/objects/Discriminator"
            },
            xml: {
              $ref: "#/visitors/document/objects/XML"
            },
            externalDocs: {
              $ref: "#/visitors/document/objects/ExternalDocumentation"
            },
            example: {
              $ref: "#/visitors/value"
            }
          }
        },
        Discriminator: {
          $visitor: distriminator_default2,
          fixedFields: {
            propertyName: specification_default2.visitors.document.objects.Discriminator.fixedFields.propertyName,
            mapping: specification_default2.visitors.document.objects.Discriminator.fixedFields.mapping
          }
        },
        XML: {
          $visitor: xml_default2,
          fixedFields: {
            name: specification_default2.visitors.document.objects.XML.fixedFields.name,
            namespace: specification_default2.visitors.document.objects.XML.fixedFields.namespace,
            prefix: specification_default2.visitors.document.objects.XML.fixedFields.prefix,
            attribute: specification_default2.visitors.document.objects.XML.fixedFields.attribute,
            wrapped: specification_default2.visitors.document.objects.XML.fixedFields.wrapped
          }
        },
        SecurityScheme: {
          $visitor: security_scheme_default2,
          fixedFields: {
            type: specification_default2.visitors.document.objects.SecurityScheme.fixedFields.type,
            description: specification_default2.visitors.document.objects.SecurityScheme.fixedFields.description,
            name: specification_default2.visitors.document.objects.SecurityScheme.fixedFields.name,
            in: specification_default2.visitors.document.objects.SecurityScheme.fixedFields.in,
            scheme: specification_default2.visitors.document.objects.SecurityScheme.fixedFields.scheme,
            bearerFormat: specification_default2.visitors.document.objects.SecurityScheme.fixedFields.bearerFormat,
            flows: {
              $ref: "#/visitors/document/objects/OAuthFlows"
            },
            openIdConnectUrl: specification_default2.visitors.document.objects.SecurityScheme.fixedFields.openIdConnectUrl
          }
        },
        OAuthFlows: {
          $visitor: oauth_flows_default2,
          fixedFields: {
            implicit: {
              $ref: "#/visitors/document/objects/OAuthFlow"
            },
            password: {
              $ref: "#/visitors/document/objects/OAuthFlow"
            },
            clientCredentials: {
              $ref: "#/visitors/document/objects/OAuthFlow"
            },
            authorizationCode: {
              $ref: "#/visitors/document/objects/OAuthFlow"
            }
          }
        },
        OAuthFlow: {
          $visitor: oauth_flow_default2,
          fixedFields: {
            authorizationUrl: specification_default2.visitors.document.objects.OAuthFlow.fixedFields.authorizationUrl,
            tokenUrl: specification_default2.visitors.document.objects.OAuthFlow.fixedFields.tokenUrl,
            refreshUrl: specification_default2.visitors.document.objects.OAuthFlow.fixedFields.refreshUrl,
            scopes: specification_default2.visitors.document.objects.OAuthFlow.fixedFields.scopes
          }
        },
        SecurityRequirement: {
          $visitor: security_requirement_default2
        }
      },
      extension: {
        $visitor: specification_default2.visitors.document.extension.$visitor
      }
    }
  }
};
var specification_default3 = specification3;

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/index.mjs
var refract5 = (value, {
  specPath = ["visitors", "document", "objects", "OpenApi", "$visitor"],
  plugins: plugins2 = []
} = {}) => {
  const element = (0, import_minim14.refract)(value);
  const resolvedSpec = dereference(specification_default3);
  const RootVisitorClass = path_default(specPath, resolvedSpec);
  const rootVisitor = new RootVisitorClass({
    specObj: resolvedSpec
  });
  visit2(element, rootVisitor);
  return dispatchPluginsSync(rootVisitor.element, plugins2, {
    toolboxCreator: toolbox_default4,
    visitorOptions: {
      keyMap: keyMap3,
      nodeTypeGetter: getNodeType5
    }
  });
};
var createRefractor4 = (specPath) => (value, options = {}) => refract5(value, {
  specPath,
  ...options
});

// node_modules/@swagger-api/apidom-ns-openapi-3-1/src/refractor/registration.mjs
Callback_default2.refract = createRefractor4(["visitors", "document", "objects", "Callback", "$visitor"]);
Components_default2.refract = createRefractor4(["visitors", "document", "objects", "Components", "$visitor"]);
Contact_default2.refract = createRefractor4(["visitors", "document", "objects", "Contact", "$visitor"]);
Example_default2.refract = createRefractor4(["visitors", "document", "objects", "Example", "$visitor"]);
Discriminator_default2.refract = createRefractor4(["visitors", "document", "objects", "Discriminator", "$visitor"]);
Encoding_default2.refract = createRefractor4(["visitors", "document", "objects", "Encoding", "$visitor"]);
ExternalDocumentation_default2.refract = createRefractor4(["visitors", "document", "objects", "ExternalDocumentation", "$visitor"]);
Header_default2.refract = createRefractor4(["visitors", "document", "objects", "Header", "$visitor"]);
Info_default2.refract = createRefractor4(["visitors", "document", "objects", "Info", "$visitor"]);
JsonSchemaDialect_default.refract = createRefractor4(["visitors", "document", "objects", "OpenApi", "fixedFields", "jsonSchemaDialect"]);
License_default2.refract = createRefractor4(["visitors", "document", "objects", "License", "$visitor"]);
Link_default2.refract = createRefractor4(["visitors", "document", "objects", "Link", "$visitor"]);
MediaType_default2.refract = createRefractor4(["visitors", "document", "objects", "MediaType", "$visitor"]);
OAuthFlow_default2.refract = createRefractor4(["visitors", "document", "objects", "OAuthFlow", "$visitor"]);
OAuthFlows_default2.refract = createRefractor4(["visitors", "document", "objects", "OAuthFlows", "$visitor"]);
Openapi_default2.refract = createRefractor4(["visitors", "document", "objects", "OpenApi", "fixedFields", "openapi"]);
OpenApi3_1_default.refract = createRefractor4(["visitors", "document", "objects", "OpenApi", "$visitor"]);
Operation_default2.refract = createRefractor4(["visitors", "document", "objects", "Operation", "$visitor"]);
Parameter_default2.refract = createRefractor4(["visitors", "document", "objects", "Parameter", "$visitor"]);
PathItem_default2.refract = createRefractor4(["visitors", "document", "objects", "PathItem", "$visitor"]);
Paths_default2.refract = createRefractor4(["visitors", "document", "objects", "Paths", "$visitor"]);
Reference_default3.refract = createRefractor4(["visitors", "document", "objects", "Reference", "$visitor"]);
RequestBody_default2.refract = createRefractor4(["visitors", "document", "objects", "RequestBody", "$visitor"]);
Response_default2.refract = createRefractor4(["visitors", "document", "objects", "Response", "$visitor"]);
Responses_default2.refract = createRefractor4(["visitors", "document", "objects", "Responses", "$visitor"]);
Schema_default2.refract = createRefractor4(["visitors", "document", "objects", "Schema", "$visitor"]);
SecurityRequirement_default2.refract = createRefractor4(["visitors", "document", "objects", "SecurityRequirement", "$visitor"]);
SecurityScheme_default2.refract = createRefractor4(["visitors", "document", "objects", "SecurityScheme", "$visitor"]);
Server_default2.refract = createRefractor4(["visitors", "document", "objects", "Server", "$visitor"]);
ServerVariable_default2.refract = createRefractor4(["visitors", "document", "objects", "ServerVariable", "$visitor"]);
Tag_default3.refract = createRefractor4(["visitors", "document", "objects", "Tag", "$visitor"]);
Xml_default2.refract = createRefractor4(["visitors", "document", "objects", "XML", "$visitor"]);

// node_modules/@swagger-api/apidom-reference/src/parse/parsers/binary/index-browser.mjs
var BinaryParser = class extends Parser_default {
  constructor(options) {
    super({
      ...options !== null && options !== void 0 ? options : {},
      name: "binary"
    });
  }
  canParse(file) {
    return this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
  }
  // eslint-disable-next-line class-methods-use-this
  parse(file) {
    try {
      const binaryString = unescape(encodeURIComponent(file.toString()));
      const base64String = btoa(binaryString);
      const parseResultElement = new ParseResult_default();
      if (base64String.length !== 0) {
        const base64StringElement = new import_minim10.StringElement(base64String);
        base64StringElement.classes.push("result");
        parseResultElement.push(base64StringElement);
      }
      return parseResultElement;
    } catch (error) {
      throw new ParserError_default(`Error parsing "${file.uri}"`, {
        cause: error
      });
    }
  }
};
var index_browser_default = BinaryParser;

// node_modules/@swagger-api/apidom-reference/src/resolve/strategies/openapi-3-1/index.mjs
var OpenAPI3_1ResolveStrategy = class extends ResolveStrategy_default {
  constructor(options) {
    super({
      ...options !== null && options !== void 0 ? options : {},
      name: "openapi-3-1"
    });
  }
  canResolve(file, options) {
    const dereferenceStrategy = options.dereference.strategies.find((strategy) => strategy.name === "openapi-3-1");
    if (dereferenceStrategy === void 0) {
      return false;
    }
    return dereferenceStrategy.canDereference(file, options);
  }
  async resolve(file, options) {
    const dereferenceStrategy = options.dereference.strategies.find((strategy) => strategy.name === "openapi-3-1");
    if (dereferenceStrategy === void 0) {
      throw new UnmatchedDereferenceStrategyError_default('"openapi-3-1" dereference strategy is not available.');
    }
    const refSet = new ReferenceSet_default();
    const mergedOptions = merge3(options, {
      resolve: {
        internal: false
      },
      dereference: {
        refSet
      }
    });
    await dereferenceStrategy.dereference(file, mergedOptions);
    return refSet;
  }
};
var openapi_3_1_default = OpenAPI3_1ResolveStrategy;

// node_modules/swagger-client/es/helpers/abortcontroller-ponyfill.browser.js
var {
  AbortController: AbortController2,
  AbortSignal
} = globalThis;

// node_modules/swagger-client/es/helpers/abortcontroller-polyfill.browser.js
if (typeof globalThis.AbortController === "undefined") {
  globalThis.AbortController = AbortController2;
}
if (typeof globalThis.AbortSignal === "undefined") {
  globalThis.AbortSignal = AbortSignal;
}

// node_modules/swagger-client/es/resolver/apidom/reference/resolve/resolvers/http-swagger-client/index.js
var HTTPResolverSwaggerClient = class extends HTTPResolver_default {
  constructor({
    swaggerHTTPClient = http,
    swaggerHTTPClientConfig = {},
    ...rest
  } = {}) {
    super({
      ...rest,
      name: "http-swagger-client"
    });
    __publicField(this, "swaggerHTTPClient", http);
    __publicField(this, "swaggerHTTPClientConfig");
    this.swaggerHTTPClient = swaggerHTTPClient;
    this.swaggerHTTPClientConfig = swaggerHTTPClientConfig;
  }
  getHttpClient() {
    return this.swaggerHTTPClient;
  }
  async read(file) {
    const client = this.getHttpClient();
    const controller = new AbortController();
    const {
      signal
    } = controller;
    const timeoutID = setTimeout(() => {
      controller.abort();
    }, this.timeout);
    const credentials = this.getHttpClient().withCredentials || this.withCredentials ? "include" : "same-origin";
    const redirect = this.redirects === 0 ? "error" : "follow";
    const follow = this.redirects > 0 ? this.redirects : void 0;
    try {
      const response = await client({
        url: file.uri,
        signal,
        userFetch: async (resource, options) => {
          let res = await fetch(resource, options);
          try {
            res.headers.delete("Content-Type");
          } catch {
            res = new Response(res.body, {
              ...res,
              headers: new Headers(res.headers)
            });
            res.headers.delete("Content-Type");
          }
          return res;
        },
        credentials,
        redirect,
        follow,
        ...this.swaggerHTTPClientConfig
      });
      return response.text.arrayBuffer();
    } catch (error) {
      throw new ResolverError_default(`Error downloading "${file.uri}"`, {
        cause: error
      });
    } finally {
      clearTimeout(timeoutID);
    }
  }
};
var http_swagger_client_default = HTTPResolverSwaggerClient;

// node_modules/swagger-client/es/resolver/apidom/reference/parse/parsers/json/index.js
var JSONParser = class extends Parser_default {
  constructor(options = {}) {
    super({
      name: "json-swagger-client",
      mediaTypes: ["application/json"],
      ...options
    });
  }
  async canParse(file) {
    const hasSupportedFileExtension = this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
    const hasSupportedMediaType = this.mediaTypes.includes(file.mediaType);
    if (!hasSupportedFileExtension) return false;
    if (hasSupportedMediaType) return true;
    if (!hasSupportedMediaType) {
      try {
        JSON.parse(file.toString());
        return true;
      } catch (error) {
        return false;
      }
    }
    return false;
  }
  async parse(file) {
    if (this.sourceMap) {
      throw new ParserError_default("json-swagger-client parser plugin doesn't support sourceMaps option");
    }
    const parseResultElement = new ParseResult_default();
    const source = file.toString();
    if (this.allowEmpty && source.trim() === "") {
      return parseResultElement;
    }
    try {
      const element = from_default(JSON.parse(source));
      element.classes.push("result");
      parseResultElement.push(element);
      return parseResultElement;
    } catch (error) {
      throw new ParserError_default(`Error parsing "${file.uri}"`, {
        cause: error
      });
    }
  }
};
var json_default3 = JSONParser;

// node_modules/swagger-client/es/resolver/apidom/reference/parse/parsers/yaml-1-2/index.js
var YAMLParser = class extends Parser_default {
  constructor(options = {}) {
    super({
      name: "yaml-1-2-swagger-client",
      mediaTypes: ["text/yaml", "application/yaml"],
      ...options
    });
  }
  async canParse(file) {
    const hasSupportedFileExtension = this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
    const hasSupportedMediaType = this.mediaTypes.includes(file.mediaType);
    if (!hasSupportedFileExtension) return false;
    if (hasSupportedMediaType) return true;
    if (!hasSupportedMediaType) {
      try {
        js_yaml_default.load(file.toString(), {
          schema: JSON_SCHEMA
        });
        return true;
      } catch (error) {
        return false;
      }
    }
    return false;
  }
  async parse(file) {
    if (this.sourceMap) {
      throw new ParserError_default("yaml-1-2-swagger-client parser plugin doesn't support sourceMaps option");
    }
    const parseResultElement = new ParseResult_default();
    const source = file.toString();
    try {
      const pojo = js_yaml_default.load(source, {
        schema: JSON_SCHEMA
      });
      if (this.allowEmpty && typeof pojo === "undefined") {
        return parseResultElement;
      }
      const element = from_default(pojo);
      element.classes.push("result");
      parseResultElement.push(element);
      return parseResultElement;
    } catch (error) {
      throw new ParserError_default(`Error parsing "${file.uri}"`, {
        cause: error
      });
    }
  }
};
var yaml_1_2_default2 = YAMLParser;

// node_modules/swagger-client/es/resolver/apidom/reference/parse/parsers/openapi-json-3-1/index.js
var OpenAPIJSON3_1Parser = class extends Parser_default {
  constructor(options = {}) {
    super({
      name: "openapi-json-3-1-swagger-client",
      mediaTypes: new OpenAPIMediaTypes(...media_types_default2.filterByFormat("generic"), ...media_types_default2.filterByFormat("json")),
      ...options
    });
    __publicField(this, "detectionRegExp", /"openapi"\s*:\s*"(?<version_json>3\.1\.(?:[1-9]\d*|0))"/);
  }
  async canParse(file) {
    const hasSupportedFileExtension = this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
    const hasSupportedMediaType = this.mediaTypes.includes(file.mediaType);
    if (!hasSupportedFileExtension) return false;
    if (hasSupportedMediaType) return true;
    if (!hasSupportedMediaType) {
      try {
        const source = file.toString();
        JSON.parse(source);
        return this.detectionRegExp.test(source);
      } catch (error) {
        return false;
      }
    }
    return false;
  }
  async parse(file) {
    if (this.sourceMap) {
      throw new ParserError_default("openapi-json-3-1-swagger-client parser plugin doesn't support sourceMaps option");
    }
    const parseResultElement = new ParseResult_default();
    const source = file.toString();
    if (this.allowEmpty && source.trim() === "") {
      return parseResultElement;
    }
    try {
      const pojo = JSON.parse(source);
      const element = OpenApi3_1_default.refract(pojo, this.refractorOpts);
      element.classes.push("result");
      parseResultElement.push(element);
      return parseResultElement;
    } catch (error) {
      throw new ParserError_default(`Error parsing "${file.uri}"`, {
        cause: error
      });
    }
  }
};
var openapi_json_3_1_default = OpenAPIJSON3_1Parser;

// node_modules/swagger-client/es/resolver/apidom/reference/parse/parsers/openapi-yaml-3-1/index.js
var OpenAPIYAML31Parser = class extends Parser_default {
  constructor(options = {}) {
    super({
      name: "openapi-yaml-3-1-swagger-client",
      mediaTypes: new OpenAPIMediaTypes(...media_types_default2.filterByFormat("generic"), ...media_types_default2.filterByFormat("yaml")),
      ...options
    });
    __publicField(this, "detectionRegExp", /(?<YAML>^(["']?)openapi\2\s*:\s*(["']?)(?<version_yaml>3\.1\.(?:[1-9]\d*|0))\3(?:\s+|$))|(?<JSON>"openapi"\s*:\s*"(?<version_json>3\.1\.(?:[1-9]\d*|0))")/m);
  }
  async canParse(file) {
    const hasSupportedFileExtension = this.fileExtensions.length === 0 ? true : this.fileExtensions.includes(file.extension);
    const hasSupportedMediaType = this.mediaTypes.includes(file.mediaType);
    if (!hasSupportedFileExtension) return false;
    if (hasSupportedMediaType) return true;
    if (!hasSupportedMediaType) {
      try {
        const source = file.toString();
        js_yaml_default.load(source);
        return this.detectionRegExp.test(source);
      } catch (error) {
        return false;
      }
    }
    return false;
  }
  async parse(file) {
    if (this.sourceMap) {
      throw new ParserError_default("openapi-yaml-3-1-swagger-client parser plugin doesn't support sourceMaps option");
    }
    const parseResultElement = new ParseResult_default();
    const source = file.toString();
    try {
      const pojo = js_yaml_default.load(source, {
        schema: JSON_SCHEMA
      });
      if (this.allowEmpty && typeof pojo === "undefined") {
        return parseResultElement;
      }
      const element = OpenApi3_1_default.refract(pojo, this.refractorOpts);
      element.classes.push("result");
      parseResultElement.push(element);
      return parseResultElement;
    } catch (error) {
      throw new ParserError_default(`Error parsing "${file.uri}"`, {
        cause: error
      });
    }
  }
};
var openapi_yaml_3_1_default = OpenAPIYAML31Parser;

// node_modules/@swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/selectors/$anchor.mjs
var isAnchor2 = (uri2) => {
  return /^[A-Za-z_][A-Za-z_0-9.-]*$/.test(uri2);
};
var uriToAnchor = (uri2) => {
  const hash = getHash(uri2);
  return trimCharsStart_default("#", hash);
};
var parse3 = (anchor) => {
  if (!isAnchor2(anchor)) {
    throw new InvalidJsonSchema_anchorError_default(anchor);
  }
  return anchor;
};
var evaluate2 = (anchor, element) => {
  const token = parse3(anchor);
  const result = find_default2((e2) => isSchemaElement2(e2) && value_default(e2.$anchor) === token, element);
  if (isUndefined_default(result)) {
    throw new EvaluationJsonSchema_anchorError_default(`Evaluation failed on token: "${token}"`);
  }
  return result;
};

// node_modules/@swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/util.mjs
var resolveSchema$refField = (retrievalURI2, schemaElement) => {
  if (typeof schemaElement.$ref === "undefined") {
    return void 0;
  }
  const hash = getHash(value_default(schemaElement.$ref));
  const inherited$id = value_default(schemaElement.meta.get("inherited$id"));
  const $refBaseURI = reduce_default((acc, uri2) => {
    return resolve(acc, sanitize(stripHash(uri2)));
  }, retrievalURI2, [...inherited$id, value_default(schemaElement.$ref)]);
  return `${$refBaseURI}${hash === "#" ? "" : hash}`;
};
var resolveSchema$idField = (retrievalURI2, schemaElement) => {
  if (typeof schemaElement.$id === "undefined") {
    return void 0;
  }
  const inherited$id = value_default(schemaElement.meta.get("inherited$id"));
  return reduce_default((acc, $id) => {
    return resolve(acc, sanitize(stripHash($id)));
  }, retrievalURI2, [...inherited$id, value_default(schemaElement.$id)]);
};
var refractToSchemaElement = (element) => {
  if (refractToSchemaElement.cache.has(element)) {
    return refractToSchemaElement.cache.get(element);
  }
  const refracted = Schema_default2.refract(element);
  refractToSchemaElement.cache.set(element, refracted);
  return refracted;
};
refractToSchemaElement.cache = /* @__PURE__ */ new WeakMap();
var maybeRefractToSchemaElement = (element) => {
  if (isPrimitiveElement(element)) {
    return refractToSchemaElement(element);
  }
  return element;
};

// node_modules/@swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/selectors/uri.mjs
var evaluate3 = (uri2, element) => {
  const {
    cache
  } = evaluate3;
  const uriStrippedHash = stripHash(uri2);
  const isSchemaElementWith$id = (e2) => isSchemaElement2(e2) && typeof e2.$id !== "undefined";
  if (!cache.has(element)) {
    const schemaObjectElements = filter_default2(isSchemaElementWith$id, element);
    cache.set(element, Array.from(schemaObjectElements));
  }
  const result = cache.get(element).find((e2) => {
    const $idBaseURI = resolveSchema$idField(uriStrippedHash, e2);
    return $idBaseURI === uriStrippedHash;
  });
  if (isUndefined_default(result)) {
    throw new EvaluationJsonSchemaUriError_default(`Evaluation failed on URI: "${uri2}"`);
  }
  let fragmentEvaluate;
  let selector;
  if (isAnchor2(uriToAnchor(uri2))) {
    fragmentEvaluate = evaluate2;
    selector = uriToAnchor(uri2);
  } else {
    fragmentEvaluate = evaluate_default;
    selector = uriToPointer(uri2);
  }
  return fragmentEvaluate(selector, result);
};
evaluate3.cache = /* @__PURE__ */ new WeakMap();

// node_modules/@swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/visitor.mjs
var visitAsync = visit2[Symbol.for("nodejs.util.promisify.custom")];
var identityManager = new IdentityManager();
var mutationReplacer = (newElement, oldElement, key57, parent) => {
  if (isMemberElement(parent)) {
    parent.value = newElement;
  } else if (Array.isArray(parent)) {
    parent[key57] = newElement;
  }
};
var OpenAPI3_1DereferenceVisitor = class _OpenAPI3_1DereferenceVisitor {
  constructor({
    reference,
    namespace: namespace2,
    options,
    indirections = [],
    ancestors = new AncestorLineage(),
    refractCache = /* @__PURE__ */ new Map()
  }) {
    __publicField(this, "indirections");
    __publicField(this, "namespace");
    __publicField(this, "reference");
    __publicField(this, "options");
    __publicField(this, "ancestors");
    __publicField(this, "refractCache");
    this.indirections = indirections;
    this.namespace = namespace2;
    this.reference = reference;
    this.options = options;
    this.ancestors = new AncestorLineage(...ancestors);
    this.refractCache = refractCache;
  }
  toBaseURI(uri2) {
    return resolve(this.reference.uri, sanitize(stripHash(uri2)));
  }
  async toReference(uri2) {
    if (this.reference.depth >= this.options.resolve.maxDepth) {
      throw new MaximumResolveDepthError_default(`Maximum resolution depth of ${this.options.resolve.maxDepth} has been exceeded by file "${this.reference.uri}"`);
    }
    const baseURI = this.toBaseURI(uri2);
    const {
      refSet
    } = this.reference;
    if (refSet.has(baseURI)) {
      return refSet.find(propEq_default(baseURI, "uri"));
    }
    const parseResult = await parse_default(unsanitize(baseURI), {
      ...this.options,
      parse: {
        ...this.options.parse,
        mediaType: "text/plain"
      }
    });
    const mutableReference = new Reference_default({
      uri: baseURI,
      value: cloneDeep(parseResult),
      depth: this.reference.depth + 1
    });
    refSet.add(mutableReference);
    if (this.options.dereference.immutable) {
      const immutableReference = new Reference_default({
        uri: `immutable://${baseURI}`,
        value: parseResult,
        depth: this.reference.depth + 1
      });
      refSet.add(immutableReference);
    }
    return mutableReference;
  }
  toAncestorLineage(ancestors) {
    const directAncestors = new Set(ancestors.filter(isElement));
    const ancestorsLineage = new AncestorLineage(...this.ancestors, directAncestors);
    return [ancestorsLineage, directAncestors];
  }
  async ReferenceElement(referencingElement, key57, parent, path4, ancestors, link) {
    if (this.indirections.includes(referencingElement)) {
      return false;
    }
    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);
    const retrievalURI2 = this.toBaseURI(value_default(referencingElement.$ref));
    const isInternalReference = stripHash(this.reference.uri) === retrievalURI2;
    const isExternalReference = !isInternalReference;
    if (!this.options.resolve.internal && isInternalReference) {
      return false;
    }
    if (!this.options.resolve.external && isExternalReference) {
      return false;
    }
    const reference = await this.toReference(value_default(referencingElement.$ref));
    const $refBaseURI = resolve(retrievalURI2, value_default(referencingElement.$ref));
    this.indirections.push(referencingElement);
    const jsonPointer = uriToPointer($refBaseURI);
    let referencedElement = evaluate_default(jsonPointer, reference.value.result);
    referencedElement.id = identityManager.identify(referencedElement);
    if (isPrimitiveElement(referencedElement)) {
      const referencedElementType = value_default(referencingElement.meta.get("referenced-element"));
      const cacheKey = `${referencedElementType}-${value_default(identityManager.identify(referencedElement))}`;
      if (this.refractCache.has(cacheKey)) {
        referencedElement = this.refractCache.get(cacheKey);
      } else if (isReferenceLikeElement(referencedElement)) {
        referencedElement = Reference_default3.refract(referencedElement);
        referencedElement.setMetaProperty("referenced-element", referencedElementType);
        this.refractCache.set(cacheKey, referencedElement);
      } else {
        const ElementClass = this.namespace.getElementClass(referencedElementType);
        referencedElement = ElementClass.refract(referencedElement);
        this.refractCache.set(cacheKey, referencedElement);
      }
    }
    if (referencingElement === referencedElement) {
      throw new ApiDOMError_default("Recursive Reference Object detected");
    }
    if (this.indirections.length > this.options.dereference.maxDepth) {
      throw new MaximumDereferenceDepthError_default(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
    }
    if (ancestorsLineage.includes(referencedElement)) {
      reference.refSet.circular = true;
      if (this.options.dereference.circular === "error") {
        throw new ApiDOMError_default("Circular reference detected");
      } else if (this.options.dereference.circular === "replace") {
        var _this$options$derefer, _this$options$derefer2;
        const refElement = new import_minim10.RefElement(referencedElement.id, {
          type: "reference",
          uri: reference.uri,
          $ref: value_default(referencingElement.$ref)
        });
        const replacer = (_this$options$derefer = (_this$options$derefer2 = this.options.dereference.strategyOpts["openapi-3-1"]) === null || _this$options$derefer2 === void 0 ? void 0 : _this$options$derefer2.circularReplacer) !== null && _this$options$derefer !== void 0 ? _this$options$derefer : this.options.dereference.circularReplacer;
        const replacement = replacer(refElement);
        link.replaceWith(replacement, mutationReplacer);
        return !parent ? replacement : false;
      }
    }
    const isNonRootDocument = stripHash(reference.refSet.rootRef.uri) !== reference.uri;
    const shouldDetectCircular = ["error", "replace"].includes(this.options.dereference.circular);
    if ((isExternalReference || isNonRootDocument || isReferenceElement2(referencedElement) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {
      directAncestors.add(referencingElement);
      const visitor2 = new _OpenAPI3_1DereferenceVisitor({
        reference,
        namespace: this.namespace,
        indirections: [...this.indirections],
        options: this.options,
        refractCache: this.refractCache,
        ancestors: ancestorsLineage
      });
      referencedElement = await visitAsync(referencedElement, visitor2, {
        keyMap: keyMap3,
        nodeTypeGetter: getNodeType5
      });
      directAncestors.delete(referencingElement);
    }
    this.indirections.pop();
    const mergedElement = cloneShallow(referencedElement);
    mergedElement.setMetaProperty("id", identityManager.generateId());
    mergedElement.setMetaProperty("ref-fields", {
      $ref: value_default(referencingElement.$ref),
      // @ts-ignore
      description: value_default(referencingElement.description),
      // @ts-ignore
      summary: value_default(referencingElement.summary)
    });
    mergedElement.setMetaProperty("ref-origin", reference.uri);
    mergedElement.setMetaProperty("ref-referencing-element-id", cloneDeep(identityManager.identify(referencingElement)));
    if (isObjectElement(referencedElement) && isObjectElement(mergedElement)) {
      if (referencingElement.hasKey("description") && "description" in referencedElement) {
        mergedElement.remove("description");
        mergedElement.set("description", referencingElement.get("description"));
      }
      if (referencingElement.hasKey("summary") && "summary" in referencedElement) {
        mergedElement.remove("summary");
        mergedElement.set("summary", referencingElement.get("summary"));
      }
    }
    link.replaceWith(mergedElement, mutationReplacer);
    return !parent ? mergedElement : false;
  }
  async PathItemElement(referencingElement, key57, parent, path4, ancestors, link) {
    if (!isStringElement(referencingElement.$ref)) {
      return void 0;
    }
    if (this.indirections.includes(referencingElement)) {
      return false;
    }
    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);
    const retrievalURI2 = this.toBaseURI(value_default(referencingElement.$ref));
    const isInternalReference = stripHash(this.reference.uri) === retrievalURI2;
    const isExternalReference = !isInternalReference;
    if (!this.options.resolve.internal && isInternalReference) {
      return void 0;
    }
    if (!this.options.resolve.external && isExternalReference) {
      return void 0;
    }
    const reference = await this.toReference(value_default(referencingElement.$ref));
    const $refBaseURI = resolve(retrievalURI2, value_default(referencingElement.$ref));
    this.indirections.push(referencingElement);
    const jsonPointer = uriToPointer($refBaseURI);
    let referencedElement = evaluate_default(jsonPointer, reference.value.result);
    referencedElement.id = identityManager.identify(referencedElement);
    if (isPrimitiveElement(referencedElement)) {
      const cacheKey = `path-item-${value_default(identityManager.identify(referencedElement))}`;
      if (this.refractCache.has(cacheKey)) {
        referencedElement = this.refractCache.get(cacheKey);
      } else {
        referencedElement = PathItem_default2.refract(referencedElement);
        this.refractCache.set(cacheKey, referencedElement);
      }
    }
    if (referencingElement === referencedElement) {
      throw new ApiDOMError_default("Recursive Path Item Object reference detected");
    }
    if (this.indirections.length > this.options.dereference.maxDepth) {
      throw new MaximumDereferenceDepthError_default(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
    }
    if (ancestorsLineage.includes(referencedElement)) {
      reference.refSet.circular = true;
      if (this.options.dereference.circular === "error") {
        throw new ApiDOMError_default("Circular reference detected");
      } else if (this.options.dereference.circular === "replace") {
        var _this$options$derefer3, _this$options$derefer4;
        const refElement = new import_minim10.RefElement(referencedElement.id, {
          type: "path-item",
          uri: reference.uri,
          $ref: value_default(referencingElement.$ref)
        });
        const replacer = (_this$options$derefer3 = (_this$options$derefer4 = this.options.dereference.strategyOpts["openapi-3-1"]) === null || _this$options$derefer4 === void 0 ? void 0 : _this$options$derefer4.circularReplacer) !== null && _this$options$derefer3 !== void 0 ? _this$options$derefer3 : this.options.dereference.circularReplacer;
        const replacement = replacer(refElement);
        link.replaceWith(replacement, mutationReplacer);
        return !parent ? replacement : false;
      }
    }
    const isNonRootDocument = stripHash(reference.refSet.rootRef.uri) !== reference.uri;
    const shouldDetectCircular = ["error", "replace"].includes(this.options.dereference.circular);
    if ((isExternalReference || isNonRootDocument || isPathItemElement2(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {
      directAncestors.add(referencingElement);
      const visitor2 = new _OpenAPI3_1DereferenceVisitor({
        reference,
        namespace: this.namespace,
        indirections: [...this.indirections],
        options: this.options,
        refractCache: this.refractCache,
        ancestors: ancestorsLineage
      });
      referencedElement = await visitAsync(referencedElement, visitor2, {
        keyMap: keyMap3,
        nodeTypeGetter: getNodeType5
      });
      directAncestors.delete(referencingElement);
    }
    this.indirections.pop();
    if (isPathItemElement2(referencedElement)) {
      const mergedElement = new PathItem_default2([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));
      mergedElement.setMetaProperty("id", identityManager.generateId());
      referencingElement.forEach((value, keyElement, item) => {
        mergedElement.remove(value_default(keyElement));
        mergedElement.content.push(item);
      });
      mergedElement.remove("$ref");
      mergedElement.setMetaProperty("ref-fields", {
        $ref: value_default(referencingElement.$ref)
      });
      mergedElement.setMetaProperty("ref-origin", reference.uri);
      mergedElement.setMetaProperty("ref-referencing-element-id", cloneDeep(identityManager.identify(referencingElement)));
      referencedElement = mergedElement;
    }
    link.replaceWith(referencedElement, mutationReplacer);
    return !parent ? referencedElement : void 0;
  }
  async LinkElement(linkElement, key57, parent, path4, ancestors, link) {
    if (!isStringElement(linkElement.operationRef) && !isStringElement(linkElement.operationId)) {
      return void 0;
    }
    if (isStringElement(linkElement.operationRef) && isStringElement(linkElement.operationId)) {
      throw new ApiDOMError_default("LinkElement operationRef and operationId fields are mutually exclusive.");
    }
    let operationElement;
    if (isStringElement(linkElement.operationRef)) {
      var _linkElementCopy$oper;
      const jsonPointer = uriToPointer(value_default(linkElement.operationRef));
      const retrievalURI2 = this.toBaseURI(value_default(linkElement.operationRef));
      const isInternalReference = stripHash(this.reference.uri) === retrievalURI2;
      const isExternalReference = !isInternalReference;
      if (!this.options.resolve.internal && isInternalReference) {
        return void 0;
      }
      if (!this.options.resolve.external && isExternalReference) {
        return void 0;
      }
      const reference = await this.toReference(value_default(linkElement.operationRef));
      operationElement = evaluate_default(jsonPointer, reference.value.result);
      if (isPrimitiveElement(operationElement)) {
        const cacheKey = `operation-${value_default(identityManager.identify(operationElement))}`;
        if (this.refractCache.has(cacheKey)) {
          operationElement = this.refractCache.get(cacheKey);
        } else {
          operationElement = Operation_default2.refract(operationElement);
          this.refractCache.set(cacheKey, operationElement);
        }
      }
      operationElement = cloneShallow(operationElement);
      operationElement.setMetaProperty("ref-origin", reference.uri);
      const linkElementCopy = cloneShallow(linkElement);
      (_linkElementCopy$oper = linkElementCopy.operationRef) === null || _linkElementCopy$oper === void 0 || _linkElementCopy$oper.meta.set("operation", operationElement);
      link.replaceWith(linkElementCopy, mutationReplacer);
      return !parent ? linkElementCopy : void 0;
    }
    if (isStringElement(linkElement.operationId)) {
      var _linkElementCopy$oper2;
      const operationId = value_default(linkElement.operationId);
      const reference = await this.toReference(unsanitize(this.reference.uri));
      operationElement = find_default2((e2) => isOperationElement2(e2) && isElement(e2.operationId) && e2.operationId.equals(operationId), reference.value.result);
      if (isUndefined_default(operationElement)) {
        throw new ApiDOMError_default(`OperationElement(operationId=${operationId}) not found.`);
      }
      const linkElementCopy = cloneShallow(linkElement);
      (_linkElementCopy$oper2 = linkElementCopy.operationId) === null || _linkElementCopy$oper2 === void 0 || _linkElementCopy$oper2.meta.set("operation", operationElement);
      link.replaceWith(linkElementCopy, mutationReplacer);
      return !parent ? linkElementCopy : void 0;
    }
    return void 0;
  }
  async ExampleElement(exampleElement, key57, parent, path4, ancestors, link) {
    if (!isStringElement(exampleElement.externalValue)) {
      return void 0;
    }
    if (exampleElement.hasKey("value") && isStringElement(exampleElement.externalValue)) {
      throw new ApiDOMError_default("ExampleElement value and externalValue fields are mutually exclusive.");
    }
    const retrievalURI2 = this.toBaseURI(value_default(exampleElement.externalValue));
    const isInternalReference = stripHash(this.reference.uri) === retrievalURI2;
    const isExternalReference = !isInternalReference;
    if (!this.options.resolve.internal && isInternalReference) {
      return void 0;
    }
    if (!this.options.resolve.external && isExternalReference) {
      return void 0;
    }
    const reference = await this.toReference(value_default(exampleElement.externalValue));
    const valueElement = cloneShallow(reference.value.result);
    valueElement.setMetaProperty("ref-origin", reference.uri);
    const exampleElementCopy = cloneShallow(exampleElement);
    exampleElementCopy.value = valueElement;
    link.replaceWith(exampleElementCopy, mutationReplacer);
    return !parent ? exampleElementCopy : void 0;
  }
  async SchemaElement(referencingElement, key57, parent, path4, ancestors, link) {
    if (!isStringElement(referencingElement.$ref)) {
      return void 0;
    }
    if (this.indirections.includes(referencingElement)) {
      return false;
    }
    const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);
    let reference = await this.toReference(unsanitize(this.reference.uri));
    let {
      uri: retrievalURI2
    } = reference;
    const $refBaseURI = resolveSchema$refField(retrievalURI2, referencingElement);
    const $refBaseURIStrippedHash = stripHash($refBaseURI);
    const file = new File_default({
      uri: $refBaseURIStrippedHash
    });
    const isUnknownURI = none_default((r2) => r2.canRead(file), this.options.resolve.resolvers);
    const isURL = !isUnknownURI;
    let isInternalReference = stripHash(this.reference.uri) === $refBaseURI;
    let isExternalReference = !isInternalReference;
    this.indirections.push(referencingElement);
    let referencedElement;
    try {
      if (isUnknownURI || isURL) {
        retrievalURI2 = this.toBaseURI($refBaseURI);
        const selector = $refBaseURI;
        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);
        referencedElement = evaluate3(selector, referenceAsSchema);
        referencedElement = maybeRefractToSchemaElement(referencedElement);
        referencedElement.id = identityManager.identify(referencedElement);
        if (!this.options.resolve.internal && isInternalReference) {
          return void 0;
        }
        if (!this.options.resolve.external && isExternalReference) {
          return void 0;
        }
      } else {
        retrievalURI2 = this.toBaseURI($refBaseURI);
        isInternalReference = stripHash(this.reference.uri) === retrievalURI2;
        isExternalReference = !isInternalReference;
        if (!this.options.resolve.internal && isInternalReference) {
          return void 0;
        }
        if (!this.options.resolve.external && isExternalReference) {
          return void 0;
        }
        reference = await this.toReference(unsanitize($refBaseURI));
        const selector = uriToPointer($refBaseURI);
        const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);
        referencedElement = evaluate_default(selector, referenceAsSchema);
        referencedElement = maybeRefractToSchemaElement(referencedElement);
        referencedElement.id = identityManager.identify(referencedElement);
      }
    } catch (error) {
      if (isURL && error instanceof EvaluationJsonSchemaUriError_default) {
        if (isAnchor2(uriToAnchor($refBaseURI))) {
          isInternalReference = stripHash(this.reference.uri) === retrievalURI2;
          isExternalReference = !isInternalReference;
          if (!this.options.resolve.internal && isInternalReference) {
            return void 0;
          }
          if (!this.options.resolve.external && isExternalReference) {
            return void 0;
          }
          reference = await this.toReference(unsanitize($refBaseURI));
          const selector = uriToAnchor($refBaseURI);
          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);
          referencedElement = evaluate2(selector, referenceAsSchema);
          referencedElement = maybeRefractToSchemaElement(referencedElement);
          referencedElement.id = identityManager.identify(referencedElement);
        } else {
          retrievalURI2 = this.toBaseURI($refBaseURI);
          isInternalReference = stripHash(this.reference.uri) === retrievalURI2;
          isExternalReference = !isInternalReference;
          if (!this.options.resolve.internal && isInternalReference) {
            return void 0;
          }
          if (!this.options.resolve.external && isExternalReference) {
            return void 0;
          }
          reference = await this.toReference(unsanitize($refBaseURI));
          const selector = uriToPointer($refBaseURI);
          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);
          referencedElement = evaluate_default(selector, referenceAsSchema);
          referencedElement = maybeRefractToSchemaElement(referencedElement);
          referencedElement.id = identityManager.identify(referencedElement);
        }
      } else {
        throw error;
      }
    }
    if (referencingElement === referencedElement) {
      throw new ApiDOMError_default("Recursive Schema Object reference detected");
    }
    if (this.indirections.length > this.options.dereference.maxDepth) {
      throw new MaximumDereferenceDepthError_default(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
    }
    if (ancestorsLineage.includes(referencedElement)) {
      reference.refSet.circular = true;
      if (this.options.dereference.circular === "error") {
        throw new ApiDOMError_default("Circular reference detected");
      } else if (this.options.dereference.circular === "replace") {
        var _this$options$derefer5, _this$options$derefer6;
        const refElement = new import_minim10.RefElement(referencedElement.id, {
          type: "json-schema",
          uri: reference.uri,
          $ref: value_default(referencingElement.$ref)
        });
        const replacer = (_this$options$derefer5 = (_this$options$derefer6 = this.options.dereference.strategyOpts["openapi-3-1"]) === null || _this$options$derefer6 === void 0 ? void 0 : _this$options$derefer6.circularReplacer) !== null && _this$options$derefer5 !== void 0 ? _this$options$derefer5 : this.options.dereference.circularReplacer;
        const replacement = replacer(refElement);
        link.replaceWith(replacement, mutationReplacer);
        return !parent ? replacement : false;
      }
    }
    const isNonRootDocument = stripHash(reference.refSet.rootRef.uri) !== reference.uri;
    const shouldDetectCircular = ["error", "replace"].includes(this.options.dereference.circular);
    if ((isExternalReference || isNonRootDocument || isSchemaElement2(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {
      directAncestors.add(referencingElement);
      const visitor2 = new _OpenAPI3_1DereferenceVisitor({
        reference,
        namespace: this.namespace,
        indirections: [...this.indirections],
        options: this.options,
        refractCache: this.refractCache,
        ancestors: ancestorsLineage
      });
      referencedElement = await visitAsync(referencedElement, visitor2, {
        keyMap: keyMap3,
        nodeTypeGetter: getNodeType5
      });
      directAncestors.delete(referencingElement);
    }
    this.indirections.pop();
    if (isBooleanJsonSchemaElement2(referencedElement)) {
      const booleanJsonSchemaElement = cloneDeep(referencedElement);
      booleanJsonSchemaElement.setMetaProperty("id", identityManager.generateId());
      booleanJsonSchemaElement.setMetaProperty("ref-fields", {
        $ref: value_default(referencingElement.$ref)
      });
      booleanJsonSchemaElement.setMetaProperty("ref-origin", reference.uri);
      booleanJsonSchemaElement.setMetaProperty("ref-referencing-element-id", cloneDeep(identityManager.identify(referencingElement)));
      link.replaceWith(booleanJsonSchemaElement, mutationReplacer);
      return !parent ? booleanJsonSchemaElement : false;
    }
    if (isSchemaElement2(referencedElement)) {
      const mergedElement = new Schema_default2([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));
      mergedElement.setMetaProperty("id", identityManager.generateId());
      referencingElement.forEach((value, keyElement, item) => {
        mergedElement.remove(value_default(keyElement));
        mergedElement.content.push(item);
      });
      mergedElement.remove("$ref");
      mergedElement.setMetaProperty("ref-fields", {
        $ref: value_default(referencingElement.$ref)
      });
      mergedElement.setMetaProperty("ref-origin", reference.uri);
      mergedElement.setMetaProperty("ref-referencing-element-id", cloneDeep(identityManager.identify(referencingElement)));
      referencedElement = mergedElement;
    }
    link.replaceWith(referencedElement, mutationReplacer);
    return !parent ? referencedElement : void 0;
  }
};
var visitor_default = OpenAPI3_1DereferenceVisitor;

// node_modules/@swagger-api/apidom-reference/src/dereference/strategies/openapi-3-1/index.mjs
var visitAsync2 = visit2[Symbol.for("nodejs.util.promisify.custom")];
var OpenAPI3_1DereferenceStrategy = class extends DereferenceStrategy_default {
  constructor(options) {
    super({
      ...options !== null && options !== void 0 ? options : {},
      name: "openapi-3-1"
    });
  }
  canDereference(file) {
    var _file$parseResult;
    if (file.mediaType !== "text/plain") {
      return media_types_default2.includes(file.mediaType);
    }
    return isOpenApi3_1Element((_file$parseResult = file.parseResult) === null || _file$parseResult === void 0 ? void 0 : _file$parseResult.result);
  }
  async dereference(file, options) {
    var _options$dereference$;
    const namespace2 = createNamespace(namespace_default4);
    const immutableRefSet = (_options$dereference$ = options.dereference.refSet) !== null && _options$dereference$ !== void 0 ? _options$dereference$ : new ReferenceSet_default();
    const mutableRefSet = new ReferenceSet_default();
    let refSet = immutableRefSet;
    let reference;
    if (!immutableRefSet.has(file.uri)) {
      reference = new Reference_default({
        uri: file.uri,
        value: file.parseResult
      });
      immutableRefSet.add(reference);
    } else {
      reference = immutableRefSet.find(propEq_default(file.uri, "uri"));
    }
    if (options.dereference.immutable) {
      immutableRefSet.refs.map((ref) => new Reference_default({
        ...ref,
        value: cloneDeep(ref.value)
      })).forEach((ref) => mutableRefSet.add(ref));
      reference = mutableRefSet.find((ref) => ref.uri === file.uri);
      refSet = mutableRefSet;
    }
    const visitor2 = new visitor_default({
      reference,
      namespace: namespace2,
      options
    });
    const dereferencedElement = await visitAsync2(refSet.rootRef.value, visitor2, {
      keyMap: keyMap3,
      nodeTypeGetter: getNodeType5
    });
    if (options.dereference.immutable) {
      mutableRefSet.refs.filter((ref) => ref.uri.startsWith("immutable://")).map((ref) => new Reference_default({
        ...ref,
        uri: ref.uri.replace(/^immutable:\/\//, "")
      })).forEach((ref) => immutableRefSet.add(ref));
    }
    if (options.dereference.refSet === null) {
      immutableRefSet.clean();
    }
    mutableRefSet.clean();
    return dereferencedElement;
  }
};
var openapi_3_1_default2 = OpenAPI3_1DereferenceStrategy;

// node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/utils/to-path.js
var trimParseResult = (elementPath) => elementPath.slice(2);
var toPath = (elementPath) => {
  const elementPathSanitized = trimParseResult(elementPath);
  return elementPathSanitized.reduce((path4, element, index) => {
    if (isMemberElement(element)) {
      const token = String(value_default(element.key));
      path4.push(token);
    } else if (isArrayElement(elementPathSanitized[index - 2])) {
      const token = elementPathSanitized[index - 2].content.indexOf(element);
      path4.push(token);
    }
    return path4;
  }, []);
};
var to_path_default = toPath;

// node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/visitors/properties.js
var ModelPropertyMacroVisitor = class {
  constructor({
    modelPropertyMacro,
    options
  }) {
    __publicField(this, "modelPropertyMacro");
    __publicField(this, "options");
    __publicField(this, "SchemaElement", {
      leave: (schemaElement, key57, parent, path4, ancestors) => {
        if (typeof schemaElement.properties === "undefined") return;
        if (!isObjectElement(schemaElement.properties)) return;
        schemaElement.properties.forEach((property2) => {
          if (!isObjectElement(property2)) return;
          try {
            const macroValue = this.modelPropertyMacro(value_default(property2));
            property2.set("default", macroValue);
          } catch (error) {
            var _this$options$derefer, _this$options$derefer2;
            const macroError = new Error(error, {
              cause: error
            });
            macroError.fullPath = [...to_path_default([...ancestors, parent, schemaElement]), "properties"];
            (_this$options$derefer = this.options.dereference.dereferenceOpts) === null || _this$options$derefer === void 0 || (_this$options$derefer = _this$options$derefer.errors) === null || _this$options$derefer === void 0 || (_this$options$derefer2 = _this$options$derefer.push) === null || _this$options$derefer2 === void 0 || _this$options$derefer2.call(_this$options$derefer, macroError);
          }
        });
      }
    });
    this.modelPropertyMacro = modelPropertyMacro;
    this.options = options;
  }
};
var properties_default2 = ModelPropertyMacroVisitor;

// node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/visitors/all-of.js
var AllOfVisitor4 = class {
  constructor({
    options
  }) {
    __publicField(this, "options");
    __publicField(this, "SchemaElement", {
      leave(schemaElement, key57, parent, path4, ancestors) {
        if (typeof schemaElement.allOf === "undefined") return void 0;
        if (!isArrayElement(schemaElement.allOf)) {
          var _this$options$derefer, _this$options$derefer2;
          const error = new TypeError("allOf must be an array");
          error.fullPath = [...to_path_default([...ancestors, parent, schemaElement]), "allOf"];
          (_this$options$derefer = this.options.dereference.dereferenceOpts) === null || _this$options$derefer === void 0 || (_this$options$derefer = _this$options$derefer.errors) === null || _this$options$derefer === void 0 || (_this$options$derefer2 = _this$options$derefer.push) === null || _this$options$derefer2 === void 0 || _this$options$derefer2.call(_this$options$derefer, error);
          return void 0;
        }
        if (schemaElement.allOf.isEmpty) {
          schemaElement.remove("allOf");
          return void 0;
        }
        const includesSchemaElementOnly = schemaElement.allOf.content.every(isSchemaElement2);
        if (!includesSchemaElementOnly) {
          var _this$options$derefer3, _this$options$derefer4;
          const error = new TypeError("Elements in allOf must be objects");
          error.fullPath = [...to_path_default([...ancestors, parent, schemaElement]), "allOf"];
          (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || (_this$options$derefer3 = _this$options$derefer3.errors) === null || _this$options$derefer3 === void 0 || (_this$options$derefer4 = _this$options$derefer3.push) === null || _this$options$derefer4 === void 0 || _this$options$derefer4.call(_this$options$derefer3, error);
          return void 0;
        }
        while (schemaElement.hasKey("allOf")) {
          const {
            allOf
          } = schemaElement;
          schemaElement.remove("allOf");
          const allOfMerged = deepmerge_default.all([...allOf.content, schemaElement]);
          if (!schemaElement.hasKey("$$ref")) {
            allOfMerged.remove("$$ref");
          }
          if (schemaElement.hasKey("example")) {
            const member = allOfMerged.getMember("example");
            if (member) {
              member.value = schemaElement.get("example");
            }
          }
          if (schemaElement.hasKey("examples")) {
            const member = allOfMerged.getMember("examples");
            if (member) {
              member.value = schemaElement.get("examples");
            }
          }
          schemaElement.content = allOfMerged.content;
        }
        return void 0;
      }
    });
    this.options = options;
  }
};
var all_of_default2 = AllOfVisitor4;

// node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/visitors/parameters.js
var _macroOperation;
var ParameterMacroVisitor = class {
  constructor({
    parameterMacro,
    options
  }) {
    __publicField(this, "parameterMacro");
    __publicField(this, "options");
    __privateAdd(this, _macroOperation);
    __publicField(this, "OperationElement", {
      enter: (operationElement) => {
        __privateSet(this, _macroOperation, operationElement);
      },
      leave: () => {
        __privateSet(this, _macroOperation, void 0);
      }
    });
    __publicField(this, "ParameterElement", {
      leave: (parameterElement, key57, parent, path4, ancestors) => {
        const pojoOperation = __privateGet(this, _macroOperation) ? value_default(__privateGet(this, _macroOperation)) : null;
        const pojoParameter = value_default(parameterElement);
        try {
          const macroValue = this.parameterMacro(pojoOperation, pojoParameter);
          parameterElement.set("default", macroValue);
        } catch (error) {
          var _this$options$derefer, _this$options$derefer2;
          const macroError = new Error(error, {
            cause: error
          });
          macroError.fullPath = to_path_default([...ancestors, parent]);
          (_this$options$derefer = this.options.dereference.dereferenceOpts) === null || _this$options$derefer === void 0 || (_this$options$derefer = _this$options$derefer.errors) === null || _this$options$derefer === void 0 || (_this$options$derefer2 = _this$options$derefer.push) === null || _this$options$derefer2 === void 0 || _this$options$derefer2.call(_this$options$derefer, macroError);
        }
      }
    });
    this.parameterMacro = parameterMacro;
    this.options = options;
  }
};
_macroOperation = new WeakMap();
var parameters_default2 = ParameterMacroVisitor;

// node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/utils/get-root-cause.js
var getRootCause = (error) => {
  if (error.cause == null) return error;
  let {
    cause
  } = error;
  while (cause.cause != null) {
    cause = cause.cause;
  }
  return cause;
};
var get_root_cause_default = getRootCause;

// node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/errors/SchemaRefError.js
var SchemaRefError = class extends ApiDOMStructuredError_default {
};
var SchemaRefError_default = SchemaRefError;

// node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/visitors/dereference.js
var {
  wrapError: wrapError2
} = refs_default;
var visitAsync3 = visit2[Symbol.for("nodejs.util.promisify.custom")];
var identityManager2 = new IdentityManager();
var mutationReplacer2 = (newElement, oldElement, key57, parent) => {
  if (isMemberElement(parent)) {
    parent.value = newElement;
  } else if (Array.isArray(parent)) {
    parent[key57] = newElement;
  }
};
var OpenAPI3_1SwaggerClientDereferenceVisitor = class _OpenAPI3_1SwaggerClientDereferenceVisitor extends visitor_default {
  constructor({
    allowMetaPatches = true,
    useCircularStructures = false,
    basePath = null,
    ...rest
  }) {
    super(rest);
    __publicField(this, "useCircularStructures");
    __publicField(this, "allowMetaPatches");
    __publicField(this, "basePath");
    this.allowMetaPatches = allowMetaPatches;
    this.useCircularStructures = useCircularStructures;
    this.basePath = basePath;
  }
  async ReferenceElement(referencingElement, key57, parent, path4, ancestors, link) {
    try {
      if (this.indirections.includes(referencingElement)) {
        return false;
      }
      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);
      const retrievalURI2 = this.toBaseURI(value_default(referencingElement.$ref));
      const isInternalReference = url_exports.stripHash(this.reference.uri) === retrievalURI2;
      const isExternalReference = !isInternalReference;
      if (!this.options.resolve.internal && isInternalReference) {
        return false;
      }
      if (!this.options.resolve.external && isExternalReference) {
        return false;
      }
      const reference = await this.toReference(value_default(referencingElement.$ref));
      const $refBaseURI = url_exports.resolve(retrievalURI2, value_default(referencingElement.$ref));
      this.indirections.push(referencingElement);
      const jsonPointer = uriToPointer($refBaseURI);
      let referencedElement = evaluate_default(jsonPointer, reference.value.result);
      referencedElement.id = identityManager2.identify(referencedElement);
      if (isPrimitiveElement(referencedElement)) {
        const referencedElementType = value_default(referencingElement.meta.get("referenced-element"));
        const cacheKey = `${referencedElementType}-${value_default(identityManager2.identify(referencedElement))}`;
        if (this.refractCache.has(cacheKey)) {
          referencedElement = this.refractCache.get(cacheKey);
        } else if (isReferenceLikeElement(referencedElement)) {
          referencedElement = Reference_default3.refract(referencedElement);
          referencedElement.setMetaProperty("referenced-element", referencedElementType);
          this.refractCache.set(cacheKey, referencedElement);
        } else {
          const ElementClass = this.namespace.getElementClass(referencedElementType);
          referencedElement = ElementClass.refract(referencedElement);
          this.refractCache.set(cacheKey, referencedElement);
        }
      }
      if (referencingElement === referencedElement) {
        throw new ApiDOMError_default("Recursive Reference Object detected");
      }
      if (this.indirections.length > this.options.dereference.maxDepth) {
        throw new MaximumDereferenceDepthError_default(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
      }
      if (ancestorsLineage.includes(referencedElement)) {
        reference.refSet.circular = true;
        if (this.options.dereference.circular === "error") {
          throw new ApiDOMError_default("Circular reference detected");
        } else if (this.options.dereference.circular === "replace") {
          var _this$options$derefer, _this$options$derefer2;
          const refElement = new import_minim10.RefElement(referencedElement.id, {
            type: "reference",
            uri: reference.uri,
            $ref: value_default(referencingElement.$ref),
            baseURI: $refBaseURI,
            referencingElement
          });
          const replacer = (_this$options$derefer = (_this$options$derefer2 = this.options.dereference.strategyOpts["openapi-3-1"]) === null || _this$options$derefer2 === void 0 ? void 0 : _this$options$derefer2.circularReplacer) !== null && _this$options$derefer !== void 0 ? _this$options$derefer : this.options.dereference.circularReplacer;
          const replacement = replacer(refElement);
          link.replaceWith(refElement, mutationReplacer2);
          return !parent ? replacement : false;
        }
      }
      const isNonRootDocument = url_exports.stripHash(reference.refSet.rootRef.uri) !== reference.uri;
      const shouldDetectCircular = ["error", "replace"].includes(this.options.dereference.circular);
      if ((isExternalReference || isNonRootDocument || isReferenceElement2(referencedElement) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {
        var _this$basePath;
        directAncestors.add(referencingElement);
        const visitor2 = new _OpenAPI3_1SwaggerClientDereferenceVisitor({
          reference,
          namespace: this.namespace,
          indirections: [...this.indirections],
          options: this.options,
          refractCache: this.refractCache,
          ancestors: ancestorsLineage,
          allowMetaPatches: this.allowMetaPatches,
          useCircularStructures: this.useCircularStructures,
          basePath: (_this$basePath = this.basePath) !== null && _this$basePath !== void 0 ? _this$basePath : [...to_path_default([...ancestors, parent, referencingElement]), "$ref"]
        });
        referencedElement = await visitAsync3(referencedElement, visitor2, {
          keyMap: keyMap3,
          nodeTypeGetter: getNodeType5
        });
        directAncestors.delete(referencingElement);
      }
      this.indirections.pop();
      const mergedElement = cloneShallow(referencedElement);
      mergedElement.setMetaProperty("ref-fields", {
        $ref: value_default(referencingElement.$ref),
        description: value_default(referencingElement.description),
        summary: value_default(referencingElement.summary)
      });
      mergedElement.setMetaProperty("ref-origin", reference.uri);
      mergedElement.setMetaProperty("ref-referencing-element-id", cloneDeep(identityManager2.identify(referencingElement)));
      if (isObjectElement(referencedElement)) {
        if (referencingElement.hasKey("description") && "description" in referencedElement) {
          mergedElement.remove("description");
          mergedElement.set("description", referencingElement.get("description"));
        }
        if (referencingElement.hasKey("summary") && "summary" in referencedElement) {
          mergedElement.remove("summary");
          mergedElement.set("summary", referencingElement.get("summary"));
        }
      }
      if (this.allowMetaPatches && isObjectElement(mergedElement)) {
        if (!mergedElement.hasKey("$$ref")) {
          const baseURI = url_exports.resolve(retrievalURI2, $refBaseURI);
          mergedElement.set("$$ref", baseURI);
        }
      }
      link.replaceWith(mergedElement, mutationReplacer2);
      return !parent ? mergedElement : false;
    } catch (error) {
      var _this$basePath2, _this$options$derefer3, _this$options$derefer4;
      const rootCause = get_root_cause_default(error);
      const wrappedError = wrapError2(rootCause, {
        baseDoc: this.reference.uri,
        $ref: value_default(referencingElement.$ref),
        pointer: uriToPointer(value_default(referencingElement.$ref)),
        fullPath: (_this$basePath2 = this.basePath) !== null && _this$basePath2 !== void 0 ? _this$basePath2 : [...to_path_default([...ancestors, parent, referencingElement]), "$ref"]
      });
      (_this$options$derefer3 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer3 === void 0 || (_this$options$derefer3 = _this$options$derefer3.errors) === null || _this$options$derefer3 === void 0 || (_this$options$derefer4 = _this$options$derefer3.push) === null || _this$options$derefer4 === void 0 || _this$options$derefer4.call(_this$options$derefer3, wrappedError);
      return void 0;
    }
  }
  async PathItemElement(pathItemElement, key57, parent, path4, ancestors, link) {
    try {
      if (!isStringElement(pathItemElement.$ref)) {
        return void 0;
      }
      if (this.indirections.includes(pathItemElement)) {
        return false;
      }
      if (includesClasses(["cycle"], pathItemElement.$ref)) {
        return false;
      }
      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);
      const retrievalURI2 = this.toBaseURI(value_default(pathItemElement.$ref));
      const isInternalReference = url_exports.stripHash(this.reference.uri) === retrievalURI2;
      const isExternalReference = !isInternalReference;
      if (!this.options.resolve.internal && isInternalReference) {
        return void 0;
      }
      if (!this.options.resolve.external && isExternalReference) {
        return void 0;
      }
      const reference = await this.toReference(value_default(pathItemElement.$ref));
      const $refBaseURI = url_exports.resolve(retrievalURI2, value_default(pathItemElement.$ref));
      this.indirections.push(pathItemElement);
      const jsonPointer = uriToPointer($refBaseURI);
      let referencedElement = evaluate_default(jsonPointer, reference.value.result);
      referencedElement.id = identityManager2.identify(referencedElement);
      if (isPrimitiveElement(referencedElement)) {
        const cacheKey = `path-item-${value_default(identityManager2.identify(referencedElement))}`;
        if (this.refractCache.has(cacheKey)) {
          referencedElement = this.refractCache.get(cacheKey);
        } else {
          referencedElement = PathItem_default2.refract(referencedElement);
          this.refractCache.set(cacheKey, referencedElement);
        }
      }
      if (pathItemElement === referencedElement) {
        throw new ApiDOMError_default("Recursive Path Item Object reference detected");
      }
      if (this.indirections.length > this.options.dereference.maxDepth) {
        throw new MaximumDereferenceDepthError_default(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
      }
      if (ancestorsLineage.includes(referencedElement)) {
        reference.refSet.circular = true;
        if (this.options.dereference.circular === "error") {
          throw new ApiDOMError_default("Circular reference detected");
        } else if (this.options.dereference.circular === "replace") {
          var _this$options$derefer5, _this$options$derefer6;
          const refElement = new import_minim10.RefElement(referencedElement.id, {
            type: "path-item",
            uri: reference.uri,
            $ref: value_default(pathItemElement.$ref),
            baseURI: $refBaseURI,
            referencingElement: pathItemElement
          });
          const replacer = (_this$options$derefer5 = (_this$options$derefer6 = this.options.dereference.strategyOpts["openapi-3-1"]) === null || _this$options$derefer6 === void 0 ? void 0 : _this$options$derefer6.circularReplacer) !== null && _this$options$derefer5 !== void 0 ? _this$options$derefer5 : this.options.dereference.circularReplacer;
          const replacement = replacer(refElement);
          link.replaceWith(refElement, mutationReplacer2);
          return !parent ? replacement : false;
        }
      }
      const isNonRootDocument = url_exports.stripHash(reference.refSet.rootRef.uri) !== reference.uri;
      const shouldDetectCircular = ["error", "replace"].includes(this.options.dereference.circular);
      if ((isExternalReference || isNonRootDocument || isPathItemElement2(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {
        var _this$basePath3;
        directAncestors.add(pathItemElement);
        const visitor2 = new _OpenAPI3_1SwaggerClientDereferenceVisitor({
          reference,
          namespace: this.namespace,
          indirections: [...this.indirections],
          options: this.options,
          ancestors: ancestorsLineage,
          allowMetaPatches: this.allowMetaPatches,
          useCircularStructures: this.useCircularStructures,
          basePath: (_this$basePath3 = this.basePath) !== null && _this$basePath3 !== void 0 ? _this$basePath3 : [...to_path_default([...ancestors, parent, pathItemElement]), "$ref"]
        });
        referencedElement = await visitAsync3(referencedElement, visitor2, {
          keyMap: keyMap3,
          nodeTypeGetter: getNodeType5
        });
        directAncestors.delete(pathItemElement);
      }
      this.indirections.pop();
      if (isPathItemElement2(referencedElement)) {
        const mergedElement = new PathItem_default2([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));
        pathItemElement.forEach((value, keyElement, item) => {
          mergedElement.remove(value_default(keyElement));
          mergedElement.content.push(item);
        });
        mergedElement.remove("$ref");
        mergedElement.setMetaProperty("ref-fields", {
          $ref: value_default(pathItemElement.$ref)
        });
        mergedElement.setMetaProperty("ref-origin", reference.uri);
        mergedElement.setMetaProperty("ref-referencing-element-id", cloneDeep(identityManager2.identify(pathItemElement)));
        if (this.allowMetaPatches) {
          if (typeof mergedElement.get("$$ref") === "undefined") {
            const baseURI = url_exports.resolve(retrievalURI2, $refBaseURI);
            mergedElement.set("$$ref", baseURI);
          }
        }
        referencedElement = mergedElement;
      }
      link.replaceWith(referencedElement, mutationReplacer2);
      return !parent ? referencedElement : void 0;
    } catch (error) {
      var _this$basePath4, _this$options$derefer7, _this$options$derefer8;
      const rootCause = get_root_cause_default(error);
      const wrappedError = wrapError2(rootCause, {
        baseDoc: this.reference.uri,
        $ref: value_default(pathItemElement.$ref),
        pointer: uriToPointer(value_default(pathItemElement.$ref)),
        fullPath: (_this$basePath4 = this.basePath) !== null && _this$basePath4 !== void 0 ? _this$basePath4 : [...to_path_default([...ancestors, parent, pathItemElement]), "$ref"]
      });
      (_this$options$derefer7 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer7 === void 0 || (_this$options$derefer7 = _this$options$derefer7.errors) === null || _this$options$derefer7 === void 0 || (_this$options$derefer8 = _this$options$derefer7.push) === null || _this$options$derefer8 === void 0 || _this$options$derefer8.call(_this$options$derefer7, wrappedError);
      return void 0;
    }
  }
  async SchemaElement(referencingElement, key57, parent, path4, ancestors, link) {
    try {
      if (!isStringElement(referencingElement.$ref)) {
        return void 0;
      }
      if (this.indirections.includes(referencingElement)) {
        return false;
      }
      const [ancestorsLineage, directAncestors] = this.toAncestorLineage([...ancestors, parent]);
      let reference = await this.toReference(url_exports.unsanitize(this.reference.uri));
      let {
        uri: retrievalURI2
      } = reference;
      const $refBaseURI = resolveSchema$refField(retrievalURI2, referencingElement);
      const $refBaseURIStrippedHash = url_exports.stripHash($refBaseURI);
      const file = new File_default({
        uri: $refBaseURIStrippedHash
      });
      const isUnknownURI = !this.options.resolve.resolvers.some((r2) => r2.canRead(file));
      const isURL = !isUnknownURI;
      let isInternalReference = url_exports.stripHash(this.reference.uri) === $refBaseURI;
      let isExternalReference = !isInternalReference;
      this.indirections.push(referencingElement);
      let referencedElement;
      try {
        if (isUnknownURI || isURL) {
          retrievalURI2 = this.toBaseURI($refBaseURI);
          const selector = $refBaseURI;
          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);
          referencedElement = evaluate3(selector, referenceAsSchema);
          referencedElement = maybeRefractToSchemaElement(referencedElement);
          referencedElement.id = identityManager2.identify(referencedElement);
          if (!this.options.resolve.internal && isInternalReference) {
            return void 0;
          }
          if (!this.options.resolve.external && isExternalReference) {
            return void 0;
          }
        } else {
          retrievalURI2 = this.toBaseURI($refBaseURI);
          isInternalReference = url_exports.stripHash(this.reference.uri) === retrievalURI2;
          isExternalReference = !isInternalReference;
          if (!this.options.resolve.internal && isInternalReference) {
            return void 0;
          }
          if (!this.options.resolve.external && isExternalReference) {
            return void 0;
          }
          reference = await this.toReference(url_exports.unsanitize($refBaseURI));
          const selector = uriToPointer($refBaseURI);
          const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);
          referencedElement = evaluate_default(selector, referenceAsSchema);
          referencedElement = maybeRefractToSchemaElement(referencedElement);
          referencedElement.id = identityManager2.identify(referencedElement);
        }
      } catch (error) {
        if (isURL && error instanceof EvaluationJsonSchemaUriError_default) {
          if (isAnchor2(uriToAnchor($refBaseURI))) {
            isInternalReference = url_exports.stripHash(this.reference.uri) === retrievalURI2;
            isExternalReference = !isInternalReference;
            if (!this.options.resolve.internal && isInternalReference) {
              return void 0;
            }
            if (!this.options.resolve.external && isExternalReference) {
              return void 0;
            }
            reference = await this.toReference(url_exports.unsanitize($refBaseURI));
            const selector = uriToAnchor($refBaseURI);
            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);
            referencedElement = evaluate2(selector, referenceAsSchema);
            referencedElement = maybeRefractToSchemaElement(referencedElement);
            referencedElement.id = identityManager2.identify(referencedElement);
          } else {
            retrievalURI2 = this.toBaseURI(value_default($refBaseURI));
            isInternalReference = url_exports.stripHash(this.reference.uri) === retrievalURI2;
            isExternalReference = !isInternalReference;
            if (!this.options.resolve.internal && isInternalReference) {
              return void 0;
            }
            if (!this.options.resolve.external && isExternalReference) {
              return void 0;
            }
            reference = await this.toReference(url_exports.unsanitize($refBaseURI));
            const selector = uriToPointer($refBaseURI);
            const referenceAsSchema = maybeRefractToSchemaElement(reference.value.result);
            referencedElement = evaluate_default(selector, referenceAsSchema);
            referencedElement = maybeRefractToSchemaElement(referencedElement);
            referencedElement.id = identityManager2.identify(referencedElement);
          }
        } else {
          throw error;
        }
      }
      if (referencingElement === referencedElement) {
        throw new ApiDOMError_default("Recursive Schema Object reference detected");
      }
      if (this.indirections.length > this.options.dereference.maxDepth) {
        throw new MaximumDereferenceDepthError_default(`Maximum dereference depth of "${this.options.dereference.maxDepth}" has been exceeded in file "${this.reference.uri}"`);
      }
      if (ancestorsLineage.includes(referencedElement)) {
        reference.refSet.circular = true;
        if (this.options.dereference.circular === "error") {
          throw new ApiDOMError_default("Circular reference detected");
        } else if (this.options.dereference.circular === "replace") {
          var _this$options$derefer9, _this$options$derefer10;
          const refElement = new import_minim10.RefElement(referencedElement.id, {
            type: "json-schema",
            uri: reference.uri,
            $ref: value_default(referencingElement.$ref),
            baseURI: url_exports.resolve(retrievalURI2, $refBaseURI),
            referencingElement
          });
          const replacer = (_this$options$derefer9 = (_this$options$derefer10 = this.options.dereference.strategyOpts["openapi-3-1"]) === null || _this$options$derefer10 === void 0 ? void 0 : _this$options$derefer10.circularReplacer) !== null && _this$options$derefer9 !== void 0 ? _this$options$derefer9 : this.options.dereference.circularReplacer;
          const replacement = replacer(refElement);
          link.replaceWith(replacement, mutationReplacer2);
          return !parent ? replacement : false;
        }
      }
      const isNonRootDocument = url_exports.stripHash(reference.refSet.rootRef.uri) !== reference.uri;
      const shouldDetectCircular = ["error", "replace"].includes(this.options.dereference.circular);
      if ((isExternalReference || isNonRootDocument || isSchemaElement2(referencedElement) && isStringElement(referencedElement.$ref) || shouldDetectCircular) && !ancestorsLineage.includesCycle(referencedElement)) {
        var _this$basePath5;
        directAncestors.add(referencingElement);
        const mergeVisitor = new _OpenAPI3_1SwaggerClientDereferenceVisitor({
          reference,
          namespace: this.namespace,
          indirections: [...this.indirections],
          options: this.options,
          useCircularStructures: this.useCircularStructures,
          allowMetaPatches: this.allowMetaPatches,
          ancestors: ancestorsLineage,
          basePath: (_this$basePath5 = this.basePath) !== null && _this$basePath5 !== void 0 ? _this$basePath5 : [...to_path_default([...ancestors, parent, referencingElement]), "$ref"]
        });
        referencedElement = await visitAsync3(referencedElement, mergeVisitor, {
          keyMap: keyMap3,
          nodeTypeGetter: getNodeType5
        });
        directAncestors.delete(referencingElement);
      }
      this.indirections.pop();
      if (isBooleanJsonSchemaElement2(referencedElement)) {
        const booleanJsonSchemaElement = cloneDeep(referencedElement);
        booleanJsonSchemaElement.setMetaProperty("ref-fields", {
          $ref: value_default(referencingElement.$ref)
        });
        booleanJsonSchemaElement.setMetaProperty("ref-origin", reference.uri);
        booleanJsonSchemaElement.setMetaProperty("ref-referencing-element-id", cloneDeep(identityManager2.identify(referencingElement)));
        link.replaceWith(booleanJsonSchemaElement, mutationReplacer2);
        return !parent ? booleanJsonSchemaElement : false;
      }
      if (isSchemaElement2(referencedElement)) {
        const mergedElement = new Schema_default2([...referencedElement.content], cloneDeep(referencedElement.meta), cloneDeep(referencedElement.attributes));
        referencingElement.forEach((value, keyElement, item) => {
          mergedElement.remove(value_default(keyElement));
          mergedElement.content.push(item);
        });
        mergedElement.remove("$ref");
        mergedElement.setMetaProperty("ref-fields", {
          $ref: value_default(referencingElement.$ref)
        });
        mergedElement.setMetaProperty("ref-origin", reference.uri);
        mergedElement.setMetaProperty("ref-referencing-element-id", cloneDeep(identityManager2.identify(referencingElement)));
        if (this.allowMetaPatches) {
          if (typeof mergedElement.get("$$ref") === "undefined") {
            const baseURI = url_exports.resolve(retrievalURI2, $refBaseURI);
            mergedElement.set("$$ref", baseURI);
          }
        }
        referencedElement = mergedElement;
      }
      link.replaceWith(referencedElement, mutationReplacer2);
      return !parent ? referencedElement : void 0;
    } catch (error) {
      var _this$basePath6, _this$options$derefer11, _this$options$derefer12;
      const rootCause = get_root_cause_default(error);
      const wrappedError = new SchemaRefError_default(`Could not resolve reference: ${rootCause.message}`, {
        baseDoc: this.reference.uri,
        $ref: value_default(referencingElement.$ref),
        fullPath: (_this$basePath6 = this.basePath) !== null && _this$basePath6 !== void 0 ? _this$basePath6 : [...to_path_default([...ancestors, parent, referencingElement]), "$ref"],
        cause: rootCause
      });
      (_this$options$derefer11 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer11 === void 0 || (_this$options$derefer11 = _this$options$derefer11.errors) === null || _this$options$derefer11 === void 0 || (_this$options$derefer12 = _this$options$derefer11.push) === null || _this$options$derefer12 === void 0 || _this$options$derefer12.call(_this$options$derefer11, wrappedError);
      return void 0;
    }
  }
  // eslint-disable-next-line class-methods-use-this
  async LinkElement() {
    return void 0;
  }
  async ExampleElement(exampleElement, key57, parent, path4, ancestors, link) {
    try {
      return await super.ExampleElement(exampleElement, key57, parent, path4, ancestors, link);
    } catch (error) {
      var _this$basePath7, _this$options$derefer13, _this$options$derefer14;
      const rootCause = get_root_cause_default(error);
      const wrappedError = wrapError2(rootCause, {
        baseDoc: this.reference.uri,
        externalValue: value_default(exampleElement.externalValue),
        fullPath: (_this$basePath7 = this.basePath) !== null && _this$basePath7 !== void 0 ? _this$basePath7 : [...to_path_default([...ancestors, parent, exampleElement]), "externalValue"]
      });
      (_this$options$derefer13 = this.options.dereference.dereferenceOpts) === null || _this$options$derefer13 === void 0 || (_this$options$derefer13 = _this$options$derefer13.errors) === null || _this$options$derefer13 === void 0 || (_this$options$derefer14 = _this$options$derefer13.push) === null || _this$options$derefer14 === void 0 || _this$options$derefer14.call(_this$options$derefer13, wrappedError);
      return void 0;
    }
  }
};
var dereference_default2 = OpenAPI3_1SwaggerClientDereferenceVisitor;

// node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/visitors/root.js
var mergeAllVisitorsAsync = mergeAll3[Symbol.for("nodejs.util.promisify.custom")];
var RootVisitor = class {
  constructor({
    parameterMacro,
    modelPropertyMacro,
    mode,
    options,
    ...rest
  }) {
    const visitors = [];
    visitors.push(new dereference_default2({
      ...rest,
      options
    }));
    if (typeof modelPropertyMacro === "function") {
      visitors.push(new properties_default2({
        modelPropertyMacro,
        options
      }));
    }
    if (mode !== "strict") {
      visitors.push(new all_of_default2({
        options
      }));
    }
    if (typeof parameterMacro === "function") {
      visitors.push(new parameters_default2({
        parameterMacro,
        options
      }));
    }
    const mergedVisitor = mergeAllVisitorsAsync(visitors, {
      nodeTypeGetter: getNodeType5
    });
    Object.assign(this, mergedVisitor);
  }
};
var root_default = RootVisitor;

// node_modules/swagger-client/es/resolver/apidom/reference/dereference/strategies/openapi-3-1-swagger-client/index.js
var visitAsync4 = visit2[Symbol.for("nodejs.util.promisify.custom")];
var OpenAPI3_1SwaggerClientDereferenceStrategy = class extends openapi_3_1_default2 {
  constructor({
    allowMetaPatches = false,
    parameterMacro = null,
    modelPropertyMacro = null,
    mode = "non-strict",
    ancestors = [],
    ...rest
  } = {}) {
    super({
      ...rest
    });
    __publicField(this, "allowMetaPatches");
    __publicField(this, "parameterMacro");
    __publicField(this, "modelPropertyMacro");
    __publicField(this, "mode");
    __publicField(this, "ancestors");
    this.name = "openapi-3-1-swagger-client";
    this.allowMetaPatches = allowMetaPatches;
    this.parameterMacro = parameterMacro;
    this.modelPropertyMacro = modelPropertyMacro;
    this.mode = mode;
    this.ancestors = [...ancestors];
  }
  async dereference(file, options) {
    var _options$dereference$;
    const namespace2 = createNamespace(namespace_default4);
    const immutableRefSet = (_options$dereference$ = options.dereference.refSet) !== null && _options$dereference$ !== void 0 ? _options$dereference$ : new ReferenceSet_default();
    const mutableRefsSet = new ReferenceSet_default();
    let refSet = immutableRefSet;
    let reference;
    if (!immutableRefSet.has(file.uri)) {
      reference = new Reference_default({
        uri: file.uri,
        value: file.parseResult
      });
      immutableRefSet.add(reference);
    } else {
      reference = immutableRefSet.find((ref) => ref.uri === file.uri);
    }
    if (options.dereference.immutable) {
      immutableRefSet.refs.map((ref) => new Reference_default({
        ...ref,
        value: cloneDeep(ref.value)
      })).forEach((ref) => mutableRefsSet.add(ref));
      reference = mutableRefsSet.find((ref) => ref.uri === file.uri);
      refSet = mutableRefsSet;
    }
    const rootVisitor = new root_default({
      reference,
      namespace: namespace2,
      options,
      allowMetaPatches: this.allowMetaPatches,
      ancestors: this.ancestors,
      modelPropertyMacro: this.modelPropertyMacro,
      mode: this.mode,
      parameterMacro: this.parameterMacro
    });
    const dereferencedElement = await visitAsync4(refSet.rootRef.value, rootVisitor, {
      keyMap: keyMap3,
      nodeTypeGetter: getNodeType5
    });
    if (options.dereference.immutable) {
      mutableRefsSet.refs.filter((ref) => ref.uri.startsWith("immutable://")).map((ref) => new Reference_default({
        ...ref,
        uri: ref.uri.replace(/^immutable:\/\//, "")
      })).forEach((ref) => immutableRefSet.add(ref));
    }
    if (options.dereference.refSet === null) {
      immutableRefSet.clean();
    }
    mutableRefsSet.clean();
    return dereferencedElement;
  }
};
var openapi_3_1_swagger_client_default = OpenAPI3_1SwaggerClientDereferenceStrategy;

// node_modules/swagger-client/es/resolver/strategies/openapi-3-1-apidom/resolve.js
var circularReplacer = (refElement) => {
  const $refBaseURI = value_default(refElement.meta.get("baseURI"));
  const referencingElement = refElement.meta.get("referencingElement");
  return new import_minim10.ObjectElement({
    $ref: $refBaseURI
  }, cloneDeep(referencingElement.meta), cloneDeep(referencingElement.attributes));
};
var resolveOpenAPI31Strategy = async (options) => {
  const {
    spec: spec2,
    timeout,
    redirects,
    requestInterceptor,
    responseInterceptor,
    pathDiscriminator = [],
    allowMetaPatches = false,
    useCircularStructures = false,
    skipNormalization = false,
    parameterMacro = null,
    modelPropertyMacro = null,
    mode = "non-strict",
    strategies
  } = options;
  try {
    const {
      cache
    } = resolveOpenAPI31Strategy;
    const strategy = strategies.find((strg) => strg.match(spec2));
    const cwd2 = url_exports.isHttpUrl(url_exports.cwd()) ? url_exports.cwd() : DEFAULT_BASE_URL;
    const retrievalURI2 = retrievalURI(options);
    const baseURI = url_exports.resolve(cwd2, retrievalURI2);
    let openApiElement;
    if (cache.has(spec2)) {
      openApiElement = cache.get(spec2);
    } else {
      openApiElement = OpenApi3_1_default.refract(spec2);
      openApiElement.classes.push("result");
      cache.set(spec2, openApiElement);
    }
    const openApiParseResultElement = new ParseResult_default([openApiElement]);
    const jsonPointer = compile_default(pathDiscriminator);
    const jsonPointerURI = jsonPointer === "" ? "" : `#${jsonPointer}`;
    const fragmentElement = evaluate_default(jsonPointer, openApiElement);
    const openApiElementReference = new Reference_default({
      uri: baseURI,
      value: openApiParseResultElement
    });
    const refSet = new ReferenceSet_default({
      refs: [openApiElementReference]
    });
    if (jsonPointer !== "") refSet.rootRef = void 0;
    const ancestors = [/* @__PURE__ */ new Set([fragmentElement])];
    const errors = [];
    const dereferenced = await dereferenceApiDOM2(fragmentElement, {
      resolve: {
        /**
         * swagger-client only supports resolving HTTP(S) URLs or spec objects.
         * If runtime env is detected as non-browser one,
         * and baseURI was not provided as part of resolver options,
         * then below baseURI check will make sure that constant HTTPS URL is used as baseURI.
         */
        baseURI: `${baseURI}${jsonPointerURI}`,
        resolvers: [new http_swagger_client_default({
          timeout: timeout || 1e4,
          redirects: redirects || 10
        })],
        resolverOpts: {
          swaggerHTTPClientConfig: {
            requestInterceptor,
            responseInterceptor
          }
        },
        strategies: [new openapi_3_1_default()]
      },
      parse: {
        mediaType: media_types_default2.latest(),
        parsers: [new openapi_json_3_1_default({
          allowEmpty: false,
          sourceMap: false
        }), new openapi_yaml_3_1_default({
          allowEmpty: false,
          sourceMap: false
        }), new json_default3({
          allowEmpty: false,
          sourceMap: false
        }), new yaml_1_2_default2({
          allowEmpty: false,
          sourceMap: false
        }), new index_browser_default({
          allowEmpty: false,
          sourceMap: false
        })]
      },
      dereference: {
        maxDepth: 100,
        strategies: [new openapi_3_1_swagger_client_default({
          allowMetaPatches,
          useCircularStructures,
          parameterMacro,
          modelPropertyMacro,
          mode,
          ancestors
        })],
        refSet,
        dereferenceOpts: {
          errors
        },
        immutable: false,
        circular: useCircularStructures ? "ignore" : "replace",
        circularReplacer: useCircularStructures ? options_default.dereference.circularReplacer : circularReplacer
      }
    });
    const transcluded = transclude(fragmentElement, dereferenced, openApiElement);
    const normalized = skipNormalization ? transcluded : strategy.normalize(transcluded);
    return {
      spec: value_default(normalized),
      errors
    };
  } catch (error) {
    if (error instanceof InvalidJsonPointerError_default || error instanceof EvaluationJsonPointerError_default) {
      return {
        spec: null,
        errors: []
      };
    }
    throw error;
  }
};
resolveOpenAPI31Strategy.cache = /* @__PURE__ */ new WeakMap();
var resolve_default2 = resolveOpenAPI31Strategy;

// node_modules/swagger-client/es/resolver/strategies/openapi-3-1-apidom/normalize.js
var normalize2 = (element) => {
  if (!isObjectElement(element)) return element;
  const plugins2 = [normalize_operation_ids_default({
    operationIdNormalizer: (operationId, path4, method) => opId({
      operationId
    }, path4, method, {
      v2OperationIdCompatibilityMode: false
    })
  }), normalize_parameters_default(), normalize_security_requirements_default(), normalize_parameter_examples_default(), normalize_header_examples_default()];
  const normalized = dispatchPluginsSync(element, plugins2, {
    toolboxCreator: toolbox_default4,
    visitorOptions: {
      keyMap: keyMap3,
      nodeTypeGetter: getNodeType5
    }
  });
  return normalized;
};
var pojoAdapter = (normalizeFn) => (spec2) => {
  const openApiElement = OpenApi3_1_default.refract(spec2);
  openApiElement.classes.push("result");
  const normalized = normalizeFn(openApiElement);
  const value = value_default(normalized);
  resolve_default2.cache.set(value, normalized);
  return value_default(normalized);
};
var normalize_default = normalize2;

// node_modules/swagger-client/es/resolver/strategies/openapi-3-1-apidom/index.js
var openApi31ApiDOMStrategy = {
  name: "openapi-3-1-apidom",
  match(spec2) {
    return isOpenAPI31(spec2);
  },
  normalize(spec2) {
    if (!isElement(spec2) && isPlainObj_default(spec2) && !spec2.$$normalized) {
      const preNormalized = pojoAdapter(normalize_default)(spec2);
      preNormalized.$$normalized = true;
      return preNormalized;
    }
    if (isElement(spec2)) {
      return normalize_default(spec2);
    }
    return spec2;
  },
  async resolve(options) {
    return resolve_default2(options);
  }
};
var openapi_3_1_apidom_default = openApi31ApiDOMStrategy;

// node_modules/swagger-client/es/resolver/index.js
var resolve2 = async (options) => {
  const {
    spec: spec2,
    requestInterceptor,
    responseInterceptor
  } = options;
  const retrievalURI2 = retrievalURI(options);
  const httpClient2 = httpClient(options);
  const retrievedSpec = spec2 || await makeFetchJSON(httpClient2, {
    requestInterceptor,
    responseInterceptor
  })(retrievalURI2);
  const strategyOptions = {
    ...options,
    spec: retrievedSpec
  };
  const strategy = options.strategies.find((strg) => strg.match(retrievedSpec));
  return strategy.resolve(strategyOptions);
};
var makeResolve = (defaultOptions3) => async (options) => {
  const mergedOptions = {
    ...defaultOptions3,
    ...options
  };
  return resolve2(mergedOptions);
};
var resolver_default = makeResolve({
  strategies: [openapi_3_0_default, openapi_2_default, generic_default]
});

// node_modules/swagger-client/es/execute/index.js
var import_cookie = __toESM(require_cookie());

// node_modules/openapi-server-url-templating/es/server-url-templating.mjs
function grammar() {
  this.grammarObject = "grammarObject";
  this.rules = [];
  this.rules[0] = {
    name: "server-url-template",
    lower: "server-url-template",
    index: 0,
    isBkr: false
  };
  this.rules[1] = {
    name: "server-variable",
    lower: "server-variable",
    index: 1,
    isBkr: false
  };
  this.rules[2] = {
    name: "server-variable-name",
    lower: "server-variable-name",
    index: 2,
    isBkr: false
  };
  this.rules[3] = {
    name: "literals",
    lower: "literals",
    index: 3,
    isBkr: false
  };
  this.rules[4] = {
    name: "ALPHA",
    lower: "alpha",
    index: 4,
    isBkr: false
  };
  this.rules[5] = {
    name: "DIGIT",
    lower: "digit",
    index: 5,
    isBkr: false
  };
  this.rules[6] = {
    name: "HEXDIG",
    lower: "hexdig",
    index: 6,
    isBkr: false
  };
  this.rules[7] = {
    name: "pct-encoded",
    lower: "pct-encoded",
    index: 7,
    isBkr: false
  };
  this.rules[8] = {
    name: "unreserved",
    lower: "unreserved",
    index: 8,
    isBkr: false
  };
  this.rules[9] = {
    name: "sub-delims",
    lower: "sub-delims",
    index: 9,
    isBkr: false
  };
  this.rules[10] = {
    name: "ucschar",
    lower: "ucschar",
    index: 10,
    isBkr: false
  };
  this.rules[11] = {
    name: "iprivate",
    lower: "iprivate",
    index: 11,
    isBkr: false
  };
  this.udts = [];
  this.rules[0].opcodes = [];
  this.rules[0].opcodes[0] = {
    type: 3,
    min: 1,
    max: Infinity
  };
  this.rules[0].opcodes[1] = {
    type: 1,
    children: [2, 3]
  };
  this.rules[0].opcodes[2] = {
    type: 4,
    index: 3
  };
  this.rules[0].opcodes[3] = {
    type: 4,
    index: 1
  };
  this.rules[1].opcodes = [];
  this.rules[1].opcodes[0] = {
    type: 2,
    children: [1, 2, 3]
  };
  this.rules[1].opcodes[1] = {
    type: 7,
    string: [123]
  };
  this.rules[1].opcodes[2] = {
    type: 4,
    index: 2
  };
  this.rules[1].opcodes[3] = {
    type: 7,
    string: [125]
  };
  this.rules[2].opcodes = [];
  this.rules[2].opcodes[0] = {
    type: 3,
    min: 1,
    max: Infinity
  };
  this.rules[2].opcodes[1] = {
    type: 1,
    children: [2, 3, 4, 5, 6]
  };
  this.rules[2].opcodes[2] = {
    type: 4,
    index: 8
  };
  this.rules[2].opcodes[3] = {
    type: 4,
    index: 7
  };
  this.rules[2].opcodes[4] = {
    type: 4,
    index: 9
  };
  this.rules[2].opcodes[5] = {
    type: 7,
    string: [58]
  };
  this.rules[2].opcodes[6] = {
    type: 7,
    string: [64]
  };
  this.rules[3].opcodes = [];
  this.rules[3].opcodes[0] = {
    type: 3,
    min: 1,
    max: Infinity
  };
  this.rules[3].opcodes[1] = {
    type: 1,
    children: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
  };
  this.rules[3].opcodes[2] = {
    type: 6,
    string: [33]
  };
  this.rules[3].opcodes[3] = {
    type: 5,
    min: 35,
    max: 36
  };
  this.rules[3].opcodes[4] = {
    type: 6,
    string: [38]
  };
  this.rules[3].opcodes[5] = {
    type: 5,
    min: 40,
    max: 59
  };
  this.rules[3].opcodes[6] = {
    type: 6,
    string: [61]
  };
  this.rules[3].opcodes[7] = {
    type: 5,
    min: 63,
    max: 91
  };
  this.rules[3].opcodes[8] = {
    type: 6,
    string: [93]
  };
  this.rules[3].opcodes[9] = {
    type: 6,
    string: [95]
  };
  this.rules[3].opcodes[10] = {
    type: 5,
    min: 97,
    max: 122
  };
  this.rules[3].opcodes[11] = {
    type: 6,
    string: [126]
  };
  this.rules[3].opcodes[12] = {
    type: 4,
    index: 10
  };
  this.rules[3].opcodes[13] = {
    type: 4,
    index: 11
  };
  this.rules[3].opcodes[14] = {
    type: 4,
    index: 7
  };
  this.rules[4].opcodes = [];
  this.rules[4].opcodes[0] = {
    type: 1,
    children: [1, 2]
  };
  this.rules[4].opcodes[1] = {
    type: 5,
    min: 65,
    max: 90
  };
  this.rules[4].opcodes[2] = {
    type: 5,
    min: 97,
    max: 122
  };
  this.rules[5].opcodes = [];
  this.rules[5].opcodes[0] = {
    type: 5,
    min: 48,
    max: 57
  };
  this.rules[6].opcodes = [];
  this.rules[6].opcodes[0] = {
    type: 1,
    children: [1, 2, 3, 4, 5, 6, 7]
  };
  this.rules[6].opcodes[1] = {
    type: 4,
    index: 5
  };
  this.rules[6].opcodes[2] = {
    type: 7,
    string: [97]
  };
  this.rules[6].opcodes[3] = {
    type: 7,
    string: [98]
  };
  this.rules[6].opcodes[4] = {
    type: 7,
    string: [99]
  };
  this.rules[6].opcodes[5] = {
    type: 7,
    string: [100]
  };
  this.rules[6].opcodes[6] = {
    type: 7,
    string: [101]
  };
  this.rules[6].opcodes[7] = {
    type: 7,
    string: [102]
  };
  this.rules[7].opcodes = [];
  this.rules[7].opcodes[0] = {
    type: 2,
    children: [1, 2, 3]
  };
  this.rules[7].opcodes[1] = {
    type: 7,
    string: [37]
  };
  this.rules[7].opcodes[2] = {
    type: 4,
    index: 6
  };
  this.rules[7].opcodes[3] = {
    type: 4,
    index: 6
  };
  this.rules[8].opcodes = [];
  this.rules[8].opcodes[0] = {
    type: 1,
    children: [1, 2, 3, 4, 5, 6]
  };
  this.rules[8].opcodes[1] = {
    type: 4,
    index: 4
  };
  this.rules[8].opcodes[2] = {
    type: 4,
    index: 5
  };
  this.rules[8].opcodes[3] = {
    type: 7,
    string: [45]
  };
  this.rules[8].opcodes[4] = {
    type: 7,
    string: [46]
  };
  this.rules[8].opcodes[5] = {
    type: 7,
    string: [95]
  };
  this.rules[8].opcodes[6] = {
    type: 7,
    string: [126]
  };
  this.rules[9].opcodes = [];
  this.rules[9].opcodes[0] = {
    type: 1,
    children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
  };
  this.rules[9].opcodes[1] = {
    type: 7,
    string: [33]
  };
  this.rules[9].opcodes[2] = {
    type: 7,
    string: [36]
  };
  this.rules[9].opcodes[3] = {
    type: 7,
    string: [38]
  };
  this.rules[9].opcodes[4] = {
    type: 7,
    string: [39]
  };
  this.rules[9].opcodes[5] = {
    type: 7,
    string: [40]
  };
  this.rules[9].opcodes[6] = {
    type: 7,
    string: [41]
  };
  this.rules[9].opcodes[7] = {
    type: 7,
    string: [42]
  };
  this.rules[9].opcodes[8] = {
    type: 7,
    string: [43]
  };
  this.rules[9].opcodes[9] = {
    type: 7,
    string: [44]
  };
  this.rules[9].opcodes[10] = {
    type: 7,
    string: [59]
  };
  this.rules[9].opcodes[11] = {
    type: 7,
    string: [61]
  };
  this.rules[10].opcodes = [];
  this.rules[10].opcodes[0] = {
    type: 1,
    children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]
  };
  this.rules[10].opcodes[1] = {
    type: 5,
    min: 160,
    max: 55295
  };
  this.rules[10].opcodes[2] = {
    type: 5,
    min: 63744,
    max: 64975
  };
  this.rules[10].opcodes[3] = {
    type: 5,
    min: 65008,
    max: 65519
  };
  this.rules[10].opcodes[4] = {
    type: 5,
    min: 65536,
    max: 131069
  };
  this.rules[10].opcodes[5] = {
    type: 5,
    min: 131072,
    max: 196605
  };
  this.rules[10].opcodes[6] = {
    type: 5,
    min: 196608,
    max: 262141
  };
  this.rules[10].opcodes[7] = {
    type: 5,
    min: 262144,
    max: 327677
  };
  this.rules[10].opcodes[8] = {
    type: 5,
    min: 327680,
    max: 393213
  };
  this.rules[10].opcodes[9] = {
    type: 5,
    min: 393216,
    max: 458749
  };
  this.rules[10].opcodes[10] = {
    type: 5,
    min: 458752,
    max: 524285
  };
  this.rules[10].opcodes[11] = {
    type: 5,
    min: 524288,
    max: 589821
  };
  this.rules[10].opcodes[12] = {
    type: 5,
    min: 589824,
    max: 655357
  };
  this.rules[10].opcodes[13] = {
    type: 5,
    min: 655360,
    max: 720893
  };
  this.rules[10].opcodes[14] = {
    type: 5,
    min: 720896,
    max: 786429
  };
  this.rules[10].opcodes[15] = {
    type: 5,
    min: 786432,
    max: 851965
  };
  this.rules[10].opcodes[16] = {
    type: 5,
    min: 851968,
    max: 917501
  };
  this.rules[10].opcodes[17] = {
    type: 5,
    min: 921600,
    max: 983037
  };
  this.rules[11].opcodes = [];
  this.rules[11].opcodes[0] = {
    type: 1,
    children: [1, 2, 3]
  };
  this.rules[11].opcodes[1] = {
    type: 5,
    min: 57344,
    max: 63743
  };
  this.rules[11].opcodes[2] = {
    type: 5,
    min: 983040,
    max: 1048573
  };
  this.rules[11].opcodes[3] = {
    type: 5,
    min: 1048576,
    max: 1114109
  };
  this.toString = function toString5() {
    let str2 = "";
    str2 += "; OpenAPI Server URL templating ABNF syntax\n";
    str2 += "server-url-template    = 1*( literals / server-variable )\n";
    str2 += 'server-variable        = "{" server-variable-name "}"\n';
    str2 += 'server-variable-name   = 1*( unreserved / pct-encoded / sub-delims / ":" / "@" )\n';
    str2 += "literals               = 1*( %x21 / %x23-24 / %x26 / %x28-3B / %x3D / %x3F-5B\n";
    str2 += "                       / %x5D / %x5F / %x61-7A / %x7E / ucschar / iprivate\n";
    str2 += "                       / pct-encoded)\n";
    str2 += "                           ; any Unicode character except: CTL, SP,\n";
    str2 += `                           ;  DQUOTE, "'", "%" (aside from pct-encoded),
`;
    str2 += '                           ;  "<", ">", "\\", "^", "`", "{", "|", "}"\n';
    str2 += "\n";
    str2 += "; Characters definitions (from RFC 6570)\n";
    str2 += "ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z\n";
    str2 += "DIGIT          =  %x30-39             ; 0-9\n";
    str2 += 'HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"\n';
    str2 += "                 ; case-insensitive\n";
    str2 += "\n";
    str2 += 'pct-encoded    =  "%" HEXDIG HEXDIG\n';
    str2 += 'unreserved     =  ALPHA / DIGIT / "-" / "." / "_" / "~"\n';
    str2 += `sub-delims     =  "!" / "$" / "&" / "'" / "(" / ")"
`;
    str2 += '               /  "*" / "+" / "," / ";" / "="\n';
    str2 += "\n";
    str2 += "ucschar        =  %xA0-D7FF / %xF900-FDCF / %xFDF0-FFEF\n";
    str2 += "               /  %x10000-1FFFD / %x20000-2FFFD / %x30000-3FFFD\n";
    str2 += "               /  %x40000-4FFFD / %x50000-5FFFD / %x60000-6FFFD\n";
    str2 += "               /  %x70000-7FFFD / %x80000-8FFFD / %x90000-9FFFD\n";
    str2 += "               /  %xA0000-AFFFD / %xB0000-BFFFD / %xC0000-CFFFD\n";
    str2 += "               /  %xD0000-DFFFD / %xE1000-EFFFD\n";
    str2 += "\n";
    str2 += "iprivate       =  %xE000-F8FF / %xF0000-FFFFD / %x100000-10FFFD\n";
    return str2;
  };
}

// node_modules/apg-lite/lib/parser.js
var Parser2 = function fnparser() {
  const id = identifiers;
  const utils2 = utilities;
  const p2 = this;
  const thisFileName = "parser.js: Parser(): ";
  const systemData = function systemData2() {
    this.state = id.ACTIVE;
    this.phraseLength = 0;
    this.refresh = () => {
      this.state = id.ACTIVE;
      this.phraseLength = 0;
    };
  };
  p2.ast = void 0;
  p2.stats = void 0;
  p2.trace = void 0;
  p2.callbacks = [];
  let lookAhead = 0;
  let treeDepth = 0;
  let maxTreeDepth = 0;
  let nodeHits = 0;
  let maxMatched = 0;
  let rules2 = void 0;
  let udts = void 0;
  let opcodes = void 0;
  let chars = void 0;
  let sysData = new systemData();
  let ruleCallbacks = void 0;
  let udtCallbacks = void 0;
  let userData = void 0;
  const clear2 = () => {
    lookAhead = 0;
    treeDepth = 0;
    maxTreeDepth = 0;
    nodeHits = 0;
    maxMatched = 0;
    rules2 = void 0;
    udts = void 0;
    opcodes = void 0;
    chars = void 0;
    sysData.refresh();
    ruleCallbacks = void 0;
    udtCallbacks = void 0;
    userData = void 0;
  };
  const initializeCallbacks = () => {
    const functionName = `${thisFileName}initializeCallbacks(): `;
    let i2;
    ruleCallbacks = [];
    udtCallbacks = [];
    for (i2 = 0; i2 < rules2.length; i2 += 1) {
      ruleCallbacks[i2] = void 0;
    }
    for (i2 = 0; i2 < udts.length; i2 += 1) {
      udtCallbacks[i2] = void 0;
    }
    let func;
    const list4 = [];
    for (i2 = 0; i2 < rules2.length; i2 += 1) {
      list4.push(rules2[i2].lower);
    }
    for (i2 = 0; i2 < udts.length; i2 += 1) {
      list4.push(udts[i2].lower);
    }
    for (const index in p2.callbacks) {
      if (p2.callbacks.hasOwnProperty(index)) {
        i2 = list4.indexOf(index.toLowerCase());
        if (i2 < 0) {
          throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);
        }
        func = p2.callbacks[index] ? p2.callbacks[index] : void 0;
        if (typeof func === "function" || func === void 0) {
          if (i2 < rules2.length) {
            ruleCallbacks[i2] = func;
          } else {
            udtCallbacks[i2 - rules2.length] = func;
          }
        } else {
          throw new Error(`${functionName}syntax callback[${index}] must be function reference or falsy)`);
        }
      }
    }
  };
  p2.parse = (grammar5, startName, inputString, callbackData) => {
    const functionName = `${thisFileName}parse(): `;
    clear2();
    chars = utils2.stringToChars(inputString);
    rules2 = grammar5.rules;
    udts = grammar5.udts;
    const lower = startName.toLowerCase();
    let startIndex = void 0;
    for (const i2 in rules2) {
      if (rules2.hasOwnProperty(i2)) {
        if (lower === rules2[i2].lower) {
          startIndex = rules2[i2].index;
          break;
        }
      }
    }
    if (startIndex === void 0) {
      throw new Error(`${functionName}start rule name '${startRule}' not recognized`);
    }
    initializeCallbacks();
    if (p2.trace) {
      p2.trace.init(rules2, udts, chars);
    }
    if (p2.stats) {
      p2.stats.init(rules2, udts);
    }
    if (p2.ast) {
      p2.ast.init(rules2, udts, chars);
    }
    userData = callbackData;
    opcodes = [
      {
        type: id.RNM,
        index: startIndex
      }
    ];
    opExecute(0, 0);
    opcodes = void 0;
    let success = false;
    switch (sysData.state) {
      case id.ACTIVE:
        throw new Error(`${functionName}final state should never be 'ACTIVE'`);
      case id.NOMATCH:
        success = false;
        break;
      case id.EMPTY:
      case id.MATCH:
        if (sysData.phraseLength === chars.length) {
          success = true;
        } else {
          success = false;
        }
        break;
      default:
        throw new Error("unrecognized state");
    }
    return {
      success,
      state: sysData.state,
      stateName: id.idName(sysData.state),
      length: chars.length,
      matched: sysData.phraseLength,
      maxMatched,
      maxTreeDepth,
      nodeHits
    };
  };
  const opALT = (opIndex, phraseIndex) => {
    const op = opcodes[opIndex];
    for (let i2 = 0; i2 < op.children.length; i2 += 1) {
      opExecute(op.children[i2], phraseIndex);
      if (sysData.state !== id.NOMATCH) {
        break;
      }
    }
  };
  const opCAT = (opIndex, phraseIndex) => {
    let success;
    let astLength;
    let catCharIndex;
    let catPhrase;
    const op = opcodes[opIndex];
    if (p2.ast) {
      astLength = p2.ast.getLength();
    }
    success = true;
    catCharIndex = phraseIndex;
    catPhrase = 0;
    for (let i2 = 0; i2 < op.children.length; i2 += 1) {
      opExecute(op.children[i2], catCharIndex);
      if (sysData.state === id.NOMATCH) {
        success = false;
        break;
      } else {
        catCharIndex += sysData.phraseLength;
        catPhrase += sysData.phraseLength;
      }
    }
    if (success) {
      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;
      sysData.phraseLength = catPhrase;
    } else {
      sysData.state = id.NOMATCH;
      sysData.phraseLength = 0;
      if (p2.ast) {
        p2.ast.setLength(astLength);
      }
    }
  };
  const opREP = (opIndex, phraseIndex) => {
    let astLength;
    let repCharIndex;
    let repPhrase;
    let repCount;
    const op = opcodes[opIndex];
    if (op.max === 0) {
      sysData.state = id.EMPTY;
      sysData.phraseLength = 0;
      return;
    }
    repCharIndex = phraseIndex;
    repPhrase = 0;
    repCount = 0;
    if (p2.ast) {
      astLength = p2.ast.getLength();
    }
    while (1) {
      if (repCharIndex >= chars.length) {
        break;
      }
      opExecute(opIndex + 1, repCharIndex);
      if (sysData.state === id.NOMATCH) {
        break;
      }
      if (sysData.state === id.EMPTY) {
        break;
      }
      repCount += 1;
      repPhrase += sysData.phraseLength;
      repCharIndex += sysData.phraseLength;
      if (repCount === op.max) {
        break;
      }
    }
    if (sysData.state === id.EMPTY) {
      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
      sysData.phraseLength = repPhrase;
    } else if (repCount >= op.min) {
      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;
      sysData.phraseLength = repPhrase;
    } else {
      sysData.state = id.NOMATCH;
      sysData.phraseLength = 0;
      if (p2.ast) {
        p2.ast.setLength(astLength);
      }
    }
  };
  const validateRnmCallbackResult = (rule, sysData2, charsLeft, down) => {
    if (sysData2.phraseLength > charsLeft) {
      let str2 = `${thisFileName}opRNM(${rule.name}): callback function error: `;
      str2 += `sysData.phraseLength: ${sysData2.phraseLength}`;
      str2 += ` must be <= remaining chars: ${charsLeft}`;
      throw new Error(str2);
    }
    switch (sysData2.state) {
      case id.ACTIVE:
        if (!down) {
          throw new Error(
            `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`
          );
        }
        break;
      case id.EMPTY:
        sysData2.phraseLength = 0;
        break;
      case id.MATCH:
        if (sysData2.phraseLength === 0) {
          sysData2.state = id.EMPTY;
        }
        break;
      case id.NOMATCH:
        sysData2.phraseLength = 0;
        break;
      default:
        throw new Error(
          `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData2.state}`
        );
    }
  };
  const opRNM = (opIndex, phraseIndex) => {
    let astLength;
    let astDefined;
    let savedOpcodes;
    const op = opcodes[opIndex];
    const rule = rules2[op.index];
    const callback = ruleCallbacks[rule.index];
    if (!lookAhead) {
      astDefined = p2.ast && p2.ast.ruleDefined(op.index);
      if (astDefined) {
        astLength = p2.ast.getLength();
        p2.ast.down(op.index, rules2[op.index].name);
      }
    }
    if (callback) {
      const charsLeft = chars.length - phraseIndex;
      callback(sysData, chars, phraseIndex, userData);
      validateRnmCallbackResult(rule, sysData, charsLeft, true);
      if (sysData.state === id.ACTIVE) {
        savedOpcodes = opcodes;
        opcodes = rule.opcodes;
        opExecute(0, phraseIndex);
        opcodes = savedOpcodes;
        callback(sysData, chars, phraseIndex, userData);
        validateRnmCallbackResult(rule, sysData, charsLeft, false);
      }
    } else {
      savedOpcodes = opcodes;
      opcodes = rule.opcodes;
      opExecute(0, phraseIndex, sysData);
      opcodes = savedOpcodes;
    }
    if (!lookAhead) {
      if (astDefined) {
        if (sysData.state === id.NOMATCH) {
          p2.ast.setLength(astLength);
        } else {
          p2.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);
        }
      }
    }
  };
  const opTRG = (opIndex, phraseIndex) => {
    const op = opcodes[opIndex];
    sysData.state = id.NOMATCH;
    if (phraseIndex < chars.length) {
      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {
        sysData.state = id.MATCH;
        sysData.phraseLength = 1;
      }
    }
  };
  const opTBS = (opIndex, phraseIndex) => {
    const op = opcodes[opIndex];
    const len = op.string.length;
    sysData.state = id.NOMATCH;
    if (phraseIndex + len <= chars.length) {
      for (let i2 = 0; i2 < len; i2 += 1) {
        if (chars[phraseIndex + i2] !== op.string[i2]) {
          return;
        }
      }
      sysData.state = id.MATCH;
      sysData.phraseLength = len;
    }
  };
  const opTLS = (opIndex, phraseIndex) => {
    let code2;
    const op = opcodes[opIndex];
    sysData.state = id.NOMATCH;
    const len = op.string.length;
    if (len === 0) {
      sysData.state = id.EMPTY;
      return;
    }
    if (phraseIndex + len <= chars.length) {
      for (let i2 = 0; i2 < len; i2 += 1) {
        code2 = chars[phraseIndex + i2];
        if (code2 >= 65 && code2 <= 90) {
          code2 += 32;
        }
        if (code2 !== op.string[i2]) {
          return;
        }
      }
      sysData.state = id.MATCH;
      sysData.phraseLength = len;
    }
  };
  const validateUdtCallbackResult = (udt, sysData2, charsLeft) => {
    if (sysData2.phraseLength > charsLeft) {
      let str2 = `${thisFileName}opUDT(${udt.name}): callback function error: `;
      str2 += `sysData.phraseLength: ${sysData2.phraseLength}`;
      str2 += ` must be <= remaining chars: ${charsLeft}`;
      throw new Error(str2);
    }
    switch (sysData2.state) {
      case id.ACTIVE:
        throw new Error(`${thisFileName}opUDT(${udt.name}) ACTIVE state return not allowed.`);
      case id.EMPTY:
        if (udt.empty) {
          sysData2.phraseLength = 0;
        } else {
          throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);
        }
        break;
      case id.MATCH:
        if (sysData2.phraseLength === 0) {
          if (udt.empty) {
            sysData2.state = id.EMPTY;
          } else {
            throw new Error(`${thisFileName}opUDT(${udt.name}) may not return EMPTY.`);
          }
        }
        break;
      case id.NOMATCH:
        sysData2.phraseLength = 0;
        break;
      default:
        throw new Error(
          `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData2.state}`
        );
    }
  };
  const opUDT = (opIndex, phraseIndex) => {
    let astLength;
    let astIndex;
    let astDefined;
    const op = opcodes[opIndex];
    const udt = udts[op.index];
    sysData.UdtIndex = udt.index;
    if (!lookAhead) {
      astDefined = p2.ast && p2.ast.udtDefined(op.index);
      if (astDefined) {
        astIndex = rules2.length + op.index;
        astLength = p2.ast.getLength();
        p2.ast.down(astIndex, udt.name);
      }
    }
    const charsLeft = chars.length - phraseIndex;
    udtCallbacks[op.index](sysData, chars, phraseIndex, userData);
    validateUdtCallbackResult(udt, sysData, charsLeft);
    if (!lookAhead) {
      if (astDefined) {
        if (sysData.state === id.NOMATCH) {
          p2.ast.setLength(astLength);
        } else {
          p2.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);
        }
      }
    }
  };
  const opAND = (opIndex, phraseIndex) => {
    lookAhead += 1;
    opExecute(opIndex + 1, phraseIndex);
    lookAhead -= 1;
    sysData.phraseLength = 0;
    switch (sysData.state) {
      case id.EMPTY:
        sysData.state = id.EMPTY;
        break;
      case id.MATCH:
        sysData.state = id.EMPTY;
        break;
      case id.NOMATCH:
        sysData.state = id.NOMATCH;
        break;
      default:
        throw new Error(`opAND: invalid state ${sysData.state}`);
    }
  };
  const opNOT = (opIndex, phraseIndex) => {
    lookAhead += 1;
    opExecute(opIndex + 1, phraseIndex);
    lookAhead -= 1;
    sysData.phraseLength = 0;
    switch (sysData.state) {
      case id.EMPTY:
      case id.MATCH:
        sysData.state = id.NOMATCH;
        break;
      case id.NOMATCH:
        sysData.state = id.EMPTY;
        break;
      default:
        throw new Error(`opNOT: invalid state ${sysData.state}`);
    }
  };
  const opExecute = (opIndex, phraseIndex) => {
    const functionName = `${thisFileName}opExecute(): `;
    const op = opcodes[opIndex];
    nodeHits += 1;
    if (treeDepth > maxTreeDepth) {
      maxTreeDepth = treeDepth;
    }
    treeDepth += 1;
    sysData.refresh();
    if (p2.trace) {
      p2.trace.down(op, phraseIndex);
    }
    switch (op.type) {
      case id.ALT:
        opALT(opIndex, phraseIndex);
        break;
      case id.CAT:
        opCAT(opIndex, phraseIndex);
        break;
      case id.REP:
        opREP(opIndex, phraseIndex);
        break;
      case id.RNM:
        opRNM(opIndex, phraseIndex);
        break;
      case id.TRG:
        opTRG(opIndex, phraseIndex);
        break;
      case id.TBS:
        opTBS(opIndex, phraseIndex);
        break;
      case id.TLS:
        opTLS(opIndex, phraseIndex);
        break;
      case id.UDT:
        opUDT(opIndex, phraseIndex);
        break;
      case id.AND:
        opAND(opIndex, phraseIndex);
        break;
      case id.NOT:
        opNOT(opIndex, phraseIndex);
        break;
      default:
        throw new Error(`${functionName}unrecognized operator`);
    }
    if (!lookAhead) {
      if (phraseIndex + sysData.phraseLength > maxMatched) {
        maxMatched = phraseIndex + sysData.phraseLength;
      }
    }
    if (p2.stats) {
      p2.stats.collect(op, sysData);
    }
    if (p2.trace) {
      p2.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength);
    }
    treeDepth -= 1;
  };
};
var Ast = function fnast() {
  const thisFileName = "parser.js: Ast()): ";
  const id = identifiers;
  const utils2 = utilities;
  const a2 = this;
  let rules2 = void 0;
  let udts = void 0;
  let chars = void 0;
  let nodeCount = 0;
  const nodeCallbacks = [];
  const stack = [];
  const records = [];
  a2.callbacks = [];
  a2.init = (rulesIn, udtsIn, charsIn) => {
    stack.length = 0;
    records.length = 0;
    nodeCount = 0;
    rules2 = rulesIn;
    udts = udtsIn;
    chars = charsIn;
    let i2;
    const list4 = [];
    for (i2 = 0; i2 < rules2.length; i2 += 1) {
      list4.push(rules2[i2].lower);
    }
    for (i2 = 0; i2 < udts.length; i2 += 1) {
      list4.push(udts[i2].lower);
    }
    nodeCount = rules2.length + udts.length;
    for (i2 = 0; i2 < nodeCount; i2 += 1) {
      nodeCallbacks[i2] = void 0;
    }
    for (const index in a2.callbacks) {
      if (a2.callbacks.hasOwnProperty(index)) {
        const lower = index.toLowerCase();
        i2 = list4.indexOf(lower);
        if (i2 < 0) {
          throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);
        }
        nodeCallbacks[i2] = a2.callbacks[index];
      }
    }
  };
  a2.ruleDefined = (index) => !!nodeCallbacks[index];
  a2.udtDefined = (index) => !!nodeCallbacks[rules2.length + index];
  a2.down = (callbackIndex, name2) => {
    const thisIndex = records.length;
    stack.push(thisIndex);
    records.push({
      name: name2,
      thisIndex,
      thatIndex: void 0,
      state: id.SEM_PRE,
      callbackIndex,
      phraseIndex: void 0,
      phraseLength: void 0,
      stack: stack.length
    });
    return thisIndex;
  };
  a2.up = (callbackIndex, name2, phraseIndex, phraseLength) => {
    const thisIndex = records.length;
    const thatIndex = stack.pop();
    records.push({
      name: name2,
      thisIndex,
      thatIndex,
      state: id.SEM_POST,
      callbackIndex,
      phraseIndex,
      phraseLength,
      stack: stack.length
    });
    records[thatIndex].thatIndex = thisIndex;
    records[thatIndex].phraseIndex = phraseIndex;
    records[thatIndex].phraseLength = phraseLength;
    return thisIndex;
  };
  a2.translate = (data) => {
    let ret;
    let callback;
    let record;
    for (let i2 = 0; i2 < records.length; i2 += 1) {
      record = records[i2];
      callback = nodeCallbacks[record.callbackIndex];
      if (callback) {
        if (record.state === id.SEM_PRE) {
          callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);
        } else if (callback) {
          callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);
        }
      }
    }
  };
  a2.setLength = (length3) => {
    records.length = length3;
    if (length3 > 0) {
      stack.length = records[length3 - 1].stack;
    } else {
      stack.length = 0;
    }
  };
  a2.getLength = () => records.length;
  function indent(n) {
    let ret = "";
    while (n-- > 0) {
      ret += " ";
    }
    return ret;
  }
  a2.toXml = () => {
    let xml3 = "";
    let depth = 0;
    xml3 += '<?xml version="1.0" encoding="utf-8"?>\n';
    xml3 += `<root nodes="${records.length / 2}" characters="${chars.length}">
`;
    xml3 += `<!-- input string -->
`;
    xml3 += indent(depth + 2);
    xml3 += utils2.charsToString(chars);
    xml3 += "\n";
    records.forEach((rec) => {
      if (rec.state === id.SEM_PRE) {
        depth += 1;
        xml3 += indent(depth);
        xml3 += `<node name="${rec.name}" index="${rec.phraseIndex}" length="${rec.phraseLength}">
`;
        xml3 += indent(depth + 2);
        xml3 += utils2.charsToString(chars, rec.phraseIndex, rec.phraseLength);
        xml3 += "\n";
      } else {
        xml3 += indent(depth);
        xml3 += `</node><!-- name="${rec.name}" -->
`;
        depth -= 1;
      }
    });
    xml3 += "</root>\n";
    return xml3;
  };
};
var utilities = {
  // utility functions
  stringToChars: (string) => [...string].map((cp) => cp.codePointAt(0)),
  charsToString: (chars, beg, len) => {
    let subChars = chars;
    while (1) {
      if (beg === void 0 || beg < 0) {
        break;
      }
      if (len === void 0) {
        subChars = chars.slice(beg);
        break;
      }
      if (len <= 0) {
        return "";
      }
      subChars = chars.slice(beg, beg + len);
      break;
    }
    return String.fromCodePoint(...subChars);
  }
};
var identifiers = {
  // Identifies the operator type.
  // NB: These must match the values in apg-js 4.3.0, apg-lib/identifiers.
  /* the original ABNF operators */
  ALT: 1,
  CAT: 2,
  REP: 3,
  RNM: 4,
  TRG: 5,
  TBS: 6,
  TLS: 7,
  /* the super set, SABNF operators */
  UDT: 11,
  AND: 12,
  NOT: 13,
  // Used by the parser and the user's `RNM` and `UDT` callback functions.
  // Identifies the parser state as it traverses the parse tree nodes.
  // - *ACTIVE* - indicates the downward direction through the parse tree node.
  // - *MATCH* - indicates the upward direction and a phrase, of length \> 0, has been successfully matched
  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched
  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all
  ACTIVE: 100,
  MATCH: 101,
  EMPTY: 102,
  NOMATCH: 103,
  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions
  // to indicate the direction of flow through the `AST` nodes.
  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.
  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.
  SEM_PRE: 200,
  SEM_POST: 201,
  // Ignored. Retained for backwords compatibility.
  SEM_OK: 300,
  idName: (s2) => {
    switch (s2) {
      case identifiers.ALT:
        return "ALT";
      case identifiers.CAT:
        return "CAT";
      case identifiers.REP:
        return "REP";
      case identifiers.RNM:
        return "RNM";
      case identifiers.TRG:
        return "TRG";
      case identifiers.TBS:
        return "TBS";
      case identifiers.TLS:
        return "TLS";
      case identifiers.UDT:
        return "UDT";
      case identifiers.AND:
        return "AND";
      case identifiers.NOT:
        return "NOT";
      case identifiers.ACTIVE:
        return "ACTIVE";
      case identifiers.EMPTY:
        return "EMPTY";
      case identifiers.MATCH:
        return "MATCH";
      case identifiers.NOMATCH:
        return "NOMATCH";
      case identifiers.SEM_PRE:
        return "SEM_PRE";
      case identifiers.SEM_POST:
        return "SEM_POST";
      case identifiers.SEM_OK:
        return "SEM_OK";
      default:
        return "UNRECOGNIZED STATE";
    }
  }
};

// node_modules/openapi-server-url-templating/es/parse/callbacks/server-url-template.mjs
var serverUrlTemplate = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    if (Array.isArray(data) === false) {
      throw new Error("parser's user data must be an array");
    }
    data.push(["server-url-template", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  }
  return identifiers.SEM_OK;
};
var server_url_template_default = serverUrlTemplate;

// node_modules/openapi-server-url-templating/es/parse/callbacks/server-variable.mjs
var serverVariable = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    if (Array.isArray(data) === false) {
      throw new Error("parser's user data must be an array");
    }
    data.push(["server-variable", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  }
  return identifiers.SEM_OK;
};
var server_variable_default3 = serverVariable;

// node_modules/openapi-server-url-templating/es/parse/callbacks/server-variable-name.mjs
var serverVariableName = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    if (Array.isArray(data) === false) {
      throw new Error("parser's user data must be an array");
    }
    data.push(["server-variable-name", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  }
  return identifiers.SEM_OK;
};
var server_variable_name_default = serverVariableName;

// node_modules/openapi-server-url-templating/es/parse/callbacks/literals.mjs
var literals = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    if (Array.isArray(data) === false) {
      throw new Error("parser's user data must be an array");
    }
    data.push(["literals", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  }
  return identifiers.SEM_OK;
};
var literals_default = literals;

// node_modules/openapi-server-url-templating/es/parse/index.mjs
var grammar2 = new grammar();
var parse4 = (serverURLTemplate) => {
  const parser = new Parser2();
  parser.ast = new Ast();
  parser.ast.callbacks["server-url-template"] = server_url_template_default;
  parser.ast.callbacks["server-variable"] = server_variable_default3;
  parser.ast.callbacks["server-variable-name"] = server_variable_name_default;
  parser.ast.callbacks["literals"] = literals_default;
  const result = parser.parse(grammar2, "server-url-template", serverURLTemplate);
  return {
    result,
    ast: parser.ast
  };
};
var parse_default3 = parse4;

// node_modules/openapi-server-url-templating/es/test.mjs
var test3 = (serverURLTemplate, {
  strict = false
} = {}) => {
  try {
    const parseResult = parse_default3(serverURLTemplate);
    if (!parseResult.result.success) return false;
    const parts = [];
    parseResult.ast.translate(parts);
    const hasServerVariable = parts.some(([type5]) => type5 === "server-variable");
    if (!strict && !hasServerVariable) {
      try {
        new URL(serverURLTemplate, "https://vladimirgorej.com");
        return true;
      } catch {
        return false;
      }
    }
    return strict ? hasServerVariable : true;
  } catch {
    return false;
  }
};
var test_default2 = test3;

// node_modules/openapi-server-url-templating/es/substitute.mjs
var isEncoded = (serverVariableValue) => {
  try {
    return typeof serverVariableValue === "string" && decodeURIComponent(serverVariableValue) !== serverVariableValue;
  } catch {
    return false;
  }
};
var encodeServerVariable = (serverVariableValue) => {
  if (isEncoded(serverVariableValue)) {
    return serverVariableValue;
  }
  return encodeURIComponent(serverVariableValue).replace(/%5B/g, "[").replace(/%5D/g, "]");
};
var significantTypes = ["literals", "server-variable-name"];
var substitute = (serverURLTemplate, serverVariables, options = {}) => {
  const defaultOptions3 = {
    encoder: encodeServerVariable
  };
  const mergedOptions = {
    ...defaultOptions3,
    ...options
  };
  const parseResult = parse_default3(serverURLTemplate);
  if (!parseResult.result.success) return serverURLTemplate;
  const parts = [];
  parseResult.ast.translate(parts);
  const substitutedParts = parts.filter(([type5]) => significantTypes.includes(type5)).map(([type5, value]) => {
    if (type5 === "server-variable-name") {
      return Object.hasOwn(serverVariables, value) ? mergedOptions.encoder(serverVariables[value], value) : `{${value}}`;
    }
    return value;
  });
  return substitutedParts.join("");
};
var substitute_default = substitute;

// node_modules/openapi-path-templating/es/path-templating.mjs
function grammar3() {
  this.grammarObject = "grammarObject";
  this.rules = [];
  this.rules[0] = {
    name: "path-template",
    lower: "path-template",
    index: 0,
    isBkr: false
  };
  this.rules[1] = {
    name: "path",
    lower: "path",
    index: 1,
    isBkr: false
  };
  this.rules[2] = {
    name: "path-segment",
    lower: "path-segment",
    index: 2,
    isBkr: false
  };
  this.rules[3] = {
    name: "query",
    lower: "query",
    index: 3,
    isBkr: false
  };
  this.rules[4] = {
    name: "query-literal",
    lower: "query-literal",
    index: 4,
    isBkr: false
  };
  this.rules[5] = {
    name: "query-marker",
    lower: "query-marker",
    index: 5,
    isBkr: false
  };
  this.rules[6] = {
    name: "fragment",
    lower: "fragment",
    index: 6,
    isBkr: false
  };
  this.rules[7] = {
    name: "fragment-literal",
    lower: "fragment-literal",
    index: 7,
    isBkr: false
  };
  this.rules[8] = {
    name: "fragment-marker",
    lower: "fragment-marker",
    index: 8,
    isBkr: false
  };
  this.rules[9] = {
    name: "slash",
    lower: "slash",
    index: 9,
    isBkr: false
  };
  this.rules[10] = {
    name: "path-literal",
    lower: "path-literal",
    index: 10,
    isBkr: false
  };
  this.rules[11] = {
    name: "template-expression",
    lower: "template-expression",
    index: 11,
    isBkr: false
  };
  this.rules[12] = {
    name: "template-expression-param-name",
    lower: "template-expression-param-name",
    index: 12,
    isBkr: false
  };
  this.rules[13] = {
    name: "unreserved",
    lower: "unreserved",
    index: 13,
    isBkr: false
  };
  this.rules[14] = {
    name: "pct-encoded",
    lower: "pct-encoded",
    index: 14,
    isBkr: false
  };
  this.rules[15] = {
    name: "sub-delims",
    lower: "sub-delims",
    index: 15,
    isBkr: false
  };
  this.rules[16] = {
    name: "ALPHA",
    lower: "alpha",
    index: 16,
    isBkr: false
  };
  this.rules[17] = {
    name: "DIGIT",
    lower: "digit",
    index: 17,
    isBkr: false
  };
  this.rules[18] = {
    name: "HEXDIG",
    lower: "hexdig",
    index: 18,
    isBkr: false
  };
  this.udts = [];
  this.rules[0].opcodes = [];
  this.rules[0].opcodes[0] = {
    type: 2,
    children: [1, 2, 6]
  };
  this.rules[0].opcodes[1] = {
    type: 4,
    index: 1
  };
  this.rules[0].opcodes[2] = {
    type: 3,
    min: 0,
    max: 1
  };
  this.rules[0].opcodes[3] = {
    type: 2,
    children: [4, 5]
  };
  this.rules[0].opcodes[4] = {
    type: 4,
    index: 5
  };
  this.rules[0].opcodes[5] = {
    type: 4,
    index: 3
  };
  this.rules[0].opcodes[6] = {
    type: 3,
    min: 0,
    max: 1
  };
  this.rules[0].opcodes[7] = {
    type: 2,
    children: [8, 9]
  };
  this.rules[0].opcodes[8] = {
    type: 4,
    index: 8
  };
  this.rules[0].opcodes[9] = {
    type: 4,
    index: 6
  };
  this.rules[1].opcodes = [];
  this.rules[1].opcodes[0] = {
    type: 2,
    children: [1, 2, 6]
  };
  this.rules[1].opcodes[1] = {
    type: 4,
    index: 9
  };
  this.rules[1].opcodes[2] = {
    type: 3,
    min: 0,
    max: Infinity
  };
  this.rules[1].opcodes[3] = {
    type: 2,
    children: [4, 5]
  };
  this.rules[1].opcodes[4] = {
    type: 4,
    index: 2
  };
  this.rules[1].opcodes[5] = {
    type: 4,
    index: 9
  };
  this.rules[1].opcodes[6] = {
    type: 3,
    min: 0,
    max: 1
  };
  this.rules[1].opcodes[7] = {
    type: 4,
    index: 2
  };
  this.rules[2].opcodes = [];
  this.rules[2].opcodes[0] = {
    type: 3,
    min: 1,
    max: Infinity
  };
  this.rules[2].opcodes[1] = {
    type: 1,
    children: [2, 3]
  };
  this.rules[2].opcodes[2] = {
    type: 4,
    index: 10
  };
  this.rules[2].opcodes[3] = {
    type: 4,
    index: 11
  };
  this.rules[3].opcodes = [];
  this.rules[3].opcodes[0] = {
    type: 3,
    min: 0,
    max: Infinity
  };
  this.rules[3].opcodes[1] = {
    type: 4,
    index: 4
  };
  this.rules[4].opcodes = [];
  this.rules[4].opcodes[0] = {
    type: 3,
    min: 1,
    max: Infinity
  };
  this.rules[4].opcodes[1] = {
    type: 1,
    children: [2, 3, 4, 5, 6, 7, 8, 9, 10]
  };
  this.rules[4].opcodes[2] = {
    type: 4,
    index: 13
  };
  this.rules[4].opcodes[3] = {
    type: 4,
    index: 14
  };
  this.rules[4].opcodes[4] = {
    type: 4,
    index: 15
  };
  this.rules[4].opcodes[5] = {
    type: 7,
    string: [58]
  };
  this.rules[4].opcodes[6] = {
    type: 7,
    string: [64]
  };
  this.rules[4].opcodes[7] = {
    type: 7,
    string: [47]
  };
  this.rules[4].opcodes[8] = {
    type: 7,
    string: [63]
  };
  this.rules[4].opcodes[9] = {
    type: 7,
    string: [38]
  };
  this.rules[4].opcodes[10] = {
    type: 7,
    string: [61]
  };
  this.rules[5].opcodes = [];
  this.rules[5].opcodes[0] = {
    type: 7,
    string: [63]
  };
  this.rules[6].opcodes = [];
  this.rules[6].opcodes[0] = {
    type: 3,
    min: 0,
    max: Infinity
  };
  this.rules[6].opcodes[1] = {
    type: 4,
    index: 7
  };
  this.rules[7].opcodes = [];
  this.rules[7].opcodes[0] = {
    type: 3,
    min: 1,
    max: Infinity
  };
  this.rules[7].opcodes[1] = {
    type: 1,
    children: [2, 3, 4, 5, 6, 7, 8]
  };
  this.rules[7].opcodes[2] = {
    type: 4,
    index: 13
  };
  this.rules[7].opcodes[3] = {
    type: 4,
    index: 14
  };
  this.rules[7].opcodes[4] = {
    type: 4,
    index: 15
  };
  this.rules[7].opcodes[5] = {
    type: 7,
    string: [58]
  };
  this.rules[7].opcodes[6] = {
    type: 7,
    string: [64]
  };
  this.rules[7].opcodes[7] = {
    type: 7,
    string: [47]
  };
  this.rules[7].opcodes[8] = {
    type: 7,
    string: [63]
  };
  this.rules[8].opcodes = [];
  this.rules[8].opcodes[0] = {
    type: 7,
    string: [35]
  };
  this.rules[9].opcodes = [];
  this.rules[9].opcodes[0] = {
    type: 7,
    string: [47]
  };
  this.rules[10].opcodes = [];
  this.rules[10].opcodes[0] = {
    type: 3,
    min: 1,
    max: Infinity
  };
  this.rules[10].opcodes[1] = {
    type: 1,
    children: [2, 3, 4, 5, 6]
  };
  this.rules[10].opcodes[2] = {
    type: 4,
    index: 13
  };
  this.rules[10].opcodes[3] = {
    type: 4,
    index: 14
  };
  this.rules[10].opcodes[4] = {
    type: 4,
    index: 15
  };
  this.rules[10].opcodes[5] = {
    type: 7,
    string: [58]
  };
  this.rules[10].opcodes[6] = {
    type: 7,
    string: [64]
  };
  this.rules[11].opcodes = [];
  this.rules[11].opcodes[0] = {
    type: 2,
    children: [1, 2, 3]
  };
  this.rules[11].opcodes[1] = {
    type: 7,
    string: [123]
  };
  this.rules[11].opcodes[2] = {
    type: 4,
    index: 12
  };
  this.rules[11].opcodes[3] = {
    type: 7,
    string: [125]
  };
  this.rules[12].opcodes = [];
  this.rules[12].opcodes[0] = {
    type: 3,
    min: 1,
    max: Infinity
  };
  this.rules[12].opcodes[1] = {
    type: 1,
    children: [2, 3, 4, 5, 6]
  };
  this.rules[12].opcodes[2] = {
    type: 4,
    index: 13
  };
  this.rules[12].opcodes[3] = {
    type: 4,
    index: 14
  };
  this.rules[12].opcodes[4] = {
    type: 4,
    index: 15
  };
  this.rules[12].opcodes[5] = {
    type: 7,
    string: [58]
  };
  this.rules[12].opcodes[6] = {
    type: 7,
    string: [64]
  };
  this.rules[13].opcodes = [];
  this.rules[13].opcodes[0] = {
    type: 1,
    children: [1, 2, 3, 4, 5, 6]
  };
  this.rules[13].opcodes[1] = {
    type: 4,
    index: 16
  };
  this.rules[13].opcodes[2] = {
    type: 4,
    index: 17
  };
  this.rules[13].opcodes[3] = {
    type: 7,
    string: [45]
  };
  this.rules[13].opcodes[4] = {
    type: 7,
    string: [46]
  };
  this.rules[13].opcodes[5] = {
    type: 7,
    string: [95]
  };
  this.rules[13].opcodes[6] = {
    type: 7,
    string: [126]
  };
  this.rules[14].opcodes = [];
  this.rules[14].opcodes[0] = {
    type: 2,
    children: [1, 2, 3]
  };
  this.rules[14].opcodes[1] = {
    type: 7,
    string: [37]
  };
  this.rules[14].opcodes[2] = {
    type: 4,
    index: 18
  };
  this.rules[14].opcodes[3] = {
    type: 4,
    index: 18
  };
  this.rules[15].opcodes = [];
  this.rules[15].opcodes[0] = {
    type: 1,
    children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
  };
  this.rules[15].opcodes[1] = {
    type: 7,
    string: [33]
  };
  this.rules[15].opcodes[2] = {
    type: 7,
    string: [36]
  };
  this.rules[15].opcodes[3] = {
    type: 7,
    string: [38]
  };
  this.rules[15].opcodes[4] = {
    type: 7,
    string: [39]
  };
  this.rules[15].opcodes[5] = {
    type: 7,
    string: [40]
  };
  this.rules[15].opcodes[6] = {
    type: 7,
    string: [41]
  };
  this.rules[15].opcodes[7] = {
    type: 7,
    string: [42]
  };
  this.rules[15].opcodes[8] = {
    type: 7,
    string: [43]
  };
  this.rules[15].opcodes[9] = {
    type: 7,
    string: [44]
  };
  this.rules[15].opcodes[10] = {
    type: 7,
    string: [59]
  };
  this.rules[15].opcodes[11] = {
    type: 7,
    string: [61]
  };
  this.rules[16].opcodes = [];
  this.rules[16].opcodes[0] = {
    type: 1,
    children: [1, 2]
  };
  this.rules[16].opcodes[1] = {
    type: 5,
    min: 65,
    max: 90
  };
  this.rules[16].opcodes[2] = {
    type: 5,
    min: 97,
    max: 122
  };
  this.rules[17].opcodes = [];
  this.rules[17].opcodes[0] = {
    type: 5,
    min: 48,
    max: 57
  };
  this.rules[18].opcodes = [];
  this.rules[18].opcodes[0] = {
    type: 1,
    children: [1, 2, 3, 4, 5, 6, 7]
  };
  this.rules[18].opcodes[1] = {
    type: 4,
    index: 17
  };
  this.rules[18].opcodes[2] = {
    type: 7,
    string: [97]
  };
  this.rules[18].opcodes[3] = {
    type: 7,
    string: [98]
  };
  this.rules[18].opcodes[4] = {
    type: 7,
    string: [99]
  };
  this.rules[18].opcodes[5] = {
    type: 7,
    string: [100]
  };
  this.rules[18].opcodes[6] = {
    type: 7,
    string: [101]
  };
  this.rules[18].opcodes[7] = {
    type: 7,
    string: [102]
  };
  this.toString = function toString5() {
    let str2 = "";
    str2 += "; OpenAPI Path Templating ABNF syntax\n";
    str2 += "path-template                  = path [ query-marker query ] [ fragment-marker fragment ]\n";
    str2 += "path                           = slash *( path-segment slash ) [ path-segment ]\n";
    str2 += "path-segment                   = 1*( path-literal / template-expression )\n";
    str2 += "query                          = *( query-literal )\n";
    str2 += 'query-literal                  = 1*( unreserved / pct-encoded / sub-delims / ":" / "@" / "/" / "?" / "&" / "=" )\n';
    str2 += 'query-marker                   = "?"\n';
    str2 += "fragment                       = *( fragment-literal )\n";
    str2 += 'fragment-literal               = 1*( unreserved / pct-encoded / sub-delims / ":" / "@" / "/" / "?" )\n';
    str2 += 'fragment-marker                = "#"\n';
    str2 += 'slash                          = "/"\n';
    str2 += 'path-literal                   = 1*( unreserved / pct-encoded / sub-delims / ":" / "@" )\n';
    str2 += 'template-expression            = "{" template-expression-param-name "}"\n';
    str2 += 'template-expression-param-name = 1*( unreserved / pct-encoded / sub-delims / ":" / "@" )\n';
    str2 += "\n";
    str2 += "; Characters definitions (from RFC 3986)\n";
    str2 += 'unreserved          = ALPHA / DIGIT / "-" / "." / "_" / "~"\n';
    str2 += 'pct-encoded         = "%" HEXDIG HEXDIG\n';
    str2 += `sub-delims          = "!" / "$" / "&" / "'" / "(" / ")"
`;
    str2 += '                    / "*" / "+" / "," / ";" / "="\n';
    str2 += "ALPHA               = %x41-5A / %x61-7A   ; A-Z / a-z\n";
    str2 += "DIGIT               = %x30-39            ; 0-9\n";
    str2 += 'HEXDIG              = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"\n';
    return str2;
  };
}

// node_modules/openapi-path-templating/es/parse/callbacks/slash.mjs
var slash = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    data.push(["slash", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  } else if (state2 === identifiers.SEM_POST) {
  }
  return identifiers.SEM_OK;
};
var slash_default = slash;

// node_modules/openapi-path-templating/es/parse/callbacks/path-template.mjs
var pathTemplate = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    if (Array.isArray(data) === false) {
      throw new Error("parser's user data must be an array");
    }
    data.push(["path-template", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  }
  return identifiers.SEM_OK;
};
var path_template_default = pathTemplate;

// node_modules/openapi-path-templating/es/parse/callbacks/path.mjs
var path2 = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    data.push(["path", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  } else if (state2 === identifiers.SEM_POST) {
  }
  return identifiers.SEM_OK;
};
var path_default2 = path2;

// node_modules/openapi-path-templating/es/parse/callbacks/path-literal.mjs
var pathLiteral = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    data.push(["path-literal", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  } else if (state2 === identifiers.SEM_POST) {
  }
  return identifiers.SEM_OK;
};
var path_literal_default = pathLiteral;

// node_modules/openapi-path-templating/es/parse/callbacks/query.mjs
var query = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    data.push(["query", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  } else if (state2 === identifiers.SEM_POST) {
  }
  return identifiers.SEM_OK;
};
var query_default = query;

// node_modules/openapi-path-templating/es/parse/callbacks/query-marker.mjs
var queryMarker = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    data.push(["query-marker", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  } else if (state2 === identifiers.SEM_POST) {
  }
  return identifiers.SEM_OK;
};
var query_marker_default = queryMarker;

// node_modules/openapi-path-templating/es/parse/callbacks/fragment.mjs
var fragment = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    data.push(["fragment", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  } else if (state2 === identifiers.SEM_POST) {
  }
  return identifiers.SEM_OK;
};
var fragment_default = fragment;

// node_modules/openapi-path-templating/es/parse/callbacks/fragment-marker.mjs
var fragmentMarker = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    data.push(["fragment-marker", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  } else if (state2 === identifiers.SEM_POST) {
  }
  return identifiers.SEM_OK;
};
var fragment_marker_default = fragmentMarker;

// node_modules/openapi-path-templating/es/parse/callbacks/template-expression.mjs
var templateExpression = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    data.push(["template-expression", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  } else if (state2 === identifiers.SEM_POST) {
  }
  return identifiers.SEM_OK;
};
var template_expression_default = templateExpression;

// node_modules/openapi-path-templating/es/parse/callbacks/template-expression-param-name.mjs
var templateExpressionParamName = (state2, chars, phraseIndex, phraseLength, data) => {
  if (state2 === identifiers.SEM_PRE) {
    data.push(["template-expression-param-name", utilities.charsToString(chars, phraseIndex, phraseLength)]);
  } else if (state2 === identifiers.SEM_POST) {
  }
  return identifiers.SEM_OK;
};
var template_expression_param_name_default = templateExpressionParamName;

// node_modules/openapi-path-templating/es/parse/index.mjs
var grammar4 = new grammar3();
var parse5 = (pathTemplate2) => {
  const parser = new Parser2();
  parser.ast = new Ast();
  parser.ast.callbacks["path-template"] = path_template_default;
  parser.ast.callbacks["path"] = path_default2;
  parser.ast.callbacks["query"] = query_default;
  parser.ast.callbacks["query-marker"] = query_marker_default;
  parser.ast.callbacks["fragment"] = fragment_default;
  parser.ast.callbacks["fragment-marker"] = fragment_marker_default;
  parser.ast.callbacks["slash"] = slash_default;
  parser.ast.callbacks["path-literal"] = path_literal_default;
  parser.ast.callbacks["template-expression"] = template_expression_default;
  parser.ast.callbacks["template-expression-param-name"] = template_expression_param_name_default;
  const result = parser.parse(grammar4, "path-template", pathTemplate2);
  return {
    result,
    ast: parser.ast
  };
};
var parse_default4 = parse5;

// node_modules/openapi-path-templating/es/resolve.mjs
var isEncoded2 = (parameterValue) => {
  try {
    return typeof parameterValue === "string" && decodeURIComponent(parameterValue) !== parameterValue;
  } catch {
    return false;
  }
};
var encodePathComponent = (parameterValue) => {
  if (isEncoded2(parameterValue)) {
    return parameterValue;
  }
  return encodeURIComponent(parameterValue).replace(/%5B/g, "[").replace(/%5D/g, "]");
};
var significantTypes2 = ["slash", "path-literal", "query-marker", "query-literal", "template-expression-param-name"];
var resolve3 = (pathTemplate2, parameters, options = {}) => {
  const defaultOptions3 = {
    encoder: encodePathComponent
  };
  const mergedOptions = {
    ...defaultOptions3,
    ...options
  };
  const parseResult = parse_default4(pathTemplate2);
  if (!parseResult.result.success) return pathTemplate2;
  const parts = [];
  parseResult.ast.translate(parts);
  const resolvedParts = parts.filter(([type5]) => significantTypes2.includes(type5)).map(([type5, value]) => {
    if (type5 === "template-expression-param-name") {
      return Object.hasOwn(parameters, value) ? mergedOptions.encoder(parameters[value], value) : `{${value}}`;
    }
    return value;
  });
  return resolvedParts.join("");
};
var resolve_default3 = resolve3;

// node_modules/swagger-client/es/execute/swagger2/parameter-builders.js
var parameter_builders_default = {
  body: bodyBuilder,
  header: headerBuilder,
  query: queryBuilder,
  path: pathBuilder,
  formData: formDataBuilder
};
function bodyBuilder({
  req,
  value
}) {
  if (value !== void 0) {
    req.body = value;
  }
}
function formDataBuilder({
  req,
  value,
  parameter
}) {
  if (value === false && parameter.type === "boolean") {
    value = "false";
  }
  if (value === 0 && ["number", "integer"].indexOf(parameter.type) > -1) {
    value = "0";
  }
  if (value) {
    req.form = req.form || {};
    req.form[parameter.name] = {
      collectionFormat: parameter.collectionFormat,
      value
    };
  } else if (parameter.allowEmptyValue && value !== void 0) {
    req.form = req.form || {};
    const paramName = parameter.name;
    req.form[paramName] = req.form[paramName] || {};
    req.form[paramName].allowEmptyValue = true;
  }
}
function headerBuilder({
  req,
  parameter,
  value
}) {
  req.headers = req.headers || {};
  if (typeof value !== "undefined") {
    req.headers[parameter.name] = value;
  }
}
function pathBuilder({
  req,
  value,
  parameter,
  baseURL
}) {
  if (value !== void 0) {
    const pathname = req.url.replace(baseURL, "");
    const resolvedPathname = resolve_default3(pathname, {
      [parameter.name]: value
    });
    req.url = baseURL + resolvedPathname;
  }
}
function queryBuilder({
  req,
  value,
  parameter
}) {
  req.query = req.query || {};
  if (value === false && parameter.type === "boolean") {
    value = "false";
  }
  if (value === 0 && ["number", "integer"].indexOf(parameter.type) > -1) {
    value = "0";
  }
  if (value) {
    req.query[parameter.name] = {
      collectionFormat: parameter.collectionFormat,
      value
    };
  } else if (parameter.allowEmptyValue && value !== void 0) {
    const paramName = parameter.name;
    req.query[paramName] = req.query[paramName] || {};
    req.query[paramName].allowEmptyValue = true;
  }
}

// node_modules/swagger-client/es/execute/oas3/parameter-builders.js
var parameter_builders_exports = {};
__export(parameter_builders_exports, {
  cookie: () => cookie,
  header: () => header,
  path: () => path3,
  query: () => query2
});

// node_modules/swagger-client/es/execute/oas3/content-serializer.js
function serialize(value, mediaType) {
  if (mediaType.includes("application/json")) {
    if (typeof value === "string") {
      return value;
    }
    if (Array.isArray(value)) {
      value = value.map((v2) => {
        try {
          return JSON.parse(v2);
        } catch (e2) {
          return v2;
        }
      });
    }
    return JSON.stringify(value);
  }
  return String(value);
}

// node_modules/swagger-client/es/execute/oas3/parameter-builders.js
function path3({
  req,
  value,
  parameter,
  baseURL
}) {
  const {
    name: name2,
    style,
    explode,
    content
  } = parameter;
  if (value === void 0) return;
  const pathname = req.url.replace(baseURL, "");
  let resolvedPathname;
  if (content) {
    const effectiveMediaType = Object.keys(content)[0];
    resolvedPathname = resolve_default3(pathname, {
      [name2]: value
    }, {
      encoder: (val) => encodeCharacters(serialize(val, effectiveMediaType))
    });
  } else {
    resolvedPathname = resolve_default3(pathname, {
      [name2]: value
    }, {
      encoder: (val) => stylize({
        key: parameter.name,
        value: val,
        style: style || "simple",
        explode: explode || false,
        escape: "reserved"
      })
    });
  }
  req.url = baseURL + resolvedPathname;
}
function query2({
  req,
  value,
  parameter
}) {
  req.query = req.query || {};
  if (value !== void 0 && parameter.content) {
    const effectiveMediaType = Object.keys(parameter.content)[0];
    const serializedValue = serialize(value, effectiveMediaType);
    if (serializedValue) {
      req.query[parameter.name] = serializedValue;
    } else if (parameter.allowEmptyValue) {
      const paramName = parameter.name;
      req.query[paramName] = req.query[paramName] || {};
      req.query[paramName].allowEmptyValue = true;
    }
    return;
  }
  if (value === false) {
    value = "false";
  }
  if (value === 0) {
    value = "0";
  }
  if (value) {
    const {
      style,
      explode,
      allowReserved
    } = parameter;
    req.query[parameter.name] = {
      value,
      serializationOption: {
        style,
        explode,
        allowReserved
      }
    };
  } else if (parameter.allowEmptyValue && value !== void 0) {
    const paramName = parameter.name;
    req.query[paramName] = req.query[paramName] || {};
    req.query[paramName].allowEmptyValue = true;
  }
}
var PARAMETER_HEADER_BLACKLIST = ["accept", "authorization", "content-type"];
function header({
  req,
  parameter,
  value
}) {
  req.headers = req.headers || {};
  if (PARAMETER_HEADER_BLACKLIST.indexOf(parameter.name.toLowerCase()) > -1) {
    return;
  }
  if (value !== void 0 && parameter.content) {
    const effectiveMediaType = Object.keys(parameter.content)[0];
    req.headers[parameter.name] = serialize(value, effectiveMediaType);
    return;
  }
  if (value !== void 0 && !(Array.isArray(value) && value.length === 0)) {
    req.headers[parameter.name] = stylize({
      key: parameter.name,
      value,
      style: parameter.style || "simple",
      explode: typeof parameter.explode === "undefined" ? false : parameter.explode,
      escape: false
    });
  }
}
function cookie({
  req,
  parameter,
  value
}) {
  req.headers = req.headers || {};
  const type5 = typeof value;
  if (value !== void 0 && parameter.content) {
    const effectiveMediaType = Object.keys(parameter.content)[0];
    req.headers.Cookie = `${parameter.name}=${serialize(value, effectiveMediaType)}`;
    return;
  }
  if (value !== void 0 && !(Array.isArray(value) && value.length === 0)) {
    const prefix = type5 === "object" && !Array.isArray(value) && parameter.explode ? "" : `${parameter.name}=`;
    req.headers.Cookie = prefix + stylize({
      key: parameter.name,
      value,
      escape: false,
      style: parameter.style || "form",
      explode: typeof parameter.explode === "undefined" ? false : parameter.explode
    });
  }
}

// node_modules/swagger-client/es/helpers/btoa.browser.js
var globalObject = (() => {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return window;
})();
var {
  btoa: btoa2
} = globalObject;
var btoa_browser_default = btoa2;

// node_modules/swagger-client/es/execute/oas3/build-request.js
function buildRequest(options, req) {
  const {
    operation,
    requestBody,
    securities,
    spec: spec2,
    attachContentTypeForEmptyPayload
  } = options;
  let {
    requestContentType
  } = options;
  req = applySecurities({
    request: req,
    securities,
    operation,
    spec: spec2
  });
  const requestBodyDef = operation.requestBody || {};
  const requestBodyMediaTypes = Object.keys(requestBodyDef.content || {});
  const isExplicitContentTypeValid = requestContentType && requestBodyMediaTypes.indexOf(requestContentType) > -1;
  if (requestBody || attachContentTypeForEmptyPayload) {
    if (requestContentType && isExplicitContentTypeValid) {
      req.headers["Content-Type"] = requestContentType;
    } else if (!requestContentType) {
      const firstMediaType = requestBodyMediaTypes[0];
      if (firstMediaType) {
        req.headers["Content-Type"] = firstMediaType;
        requestContentType = firstMediaType;
      }
    }
  } else if (requestContentType && isExplicitContentTypeValid) {
    req.headers["Content-Type"] = requestContentType;
  }
  if (!options.responseContentType && operation.responses) {
    const mediaTypes4 = Object.entries(operation.responses).filter(([key57, value]) => {
      const code2 = parseInt(key57, 10);
      return code2 >= 200 && code2 < 300 && isPlainObj_default(value.content);
    }).reduce((acc, [, value]) => acc.concat(Object.keys(value.content)), []);
    if (mediaTypes4.length > 0) {
      req.headers.accept = mediaTypes4.join(", ");
    }
  }
  if (requestBody) {
    if (requestContentType) {
      if (requestBodyMediaTypes.indexOf(requestContentType) > -1) {
        if (requestContentType === "application/x-www-form-urlencoded" || requestContentType === "multipart/form-data") {
          if (typeof requestBody === "object") {
            var _requestBodyDef$conte, _requestBodyDef$conte2;
            const encoding = (_requestBodyDef$conte = (_requestBodyDef$conte2 = requestBodyDef.content[requestContentType]) === null || _requestBodyDef$conte2 === void 0 ? void 0 : _requestBodyDef$conte2.encoding) !== null && _requestBodyDef$conte !== void 0 ? _requestBodyDef$conte : {};
            req.form = {};
            Object.keys(requestBody).forEach((k) => {
              let value;
              try {
                value = JSON.parse(requestBody[k]);
              } catch {
                value = requestBody[k];
              }
              req.form[k] = {
                value,
                encoding: encoding[k] || {}
              };
            });
          } else if (typeof requestBody === "string") {
            var _requestBodyDef$conte3, _requestBodyDef$conte4;
            const encoding = (_requestBodyDef$conte3 = (_requestBodyDef$conte4 = requestBodyDef.content[requestContentType]) === null || _requestBodyDef$conte4 === void 0 ? void 0 : _requestBodyDef$conte4.encoding) !== null && _requestBodyDef$conte3 !== void 0 ? _requestBodyDef$conte3 : {};
            try {
              req.form = {};
              const form = JSON.parse(requestBody);
              Object.entries(form).forEach(([key57, value]) => {
                req.form[key57] = {
                  value,
                  encoding: encoding[key57] || {}
                };
              });
            } catch {
              req.form = requestBody;
            }
          } else {
            req.form = requestBody;
          }
        } else {
          req.body = requestBody;
        }
      }
    } else {
      req.body = requestBody;
    }
  }
  return req;
}
function applySecurities({
  request,
  securities = {},
  operation = {},
  spec: spec2
}) {
  var _spec$components;
  const result = {
    ...request
  };
  const {
    authorized = {}
  } = securities;
  const security = operation.security || spec2.security || [];
  const isAuthorized2 = authorized && !!Object.keys(authorized).length;
  const securityDef = (spec2 === null || spec2 === void 0 || (_spec$components = spec2.components) === null || _spec$components === void 0 ? void 0 : _spec$components.securitySchemes) || {};
  result.headers = result.headers || {};
  result.query = result.query || {};
  if (!Object.keys(securities).length || !isAuthorized2 || !security || Array.isArray(operation.security) && !operation.security.length) {
    return request;
  }
  security.forEach((securityObj) => {
    Object.keys(securityObj).forEach((key57) => {
      const auth2 = authorized[key57];
      const schema4 = securityDef[key57];
      if (!auth2) {
        return;
      }
      const value = auth2.value || auth2;
      const {
        type: type5
      } = schema4;
      if (auth2) {
        if (type5 === "apiKey") {
          if (schema4.in === "query") {
            result.query[schema4.name] = value;
          }
          if (schema4.in === "header") {
            result.headers[schema4.name] = value;
          }
          if (schema4.in === "cookie") {
            result.cookies[schema4.name] = value;
          }
        } else if (type5 === "http") {
          if (/^basic$/i.test(schema4.scheme)) {
            const username = value.username || "";
            const password = value.password || "";
            const encoded = btoa_browser_default(`${username}:${password}`);
            result.headers.Authorization = `Basic ${encoded}`;
          }
          if (/^bearer$/i.test(schema4.scheme)) {
            result.headers.Authorization = `Bearer ${value}`;
          }
        } else if (type5 === "oauth2" || type5 === "openIdConnect") {
          const token = auth2.token || {};
          const tokenName = schema4["x-tokenName"] || "access_token";
          const tokenValue = token[tokenName];
          let tokenType = token.token_type;
          if (!tokenType || tokenType.toLowerCase() === "bearer") {
            tokenType = "Bearer";
          }
          result.headers.Authorization = `${tokenType} ${tokenValue}`;
        }
      }
    });
  });
  return result;
}

// node_modules/swagger-client/es/execute/swagger2/build-request.js
function buildRequest2(options, req) {
  const {
    spec: spec2,
    operation,
    securities,
    requestContentType,
    responseContentType,
    attachContentTypeForEmptyPayload
  } = options;
  req = applySecurities2({
    request: req,
    securities,
    operation,
    spec: spec2
  });
  if (req.body || req.form || attachContentTypeForEmptyPayload) {
    if (requestContentType) {
      req.headers["Content-Type"] = requestContentType;
    } else if (Array.isArray(operation.consumes)) {
      [req.headers["Content-Type"]] = operation.consumes;
    } else if (Array.isArray(spec2.consumes)) {
      [req.headers["Content-Type"]] = spec2.consumes;
    } else if (operation.parameters && operation.parameters.filter((p2) => p2.type === "file").length) {
      req.headers["Content-Type"] = "multipart/form-data";
    } else if (operation.parameters && operation.parameters.filter((p2) => p2.in === "formData").length) {
      req.headers["Content-Type"] = "application/x-www-form-urlencoded";
    }
  } else if (requestContentType) {
    const isBodyParamPresent = operation.parameters && operation.parameters.filter((p2) => p2.in === "body").length > 0;
    const isFormDataParamPresent = operation.parameters && operation.parameters.filter((p2) => p2.in === "formData").length > 0;
    if (isBodyParamPresent || isFormDataParamPresent) {
      req.headers["Content-Type"] = requestContentType;
    }
  }
  if (!responseContentType && Array.isArray(operation.produces) && operation.produces.length > 0) {
    req.headers.accept = operation.produces.join(", ");
  }
  return req;
}
function applySecurities2({
  request,
  securities = {},
  operation = {},
  spec: spec2
}) {
  const result = {
    ...request
  };
  const {
    authorized = {},
    specSecurity = []
  } = securities;
  const security = operation.security || specSecurity;
  const isAuthorized2 = authorized && !!Object.keys(authorized).length;
  const securityDef = spec2.securityDefinitions;
  result.headers = result.headers || {};
  result.query = result.query || {};
  if (!Object.keys(securities).length || !isAuthorized2 || !security || Array.isArray(operation.security) && !operation.security.length) {
    return request;
  }
  security.forEach((securityObj) => {
    Object.keys(securityObj).forEach((key57) => {
      const auth2 = authorized[key57];
      if (!auth2) {
        return;
      }
      const {
        token
      } = auth2;
      const value = auth2.value || auth2;
      const schema4 = securityDef[key57];
      const {
        type: type5
      } = schema4;
      const tokenName = schema4["x-tokenName"] || "access_token";
      const oauthToken = token && token[tokenName];
      let tokenType = token && token.token_type;
      if (auth2) {
        if (type5 === "apiKey") {
          const inType = schema4.in === "query" ? "query" : "headers";
          result[inType] = result[inType] || {};
          result[inType][schema4.name] = value;
        } else if (type5 === "basic") {
          if (value.header) {
            result.headers.authorization = value.header;
          } else {
            const username = value.username || "";
            const password = value.password || "";
            value.base64 = btoa_browser_default(`${username}:${password}`);
            result.headers.authorization = `Basic ${value.base64}`;
          }
        } else if (type5 === "oauth2" && oauthToken) {
          tokenType = !tokenType || tokenType.toLowerCase() === "bearer" ? "Bearer" : tokenType;
          result.headers.authorization = `${tokenType} ${oauthToken}`;
        }
      }
    });
  });
  return result;
}

// node_modules/swagger-client/es/helpers/each-operation.js
function eachOperation(spec2, cb, find4) {
  if (!spec2 || typeof spec2 !== "object" || !spec2.paths || typeof spec2.paths !== "object") {
    return null;
  }
  const {
    paths: paths4
  } = spec2;
  for (const pathName in paths4) {
    for (const method in paths4[pathName]) {
      if (method.toUpperCase() === "PARAMETERS") {
        continue;
      }
      const operation = paths4[pathName][method];
      if (!operation || typeof operation !== "object") {
        continue;
      }
      const operationObj = {
        spec: spec2,
        pathName,
        method: method.toUpperCase(),
        operation
      };
      const cbValue = cb(operationObj);
      if (find4 && cbValue) {
        return operationObj;
      }
    }
  }
  return void 0;
}

// node_modules/swagger-client/es/helpers/find-operation.js
function findOperation(spec2, predicate) {
  return eachOperation(spec2, predicate, true) || null;
}

// node_modules/swagger-client/es/helpers/id-from-path-method/legacy.js
function idFromPathMethodLegacy(pathName, method) {
  return `${method.toLowerCase()}-${pathName}`;
}

// node_modules/swagger-client/es/helpers/get-operation-raw.js
function getOperationRaw(spec2, id) {
  if (!spec2 || !spec2.paths) {
    return null;
  }
  return findOperation(spec2, ({
    pathName,
    method,
    operation
  }) => {
    if (!operation || typeof operation !== "object") {
      return false;
    }
    const rawOperationId = operation.operationId;
    const operationId = opId(operation, pathName, method);
    const legacyOperationId = idFromPathMethodLegacy(pathName, method);
    return [operationId, legacyOperationId, rawOperationId].some((val) => val && val === id);
  });
}

// node_modules/swagger-client/es/helpers/is-http-url.js
var {
  isHttpUrl: isHttpUrl2
} = url_exports;

// node_modules/swagger-client/es/execute/index.js
var arrayOrEmpty = (ar2) => Array.isArray(ar2) ? ar2 : [];
var parseURIReference = (uriReference) => {
  try {
    return new URL(uriReference);
  } catch {
    const parsedURL = new URL(uriReference, DEFAULT_BASE_URL);
    const pathname = String(uriReference).startsWith("/") ? parsedURL.pathname : parsedURL.pathname.substring(1);
    return {
      hash: parsedURL.hash,
      host: "",
      hostname: "",
      href: "",
      origin: "",
      password: "",
      pathname,
      port: "",
      protocol: "",
      search: parsedURL.search,
      searchParams: parsedURL.searchParams
    };
  }
};
var OperationNotFoundError = class extends ApiDOMStructuredError_default {
};
var findParametersWithName = (name2, parameters) => parameters.filter((p2) => p2.name === name2);
var deduplicateParameters = (parameters) => {
  const paramsMap = {};
  parameters.forEach((p2) => {
    if (!paramsMap[p2.in]) {
      paramsMap[p2.in] = {};
    }
    paramsMap[p2.in][p2.name] = p2;
  });
  const dedupedParameters = [];
  Object.keys(paramsMap).forEach((i2) => {
    Object.keys(paramsMap[i2]).forEach((p2) => {
      dedupedParameters.push(paramsMap[i2][p2]);
    });
  });
  return dedupedParameters;
};
var self2 = {
  buildRequest: buildRequest3
};
function execute({
  http: userHttp,
  fetch: fetch3,
  // This is legacy
  spec: spec2,
  operationId,
  pathName,
  method,
  parameters,
  securities,
  ...extras
}) {
  const http3 = userHttp || fetch3 || http;
  if (pathName && method && !operationId) {
    operationId = idFromPathMethodLegacy(pathName, method);
  }
  const request = self2.buildRequest({
    spec: spec2,
    operationId,
    parameters,
    securities,
    http: http3,
    ...extras
  });
  if (request.body && (isPlainObj_default(request.body) || Array.isArray(request.body))) {
    request.body = JSON.stringify(request.body);
  }
  return http3(request);
}
function buildRequest3(options) {
  var _baseURL;
  const {
    spec: spec2,
    operationId,
    responseContentType,
    scheme,
    requestInterceptor,
    responseInterceptor,
    contextUrl,
    userFetch,
    server,
    serverVariables,
    http: http3,
    signal,
    serverVariableEncoder
  } = options;
  let {
    parameters,
    parameterBuilders,
    baseURL
  } = options;
  const specIsOAS3 = isOpenAPI3(spec2);
  if (!parameterBuilders) {
    if (specIsOAS3) {
      parameterBuilders = parameter_builders_exports;
    } else {
      parameterBuilders = parameter_builders_default;
    }
  }
  const credentials = http3 && http3.withCredentials ? "include" : "same-origin";
  let req = {
    url: "",
    credentials,
    headers: {},
    cookies: {}
  };
  if (signal) {
    req.signal = signal;
  }
  if (requestInterceptor) {
    req.requestInterceptor = requestInterceptor;
  }
  if (responseInterceptor) {
    req.responseInterceptor = responseInterceptor;
  }
  if (userFetch) {
    req.userFetch = userFetch;
  }
  const operationRaw = getOperationRaw(spec2, operationId);
  if (!operationRaw) {
    throw new OperationNotFoundError(`Operation ${operationId} not found`);
  }
  const {
    operation = {},
    method,
    pathName
  } = operationRaw;
  baseURL = (_baseURL = baseURL) !== null && _baseURL !== void 0 ? _baseURL : baseUrl({
    spec: spec2,
    scheme,
    contextUrl,
    server,
    serverVariables,
    pathName,
    method,
    serverVariableEncoder
  });
  req.url += baseURL;
  if (!operationId) {
    delete req.cookies;
    return req;
  }
  req.url += pathName;
  req.method = `${method}`.toUpperCase();
  parameters = parameters || {};
  const path4 = spec2.paths[pathName] || {};
  if (responseContentType) {
    req.headers.accept = responseContentType;
  }
  const combinedParameters = deduplicateParameters([].concat(arrayOrEmpty(operation.parameters)).concat(arrayOrEmpty(path4.parameters)));
  combinedParameters.forEach((parameter) => {
    const builder = parameterBuilders[parameter.in];
    let value;
    if (parameter.in === "body" && parameter.schema && parameter.schema.properties) {
      value = parameters;
    }
    value = parameter && parameter.name && parameters[parameter.name];
    if (typeof value === "undefined") {
      value = parameter && parameter.name && parameters[`${parameter.in}.${parameter.name}`];
    } else if (findParametersWithName(parameter.name, combinedParameters).length > 1) {
      console.warn(`Parameter '${parameter.name}' is ambiguous because the defined spec has more than one parameter with the name: '${parameter.name}' and the passed-in parameter values did not define an 'in' value.`);
    }
    if (value === null) {
      return;
    }
    if (typeof parameter.default !== "undefined" && typeof value === "undefined") {
      value = parameter.default;
    }
    if (typeof value === "undefined" && parameter.required && !parameter.allowEmptyValue) {
      throw new Error(`Required parameter ${parameter.name} is not provided`);
    }
    if (specIsOAS3 && parameter.schema && parameter.schema.type === "object" && typeof value === "string") {
      try {
        value = JSON.parse(value);
      } catch (e2) {
        throw new Error("Could not parse object parameter value string as JSON");
      }
    }
    if (builder) {
      builder({
        req,
        parameter,
        value,
        operation,
        spec: spec2,
        baseURL
      });
    }
  });
  const versionSpecificOptions = {
    ...options,
    operation
  };
  if (specIsOAS3) {
    req = buildRequest(versionSpecificOptions, req);
  } else {
    req = buildRequest2(versionSpecificOptions, req);
  }
  if (req.cookies && Object.keys(req.cookies).length) {
    const cookieString = Object.keys(req.cookies).reduce((prev, cookieName) => {
      const cookieValue = req.cookies[cookieName];
      const prefix = prev ? "&" : "";
      const stringified = import_cookie.default.serialize(cookieName, cookieValue);
      return prev + prefix + stringified;
    }, "");
    req.headers.Cookie = cookieString;
  }
  if (req.cookies) {
    delete req.cookies;
  }
  return serializeRequest(req);
}
var stripNonAlpha = (str2) => str2 ? str2.replace(/\W/g, "") : null;
function baseUrl(obj) {
  const specIsOAS3 = isOpenAPI3(obj.spec);
  return specIsOAS3 ? oas3BaseUrl(obj) : swagger2BaseUrl(obj);
}
var isNonEmptyServerList = (value) => Array.isArray(value) && value.length > 0;
function oas3BaseUrl({
  spec: spec2,
  pathName,
  method,
  server,
  contextUrl,
  serverVariables = {},
  serverVariableEncoder
}) {
  var _spec$paths, _spec$paths2;
  let servers = [];
  let selectedServerUrl = "";
  let selectedServerObj;
  const operationLevelServers = spec2 === null || spec2 === void 0 || (_spec$paths = spec2.paths) === null || _spec$paths === void 0 || (_spec$paths = _spec$paths[pathName]) === null || _spec$paths === void 0 || (_spec$paths = _spec$paths[(method || "").toLowerCase()]) === null || _spec$paths === void 0 ? void 0 : _spec$paths.servers;
  const pathItemLevelServers = spec2 === null || spec2 === void 0 || (_spec$paths2 = spec2.paths) === null || _spec$paths2 === void 0 || (_spec$paths2 = _spec$paths2[pathName]) === null || _spec$paths2 === void 0 ? void 0 : _spec$paths2.servers;
  const rootLevelServers = spec2 === null || spec2 === void 0 ? void 0 : spec2.servers;
  servers = isNonEmptyServerList(operationLevelServers) ? operationLevelServers : isNonEmptyServerList(pathItemLevelServers) ? pathItemLevelServers : isNonEmptyServerList(rootLevelServers) ? rootLevelServers : [DEFAULT_OPENAPI_3_SERVER];
  if (server) {
    selectedServerObj = servers.find((srv) => srv.url === server);
    if (selectedServerObj) selectedServerUrl = server;
  }
  if (!selectedServerUrl) {
    [selectedServerObj] = servers;
    selectedServerUrl = selectedServerObj.url;
  }
  if (test_default2(selectedServerUrl, {
    strict: true
  })) {
    const selectedServerVariables = Object.entries({
      ...selectedServerObj.variables
    }).reduce((acc, [serverVariableName2, serverVariable2]) => {
      acc[serverVariableName2] = serverVariable2.default;
      return acc;
    }, {});
    selectedServerUrl = substitute_default(selectedServerUrl, {
      ...selectedServerVariables,
      ...serverVariables
    }, {
      encoder: typeof serverVariableEncoder === "function" ? serverVariableEncoder : identity_default
    });
  }
  return buildOas3UrlWithContext(selectedServerUrl, contextUrl);
}
function buildOas3UrlWithContext(ourUrl = "", contextUrl = "") {
  const parsedUrl = ourUrl && contextUrl ? parseURIReference(url_exports.resolve(contextUrl, ourUrl)) : parseURIReference(ourUrl);
  const parsedContextUrl = parseURIReference(contextUrl);
  const computedScheme = stripNonAlpha(parsedUrl.protocol) || stripNonAlpha(parsedContextUrl.protocol);
  const computedHost = parsedUrl.host || parsedContextUrl.host;
  const computedPath = parsedUrl.pathname;
  let res;
  if (computedScheme && computedHost) {
    res = `${computedScheme}://${computedHost + computedPath}`;
  } else {
    res = computedPath;
  }
  return res[res.length - 1] === "/" ? res.slice(0, -1) : res;
}
function swagger2BaseUrl({
  spec: spec2,
  scheme,
  contextUrl = ""
}) {
  const parsedContextUrl = parseURIReference(contextUrl);
  const firstSchemeInSpec = Array.isArray(spec2.schemes) ? spec2.schemes[0] : null;
  const computedScheme = scheme || firstSchemeInSpec || stripNonAlpha(parsedContextUrl.protocol) || "http";
  const computedHost = spec2.host || parsedContextUrl.host || "";
  const computedPath = spec2.basePath || "";
  let res;
  if (computedScheme && computedHost) {
    res = `${computedScheme}://${computedHost + computedPath}`;
  } else {
    res = computedPath;
  }
  return res[res.length - 1] === "/" ? res.slice(0, -1) : res;
}

// node_modules/swagger-client/es/subtree-resolver/index.js
var resolveSubtree = async (obj, path4, options = {}) => {
  const {
    returnEntireTree,
    baseDoc,
    requestInterceptor,
    responseInterceptor,
    parameterMacro,
    modelPropertyMacro,
    useCircularStructures,
    strategies
  } = options;
  const resolveOptions = {
    spec: obj,
    pathDiscriminator: path4,
    baseDoc,
    requestInterceptor,
    responseInterceptor,
    parameterMacro,
    modelPropertyMacro,
    useCircularStructures,
    strategies
  };
  const strategy = strategies.find((strg) => strg.match(obj));
  const normalized = strategy.normalize(obj);
  const result = await resolver_default({
    spec: normalized,
    ...resolveOptions,
    allowMetaPatches: true,
    skipNormalization: !isOpenAPI31(obj)
  });
  if (!returnEntireTree && Array.isArray(path4) && path4.length) {
    result.spec = path4.reduce((acc, pathSegment) => acc === null || acc === void 0 ? void 0 : acc[pathSegment], result.spec) || null;
  }
  return result;
};
var makeResolveSubtree = (defaultOptions3) => async (obj, path4, options = {}) => {
  const mergedOptions = {
    ...defaultOptions3,
    ...options
  };
  return resolveSubtree(obj, path4, mergedOptions);
};
var subtree_resolver_default = makeResolveSubtree({
  strategies: [openapi_3_0_default, openapi_2_default, generic_default]
});

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var H = __toESM(require_react_dom());

// node_modules/react-redux/dist/react-redux.mjs
var React2 = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var ReactOriginal = __toESM(require_react(), 1);
var React3 = (
  // prettier-ignore
  // @ts-ignore
  "default" in ReactOriginal ? ReactOriginal["default"] : ReactOriginal
);
var ContextKey = Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  if (!React3.createContext)
    return {};
  const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());
  let realContext = contextMap.get(React3.createContext);
  if (!realContext) {
    realContext = React3.createContext(
      null
    );
    if (true) {
      realContext.displayName = "ReactRedux";
    }
    contextMap.set(React3.createContext, realContext);
  }
  return realContext;
}
var ReactReduxContext = getContext();
var notInitialized = () => {
  throw new Error("uSES not initialized!");
};
function createReduxContextHook(context2 = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = React3.useContext(context2);
    if (!contextValue) {
      throw new Error(
        "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
      );
    }
    return contextValue;
  };
}
var useReduxContext = createReduxContextHook();
var useSyncExternalStoreWithSelector = notInitialized;
var initializeUseSelector = (fn2) => {
  useSyncExternalStoreWithSelector = fn2;
};
var refEquality = (a2, b) => a2 === b;
function createSelectorHook(context2 = ReactReduxContext) {
  const useReduxContext2 = context2 === ReactReduxContext ? useReduxContext : createReduxContextHook(context2);
  const useSelector2 = (selector, equalityFnOrOptions = {}) => {
    const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
    if (true) {
      if (!selector) {
        throw new Error(`You must pass a selector to useSelector`);
      }
      if (typeof selector !== "function") {
        throw new Error(`You must pass a function as a selector to useSelector`);
      }
      if (typeof equalityFn !== "function") {
        throw new Error(
          `You must pass a function as an equality function to useSelector`
        );
      }
    }
    const {
      store,
      subscription,
      getServerState,
      stabilityCheck,
      identityFunctionCheck
    } = useReduxContext2();
    const firstRun = React3.useRef(true);
    const wrappedSelector = React3.useCallback(
      {
        [selector.name](state2) {
          const selected = selector(state2);
          if (true) {
            const {
              identityFunctionCheck: finalIdentityFunctionCheck,
              stabilityCheck: finalStabilityCheck
            } = {
              stabilityCheck,
              identityFunctionCheck,
              ...devModeChecks
            };
            if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
              const toCompare = selector(state2);
              if (!equalityFn(selected, toCompare)) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ;
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",
                  {
                    state: state2,
                    selected,
                    selected2: toCompare,
                    stack
                  }
                );
              }
            }
            if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
              if (selected === state2) {
                let stack = void 0;
                try {
                  throw new Error();
                } catch (e2) {
                  ;
                  ({ stack } = e2);
                }
                console.warn(
                  "Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",
                  { stack }
                );
              }
            }
            if (firstRun.current)
              firstRun.current = false;
          }
          return selected;
        }
      }[selector.name],
      [selector, stabilityCheck, devModeChecks.stabilityCheck]
    );
    const selectedState = useSyncExternalStoreWithSelector(
      subscription.addNestedSub,
      store.getState,
      getServerState || store.getState,
      wrappedSelector,
      equalityFn
    );
    React3.useDebugValue(selectedState);
    return selectedState;
  };
  Object.assign(useSelector2, {
    withTypes: () => useSelector2
  });
  return useSelector2;
}
var useSelector = createSelectorHook();
var REACT_ELEMENT_TYPE = Symbol.for("react.element");
var REACT_PORTAL_TYPE = Symbol.for("react.portal");
var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
var REACT_CONTEXT_TYPE = Symbol.for("react.context");
var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
var REACT_MEMO_TYPE = Symbol.for("react.memo");
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function isValidElementType(type5) {
  if (typeof type5 === "string" || typeof type5 === "function") {
    return true;
  }
  if (type5 === REACT_FRAGMENT_TYPE || type5 === REACT_PROFILER_TYPE || type5 === REACT_STRICT_MODE_TYPE || type5 === REACT_SUSPENSE_TYPE || type5 === REACT_SUSPENSE_LIST_TYPE || type5 === REACT_OFFSCREEN_TYPE) {
    return true;
  }
  if (typeof type5 === "object" && type5 !== null) {
    if (type5.$$typeof === REACT_LAZY_TYPE || type5.$$typeof === REACT_MEMO_TYPE || type5.$$typeof === REACT_PROVIDER_TYPE || type5.$$typeof === REACT_CONTEXT_TYPE || type5.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type5.$$typeof === REACT_CLIENT_REFERENCE || type5.getModuleId !== void 0) {
      return true;
    }
  }
  return false;
}
function typeOf(object2) {
  if (typeof object2 === "object" && object2 !== null) {
    const $$typeof = object2.$$typeof;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE: {
        const type5 = object2.type;
        switch (type5) {
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
          case REACT_SUSPENSE_LIST_TYPE:
            return type5;
          default: {
            const $$typeofType = type5 && type5.$$typeof;
            switch ($$typeofType) {
              case REACT_SERVER_CONTEXT_TYPE:
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;
              default:
                return $$typeof;
            }
          }
        }
      }
      case REACT_PORTAL_TYPE: {
        return $$typeof;
      }
    }
  }
  return void 0;
}
function isContextConsumer(object2) {
  return typeOf(object2) === REACT_CONTEXT_TYPE;
}
function isMemo(object2) {
  return typeOf(object2) === REACT_MEMO_TYPE;
}
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e2) {
  }
}
function verify(selector, methodName) {
  if (!selector) {
    throw new Error(`Unexpected value for ${methodName} in connect.`);
  } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
    if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
      warning(
        `The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`
      );
    }
  }
}
function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps2) {
  verify(mapStateToProps, "mapStateToProps");
  verify(mapDispatchToProps, "mapDispatchToProps");
  verify(mergeProps2, "mergeProps");
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps2, dispatch2, {
  areStatesEqual,
  areOwnPropsEqual,
  areStatePropsEqual
}) {
  let hasRunAtLeastOnce = false;
  let state2;
  let ownProps;
  let stateProps;
  let dispatchProps;
  let mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state2 = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state2, ownProps);
    dispatchProps = mapDispatchToProps(dispatch2, ownProps);
    mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state2, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch2, ownProps);
    mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state2, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps(dispatch2, ownProps);
    mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    const nextStateProps = mapStateToProps(state2, ownProps);
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    const stateChanged = !areStatesEqual(
      nextState,
      state2,
      nextOwnProps,
      ownProps
    );
    state2 = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged)
      return handleNewPropsAndNewState();
    if (propsChanged)
      return handleNewProps();
    if (stateChanged)
      return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch2, {
  initMapStateToProps,
  initMapDispatchToProps,
  initMergeProps,
  ...options
}) {
  const mapStateToProps = initMapStateToProps(dispatch2, options);
  const mapDispatchToProps = initMapDispatchToProps(dispatch2, options);
  const mergeProps2 = initMergeProps(dispatch2, options);
  if (true) {
    verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps2);
  }
  return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps2, dispatch2, options);
}
function bindActionCreators2(actionCreators, dispatch2) {
  const boundActionCreators = {};
  for (const key57 in actionCreators) {
    const actionCreator = actionCreators[key57];
    if (typeof actionCreator === "function") {
      boundActionCreators[key57] = (...args) => dispatch2(actionCreator(...args));
    }
  }
  return boundActionCreators;
}
function isPlainObject2(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  const proto2 = Object.getPrototypeOf(obj);
  if (proto2 === null)
    return true;
  let baseProto = proto2;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto2 === baseProto;
}
function verifyPlainObject(value, displayName, methodName) {
  if (!isPlainObject2(value)) {
    warning(
      `${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`
    );
  }
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch2) {
    const constant = getConstant(dispatch2);
    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch2, { displayName }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      let props3 = proxy(stateOrDispatch, ownProps);
      if (typeof props3 === "function") {
        proxy.mapToProps = props3;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props3);
        props3 = proxy(stateOrDispatch, ownProps);
      }
      if (true)
        verifyPlainObject(props3, displayName, methodName);
      return props3;
    };
    return proxy;
  };
}
function createInvalidArgFactory(arg, name2) {
  return (dispatch2, options) => {
    throw new Error(
      `Invalid value of type ${typeof arg} for ${name2} argument when connecting component ${options.wrappedComponentName}.`
    );
  };
}
function mapDispatchToPropsFactory(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(
    (dispatch2) => (
      // @ts-ignore
      bindActionCreators2(mapDispatchToProps, dispatch2)
    )
  ) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch2) => ({
    dispatch: dispatch2
  })) : typeof mapDispatchToProps === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps")
  ) : createInvalidArgFactory(mapDispatchToProps, "mapDispatchToProps");
}
function mapStateToPropsFactory(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps, "mapStateToProps")
  ) : createInvalidArgFactory(mapStateToProps, "mapStateToProps");
}
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return { ...ownProps, ...stateProps, ...dispatchProps };
}
function wrapMergePropsFunc(mergeProps2) {
  return function initMergePropsProxy(dispatch2, { displayName, areMergedPropsEqual }) {
    let hasRunOnce = false;
    let mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      const nextMergedProps = mergeProps2(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (true)
          verifyPlainObject(mergedProps, displayName, "mergeProps");
      }
      return mergedProps;
    };
  };
}
function mergePropsFactory(mergeProps2) {
  return !mergeProps2 ? () => defaultMergeProps : typeof mergeProps2 === "function" ? wrapMergePropsFunc(mergeProps2) : createInvalidArgFactory(mergeProps2, "mergeProps");
}
function defaultNoopBatch(callback) {
  callback();
}
function createListenerCollection() {
  let first = null;
  let last2 = null;
  return {
    clear() {
      first = null;
      last2 = null;
    },
    notify() {
      defaultNoopBatch(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      const listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      const listener = last2 = {
        callback,
        next: null,
        prev: last2
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last2 = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
var useIsomorphicLayoutEffect = canUseDOM || isReactNative ? React3.useLayoutEffect : React3.useEffect;
function is4(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function shallowEqual(objA, objB) {
  if (is4(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (let i2 = 0; i2 < keysA.length; i2++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !is4(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  $$typeof: true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  $$typeof: true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {
  [ForwardRef]: FORWARD_REF_STATICS,
  [Memo]: MEMO_STATICS
};
function getStatics(component) {
  if (isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      const inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent);
      }
    }
    let keys4 = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys4 = keys4.concat(getOwnPropertySymbols(sourceComponent));
    }
    const targetStatics = getStatics(targetComponent);
    const sourceStatics = getStatics(sourceComponent);
    for (let i2 = 0; i2 < keys4.length; ++i2) {
      const key57 = keys4[i2];
      if (!KNOWN_STATICS[key57] && !(sourceStatics && sourceStatics[key57]) && !(targetStatics && targetStatics[key57])) {
        const descriptor = getOwnPropertyDescriptor(sourceComponent, key57);
        try {
          defineProperty(targetComponent, key57, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var useSyncExternalStore2 = notInitialized;
var initializeConnect = (fn2) => {
  useSyncExternalStore2 = fn2;
};
var NO_SUBSCRIPTION_ARRAY = [null, null];
var stringifyComponent = (Comp) => {
  try {
    return JSON.stringify(Comp);
  } catch (err2) {
    return String(Comp);
  }
};
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
  if (!shouldHandleStateChanges)
    return () => {
    };
  let didUnsubscribe = false;
  let lastThrownError = null;
  const checkForUpdates = () => {
    if (didUnsubscribe || !isMounted.current) {
      return;
    }
    const latestStoreState = store.getState();
    let newChildProps, error;
    try {
      newChildProps = childPropsSelector(
        latestStoreState,
        lastWrapperProps.current
      );
    } catch (e2) {
      error = e2;
      lastThrownError = e2;
    }
    if (!error) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      additionalSubscribeListener();
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  const unsubscribeWrapper = () => {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
function strictEqual(a2, b) {
  return a2 === b;
}
var hasWarnedAboutDeprecatedPureOption = false;
function connect(mapStateToProps, mapDispatchToProps, mergeProps2, {
  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
  // @ts-ignore
  pure,
  areStatesEqual = strictEqual,
  areOwnPropsEqual = shallowEqual,
  areStatePropsEqual = shallowEqual,
  areMergedPropsEqual = shallowEqual,
  // use React's forwardRef to expose a ref of the wrapped component
  forwardRef: forwardRef2 = false,
  // the context consumer to use
  context: context2 = ReactReduxContext
} = {}) {
  if (true) {
    if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {
      hasWarnedAboutDeprecatedPureOption = true;
      warning(
        'The `pure` option has been removed. `connect` is now always a "pure/memoized" component'
      );
    }
  }
  const Context = context2;
  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);
  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);
  const initMergeProps = mergePropsFactory(mergeProps2);
  const shouldHandleStateChanges = Boolean(mapStateToProps);
  const wrapWithConnect = (WrappedComponent) => {
    if (true) {
      const isValid = isValidElementType(WrappedComponent);
      if (!isValid)
        throw new Error(
          `You must pass a component to the function returned by connect. Instead received ${stringifyComponent(
            WrappedComponent
          )}`
        );
    }
    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    const displayName = `Connect(${wrappedComponentName})`;
    const selectorFactoryOptions = {
      shouldHandleStateChanges,
      displayName,
      wrappedComponentName,
      WrappedComponent,
      // @ts-ignore
      initMapStateToProps,
      // @ts-ignore
      initMapDispatchToProps,
      initMergeProps,
      areStatesEqual,
      areStatePropsEqual,
      areOwnPropsEqual,
      areMergedPropsEqual
    };
    function ConnectFunction(props3) {
      const [propsContext, reactReduxForwardedRef, wrapperProps] = React3.useMemo(() => {
        const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props3;
        return [props3.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props3]);
      const ContextToUse = React3.useMemo(() => {
        let ResultContext = Context;
        if (propsContext == null ? void 0 : propsContext.Consumer) {
          if (true) {
            const isValid = isContextConsumer(
              // @ts-ignore
              React3.createElement(propsContext.Consumer, null)
            );
            if (!isValid) {
              throw new Error(
                "You must pass a valid React context consumer as `props.context`"
              );
            }
            ResultContext = propsContext;
          }
        }
        return ResultContext;
      }, [propsContext, Context]);
      const contextValue = React3.useContext(ContextToUse);
      const didStoreComeFromProps = Boolean(props3.store) && Boolean(props3.store.getState) && Boolean(props3.store.dispatch);
      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      if (!didStoreComeFromProps && !didStoreComeFromContext) {
        throw new Error(
          `Could not find "store" in the context of "${displayName}". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`
        );
      }
      const store = didStoreComeFromProps ? props3.store : contextValue.store;
      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
      const childPropsSelector = React3.useMemo(() => {
        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
      }, [store]);
      const [subscription, notifyNestedSubs] = React3.useMemo(() => {
        if (!shouldHandleStateChanges)
          return NO_SUBSCRIPTION_ARRAY;
        const subscription2 = createSubscription(
          store,
          didStoreComeFromProps ? void 0 : contextValue.subscription
        );
        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]);
      const overriddenContextValue = React3.useMemo(() => {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return {
          ...contextValue,
          subscription
        };
      }, [didStoreComeFromProps, contextValue, subscription]);
      const lastChildProps = React3.useRef(void 0);
      const lastWrapperProps = React3.useRef(wrapperProps);
      const childPropsFromStoreUpdate = React3.useRef(void 0);
      const renderIsScheduled = React3.useRef(false);
      const isMounted = React3.useRef(false);
      const latestSubscriptionCallbackError = React3.useRef(
        void 0
      );
      useIsomorphicLayoutEffect(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      const actualChildPropsSelector = React3.useMemo(() => {
        const selector = () => {
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          }
          return childPropsSelector(store.getState(), wrapperProps);
        };
        return selector;
      }, [store, wrapperProps]);
      const subscribeForReact = React3.useMemo(() => {
        const subscribe = (reactListener) => {
          if (!subscription) {
            return () => {
            };
          }
          return subscribeUpdates(
            shouldHandleStateChanges,
            store,
            subscription,
            // @ts-ignore
            childPropsSelector,
            lastWrapperProps,
            lastChildProps,
            renderIsScheduled,
            isMounted,
            childPropsFromStoreUpdate,
            notifyNestedSubs,
            reactListener
          );
        };
        return subscribe;
      }, [subscription]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [
        lastWrapperProps,
        lastChildProps,
        renderIsScheduled,
        wrapperProps,
        childPropsFromStoreUpdate,
        notifyNestedSubs
      ]);
      let actualChildProps;
      try {
        actualChildProps = useSyncExternalStore2(
          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
          subscribeForReact,
          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
          actualChildPropsSelector,
          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector
        );
      } catch (err2) {
        if (latestSubscriptionCallbackError.current) {
          ;
          err2.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
        }
        throw err2;
      }
      useIsomorphicLayoutEffect(() => {
        latestSubscriptionCallbackError.current = void 0;
        childPropsFromStoreUpdate.current = void 0;
        lastChildProps.current = actualChildProps;
      });
      const renderedWrappedComponent = React3.useMemo(() => {
        return (
          // @ts-ignore
          React3.createElement(
            WrappedComponent,
            {
              ...actualChildProps,
              ref: reactReduxForwardedRef
            }
          )
        );
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      const renderedChild = React3.useMemo(() => {
        if (shouldHandleStateChanges) {
          return React3.createElement(ContextToUse.Provider, { value: overriddenContextValue }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    const _Connect = React3.memo(ConnectFunction);
    const Connect = _Connect;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef2) {
      const _forwarded = React3.forwardRef(
        function forwardConnectRef(props3, ref) {
          return React3.createElement(Connect, { ...props3, reactReduxForwardedRef: ref });
        }
      );
      const forwarded = _forwarded;
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoistNonReactStatics(forwarded, WrappedComponent);
    }
    return hoistNonReactStatics(Connect, WrappedComponent);
  };
  return wrapWithConnect;
}
var connect_default = connect;
function Provider({
  store,
  context: context2,
  children,
  serverState,
  stabilityCheck = "once",
  identityFunctionCheck = "once"
}) {
  const contextValue = React3.useMemo(() => {
    const subscription = createSubscription(store);
    return {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0,
      stabilityCheck,
      identityFunctionCheck
    };
  }, [store, serverState, stabilityCheck, identityFunctionCheck]);
  const previousState = React3.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect(() => {
    const { subscription } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context2 || ReactReduxContext;
  return React3.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;
function createStoreHook(context2 = ReactReduxContext) {
  const useReduxContext2 = context2 === ReactReduxContext ? useReduxContext : (
    // @ts-ignore
    createReduxContextHook(context2)
  );
  const useStore2 = () => {
    const { store } = useReduxContext2();
    return store;
  };
  Object.assign(useStore2, {
    withTypes: () => useStore2
  });
  return useStore2;
}
var useStore = createStoreHook();
function createDispatchHook(context2 = ReactReduxContext) {
  const useStore2 = context2 === ReactReduxContext ? useStore : createStoreHook(context2);
  const useDispatch2 = () => {
    const store = useStore2();
    return store.dispatch;
  };
  Object.assign(useDispatch2, {
    withTypes: () => useDispatch2
  });
  return useDispatch2;
}
var useDispatch = createDispatchHook();
initializeUseSelector(import_with_selector.useSyncExternalStoreWithSelector);
initializeConnect(React2.useSyncExternalStore);

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var X = __toESM(require_identity());

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t2 = {};
  for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
    if (e2.includes(n)) continue;
    t2[n] = r2[n];
  }
  return t2;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e2, t2) {
  if (null == e2) return {};
  var o4, r2, i2 = _objectWithoutPropertiesLoose(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var s2 = Object.getOwnPropertySymbols(e2);
    for (r2 = 0; r2 < s2.length; r2++) o4 = s2[r2], t2.includes(o4) || {}.propertyIsEnumerable.call(e2, o4) && (i2[o4] = e2[o4]);
  }
  return i2;
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray10(r2, a2) {
  (null == a2 || a2 > r2.length) && (a2 = r2.length);
  for (var e2 = 0, n = Array(a2); e2 < a2; e2++) n[e2] = r2[e2];
  return n;
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles7(r2) {
  if (Array.isArray(r2)) return _arrayLikeToArray10(r2);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray8(r2) {
  if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray10(r2, a2) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray10(r2, a2);
    var t2 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray10(r2, a2) : void 0;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray7(r2) {
  return _arrayWithoutHoles7(r2) || _iterableToArray8(r2) || _unsupportedIterableToArray10(r2) || _nonIterableSpread7();
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof10(o4) {
  "@babel/helpers - typeof";
  return _typeof10 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o5) {
    return typeof o5;
  } : function(o5) {
    return o5 && "function" == typeof Symbol && o5.constructor === Symbol && o5 !== Symbol.prototype ? "symbol" : typeof o5;
  }, _typeof10(o4);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t2, r2) {
  if ("object" != _typeof10(t2) || !t2) return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t2, r2 || "default");
    if ("object" != _typeof10(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t2) {
  var i2 = toPrimitive(t2, "string");
  return "symbol" == _typeof10(i2) ? i2 : i2 + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty5(e2, r2, t2) {
  return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t2,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t2, e2;
}

// node_modules/react-syntax-highlighter/dist/esm/highlight.js
var import_react3 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t2 = arguments[e2];
      for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n[r2] = t2[r2]);
    }
    return n;
  }, _extends2.apply(null, arguments);
}

// node_modules/react-syntax-highlighter/dist/esm/create-element.js
var import_react2 = __toESM(require_react());
function ownKeys3(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e2);
    r2 && (o4 = o4.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o4);
  }
  return t2;
}
function _objectSpread3(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys3(Object(t2), true).forEach(function(r3) {
      _defineProperty5(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys3(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1) return arr;
  if (arrLength === 2) {
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength >= 4) {
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}
var classNameCombinations = {};
function getClassNameCombinations(classNames) {
  if (classNames.length === 0 || classNames.length === 1) return classNames;
  var key57 = classNames.join(".");
  if (!classNameCombinations[key57]) {
    classNameCombinations[key57] = powerSetPermutations(classNames);
  }
  return classNameCombinations[key57];
}
function createStyleObject(classNames) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
  var nonTokenClassNames = classNames.filter(function(className) {
    return className !== "token";
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread3(_objectSpread3({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames) {
  return classNames.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    childrenCount += 1;
    return children.map(function(child, i2) {
      return createElement({
        node: child,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i2)
      });
    });
  };
}
function createElement(_ref) {
  var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key57 = _ref.key;
  var properties = node.properties, type5 = node.type, TagName = node.tagName, value = node.value;
  if (type5 === "text") {
    return value;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props3;
    if (!useInlineStyles) {
      props3 = _objectSpread3(_objectSpread3({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        selector.split(".").forEach(function(className2) {
          if (!classes.includes(className2)) classes.push(className2);
        });
        return classes;
      }, []);
      var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props3 = _objectSpread3(_objectSpread3({}, properties), {}, {
        className: createClassNameString(className) || void 0,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style), stylesheet)
      });
    }
    var children = childrenCreator(node.children);
    return import_react2.default.createElement(TagName, _extends2({
      key: key57
    }, props3), children);
  }
}

// node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js
var checkForListedLanguage_default = function(astGenerator, language) {
  var langs = astGenerator.listLanguages();
  return langs.indexOf(language) !== -1;
};

// node_modules/react-syntax-highlighter/dist/esm/highlight.js
var _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ownKeys4(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o4 = Object.getOwnPropertySymbols(e2);
    r2 && (o4 = o4.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o4);
  }
  return t2;
}
function _objectSpread4(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys4(Object(t2), true).forEach(function(r3) {
      _defineProperty5(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys4(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
var newLineRegex = /\n/g;
function getNewLines(str2) {
  return str2.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
  var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style = _ref.style;
  return lines.map(function(_2, i2) {
    var number = i2 + startingLineNumber;
    return import_react3.default.createElement("span", {
      key: "line-".concat(i2),
      className: "react-syntax-highlighter-line-number",
      style: typeof style === "function" ? style(number) : style
    }, "".concat(number, "\n"));
  });
}
function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
    "float": "left",
    paddingRight: "10px"
  } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
  return import_react3.default.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, "").split("\n"),
    style: numberStyle,
    startingLineNumber
  }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: inlineLineNumberStyle
    },
    children: [{
      type: "text",
      value: lineNumber
    }]
  };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  };
  var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
  var assembledStyle = _objectSpread4(_objectSpread4({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref3) {
  var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines, _ref3$wrapLines = _ref3.wrapLines, wrapLines = _ref3$wrapLines === void 0 ? false : _ref3$wrapLines;
  var properties = wrapLines ? _objectSpread4({}, typeof lineProps === "function" ? lineProps(lineNumber) : lineProps) : {};
  properties["className"] = properties["className"] ? [].concat(_toConsumableArray7(properties["className"].trim().split(/\s+/)), _toConsumableArray7(className)) : className;
  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread4({
      display: "flex"
    }, properties.style);
  }
  return {
    type: "element",
    tagName: "span",
    properties,
    children
  };
}
function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var i2 = 0; i2 < tree.length; i2++) {
    var node = tree[i2];
    if (node.type === "text") {
      newTree.push(createLineElement({
        children: [node],
        className: _toConsumableArray7(new Set(className))
      }));
    } else if (node.children) {
      var classNames = className.concat(node.properties.className);
      flattenCodeTree(node.children, classNames).forEach(function(i3) {
        return newTree.push(i3);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;
  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: children2,
      lineNumber: lineNumber2,
      lineNumberStyle,
      largestLineNumber,
      showInlineLineNumbers,
      lineProps,
      className,
      showLineNumbers,
      wrapLongLines,
      wrapLines
    });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  var _loop = function _loop2() {
    var node = tree[index];
    var value = node.children[0].value;
    var newLines = getNewLines(value);
    if (newLines) {
      var splitValue = value.split("\n");
      splitValue.forEach(function(text3, i2) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: "text",
          value: "".concat(text3, "\n")
        };
        if (i2 === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index).concat(createLineElement({
            children: [newChild],
            className: node.properties.className
          }));
          var _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i2 === splitValue.length - 1) {
          var stringChild = tree[index + 1] && tree[index + 1].children && tree[index + 1].children[0];
          var lastLineInPreviousSpan = {
            type: "text",
            value: "".concat(text3)
          };
          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node.properties.className
            });
            tree.splice(index + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];
            var _line2 = createLine(_children2, lineNumber2, node.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild];
          var _line3 = createLine(_children3, lineNumber2, node.properties.className);
          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index;
    }
    index++;
  };
  while (index < tree.length) {
    _loop();
  }
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node, i2) {
    return createElement({
      node,
      stylesheet,
      useInlineStyles,
      key: "code-segement".concat(i2)
    });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language = _ref6.language, code2 = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage_default(astGenerator, language);
    if (language === "text") {
      return {
        value: defaultCodeValue,
        language: "text"
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language, code2);
    } else {
      return astGenerator.highlightAuto(code2);
    }
  }
  try {
    return language && language !== "text" ? {
      value: astGenerator.highlight(code2, language)
    } : {
      value: defaultCodeValue
    };
  } catch (e2) {
    return {
      value: defaultCodeValue
    };
  }
}
function highlight_default(defaultAstGenerator, defaultStyle) {
  return function SyntaxHighlighter2(_ref7) {
    var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language ? "language-".concat(language) : void 0,
      style: _objectSpread4(_objectSpread4({}, style['code[class*="language-"]']), style['code[class*="language-'.concat(language, '"]')])
    } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code2 = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = _objectWithoutProperties(_ref7, _excluded);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? import_react3.default.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber,
      codeString: code2
    }) : null;
    var defaultPreStyle = style.hljs || style['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    };
    var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
    var preProps = useInlineStyles ? Object.assign({}, rest, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest, {
      className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });
    if (wrapLongLines) {
      codeTagProps.style = _objectSpread4({
        whiteSpace: "pre-wrap"
      }, codeTagProps.style);
    } else {
      codeTagProps.style = _objectSpread4({
        whiteSpace: "pre"
      }, codeTagProps.style);
    }
    if (!astGenerator) {
      return import_react3.default.createElement(PreTag, preProps, allLineNumbers, import_react3.default.createElement(CodeTag, codeTagProps, code2));
    }
    if (wrapLines === void 0 && renderer || wrapLongLines) wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: "text",
      value: code2
    }];
    var codeTree = getCodeTree({
      astGenerator,
      language,
      code: code2,
      defaultCodeValue
    });
    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    }
    var lineCount = codeTree.value.length;
    if (lineCount === 1 && codeTree.value[0].type === "text") {
      lineCount = codeTree.value[0].value.split("\n").length;
    }
    var largestLineNumber = lineCount + startingLineNumber;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return import_react3.default.createElement(PreTag, preProps, import_react3.default.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows,
      stylesheet: style,
      useInlineStyles
    })));
  };
}

// node_modules/react-syntax-highlighter/dist/esm/light.js
var import_core2 = __toESM(require_core2());
var SyntaxHighlighter = highlight_default(import_core2.default, {});
SyntaxHighlighter.registerLanguage = import_core2.default.registerLanguage;
var light_default = SyntaxHighlighter;

// node_modules/react-syntax-highlighter/dist/esm/languages/hljs/javascript.js
var import_javascript = __toESM(require_javascript());
var javascript_default = import_javascript.default;

// node_modules/react-syntax-highlighter/dist/esm/languages/hljs/json.js
var import_json4 = __toESM(require_json());
var json_default4 = import_json4.default;

// node_modules/react-syntax-highlighter/dist/esm/languages/hljs/xml.js
var import_xml3 = __toESM(require_xml());
var xml_default3 = import_xml3.default;

// node_modules/react-syntax-highlighter/dist/esm/languages/hljs/bash.js
var import_bash = __toESM(require_bash());
var bash_default = import_bash.default;

// node_modules/react-syntax-highlighter/dist/esm/languages/hljs/yaml.js
var import_yaml = __toESM(require_yaml());
var yaml_default = import_yaml.default;

// node_modules/react-syntax-highlighter/dist/esm/languages/hljs/http.js
var import_http4 = __toESM(require_http());
var http_default = import_http4.default;

// node_modules/react-syntax-highlighter/dist/esm/languages/hljs/powershell.js
var import_powershell = __toESM(require_powershell());
var powershell_default = import_powershell.default;

// node_modules/react-syntax-highlighter/dist/esm/styles/hljs/agate.js
var agate_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#333",
    "color": "white"
  },
  "hljs-name": {
    "fontWeight": "bold"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  },
  "hljs-code": {
    "fontStyle": "italic",
    "color": "#888"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-tag": {
    "color": "#62c8f3"
  },
  "hljs-variable": {
    "color": "#ade5fc"
  },
  "hljs-template-variable": {
    "color": "#ade5fc"
  },
  "hljs-selector-id": {
    "color": "#ade5fc"
  },
  "hljs-selector-class": {
    "color": "#ade5fc"
  },
  "hljs-string": {
    "color": "#a2fca2"
  },
  "hljs-bullet": {
    "color": "#d36363"
  },
  "hljs-type": {
    "color": "#ffa"
  },
  "hljs-title": {
    "color": "#ffa"
  },
  "hljs-section": {
    "color": "#ffa"
  },
  "hljs-attribute": {
    "color": "#ffa"
  },
  "hljs-quote": {
    "color": "#ffa"
  },
  "hljs-built_in": {
    "color": "#ffa"
  },
  "hljs-builtin-name": {
    "color": "#ffa"
  },
  "hljs-number": {
    "color": "#d36363"
  },
  "hljs-symbol": {
    "color": "#d36363"
  },
  "hljs-keyword": {
    "color": "#fcc28c"
  },
  "hljs-selector-tag": {
    "color": "#fcc28c"
  },
  "hljs-literal": {
    "color": "#fcc28c"
  },
  "hljs-comment": {
    "color": "#888"
  },
  "hljs-deletion": {
    "color": "#333",
    "backgroundColor": "#fc9b9b"
  },
  "hljs-regexp": {
    "color": "#c6b4f0"
  },
  "hljs-link": {
    "color": "#c6b4f0"
  },
  "hljs-meta": {
    "color": "#fc9b9b"
  },
  "hljs-addition": {
    "backgroundColor": "#a2fca2",
    "color": "#333"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/styles/hljs/arta.js
var arta_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#222",
    "color": "#aaa"
  },
  "hljs-subst": {
    "color": "#aaa"
  },
  "hljs-section": {
    "color": "#fff",
    "fontWeight": "bold"
  },
  "hljs-comment": {
    "color": "#444"
  },
  "hljs-quote": {
    "color": "#444"
  },
  "hljs-meta": {
    "color": "#444"
  },
  "hljs-string": {
    "color": "#ffcc33"
  },
  "hljs-symbol": {
    "color": "#ffcc33"
  },
  "hljs-bullet": {
    "color": "#ffcc33"
  },
  "hljs-regexp": {
    "color": "#ffcc33"
  },
  "hljs-number": {
    "color": "#00cc66"
  },
  "hljs-addition": {
    "color": "#00cc66"
  },
  "hljs-built_in": {
    "color": "#32aaee"
  },
  "hljs-builtin-name": {
    "color": "#32aaee"
  },
  "hljs-literal": {
    "color": "#32aaee"
  },
  "hljs-type": {
    "color": "#32aaee"
  },
  "hljs-template-variable": {
    "color": "#32aaee"
  },
  "hljs-attribute": {
    "color": "#32aaee"
  },
  "hljs-link": {
    "color": "#32aaee"
  },
  "hljs-keyword": {
    "color": "#6644aa"
  },
  "hljs-selector-tag": {
    "color": "#6644aa"
  },
  "hljs-name": {
    "color": "#6644aa"
  },
  "hljs-selector-id": {
    "color": "#6644aa"
  },
  "hljs-selector-class": {
    "color": "#6644aa"
  },
  "hljs-title": {
    "color": "#bb1166"
  },
  "hljs-variable": {
    "color": "#bb1166"
  },
  "hljs-deletion": {
    "color": "#bb1166"
  },
  "hljs-template-tag": {
    "color": "#bb1166"
  },
  "hljs-doctag": {
    "fontWeight": "bold"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/styles/hljs/monokai.js
var monokai_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#272822",
    "color": "#ddd"
  },
  "hljs-tag": {
    "color": "#f92672"
  },
  "hljs-keyword": {
    "color": "#f92672",
    "fontWeight": "bold"
  },
  "hljs-selector-tag": {
    "color": "#f92672",
    "fontWeight": "bold"
  },
  "hljs-literal": {
    "color": "#f92672",
    "fontWeight": "bold"
  },
  "hljs-strong": {
    "color": "#f92672"
  },
  "hljs-name": {
    "color": "#f92672"
  },
  "hljs-code": {
    "color": "#66d9ef"
  },
  "hljs-class .hljs-title": {
    "color": "white"
  },
  "hljs-attribute": {
    "color": "#bf79db"
  },
  "hljs-symbol": {
    "color": "#bf79db"
  },
  "hljs-regexp": {
    "color": "#bf79db"
  },
  "hljs-link": {
    "color": "#bf79db"
  },
  "hljs-string": {
    "color": "#a6e22e"
  },
  "hljs-bullet": {
    "color": "#a6e22e"
  },
  "hljs-subst": {
    "color": "#a6e22e"
  },
  "hljs-title": {
    "color": "#a6e22e",
    "fontWeight": "bold"
  },
  "hljs-section": {
    "color": "#a6e22e",
    "fontWeight": "bold"
  },
  "hljs-emphasis": {
    "color": "#a6e22e"
  },
  "hljs-type": {
    "color": "#a6e22e",
    "fontWeight": "bold"
  },
  "hljs-built_in": {
    "color": "#a6e22e"
  },
  "hljs-builtin-name": {
    "color": "#a6e22e"
  },
  "hljs-selector-attr": {
    "color": "#a6e22e"
  },
  "hljs-selector-pseudo": {
    "color": "#a6e22e"
  },
  "hljs-addition": {
    "color": "#a6e22e"
  },
  "hljs-variable": {
    "color": "#a6e22e"
  },
  "hljs-template-tag": {
    "color": "#a6e22e"
  },
  "hljs-template-variable": {
    "color": "#a6e22e"
  },
  "hljs-comment": {
    "color": "#75715e"
  },
  "hljs-quote": {
    "color": "#75715e"
  },
  "hljs-deletion": {
    "color": "#75715e"
  },
  "hljs-meta": {
    "color": "#75715e"
  },
  "hljs-doctag": {
    "fontWeight": "bold"
  },
  "hljs-selector-id": {
    "fontWeight": "bold"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/styles/hljs/nord.js
var nord_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#2E3440",
    "color": "#D8DEE9"
  },
  "hljs-subst": {
    "color": "#D8DEE9"
  },
  "hljs-selector-tag": {
    "color": "#81A1C1"
  },
  "hljs-selector-id": {
    "color": "#8FBCBB",
    "fontWeight": "bold"
  },
  "hljs-selector-class": {
    "color": "#8FBCBB"
  },
  "hljs-selector-attr": {
    "color": "#8FBCBB"
  },
  "hljs-selector-pseudo": {
    "color": "#88C0D0"
  },
  "hljs-addition": {
    "backgroundColor": "rgba(163, 190, 140, 0.5)"
  },
  "hljs-deletion": {
    "backgroundColor": "rgba(191, 97, 106, 0.5)"
  },
  "hljs-built_in": {
    "color": "#8FBCBB"
  },
  "hljs-type": {
    "color": "#8FBCBB"
  },
  "hljs-class": {
    "color": "#8FBCBB"
  },
  "hljs-function": {
    "color": "#88C0D0"
  },
  "hljs-function > .hljs-title": {
    "color": "#88C0D0"
  },
  "hljs-keyword": {
    "color": "#81A1C1"
  },
  "hljs-literal": {
    "color": "#81A1C1"
  },
  "hljs-symbol": {
    "color": "#81A1C1"
  },
  "hljs-number": {
    "color": "#B48EAD"
  },
  "hljs-regexp": {
    "color": "#EBCB8B"
  },
  "hljs-string": {
    "color": "#A3BE8C"
  },
  "hljs-title": {
    "color": "#8FBCBB"
  },
  "hljs-params": {
    "color": "#D8DEE9"
  },
  "hljs-bullet": {
    "color": "#81A1C1"
  },
  "hljs-code": {
    "color": "#8FBCBB"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-formula": {
    "color": "#8FBCBB"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  },
  "hljs-link:hover": {
    "textDecoration": "underline"
  },
  "hljs-quote": {
    "color": "#4C566A"
  },
  "hljs-comment": {
    "color": "#4C566A"
  },
  "hljs-doctag": {
    "color": "#8FBCBB"
  },
  "hljs-meta": {
    "color": "#5E81AC"
  },
  "hljs-meta-keyword": {
    "color": "#5E81AC"
  },
  "hljs-meta-string": {
    "color": "#A3BE8C"
  },
  "hljs-attr": {
    "color": "#8FBCBB"
  },
  "hljs-attribute": {
    "color": "#D8DEE9"
  },
  "hljs-builtin-name": {
    "color": "#81A1C1"
  },
  "hljs-name": {
    "color": "#81A1C1"
  },
  "hljs-section": {
    "color": "#88C0D0"
  },
  "hljs-tag": {
    "color": "#81A1C1"
  },
  "hljs-variable": {
    "color": "#D8DEE9"
  },
  "hljs-template-variable": {
    "color": "#D8DEE9"
  },
  "hljs-template-tag": {
    "color": "#5E81AC"
  },
  "abnf .hljs-attribute": {
    "color": "#88C0D0"
  },
  "abnf .hljs-symbol": {
    "color": "#EBCB8B"
  },
  "apache .hljs-attribute": {
    "color": "#88C0D0"
  },
  "apache .hljs-section": {
    "color": "#81A1C1"
  },
  "arduino .hljs-built_in": {
    "color": "#88C0D0"
  },
  "aspectj .hljs-meta": {
    "color": "#D08770"
  },
  "aspectj > .hljs-title": {
    "color": "#88C0D0"
  },
  "bnf .hljs-attribute": {
    "color": "#8FBCBB"
  },
  "clojure .hljs-name": {
    "color": "#88C0D0"
  },
  "clojure .hljs-symbol": {
    "color": "#EBCB8B"
  },
  "coq .hljs-built_in": {
    "color": "#88C0D0"
  },
  "cpp .hljs-meta-string": {
    "color": "#8FBCBB"
  },
  "css .hljs-built_in": {
    "color": "#88C0D0"
  },
  "css .hljs-keyword": {
    "color": "#D08770"
  },
  "diff .hljs-meta": {
    "color": "#8FBCBB"
  },
  "ebnf .hljs-attribute": {
    "color": "#8FBCBB"
  },
  "glsl .hljs-built_in": {
    "color": "#88C0D0"
  },
  "groovy .hljs-meta:not(:first-child)": {
    "color": "#D08770"
  },
  "haxe .hljs-meta": {
    "color": "#D08770"
  },
  "java .hljs-meta": {
    "color": "#D08770"
  },
  "ldif .hljs-attribute": {
    "color": "#8FBCBB"
  },
  "lisp .hljs-name": {
    "color": "#88C0D0"
  },
  "lua .hljs-built_in": {
    "color": "#88C0D0"
  },
  "moonscript .hljs-built_in": {
    "color": "#88C0D0"
  },
  "nginx .hljs-attribute": {
    "color": "#88C0D0"
  },
  "nginx .hljs-section": {
    "color": "#5E81AC"
  },
  "pf .hljs-built_in": {
    "color": "#88C0D0"
  },
  "processing .hljs-built_in": {
    "color": "#88C0D0"
  },
  "scss .hljs-keyword": {
    "color": "#81A1C1"
  },
  "stylus .hljs-keyword": {
    "color": "#81A1C1"
  },
  "swift .hljs-meta": {
    "color": "#D08770"
  },
  "vim .hljs-built_in": {
    "color": "#88C0D0",
    "fontStyle": "italic"
  },
  "yaml .hljs-meta": {
    "color": "#D08770"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/styles/hljs/obsidian.js
var obsidian_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "background": "#282b2e",
    "color": "#e0e2e4"
  },
  "hljs-keyword": {
    "color": "#93c763",
    "fontWeight": "bold"
  },
  "hljs-selector-tag": {
    "color": "#93c763",
    "fontWeight": "bold"
  },
  "hljs-literal": {
    "color": "#93c763",
    "fontWeight": "bold"
  },
  "hljs-selector-id": {
    "color": "#93c763"
  },
  "hljs-number": {
    "color": "#ffcd22"
  },
  "hljs-attribute": {
    "color": "#668bb0"
  },
  "hljs-code": {
    "color": "white"
  },
  "hljs-class .hljs-title": {
    "color": "white"
  },
  "hljs-section": {
    "color": "white",
    "fontWeight": "bold"
  },
  "hljs-regexp": {
    "color": "#d39745"
  },
  "hljs-link": {
    "color": "#d39745"
  },
  "hljs-meta": {
    "color": "#557182"
  },
  "hljs-tag": {
    "color": "#8cbbad"
  },
  "hljs-name": {
    "color": "#8cbbad",
    "fontWeight": "bold"
  },
  "hljs-bullet": {
    "color": "#8cbbad"
  },
  "hljs-subst": {
    "color": "#8cbbad"
  },
  "hljs-emphasis": {
    "color": "#8cbbad"
  },
  "hljs-type": {
    "color": "#8cbbad",
    "fontWeight": "bold"
  },
  "hljs-built_in": {
    "color": "#8cbbad"
  },
  "hljs-selector-attr": {
    "color": "#8cbbad"
  },
  "hljs-selector-pseudo": {
    "color": "#8cbbad"
  },
  "hljs-addition": {
    "color": "#8cbbad"
  },
  "hljs-variable": {
    "color": "#8cbbad"
  },
  "hljs-template-tag": {
    "color": "#8cbbad"
  },
  "hljs-template-variable": {
    "color": "#8cbbad"
  },
  "hljs-string": {
    "color": "#ec7600"
  },
  "hljs-symbol": {
    "color": "#ec7600"
  },
  "hljs-comment": {
    "color": "#818e96"
  },
  "hljs-quote": {
    "color": "#818e96"
  },
  "hljs-deletion": {
    "color": "#818e96"
  },
  "hljs-selector-class": {
    "color": "#A082BD"
  },
  "hljs-doctag": {
    "fontWeight": "bold"
  },
  "hljs-title": {
    "fontWeight": "bold"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/styles/hljs/tomorrow-night.js
var tomorrow_night_default = {
  "hljs-comment": {
    "color": "#969896"
  },
  "hljs-quote": {
    "color": "#969896"
  },
  "hljs-variable": {
    "color": "#cc6666"
  },
  "hljs-template-variable": {
    "color": "#cc6666"
  },
  "hljs-tag": {
    "color": "#cc6666"
  },
  "hljs-name": {
    "color": "#cc6666"
  },
  "hljs-selector-id": {
    "color": "#cc6666"
  },
  "hljs-selector-class": {
    "color": "#cc6666"
  },
  "hljs-regexp": {
    "color": "#cc6666"
  },
  "hljs-deletion": {
    "color": "#cc6666"
  },
  "hljs-number": {
    "color": "#de935f"
  },
  "hljs-built_in": {
    "color": "#de935f"
  },
  "hljs-builtin-name": {
    "color": "#de935f"
  },
  "hljs-literal": {
    "color": "#de935f"
  },
  "hljs-type": {
    "color": "#de935f"
  },
  "hljs-params": {
    "color": "#de935f"
  },
  "hljs-meta": {
    "color": "#de935f"
  },
  "hljs-link": {
    "color": "#de935f"
  },
  "hljs-attribute": {
    "color": "#f0c674"
  },
  "hljs-string": {
    "color": "#b5bd68"
  },
  "hljs-symbol": {
    "color": "#b5bd68"
  },
  "hljs-bullet": {
    "color": "#b5bd68"
  },
  "hljs-addition": {
    "color": "#b5bd68"
  },
  "hljs-title": {
    "color": "#81a2be"
  },
  "hljs-section": {
    "color": "#81a2be"
  },
  "hljs-keyword": {
    "color": "#b294bb"
  },
  "hljs-selector-tag": {
    "color": "#b294bb"
  },
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "background": "#1d1f21",
    "color": "#c5c8c6",
    "padding": "0.5em"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  }
};

// node_modules/react-syntax-highlighter/dist/esm/styles/hljs/idea.js
var idea_default = {
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "padding": "0.5em",
    "color": "#000",
    "background": "#fff"
  },
  "hljs-subst": {
    "fontWeight": "normal",
    "color": "#000"
  },
  "hljs-title": {
    "fontWeight": "normal",
    "color": "#000"
  },
  "hljs-comment": {
    "color": "#808080",
    "fontStyle": "italic"
  },
  "hljs-quote": {
    "color": "#808080",
    "fontStyle": "italic"
  },
  "hljs-meta": {
    "color": "#808000"
  },
  "hljs-tag": {
    "background": "#efefef"
  },
  "hljs-section": {
    "fontWeight": "bold",
    "color": "#000080"
  },
  "hljs-name": {
    "fontWeight": "bold",
    "color": "#000080"
  },
  "hljs-literal": {
    "fontWeight": "bold",
    "color": "#000080"
  },
  "hljs-keyword": {
    "fontWeight": "bold",
    "color": "#000080"
  },
  "hljs-selector-tag": {
    "fontWeight": "bold",
    "color": "#000080"
  },
  "hljs-type": {
    "fontWeight": "bold",
    "color": "#000080"
  },
  "hljs-selector-id": {
    "fontWeight": "bold",
    "color": "#000080"
  },
  "hljs-selector-class": {
    "fontWeight": "bold",
    "color": "#000080"
  },
  "hljs-attribute": {
    "fontWeight": "bold",
    "color": "#0000ff"
  },
  "hljs-number": {
    "fontWeight": "normal",
    "color": "#0000ff"
  },
  "hljs-regexp": {
    "fontWeight": "normal",
    "color": "#0000ff"
  },
  "hljs-link": {
    "fontWeight": "normal",
    "color": "#0000ff"
  },
  "hljs-string": {
    "color": "#008000",
    "fontWeight": "bold"
  },
  "hljs-symbol": {
    "color": "#000",
    "background": "#d0eded",
    "fontStyle": "italic"
  },
  "hljs-bullet": {
    "color": "#000",
    "background": "#d0eded",
    "fontStyle": "italic"
  },
  "hljs-formula": {
    "color": "#000",
    "background": "#d0eded",
    "fontStyle": "italic"
  },
  "hljs-doctag": {
    "textDecoration": "underline"
  },
  "hljs-variable": {
    "color": "#660e7a"
  },
  "hljs-template-variable": {
    "color": "#660e7a"
  },
  "hljs-addition": {
    "background": "#baeeba"
  },
  "hljs-deletion": {
    "background": "#ffc8bd"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  }
};

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var pe = __toESM(require_file_download());
var me = __toESM(require_zipObject());
var fe = __toESM(require_toString());
var he = __toESM(require_dist4());
var ge = __toESM(require_toLower());

// node_modules/remarkable/dist/esm/index.browser.js
var textarea;
function decodeEntity(name2) {
  textarea = textarea || document.createElement("textarea");
  textarea.innerHTML = "&" + name2 + ";";
  return textarea.value;
}
function typeOf2(obj) {
  return Object.prototype.toString.call(obj);
}
function isString3(obj) {
  return typeOf2(obj) === "[object String]";
}
var hasOwn = Object.prototype.hasOwnProperty;
function has3(object2, key57) {
  return object2 ? hasOwn.call(object2, key57) : false;
}
function assign(obj) {
  var sources = [].slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key57) {
      obj[key57] = source[key57];
    });
  });
  return obj;
}
var UNESCAPE_MD_RE = /\\([\\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;
function unescapeMd(str2) {
  if (str2.indexOf("\\") < 0) {
    return str2;
  }
  return str2.replace(UNESCAPE_MD_RE, "$1");
}
function isValidEntityCode(c2) {
  if (c2 >= 55296 && c2 <= 57343) {
    return false;
  }
  if (c2 >= 64976 && c2 <= 65007) {
    return false;
  }
  if ((c2 & 65535) === 65535 || (c2 & 65535) === 65534) {
    return false;
  }
  if (c2 >= 0 && c2 <= 8) {
    return false;
  }
  if (c2 === 11) {
    return false;
  }
  if (c2 >= 14 && c2 <= 31) {
    return false;
  }
  if (c2 >= 127 && c2 <= 159) {
    return false;
  }
  if (c2 > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint(c2) {
  if (c2 > 65535) {
    c2 -= 65536;
    var surrogate1 = 55296 + (c2 >> 10), surrogate2 = 56320 + (c2 & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c2);
}
var NAMED_ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
function replaceEntityPattern(match3, name2) {
  var code2 = 0;
  var decoded = decodeEntity(name2);
  if (name2 !== decoded) {
    return decoded;
  } else if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
    code2 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint(code2);
    }
  }
  return match3;
}
function replaceEntities(str2) {
  if (str2.indexOf("&") < 0) {
    return str2;
  }
  return str2.replace(NAMED_ENTITY_RE, replaceEntityPattern);
}
var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str2) {
  if (HTML_ESCAPE_TEST_RE.test(str2)) {
    return str2.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str2;
}
var utils = Object.freeze({
  isString: isString3,
  has: has3,
  assign,
  unescapeMd,
  isValidEntityCode,
  fromCodePoint,
  replaceEntities,
  escapeHtml
});
var rules = {};
rules.blockquote_open = function() {
  return "<blockquote>\n";
};
rules.blockquote_close = function(tokens, idx) {
  return "</blockquote>" + getBreak(tokens, idx);
};
rules.code = function(tokens, idx) {
  if (tokens[idx].block) {
    return "<pre><code>" + escapeHtml(tokens[idx].content) + "</code></pre>" + getBreak(tokens, idx);
  }
  return "<code>" + escapeHtml(tokens[idx].content) + "</code>";
};
rules.fence = function(tokens, idx, options, env, instance) {
  var token = tokens[idx];
  var langClass = "";
  var langPrefix = options.langPrefix;
  var langName = "", fences2, fenceName;
  var highlighted;
  if (token.params) {
    fences2 = token.params.split(/\s+/g);
    fenceName = fences2.join(" ");
    if (has3(instance.rules.fence_custom, fences2[0])) {
      return instance.rules.fence_custom[fences2[0]](tokens, idx, options, env, instance);
    }
    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));
    langClass = ' class="' + langPrefix + langName + '"';
  }
  if (options.highlight) {
    highlighted = options.highlight.apply(options.highlight, [token.content].concat(fences2)) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  return "<pre><code" + langClass + ">" + highlighted + "</code></pre>" + getBreak(tokens, idx);
};
rules.fence_custom = {};
rules.heading_open = function(tokens, idx) {
  return "<h" + tokens[idx].hLevel + ">";
};
rules.heading_close = function(tokens, idx) {
  return "</h" + tokens[idx].hLevel + ">\n";
};
rules.hr = function(tokens, idx, options) {
  return (options.xhtmlOut ? "<hr />" : "<hr>") + getBreak(tokens, idx);
};
rules.bullet_list_open = function() {
  return "<ul>\n";
};
rules.bullet_list_close = function(tokens, idx) {
  return "</ul>" + getBreak(tokens, idx);
};
rules.list_item_open = function() {
  return "<li>";
};
rules.list_item_close = function() {
  return "</li>\n";
};
rules.ordered_list_open = function(tokens, idx) {
  var token = tokens[idx];
  var order = token.order > 1 ? ' start="' + token.order + '"' : "";
  return "<ol" + order + ">\n";
};
rules.ordered_list_close = function(tokens, idx) {
  return "</ol>" + getBreak(tokens, idx);
};
rules.paragraph_open = function(tokens, idx) {
  return tokens[idx].tight ? "" : "<p>";
};
rules.paragraph_close = function(tokens, idx) {
  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === "inline" && !tokens[idx - 1].content);
  return (tokens[idx].tight ? "" : "</p>") + (addBreak ? getBreak(tokens, idx) : "");
};
rules.link_open = function(tokens, idx, options) {
  var title = tokens[idx].title ? ' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"' : "";
  var target = options.linkTarget ? ' target="' + options.linkTarget + '"' : "";
  return '<a href="' + escapeHtml(tokens[idx].href) + '"' + title + target + ">";
};
rules.link_close = function() {
  return "</a>";
};
rules.image = function(tokens, idx, options) {
  var src = ' src="' + escapeHtml(tokens[idx].src) + '"';
  var title = tokens[idx].title ? ' title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '"' : "";
  var alt = ' alt="' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : "") + '"';
  var suffix = options.xhtmlOut ? " /" : "";
  return "<img" + src + alt + title + suffix + ">";
};
rules.table_open = function() {
  return "<table>\n";
};
rules.table_close = function() {
  return "</table>\n";
};
rules.thead_open = function() {
  return "<thead>\n";
};
rules.thead_close = function() {
  return "</thead>\n";
};
rules.tbody_open = function() {
  return "<tbody>\n";
};
rules.tbody_close = function() {
  return "</tbody>\n";
};
rules.tr_open = function() {
  return "<tr>";
};
rules.tr_close = function() {
  return "</tr>\n";
};
rules.th_open = function(tokens, idx) {
  var token = tokens[idx];
  return "<th" + (token.align ? ' style="text-align:' + token.align + '"' : "") + ">";
};
rules.th_close = function() {
  return "</th>";
};
rules.td_open = function(tokens, idx) {
  var token = tokens[idx];
  return "<td" + (token.align ? ' style="text-align:' + token.align + '"' : "") + ">";
};
rules.td_close = function() {
  return "</td>";
};
rules.strong_open = function() {
  return "<strong>";
};
rules.strong_close = function() {
  return "</strong>";
};
rules.em_open = function() {
  return "<em>";
};
rules.em_close = function() {
  return "</em>";
};
rules.del_open = function() {
  return "<del>";
};
rules.del_close = function() {
  return "</del>";
};
rules.ins_open = function() {
  return "<ins>";
};
rules.ins_close = function() {
  return "</ins>";
};
rules.mark_open = function() {
  return "<mark>";
};
rules.mark_close = function() {
  return "</mark>";
};
rules.sub = function(tokens, idx) {
  return "<sub>" + escapeHtml(tokens[idx].content) + "</sub>";
};
rules.sup = function(tokens, idx) {
  return "<sup>" + escapeHtml(tokens[idx].content) + "</sup>";
};
rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
rules.htmlblock = function(tokens, idx) {
  return tokens[idx].content;
};
rules.htmltag = function(tokens, idx) {
  return tokens[idx].content;
};
rules.abbr_open = function(tokens, idx) {
  return '<abbr title="' + escapeHtml(replaceEntities(tokens[idx].title)) + '">';
};
rules.abbr_close = function() {
  return "</abbr>";
};
rules.footnote_ref = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = "fnref" + n;
  if (tokens[idx].subId > 0) {
    id += ":" + tokens[idx].subId;
  }
  return '<sup class="footnote-ref"><a href="#fn' + n + '" id="' + id + '">[' + n + "]</a></sup>";
};
rules.footnote_block_open = function(tokens, idx, options) {
  var hr3 = options.xhtmlOut ? '<hr class="footnotes-sep" />\n' : '<hr class="footnotes-sep">\n';
  return hr3 + '<section class="footnotes">\n<ol class="footnotes-list">\n';
};
rules.footnote_block_close = function() {
  return "</ol>\n</section>\n";
};
rules.footnote_open = function(tokens, idx) {
  var id = Number(tokens[idx].id + 1).toString();
  return '<li id="fn' + id + '"  class="footnote-item">';
};
rules.footnote_close = function() {
  return "</li>\n";
};
rules.footnote_anchor = function(tokens, idx) {
  var n = Number(tokens[idx].id + 1).toString();
  var id = "fnref" + n;
  if (tokens[idx].subId > 0) {
    id += ":" + tokens[idx].subId;
  }
  return ' <a href="#' + id + '" class="footnote-backref"></a>';
};
rules.dl_open = function() {
  return "<dl>\n";
};
rules.dt_open = function() {
  return "<dt>";
};
rules.dd_open = function() {
  return "<dd>";
};
rules.dl_close = function() {
  return "</dl>\n";
};
rules.dt_close = function() {
  return "</dt>\n";
};
rules.dd_close = function() {
  return "</dd>\n";
};
function nextToken(tokens, idx) {
  if (++idx >= tokens.length - 2) {
    return idx;
  }
  if (tokens[idx].type === "paragraph_open" && tokens[idx].tight && (tokens[idx + 1].type === "inline" && tokens[idx + 1].content.length === 0) && (tokens[idx + 2].type === "paragraph_close" && tokens[idx + 2].tight)) {
    return nextToken(tokens, idx + 2);
  }
  return idx;
}
var getBreak = rules.getBreak = function getBreak2(tokens, idx) {
  idx = nextToken(tokens, idx);
  if (idx < tokens.length && tokens[idx].type === "list_item_close") {
    return "";
  }
  return "\n";
};
function Renderer() {
  this.rules = assign({}, rules);
  this.getBreak = rules.getBreak;
}
Renderer.prototype.renderInline = function(tokens, options, env) {
  var _rules2 = this.rules;
  var len = tokens.length, i2 = 0;
  var result = "";
  while (len--) {
    result += _rules2[tokens[i2].type](tokens, i2++, options, env, this);
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env) {
  var _rules2 = this.rules;
  var len = tokens.length, i2 = -1;
  var result = "";
  while (++i2 < len) {
    if (tokens[i2].type === "inline") {
      result += this.renderInline(tokens[i2].children, options, env);
    } else {
      result += _rules2[tokens[i2].type](tokens, i2, options, env, this);
    }
  }
  return result;
};
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name2) {
  var len = this.__rules__.length;
  var i2 = -1;
  while (len--) {
    if (this.__rules__[++i2].name === name2) {
      return i2;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  var self3 = this;
  var chains = [""];
  self3.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self3.__cache__ = {};
  chains.forEach(function(chain4) {
    self3.__cache__[chain4] = [];
    self3.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain4 && rule.alt.indexOf(chain4) < 0) {
        return;
      }
      self3.__cache__[chain4].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name2, fn2, options) {
  var idx = this.__find__(name2);
  var opt = options || {};
  if (idx === -1) {
    throw new Error("Parser rule not found: " + name2);
  }
  this.__rules__[idx].fn = fn2;
  this.__rules__[idx].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn2, options) {
  var idx = this.__find__(beforeName);
  var opt = options || {};
  if (idx === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(idx, 0, {
    name: ruleName,
    enabled: true,
    fn: fn2,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn2, options) {
  var idx = this.__find__(afterName);
  var opt = options || {};
  if (idx === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(idx + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn2,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn2, options) {
  var opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn2,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list4, strict) {
  list4 = !Array.isArray(list4) ? [list4] : list4;
  if (strict) {
    this.__rules__.forEach(function(rule) {
      rule.enabled = false;
    });
  }
  list4.forEach(function(name2) {
    var idx = this.__find__(name2);
    if (idx < 0) {
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = true;
  }, this);
  this.__cache__ = null;
};
Ruler.prototype.disable = function(list4) {
  list4 = !Array.isArray(list4) ? [list4] : list4;
  list4.forEach(function(name2) {
    var idx = this.__find__(name2);
    if (idx < 0) {
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = false;
  }, this);
  this.__cache__ = null;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
function block(state2) {
  if (state2.inlineMode) {
    state2.tokens.push({
      type: "inline",
      content: state2.src.replace(/\n/g, " ").trim(),
      level: 0,
      lines: [0, 1],
      children: []
    });
  } else {
    state2.block.parse(state2.src, state2.options, state2.env, state2.tokens);
  }
}
function StateInline(src, parserInline, options, env, outTokens) {
  this.src = src;
  this.env = env;
  this.options = options;
  this.parser = parserInline;
  this.tokens = outTokens;
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = [];
  this.isInLabel = false;
  this.linkLevel = 0;
  this.linkContent = "";
  this.labelUnmatchedScopes = 0;
}
StateInline.prototype.pushPending = function() {
  this.tokens.push({
    type: "text",
    content: this.pending,
    level: this.pendingLevel
  });
  this.pending = "";
};
StateInline.prototype.push = function(token) {
  if (this.pending) {
    this.pushPending();
  }
  this.tokens.push(token);
  this.pendingLevel = this.level;
};
StateInline.prototype.cacheSet = function(key57, val) {
  for (var i2 = this.cache.length; i2 <= key57; i2++) {
    this.cache.push(0);
  }
  this.cache[key57] = val;
};
StateInline.prototype.cacheGet = function(key57) {
  return key57 < this.cache.length ? this.cache[key57] : 0;
};
function parseLinkLabel(state2, start) {
  var level, found, marker, labelEnd = -1, max3 = state2.posMax, oldPos = state2.pos, oldFlag = state2.isInLabel;
  if (state2.isInLabel) {
    return -1;
  }
  if (state2.labelUnmatchedScopes) {
    state2.labelUnmatchedScopes--;
    return -1;
  }
  state2.pos = start + 1;
  state2.isInLabel = true;
  level = 1;
  while (state2.pos < max3) {
    marker = state2.src.charCodeAt(state2.pos);
    if (marker === 91) {
      level++;
    } else if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    state2.parser.skipToken(state2);
  }
  if (found) {
    labelEnd = state2.pos;
    state2.labelUnmatchedScopes = 0;
  } else {
    state2.labelUnmatchedScopes = level - 1;
  }
  state2.pos = oldPos;
  state2.isInLabel = oldFlag;
  return labelEnd;
}
function parseAbbr(str2, parserInline, options, env) {
  var state2, labelEnd, pos, max3, label, title;
  if (str2.charCodeAt(0) !== 42) {
    return -1;
  }
  if (str2.charCodeAt(1) !== 91) {
    return -1;
  }
  if (str2.indexOf("]:") === -1) {
    return -1;
  }
  state2 = new StateInline(str2, parserInline, options, env, []);
  labelEnd = parseLinkLabel(state2, 1);
  if (labelEnd < 0 || str2.charCodeAt(labelEnd + 1) !== 58) {
    return -1;
  }
  max3 = state2.posMax;
  for (pos = labelEnd + 2; pos < max3; pos++) {
    if (state2.src.charCodeAt(pos) === 10) {
      break;
    }
  }
  label = str2.slice(2, labelEnd);
  title = str2.slice(labelEnd + 2, pos).trim();
  if (title.length === 0) {
    return -1;
  }
  if (!env.abbreviations) {
    env.abbreviations = {};
  }
  if (typeof env.abbreviations[":" + label] === "undefined") {
    env.abbreviations[":" + label] = title;
  }
  return pos;
}
function abbr(state2) {
  var tokens = state2.tokens, i2, l2, content, pos;
  if (state2.inlineMode) {
    return;
  }
  for (i2 = 1, l2 = tokens.length - 1; i2 < l2; i2++) {
    if (tokens[i2 - 1].type === "paragraph_open" && tokens[i2].type === "inline" && tokens[i2 + 1].type === "paragraph_close") {
      content = tokens[i2].content;
      while (content.length) {
        pos = parseAbbr(content, state2.inline, state2.options, state2.env);
        if (pos < 0) {
          break;
        }
        content = content.slice(pos).trim();
      }
      tokens[i2].content = content;
      if (!content.length) {
        tokens[i2 - 1].tight = true;
        tokens[i2 + 1].tight = true;
      }
    }
  }
}
function normalizeLink(url) {
  var normalized = replaceEntities(url);
  try {
    normalized = decodeURI(normalized);
  } catch (err2) {
  }
  return encodeURI(normalized);
}
function parseLinkDestination(state2, pos) {
  var code2, level, link, start = pos, max3 = state2.posMax;
  if (state2.src.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max3) {
      code2 = state2.src.charCodeAt(pos);
      if (code2 === 10) {
        return false;
      }
      if (code2 === 62) {
        link = normalizeLink(unescapeMd(state2.src.slice(start + 1, pos)));
        if (!state2.parser.validateLink(link)) {
          return false;
        }
        state2.pos = pos + 1;
        state2.linkContent = link;
        return true;
      }
      if (code2 === 92 && pos + 1 < max3) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return false;
  }
  level = 0;
  while (pos < max3) {
    code2 = state2.src.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max3) {
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 1) {
        break;
      }
    }
    if (code2 === 41) {
      level--;
      if (level < 0) {
        break;
      }
    }
    pos++;
  }
  if (start === pos) {
    return false;
  }
  link = unescapeMd(state2.src.slice(start, pos));
  if (!state2.parser.validateLink(link)) {
    return false;
  }
  state2.linkContent = link;
  state2.pos = pos;
  return true;
}
function parseLinkTitle(state2, pos) {
  var code2, start = pos, max3 = state2.posMax, marker = state2.src.charCodeAt(pos);
  if (marker !== 34 && marker !== 39 && marker !== 40) {
    return false;
  }
  pos++;
  if (marker === 40) {
    marker = 41;
  }
  while (pos < max3) {
    code2 = state2.src.charCodeAt(pos);
    if (code2 === marker) {
      state2.pos = pos + 1;
      state2.linkContent = unescapeMd(state2.src.slice(start + 1, pos));
      return true;
    }
    if (code2 === 92 && pos + 1 < max3) {
      pos += 2;
      continue;
    }
    pos++;
  }
  return false;
}
function normalizeReference(str2) {
  return str2.trim().replace(/\s+/g, " ").toUpperCase();
}
function parseReference(str2, parser, options, env) {
  var state2, labelEnd, pos, max3, code2, start, href, title, label;
  if (str2.charCodeAt(0) !== 91) {
    return -1;
  }
  if (str2.indexOf("]:") === -1) {
    return -1;
  }
  state2 = new StateInline(str2, parser, options, env, []);
  labelEnd = parseLinkLabel(state2, 0);
  if (labelEnd < 0 || str2.charCodeAt(labelEnd + 1) !== 58) {
    return -1;
  }
  max3 = state2.posMax;
  for (pos = labelEnd + 2; pos < max3; pos++) {
    code2 = state2.src.charCodeAt(pos);
    if (code2 !== 32 && code2 !== 10) {
      break;
    }
  }
  if (!parseLinkDestination(state2, pos)) {
    return -1;
  }
  href = state2.linkContent;
  pos = state2.pos;
  start = pos;
  for (pos = pos + 1; pos < max3; pos++) {
    code2 = state2.src.charCodeAt(pos);
    if (code2 !== 32 && code2 !== 10) {
      break;
    }
  }
  if (pos < max3 && start !== pos && parseLinkTitle(state2, pos)) {
    title = state2.linkContent;
    pos = state2.pos;
  } else {
    title = "";
    pos = start;
  }
  while (pos < max3 && state2.src.charCodeAt(pos) === 32) {
    pos++;
  }
  if (pos < max3 && state2.src.charCodeAt(pos) !== 10) {
    return -1;
  }
  label = normalizeReference(str2.slice(1, labelEnd));
  if (typeof env.references[label] === "undefined") {
    env.references[label] = { title, href };
  }
  return pos;
}
function references(state2) {
  var tokens = state2.tokens, i2, l2, content, pos;
  state2.env.references = state2.env.references || {};
  if (state2.inlineMode) {
    return;
  }
  for (i2 = 1, l2 = tokens.length - 1; i2 < l2; i2++) {
    if (tokens[i2].type === "inline" && tokens[i2 - 1].type === "paragraph_open" && tokens[i2 + 1].type === "paragraph_close") {
      content = tokens[i2].content;
      while (content.length) {
        pos = parseReference(content, state2.inline, state2.options, state2.env);
        if (pos < 0) {
          break;
        }
        content = content.slice(pos).trim();
      }
      tokens[i2].content = content;
      if (!content.length) {
        tokens[i2 - 1].tight = true;
        tokens[i2 + 1].tight = true;
      }
    }
  }
}
function inline(state2) {
  var tokens = state2.tokens, tok, i2, l2;
  for (i2 = 0, l2 = tokens.length; i2 < l2; i2++) {
    tok = tokens[i2];
    if (tok.type === "inline") {
      state2.inline.parse(tok.content, state2.options, state2.env, tok.children);
    }
  }
}
function footnote_block(state2) {
  var i2, l2, j2, t2, lastParagraph, list4, tokens, current2, currentLabel, level = 0, insideRef = false, refTokens = {};
  if (!state2.env.footnotes) {
    return;
  }
  state2.tokens = state2.tokens.filter(function(tok) {
    if (tok.type === "footnote_reference_open") {
      insideRef = true;
      current2 = [];
      currentLabel = tok.label;
      return false;
    }
    if (tok.type === "footnote_reference_close") {
      insideRef = false;
      refTokens[":" + currentLabel] = current2;
      return false;
    }
    if (insideRef) {
      current2.push(tok);
    }
    return !insideRef;
  });
  if (!state2.env.footnotes.list) {
    return;
  }
  list4 = state2.env.footnotes.list;
  state2.tokens.push({
    type: "footnote_block_open",
    level: level++
  });
  for (i2 = 0, l2 = list4.length; i2 < l2; i2++) {
    state2.tokens.push({
      type: "footnote_open",
      id: i2,
      level: level++
    });
    if (list4[i2].tokens) {
      tokens = [];
      tokens.push({
        type: "paragraph_open",
        tight: false,
        level: level++
      });
      tokens.push({
        type: "inline",
        content: "",
        level,
        children: list4[i2].tokens
      });
      tokens.push({
        type: "paragraph_close",
        tight: false,
        level: --level
      });
    } else if (list4[i2].label) {
      tokens = refTokens[":" + list4[i2].label];
    }
    state2.tokens = state2.tokens.concat(tokens);
    if (state2.tokens[state2.tokens.length - 1].type === "paragraph_close") {
      lastParagraph = state2.tokens.pop();
    } else {
      lastParagraph = null;
    }
    t2 = list4[i2].count > 0 ? list4[i2].count : 1;
    for (j2 = 0; j2 < t2; j2++) {
      state2.tokens.push({
        type: "footnote_anchor",
        id: i2,
        subId: j2,
        level
      });
    }
    if (lastParagraph) {
      state2.tokens.push(lastParagraph);
    }
    state2.tokens.push({
      type: "footnote_close",
      level: --level
    });
  }
  state2.tokens.push({
    type: "footnote_block_close",
    level: --level
  });
}
var PUNCT_CHARS = ` 
()[]'".,!?-`;
function regEscape(s2) {
  return s2.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1");
}
function abbr2(state2) {
  var i2, j2, l2, tokens, token, text3, nodes, pos, level, reg, m2, regText, blockTokens = state2.tokens;
  if (!state2.env.abbreviations) {
    return;
  }
  if (!state2.env.abbrRegExp) {
    regText = "(^|[" + PUNCT_CHARS.split("").map(regEscape).join("") + "])(" + Object.keys(state2.env.abbreviations).map(function(x2) {
      return x2.substr(1);
    }).sort(function(a2, b) {
      return b.length - a2.length;
    }).map(regEscape).join("|") + ")($|[" + PUNCT_CHARS.split("").map(regEscape).join("") + "])";
    state2.env.abbrRegExp = new RegExp(regText, "g");
  }
  reg = state2.env.abbrRegExp;
  for (j2 = 0, l2 = blockTokens.length; j2 < l2; j2++) {
    if (blockTokens[j2].type !== "inline") {
      continue;
    }
    tokens = blockTokens[j2].children;
    for (i2 = tokens.length - 1; i2 >= 0; i2--) {
      token = tokens[i2];
      if (token.type !== "text") {
        continue;
      }
      pos = 0;
      text3 = token.content;
      reg.lastIndex = 0;
      level = token.level;
      nodes = [];
      while (m2 = reg.exec(text3)) {
        if (reg.lastIndex > pos) {
          nodes.push({
            type: "text",
            content: text3.slice(pos, m2.index + m2[1].length),
            level
          });
        }
        nodes.push({
          type: "abbr_open",
          title: state2.env.abbreviations[":" + m2[2]],
          level: level++
        });
        nodes.push({
          type: "text",
          content: m2[2],
          level
        });
        nodes.push({
          type: "abbr_close",
          level: --level
        });
        pos = reg.lastIndex - m2[3].length;
      }
      if (!nodes.length) {
        continue;
      }
      if (pos < text3.length) {
        nodes.push({
          type: "text",
          content: text3.slice(pos),
          level
        });
      }
      blockTokens[j2].children = tokens = [].concat(tokens.slice(0, i2), nodes, tokens.slice(i2 + 1));
    }
  }
}
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  "c": "",
  "r": "",
  "p": "",
  "tm": ""
};
function replaceScopedAbbr(str2) {
  if (str2.indexOf("(") < 0) {
    return str2;
  }
  return str2.replace(SCOPED_ABBR_RE, function(match3, name2) {
    return SCOPED_ABBR[name2.toLowerCase()];
  });
}
function replace4(state2) {
  var i2, token, text3, inlineTokens, blkIdx;
  if (!state2.options.typographer) {
    return;
  }
  for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline") {
      continue;
    }
    inlineTokens = state2.tokens[blkIdx].children;
    for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
      token = inlineTokens[i2];
      if (token.type === "text") {
        text3 = token.content;
        text3 = replaceScopedAbbr(text3);
        if (RARE_RE.test(text3)) {
          text3 = text3.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---([^-]|$)/mg, "$1$2").replace(/(^|\s)--(\s|$)/mg, "$1$2").replace(/(^|[^-\s])--([^-\s]|$)/mg, "$1$2");
        }
        token.content = text3;
      }
    }
  }
}
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var PUNCT_RE = /[-\s()\[\]]/;
var APOSTROPHE = "";
function isLetter(str2, pos) {
  if (pos < 0 || pos >= str2.length) {
    return false;
  }
  return !PUNCT_RE.test(str2[pos]);
}
function replaceAt(str2, index, ch) {
  return str2.substr(0, index) + ch + str2.substr(index + 1);
}
function smartquotes(state2) {
  var i2, token, text3, t2, pos, max3, thisLevel, lastSpace, nextSpace, item, canOpen, canClose, j2, isSingle, blkIdx, tokens, stack;
  if (!state2.options.typographer) {
    return;
  }
  stack = [];
  for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline") {
      continue;
    }
    tokens = state2.tokens[blkIdx].children;
    stack.length = 0;
    for (i2 = 0; i2 < tokens.length; i2++) {
      token = tokens[i2];
      if (token.type !== "text" || QUOTE_TEST_RE.test(token.text)) {
        continue;
      }
      thisLevel = tokens[i2].level;
      for (j2 = stack.length - 1; j2 >= 0; j2--) {
        if (stack[j2].level <= thisLevel) {
          break;
        }
      }
      stack.length = j2 + 1;
      text3 = token.content;
      pos = 0;
      max3 = text3.length;
      OUTER:
        while (pos < max3) {
          QUOTE_RE.lastIndex = pos;
          t2 = QUOTE_RE.exec(text3);
          if (!t2) {
            break;
          }
          lastSpace = !isLetter(text3, t2.index - 1);
          pos = t2.index + 1;
          isSingle = t2[0] === "'";
          nextSpace = !isLetter(text3, pos);
          if (!nextSpace && !lastSpace) {
            if (isSingle) {
              token.content = replaceAt(token.content, t2.index, APOSTROPHE);
            }
            continue;
          }
          canOpen = !nextSpace;
          canClose = !lastSpace;
          if (canClose) {
            for (j2 = stack.length - 1; j2 >= 0; j2--) {
              item = stack[j2];
              if (stack[j2].level < thisLevel) {
                break;
              }
              if (item.single === isSingle && stack[j2].level === thisLevel) {
                item = stack[j2];
                if (isSingle) {
                  tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state2.options.quotes[2]);
                  token.content = replaceAt(token.content, t2.index, state2.options.quotes[3]);
                } else {
                  tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state2.options.quotes[0]);
                  token.content = replaceAt(token.content, t2.index, state2.options.quotes[1]);
                }
                stack.length = j2;
                continue OUTER;
              }
            }
          }
          if (canOpen) {
            stack.push({
              token: i2,
              pos: t2.index,
              single: isSingle,
              level: thisLevel
            });
          } else if (canClose && isSingle) {
            token.content = replaceAt(token.content, t2.index, APOSTROPHE);
          }
        }
    }
  }
}
var _rules = [
  ["block", block],
  ["abbr", abbr],
  ["references", references],
  ["inline", inline],
  ["footnote_tail", footnote_block],
  ["abbr2", abbr2],
  ["replacements", replace4],
  ["smartquotes", smartquotes]
];
function Core() {
  this.options = {};
  this.ruler = new Ruler();
  for (var i2 = 0; i2 < _rules.length; i2++) {
    this.ruler.push(_rules[i2][0], _rules[i2][1]);
  }
}
Core.prototype.process = function(state2) {
  var i2, l2, rules2;
  rules2 = this.ruler.getRules("");
  for (i2 = 0, l2 = rules2.length; i2 < l2; i2++) {
    rules2[i2](state2);
  }
};
function StateBlock(src, parser, options, env, tokens) {
  var ch, s2, start, pos, len, indent, indent_found;
  this.src = src;
  this.parser = parser;
  this.options = options;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.parentType = "root";
  this.ddIndent = -1;
  this.level = 0;
  this.result = "";
  s2 = this.src;
  indent = 0;
  indent_found = false;
  for (start = pos = indent = 0, len = s2.length; pos < len; pos++) {
    ch = s2.charCodeAt(pos);
    if (!indent_found) {
      if (ch === 32) {
        indent++;
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      indent_found = false;
      indent = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s2.length);
  this.eMarks.push(s2.length);
  this.tShift.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.isEmpty = function isEmpty3(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from2) {
  for (var max3 = this.lineMax; from2 < max3; from2++) {
    if (this.bMarks[from2] + this.tShift[from2] < this.eMarks[from2]) {
      break;
    }
  }
  return from2;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (var max3 = this.src.length; pos < max3; pos++) {
    if (this.src.charCodeAt(pos) !== 32) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (var max3 = this.src.length; pos < max3; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min3) {
  if (pos <= min3) {
    return pos;
  }
  while (pos > min3) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i2, first, last2, queue, shift, line = begin;
  if (begin >= end) {
    return "";
  }
  if (line + 1 === end) {
    first = this.bMarks[line] + Math.min(this.tShift[line], indent);
    last2 = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];
    return this.src.slice(first, last2);
  }
  queue = new Array(end - begin);
  for (i2 = 0; line < end; line++, i2++) {
    shift = this.tShift[line];
    if (shift > indent) {
      shift = indent;
    }
    if (shift < 0) {
      shift = 0;
    }
    first = this.bMarks[line] + shift;
    if (line + 1 < end || keepLastLF) {
      last2 = this.eMarks[line] + 1;
    } else {
      last2 = this.eMarks[line];
    }
    queue[i2] = this.src.slice(first, last2);
  }
  return queue.join("");
};
function code(state2, startLine, endLine) {
  var nextLine, last2;
  if (state2.tShift[startLine] - state2.blkIndent < 4) {
    return false;
  }
  last2 = nextLine = startLine + 1;
  while (nextLine < endLine) {
    if (state2.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state2.tShift[nextLine] - state2.blkIndent >= 4) {
      nextLine++;
      last2 = nextLine;
      continue;
    }
    break;
  }
  state2.line = nextLine;
  state2.tokens.push({
    type: "code",
    content: state2.getLines(startLine, last2, 4 + state2.blkIndent, true),
    block: true,
    lines: [startLine, state2.line],
    level: state2.level
  });
  return true;
}
function fences(state2, startLine, endLine, silent) {
  var marker, len, params, nextLine, mem, haveEndMarker = false, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (pos + 3 > max3) {
    return false;
  }
  marker = state2.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  mem = pos;
  pos = state2.skipChars(pos, marker);
  len = pos - mem;
  if (len < 3) {
    return false;
  }
  params = state2.src.slice(pos, max3).trim();
  if (params.indexOf("`") >= 0) {
    return false;
  }
  if (silent) {
    return true;
  }
  nextLine = startLine;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max3 = state2.eMarks[nextLine];
    if (pos < max3 && state2.tShift[nextLine] < state2.blkIndent) {
      break;
    }
    if (state2.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state2.tShift[nextLine] - state2.blkIndent >= 4) {
      continue;
    }
    pos = state2.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state2.skipSpaces(pos);
    if (pos < max3) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state2.tShift[startLine];
  state2.line = nextLine + (haveEndMarker ? 1 : 0);
  state2.tokens.push({
    type: "fence",
    params,
    content: state2.getLines(startLine + 1, nextLine, len, true),
    lines: [startLine, state2.line],
    level: state2.level
  });
  return true;
}
function blockquote(state2, startLine, endLine, silent) {
  var nextLine, lastLineEmpty, oldTShift, oldBMarks, oldIndent, oldParentType, lines, terminatorRules, i2, l2, terminate, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (pos > max3) {
    return false;
  }
  if (state2.src.charCodeAt(pos++) !== 62) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (state2.src.charCodeAt(pos) === 32) {
    pos++;
  }
  oldIndent = state2.blkIndent;
  state2.blkIndent = 0;
  oldBMarks = [state2.bMarks[startLine]];
  state2.bMarks[startLine] = pos;
  pos = pos < max3 ? state2.skipSpaces(pos) : pos;
  lastLineEmpty = pos >= max3;
  oldTShift = [state2.tShift[startLine]];
  state2.tShift[startLine] = pos - state2.bMarks[startLine];
  terminatorRules = state2.parser.ruler.getRules("blockquote");
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max3 = state2.eMarks[nextLine];
    if (pos >= max3) {
      break;
    }
    if (state2.src.charCodeAt(pos++) === 62) {
      if (state2.src.charCodeAt(pos) === 32) {
        pos++;
      }
      oldBMarks.push(state2.bMarks[nextLine]);
      state2.bMarks[nextLine] = pos;
      pos = pos < max3 ? state2.skipSpaces(pos) : pos;
      lastLineEmpty = pos >= max3;
      oldTShift.push(state2.tShift[nextLine]);
      state2.tShift[nextLine] = pos - state2.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    terminate = false;
    for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
      if (terminatorRules[i2](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    oldBMarks.push(state2.bMarks[nextLine]);
    oldTShift.push(state2.tShift[nextLine]);
    state2.tShift[nextLine] = -1337;
  }
  oldParentType = state2.parentType;
  state2.parentType = "blockquote";
  state2.tokens.push({
    type: "blockquote_open",
    lines: lines = [startLine, 0],
    level: state2.level++
  });
  state2.parser.tokenize(state2, startLine, nextLine);
  state2.tokens.push({
    type: "blockquote_close",
    level: --state2.level
  });
  state2.parentType = oldParentType;
  lines[1] = state2.line;
  for (i2 = 0; i2 < oldTShift.length; i2++) {
    state2.bMarks[i2 + startLine] = oldBMarks[i2];
    state2.tShift[i2 + startLine] = oldTShift[i2];
  }
  state2.blkIndent = oldIndent;
  return true;
}
function hr(state2, startLine, endLine, silent) {
  var marker, cnt, ch, pos = state2.bMarks[startLine], max3 = state2.eMarks[startLine];
  pos += state2.tShift[startLine];
  if (pos > max3) {
    return false;
  }
  marker = state2.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  cnt = 1;
  while (pos < max3) {
    ch = state2.src.charCodeAt(pos++);
    if (ch !== marker && ch !== 32) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state2.line = startLine + 1;
  state2.tokens.push({
    type: "hr",
    lines: [startLine, state2.line],
    level: state2.level
  });
  return true;
}
function skipBulletListMarker(state2, startLine) {
  var marker, pos, max3;
  pos = state2.bMarks[startLine] + state2.tShift[startLine];
  max3 = state2.eMarks[startLine];
  if (pos >= max3) {
    return -1;
  }
  marker = state2.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max3 && state2.src.charCodeAt(pos) !== 32) {
    return -1;
  }
  return pos;
}
function skipOrderedListMarker(state2, startLine) {
  var ch, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (pos + 1 >= max3) {
    return -1;
  }
  ch = state2.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max3) {
      return -1;
    }
    ch = state2.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max3 && state2.src.charCodeAt(pos) !== 32) {
    return -1;
  }
  return pos;
}
function markTightParagraphs(state2, idx) {
  var i2, l2, level = state2.level + 2;
  for (i2 = idx + 2, l2 = state2.tokens.length - 2; i2 < l2; i2++) {
    if (state2.tokens[i2].level === level && state2.tokens[i2].type === "paragraph_open") {
      state2.tokens[i2 + 2].tight = true;
      state2.tokens[i2].tight = true;
      i2 += 2;
    }
  }
}
function list2(state2, startLine, endLine, silent) {
  var nextLine, indent, oldTShift, oldIndent, oldTight, oldParentType, start, posAfterMarker, max3, indentAfterMarker, markerValue, markerCharCode, isOrdered, contentStart, listTokIdx, prevEmptyEnd, listLines, itemLines, tight = true, terminatorRules, i2, l2, terminate;
  if ((posAfterMarker = skipOrderedListMarker(state2, startLine)) >= 0) {
    isOrdered = true;
  } else if ((posAfterMarker = skipBulletListMarker(state2, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  markerCharCode = state2.src.charCodeAt(posAfterMarker - 1);
  if (silent) {
    return true;
  }
  listTokIdx = state2.tokens.length;
  if (isOrdered) {
    start = state2.bMarks[startLine] + state2.tShift[startLine];
    markerValue = Number(state2.src.substr(start, posAfterMarker - start - 1));
    state2.tokens.push({
      type: "ordered_list_open",
      order: markerValue,
      lines: listLines = [startLine, 0],
      level: state2.level++
    });
  } else {
    state2.tokens.push({
      type: "bullet_list_open",
      lines: listLines = [startLine, 0],
      level: state2.level++
    });
  }
  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state2.parser.ruler.getRules("list");
  while (nextLine < endLine) {
    contentStart = state2.skipSpaces(posAfterMarker);
    max3 = state2.eMarks[nextLine];
    if (contentStart >= max3) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = contentStart - posAfterMarker;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    if (indentAfterMarker < 1) {
      indentAfterMarker = 1;
    }
    indent = posAfterMarker - state2.bMarks[nextLine] + indentAfterMarker;
    state2.tokens.push({
      type: "list_item_open",
      lines: itemLines = [startLine, 0],
      level: state2.level++
    });
    oldIndent = state2.blkIndent;
    oldTight = state2.tight;
    oldTShift = state2.tShift[startLine];
    oldParentType = state2.parentType;
    state2.tShift[startLine] = contentStart - state2.bMarks[startLine];
    state2.blkIndent = indent;
    state2.tight = true;
    state2.parentType = "list";
    state2.parser.tokenize(state2, startLine, endLine, true);
    if (!state2.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state2.line - startLine > 1 && state2.isEmpty(state2.line - 1);
    state2.blkIndent = oldIndent;
    state2.tShift[startLine] = oldTShift;
    state2.tight = oldTight;
    state2.parentType = oldParentType;
    state2.tokens.push({
      type: "list_item_close",
      level: --state2.level
    });
    nextLine = startLine = state2.line;
    itemLines[1] = nextLine;
    contentStart = state2.bMarks[startLine];
    if (nextLine >= endLine) {
      break;
    }
    if (state2.isEmpty(nextLine)) {
      break;
    }
    if (state2.tShift[nextLine] < state2.blkIndent) {
      break;
    }
    terminate = false;
    for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
      if (terminatorRules[i2](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state2.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  state2.tokens.push({
    type: isOrdered ? "ordered_list_close" : "bullet_list_close",
    level: --state2.level
  });
  listLines[1] = nextLine;
  state2.line = nextLine;
  if (tight) {
    markTightParagraphs(state2, listTokIdx);
  }
  return true;
}
function footnote(state2, startLine, endLine, silent) {
  var oldBMark, oldTShift, oldParentType, pos, label, start = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (start + 4 > max3) {
    return false;
  }
  if (state2.src.charCodeAt(start) !== 91) {
    return false;
  }
  if (state2.src.charCodeAt(start + 1) !== 94) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  for (pos = start + 2; pos < max3; pos++) {
    if (state2.src.charCodeAt(pos) === 32) {
      return false;
    }
    if (state2.src.charCodeAt(pos) === 93) {
      break;
    }
  }
  if (pos === start + 2) {
    return false;
  }
  if (pos + 1 >= max3 || state2.src.charCodeAt(++pos) !== 58) {
    return false;
  }
  if (silent) {
    return true;
  }
  pos++;
  if (!state2.env.footnotes) {
    state2.env.footnotes = {};
  }
  if (!state2.env.footnotes.refs) {
    state2.env.footnotes.refs = {};
  }
  label = state2.src.slice(start + 2, pos - 2);
  state2.env.footnotes.refs[":" + label] = -1;
  state2.tokens.push({
    type: "footnote_reference_open",
    label,
    level: state2.level++
  });
  oldBMark = state2.bMarks[startLine];
  oldTShift = state2.tShift[startLine];
  oldParentType = state2.parentType;
  state2.tShift[startLine] = state2.skipSpaces(pos) - pos;
  state2.bMarks[startLine] = pos;
  state2.blkIndent += 4;
  state2.parentType = "footnote";
  if (state2.tShift[startLine] < state2.blkIndent) {
    state2.tShift[startLine] += state2.blkIndent;
    state2.bMarks[startLine] -= state2.blkIndent;
  }
  state2.parser.tokenize(state2, startLine, endLine, true);
  state2.parentType = oldParentType;
  state2.blkIndent -= 4;
  state2.tShift[startLine] = oldTShift;
  state2.bMarks[startLine] = oldBMark;
  state2.tokens.push({
    type: "footnote_reference_close",
    level: --state2.level
  });
  return true;
}
function heading(state2, startLine, endLine, silent) {
  var ch, level, tmp, pos = state2.bMarks[startLine] + state2.tShift[startLine], max3 = state2.eMarks[startLine];
  if (pos >= max3) {
    return false;
  }
  ch = state2.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max3) {
    return false;
  }
  level = 1;
  ch = state2.src.charCodeAt(++pos);
  while (ch === 35 && pos < max3 && level <= 6) {
    level++;
    ch = state2.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max3 && ch !== 32) {
    return false;
  }
  if (silent) {
    return true;
  }
  max3 = state2.skipCharsBack(max3, 32, pos);
  tmp = state2.skipCharsBack(max3, 35, pos);
  if (tmp > pos && state2.src.charCodeAt(tmp - 1) === 32) {
    max3 = tmp;
  }
  state2.line = startLine + 1;
  state2.tokens.push({
    type: "heading_open",
    hLevel: level,
    lines: [startLine, state2.line],
    level: state2.level
  });
  if (pos < max3) {
    state2.tokens.push({
      type: "inline",
      content: state2.src.slice(pos, max3).trim(),
      level: state2.level + 1,
      lines: [startLine, state2.line],
      children: []
    });
  }
  state2.tokens.push({ type: "heading_close", hLevel: level, level: state2.level });
  return true;
}
function lheading(state2, startLine, endLine) {
  var marker, pos, max3, next = startLine + 1;
  if (next >= endLine) {
    return false;
  }
  if (state2.tShift[next] < state2.blkIndent) {
    return false;
  }
  if (state2.tShift[next] - state2.blkIndent > 3) {
    return false;
  }
  pos = state2.bMarks[next] + state2.tShift[next];
  max3 = state2.eMarks[next];
  if (pos >= max3) {
    return false;
  }
  marker = state2.src.charCodeAt(pos);
  if (marker !== 45 && marker !== 61) {
    return false;
  }
  pos = state2.skipChars(pos, marker);
  pos = state2.skipSpaces(pos);
  if (pos < max3) {
    return false;
  }
  pos = state2.bMarks[startLine] + state2.tShift[startLine];
  state2.line = next + 1;
  state2.tokens.push({
    type: "heading_open",
    hLevel: marker === 61 ? 1 : 2,
    lines: [startLine, state2.line],
    level: state2.level
  });
  state2.tokens.push({
    type: "inline",
    content: state2.src.slice(pos, state2.eMarks[startLine]).trim(),
    level: state2.level + 1,
    lines: [startLine, state2.line - 1],
    children: []
  });
  state2.tokens.push({
    type: "heading_close",
    hLevel: marker === 61 ? 1 : 2,
    level: state2.level
  });
  return true;
}
var html_blocks = {};
[
  "article",
  "aside",
  "button",
  "blockquote",
  "body",
  "canvas",
  "caption",
  "col",
  "colgroup",
  "dd",
  "div",
  "dl",
  "dt",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "hr",
  "iframe",
  "li",
  "map",
  "object",
  "ol",
  "output",
  "p",
  "pre",
  "progress",
  "script",
  "section",
  "style",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "tr",
  "thead",
  "ul",
  "video"
].forEach(function(name2) {
  html_blocks[name2] = true;
});
var HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\s\/>]/;
var HTML_TAG_CLOSE_RE = /^<\/([a-zA-Z]{1,15})[\s>]/;
function isLetter$1(ch) {
  var lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function htmlblock(state2, startLine, endLine, silent) {
  var ch, match3, nextLine, pos = state2.bMarks[startLine], max3 = state2.eMarks[startLine], shift = state2.tShift[startLine];
  pos += shift;
  if (!state2.options.html) {
    return false;
  }
  if (shift > 3 || pos + 2 >= max3) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  ch = state2.src.charCodeAt(pos + 1);
  if (ch === 33 || ch === 63) {
    if (silent) {
      return true;
    }
  } else if (ch === 47 || isLetter$1(ch)) {
    if (ch === 47) {
      match3 = state2.src.slice(pos, max3).match(HTML_TAG_CLOSE_RE);
      if (!match3) {
        return false;
      }
    } else {
      match3 = state2.src.slice(pos, max3).match(HTML_TAG_OPEN_RE);
      if (!match3) {
        return false;
      }
    }
    if (html_blocks[match3[1].toLowerCase()] !== true) {
      return false;
    }
    if (silent) {
      return true;
    }
  } else {
    return false;
  }
  nextLine = startLine + 1;
  while (nextLine < state2.lineMax && !state2.isEmpty(nextLine)) {
    nextLine++;
  }
  state2.line = nextLine;
  state2.tokens.push({
    type: "htmlblock",
    level: state2.level,
    lines: [startLine, state2.line],
    content: state2.getLines(startLine, nextLine, 0, true)
  });
  return true;
}
function getLine2(state2, line) {
  var pos = state2.bMarks[line] + state2.blkIndent, max3 = state2.eMarks[line];
  return state2.src.substr(pos, max3 - pos);
}
function table(state2, startLine, endLine, silent) {
  var ch, lineText, pos, i2, nextLine, rows, cell, aligns, t2, tableLines, tbodyLines;
  if (startLine + 2 > endLine) {
    return false;
  }
  nextLine = startLine + 1;
  if (state2.tShift[nextLine] < state2.blkIndent) {
    return false;
  }
  pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
  if (pos >= state2.eMarks[nextLine]) {
    return false;
  }
  ch = state2.src.charCodeAt(pos);
  if (ch !== 124 && ch !== 45 && ch !== 58) {
    return false;
  }
  lineText = getLine2(state2, startLine + 1);
  if (!/^[-:| ]+$/.test(lineText)) {
    return false;
  }
  rows = lineText.split("|");
  if (rows <= 2) {
    return false;
  }
  aligns = [];
  for (i2 = 0; i2 < rows.length; i2++) {
    t2 = rows[i2].trim();
    if (!t2) {
      if (i2 === 0 || i2 === rows.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t2)) {
      return false;
    }
    if (t2.charCodeAt(t2.length - 1) === 58) {
      aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t2.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine2(state2, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  rows = lineText.replace(/^\||\|$/g, "").split("|");
  if (aligns.length !== rows.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  state2.tokens.push({
    type: "table_open",
    lines: tableLines = [startLine, 0],
    level: state2.level++
  });
  state2.tokens.push({
    type: "thead_open",
    lines: [startLine, startLine + 1],
    level: state2.level++
  });
  state2.tokens.push({
    type: "tr_open",
    lines: [startLine, startLine + 1],
    level: state2.level++
  });
  for (i2 = 0; i2 < rows.length; i2++) {
    state2.tokens.push({
      type: "th_open",
      align: aligns[i2],
      lines: [startLine, startLine + 1],
      level: state2.level++
    });
    state2.tokens.push({
      type: "inline",
      content: rows[i2].trim(),
      lines: [startLine, startLine + 1],
      level: state2.level,
      children: []
    });
    state2.tokens.push({ type: "th_close", level: --state2.level });
  }
  state2.tokens.push({ type: "tr_close", level: --state2.level });
  state2.tokens.push({ type: "thead_close", level: --state2.level });
  state2.tokens.push({
    type: "tbody_open",
    lines: tbodyLines = [startLine + 2, 0],
    level: state2.level++
  });
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state2.tShift[nextLine] < state2.blkIndent) {
      break;
    }
    lineText = getLine2(state2, nextLine).trim();
    if (lineText.indexOf("|") === -1) {
      break;
    }
    rows = lineText.replace(/^\||\|$/g, "").split("|");
    state2.tokens.push({ type: "tr_open", level: state2.level++ });
    for (i2 = 0; i2 < rows.length; i2++) {
      state2.tokens.push({ type: "td_open", align: aligns[i2], level: state2.level++ });
      cell = rows[i2].substring(
        rows[i2].charCodeAt(0) === 124 ? 1 : 0,
        rows[i2].charCodeAt(rows[i2].length - 1) === 124 ? rows[i2].length - 1 : rows[i2].length
      ).trim();
      state2.tokens.push({
        type: "inline",
        content: cell,
        level: state2.level,
        children: []
      });
      state2.tokens.push({ type: "td_close", level: --state2.level });
    }
    state2.tokens.push({ type: "tr_close", level: --state2.level });
  }
  state2.tokens.push({ type: "tbody_close", level: --state2.level });
  state2.tokens.push({ type: "table_close", level: --state2.level });
  tableLines[1] = tbodyLines[1] = nextLine;
  state2.line = nextLine;
  return true;
}
function skipMarker(state2, line) {
  var pos, marker, start = state2.bMarks[line] + state2.tShift[line], max3 = state2.eMarks[line];
  if (start >= max3) {
    return -1;
  }
  marker = state2.src.charCodeAt(start++);
  if (marker !== 126 && marker !== 58) {
    return -1;
  }
  pos = state2.skipSpaces(start);
  if (start === pos) {
    return -1;
  }
  if (pos >= max3) {
    return -1;
  }
  return pos;
}
function markTightParagraphs$1(state2, idx) {
  var i2, l2, level = state2.level + 2;
  for (i2 = idx + 2, l2 = state2.tokens.length - 2; i2 < l2; i2++) {
    if (state2.tokens[i2].level === level && state2.tokens[i2].type === "paragraph_open") {
      state2.tokens[i2 + 2].tight = true;
      state2.tokens[i2].tight = true;
      i2 += 2;
    }
  }
}
function deflist(state2, startLine, endLine, silent) {
  var contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, nextLine, oldIndent, oldDDIndent, oldParentType, oldTShift, oldTight, prevEmptyEnd, tight;
  if (silent) {
    if (state2.ddIndent < 0) {
      return false;
    }
    return skipMarker(state2, startLine) >= 0;
  }
  nextLine = startLine + 1;
  if (state2.isEmpty(nextLine)) {
    if (++nextLine > endLine) {
      return false;
    }
  }
  if (state2.tShift[nextLine] < state2.blkIndent) {
    return false;
  }
  contentStart = skipMarker(state2, nextLine);
  if (contentStart < 0) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  listTokIdx = state2.tokens.length;
  state2.tokens.push({
    type: "dl_open",
    lines: listLines = [startLine, 0],
    level: state2.level++
  });
  dtLine = startLine;
  ddLine = nextLine;
  OUTER:
    for (; ; ) {
      tight = true;
      prevEmptyEnd = false;
      state2.tokens.push({
        type: "dt_open",
        lines: [dtLine, dtLine],
        level: state2.level++
      });
      state2.tokens.push({
        type: "inline",
        content: state2.getLines(dtLine, dtLine + 1, state2.blkIndent, false).trim(),
        level: state2.level + 1,
        lines: [dtLine, dtLine],
        children: []
      });
      state2.tokens.push({
        type: "dt_close",
        level: --state2.level
      });
      for (; ; ) {
        state2.tokens.push({
          type: "dd_open",
          lines: itemLines = [nextLine, 0],
          level: state2.level++
        });
        oldTight = state2.tight;
        oldDDIndent = state2.ddIndent;
        oldIndent = state2.blkIndent;
        oldTShift = state2.tShift[ddLine];
        oldParentType = state2.parentType;
        state2.blkIndent = state2.ddIndent = state2.tShift[ddLine] + 2;
        state2.tShift[ddLine] = contentStart - state2.bMarks[ddLine];
        state2.tight = true;
        state2.parentType = "deflist";
        state2.parser.tokenize(state2, ddLine, endLine, true);
        if (!state2.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state2.line - ddLine > 1 && state2.isEmpty(state2.line - 1);
        state2.tShift[ddLine] = oldTShift;
        state2.tight = oldTight;
        state2.parentType = oldParentType;
        state2.blkIndent = oldIndent;
        state2.ddIndent = oldDDIndent;
        state2.tokens.push({
          type: "dd_close",
          level: --state2.level
        });
        itemLines[1] = nextLine = state2.line;
        if (nextLine >= endLine) {
          break OUTER;
        }
        if (state2.tShift[nextLine] < state2.blkIndent) {
          break OUTER;
        }
        contentStart = skipMarker(state2, nextLine);
        if (contentStart < 0) {
          break;
        }
        ddLine = nextLine;
      }
      if (nextLine >= endLine) {
        break;
      }
      dtLine = nextLine;
      if (state2.isEmpty(dtLine)) {
        break;
      }
      if (state2.tShift[dtLine] < state2.blkIndent) {
        break;
      }
      ddLine = dtLine + 1;
      if (ddLine >= endLine) {
        break;
      }
      if (state2.isEmpty(ddLine)) {
        ddLine++;
      }
      if (ddLine >= endLine) {
        break;
      }
      if (state2.tShift[ddLine] < state2.blkIndent) {
        break;
      }
      contentStart = skipMarker(state2, ddLine);
      if (contentStart < 0) {
        break;
      }
    }
  state2.tokens.push({
    type: "dl_close",
    level: --state2.level
  });
  listLines[1] = nextLine;
  state2.line = nextLine;
  if (tight) {
    markTightParagraphs$1(state2, listTokIdx);
  }
  return true;
}
function paragraph(state2, startLine) {
  var endLine, content, terminate, i2, l2, nextLine = startLine + 1, terminatorRules;
  endLine = state2.lineMax;
  if (nextLine < endLine && !state2.isEmpty(nextLine)) {
    terminatorRules = state2.parser.ruler.getRules("paragraph");
    for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
      if (state2.tShift[nextLine] - state2.blkIndent > 3) {
        continue;
      }
      terminate = false;
      for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
        if (terminatorRules[i2](state2, nextLine, endLine, true)) {
          terminate = true;
          break;
        }
      }
      if (terminate) {
        break;
      }
    }
  }
  content = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  state2.line = nextLine;
  if (content.length) {
    state2.tokens.push({
      type: "paragraph_open",
      tight: false,
      lines: [startLine, state2.line],
      level: state2.level
    });
    state2.tokens.push({
      type: "inline",
      content,
      level: state2.level + 1,
      lines: [startLine, state2.line],
      children: []
    });
    state2.tokens.push({
      type: "paragraph_close",
      tight: false,
      level: state2.level
    });
  }
  return true;
}
var _rules$1 = [
  ["code", code],
  ["fences", fences, ["paragraph", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "blockquote", "list"]],
  ["list", list2, ["paragraph", "blockquote"]],
  ["footnote", footnote, ["paragraph"]],
  ["heading", heading, ["paragraph", "blockquote"]],
  ["lheading", lheading],
  ["htmlblock", htmlblock, ["paragraph", "blockquote"]],
  ["table", table, ["paragraph"]],
  ["deflist", deflist, ["paragraph"]],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new Ruler();
  for (var i2 = 0; i2 < _rules$1.length; i2++) {
    this.ruler.push(_rules$1[i2][0], _rules$1[i2][1], {
      alt: (_rules$1[i2][2] || []).slice()
    });
  }
}
ParserBlock.prototype.tokenize = function(state2, startLine, endLine) {
  var rules2 = this.ruler.getRules("");
  var len = rules2.length;
  var line = startLine;
  var hasEmptyLines = false;
  var ok, i2;
  while (line < endLine) {
    state2.line = line = state2.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state2.tShift[line] < state2.blkIndent) {
      break;
    }
    for (i2 = 0; i2 < len; i2++) {
      ok = rules2[i2](state2, line, endLine, false);
      if (ok) {
        break;
      }
    }
    state2.tight = !hasEmptyLines;
    if (state2.isEmpty(state2.line - 1)) {
      hasEmptyLines = true;
    }
    line = state2.line;
    if (line < endLine && state2.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      if (line < endLine && state2.parentType === "list" && state2.isEmpty(line)) {
        break;
      }
      state2.line = line;
    }
  }
};
var TABS_SCAN_RE = /[\n\t]/g;
var NEWLINES_RE = /\r[\n\u0085]|[\u2424\u2028\u0085]/g;
var SPACES_RE = /\u00a0/g;
ParserBlock.prototype.parse = function(str2, options, env, outTokens) {
  var state2, lineStart = 0, lastTabPos = 0;
  if (!str2) {
    return [];
  }
  str2 = str2.replace(SPACES_RE, " ");
  str2 = str2.replace(NEWLINES_RE, "\n");
  if (str2.indexOf("	") >= 0) {
    str2 = str2.replace(TABS_SCAN_RE, function(match3, offset) {
      var result;
      if (str2.charCodeAt(offset) === 10) {
        lineStart = offset + 1;
        lastTabPos = 0;
        return match3;
      }
      result = "    ".slice((offset - lineStart - lastTabPos) % 4);
      lastTabPos = offset - lineStart + 1;
      return result;
    });
  }
  state2 = new StateBlock(str2, this, options, env, outTokens);
  this.tokenize(state2, state2.line, state2.lineMax);
};
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 92:
    case 96:
    case 42:
    case 95:
    case 94:
    case 91:
    case 93:
    case 33:
    case 38:
    case 60:
    case 62:
    case 123:
    case 125:
    case 36:
    case 37:
    case 64:
    case 126:
    case 43:
    case 61:
    case 58:
      return true;
    default:
      return false;
  }
}
function text(state2, silent) {
  var pos = state2.pos;
  while (pos < state2.posMax && !isTerminatorChar(state2.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state2.pos) {
    return false;
  }
  if (!silent) {
    state2.pending += state2.src.slice(state2.pos, pos);
  }
  state2.pos = pos;
  return true;
}
function newline(state2, silent) {
  var pmax, max3, pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 10) {
    return false;
  }
  pmax = state2.pending.length - 1;
  max3 = state2.posMax;
  if (!silent) {
    if (pmax >= 0 && state2.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state2.pending.charCodeAt(pmax - 1) === 32) {
        for (var i2 = pmax - 2; i2 >= 0; i2--) {
          if (state2.pending.charCodeAt(i2) !== 32) {
            state2.pending = state2.pending.substring(0, i2 + 1);
            break;
          }
        }
        state2.push({
          type: "hardbreak",
          level: state2.level
        });
      } else {
        state2.pending = state2.pending.slice(0, -1);
        state2.push({
          type: "softbreak",
          level: state2.level
        });
      }
    } else {
      state2.push({
        type: "softbreak",
        level: state2.level
      });
    }
  }
  pos++;
  while (pos < max3 && state2.src.charCodeAt(pos) === 32) {
    pos++;
  }
  state2.pos = pos;
  return true;
}
var ESCAPED = [];
for (i2 = 0; i2 < 256; i2++) {
  ESCAPED.push(0);
}
var i2;
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape2(state2, silent) {
  var ch, pos = state2.pos, max3 = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 92) {
    return false;
  }
  pos++;
  if (pos < max3) {
    ch = state2.src.charCodeAt(pos);
    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state2.pending += state2.src[pos];
      }
      state2.pos += 2;
      return true;
    }
    if (ch === 10) {
      if (!silent) {
        state2.push({
          type: "hardbreak",
          level: state2.level
        });
      }
      pos++;
      while (pos < max3 && state2.src.charCodeAt(pos) === 32) {
        pos++;
      }
      state2.pos = pos;
      return true;
    }
  }
  if (!silent) {
    state2.pending += "\\";
  }
  state2.pos++;
  return true;
}
function backticks(state2, silent) {
  var start, max3, marker, matchStart, matchEnd, pos = state2.pos, ch = state2.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  start = pos;
  pos++;
  max3 = state2.posMax;
  while (pos < max3 && state2.src.charCodeAt(pos) === 96) {
    pos++;
  }
  marker = state2.src.slice(start, pos);
  matchStart = matchEnd = pos;
  while ((matchStart = state2.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max3 && state2.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        state2.push({
          type: "code",
          content: state2.src.slice(pos, matchStart).replace(/[ \n]+/g, " ").trim(),
          block: false,
          level: state2.level
        });
      }
      state2.pos = matchEnd;
      return true;
    }
  }
  if (!silent) {
    state2.pending += marker;
  }
  state2.pos += marker.length;
  return true;
}
function del(state2, silent) {
  var found, pos, stack, max3 = state2.posMax, start = state2.pos, lastChar, nextChar;
  if (state2.src.charCodeAt(start) !== 126) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 4 >= max3) {
    return false;
  }
  if (state2.src.charCodeAt(start + 1) !== 126) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  lastChar = start > 0 ? state2.src.charCodeAt(start - 1) : -1;
  nextChar = state2.src.charCodeAt(start + 2);
  if (lastChar === 126) {
    return false;
  }
  if (nextChar === 126) {
    return false;
  }
  if (nextChar === 32 || nextChar === 10) {
    return false;
  }
  pos = start + 2;
  while (pos < max3 && state2.src.charCodeAt(pos) === 126) {
    pos++;
  }
  if (pos > start + 3) {
    state2.pos += pos - start;
    if (!silent) {
      state2.pending += state2.src.slice(start, pos);
    }
    return true;
  }
  state2.pos = start + 2;
  stack = 1;
  while (state2.pos + 1 < max3) {
    if (state2.src.charCodeAt(state2.pos) === 126) {
      if (state2.src.charCodeAt(state2.pos + 1) === 126) {
        lastChar = state2.src.charCodeAt(state2.pos - 1);
        nextChar = state2.pos + 2 < max3 ? state2.src.charCodeAt(state2.pos + 2) : -1;
        if (nextChar !== 126 && lastChar !== 126) {
          if (lastChar !== 32 && lastChar !== 10) {
            stack--;
          } else if (nextChar !== 32 && nextChar !== 10) {
            stack++;
          }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }
    state2.parser.skipToken(state2);
  }
  if (!found) {
    state2.pos = start;
    return false;
  }
  state2.posMax = state2.pos;
  state2.pos = start + 2;
  if (!silent) {
    state2.push({ type: "del_open", level: state2.level++ });
    state2.parser.tokenize(state2);
    state2.push({ type: "del_close", level: --state2.level });
  }
  state2.pos = state2.posMax + 2;
  state2.posMax = max3;
  return true;
}
function ins(state2, silent) {
  var found, pos, stack, max3 = state2.posMax, start = state2.pos, lastChar, nextChar;
  if (state2.src.charCodeAt(start) !== 43) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 4 >= max3) {
    return false;
  }
  if (state2.src.charCodeAt(start + 1) !== 43) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  lastChar = start > 0 ? state2.src.charCodeAt(start - 1) : -1;
  nextChar = state2.src.charCodeAt(start + 2);
  if (lastChar === 43) {
    return false;
  }
  if (nextChar === 43) {
    return false;
  }
  if (nextChar === 32 || nextChar === 10) {
    return false;
  }
  pos = start + 2;
  while (pos < max3 && state2.src.charCodeAt(pos) === 43) {
    pos++;
  }
  if (pos !== start + 2) {
    state2.pos += pos - start;
    if (!silent) {
      state2.pending += state2.src.slice(start, pos);
    }
    return true;
  }
  state2.pos = start + 2;
  stack = 1;
  while (state2.pos + 1 < max3) {
    if (state2.src.charCodeAt(state2.pos) === 43) {
      if (state2.src.charCodeAt(state2.pos + 1) === 43) {
        lastChar = state2.src.charCodeAt(state2.pos - 1);
        nextChar = state2.pos + 2 < max3 ? state2.src.charCodeAt(state2.pos + 2) : -1;
        if (nextChar !== 43 && lastChar !== 43) {
          if (lastChar !== 32 && lastChar !== 10) {
            stack--;
          } else if (nextChar !== 32 && nextChar !== 10) {
            stack++;
          }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }
    state2.parser.skipToken(state2);
  }
  if (!found) {
    state2.pos = start;
    return false;
  }
  state2.posMax = state2.pos;
  state2.pos = start + 2;
  if (!silent) {
    state2.push({ type: "ins_open", level: state2.level++ });
    state2.parser.tokenize(state2);
    state2.push({ type: "ins_close", level: --state2.level });
  }
  state2.pos = state2.posMax + 2;
  state2.posMax = max3;
  return true;
}
function mark(state2, silent) {
  var found, pos, stack, max3 = state2.posMax, start = state2.pos, lastChar, nextChar;
  if (state2.src.charCodeAt(start) !== 61) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 4 >= max3) {
    return false;
  }
  if (state2.src.charCodeAt(start + 1) !== 61) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  lastChar = start > 0 ? state2.src.charCodeAt(start - 1) : -1;
  nextChar = state2.src.charCodeAt(start + 2);
  if (lastChar === 61) {
    return false;
  }
  if (nextChar === 61) {
    return false;
  }
  if (nextChar === 32 || nextChar === 10) {
    return false;
  }
  pos = start + 2;
  while (pos < max3 && state2.src.charCodeAt(pos) === 61) {
    pos++;
  }
  if (pos !== start + 2) {
    state2.pos += pos - start;
    if (!silent) {
      state2.pending += state2.src.slice(start, pos);
    }
    return true;
  }
  state2.pos = start + 2;
  stack = 1;
  while (state2.pos + 1 < max3) {
    if (state2.src.charCodeAt(state2.pos) === 61) {
      if (state2.src.charCodeAt(state2.pos + 1) === 61) {
        lastChar = state2.src.charCodeAt(state2.pos - 1);
        nextChar = state2.pos + 2 < max3 ? state2.src.charCodeAt(state2.pos + 2) : -1;
        if (nextChar !== 61 && lastChar !== 61) {
          if (lastChar !== 32 && lastChar !== 10) {
            stack--;
          } else if (nextChar !== 32 && nextChar !== 10) {
            stack++;
          }
          if (stack <= 0) {
            found = true;
            break;
          }
        }
      }
    }
    state2.parser.skipToken(state2);
  }
  if (!found) {
    state2.pos = start;
    return false;
  }
  state2.posMax = state2.pos;
  state2.pos = start + 2;
  if (!silent) {
    state2.push({ type: "mark_open", level: state2.level++ });
    state2.parser.tokenize(state2);
    state2.push({ type: "mark_close", level: --state2.level });
  }
  state2.pos = state2.posMax + 2;
  state2.posMax = max3;
  return true;
}
function isAlphaNum(code2) {
  return code2 >= 48 && code2 <= 57 || code2 >= 65 && code2 <= 90 || code2 >= 97 && code2 <= 122;
}
function scanDelims(state2, start) {
  var pos = start, lastChar, nextChar, count2, can_open = true, can_close = true, max3 = state2.posMax, marker = state2.src.charCodeAt(start);
  lastChar = start > 0 ? state2.src.charCodeAt(start - 1) : -1;
  while (pos < max3 && state2.src.charCodeAt(pos) === marker) {
    pos++;
  }
  if (pos >= max3) {
    can_open = false;
  }
  count2 = pos - start;
  if (count2 >= 4) {
    can_open = can_close = false;
  } else {
    nextChar = pos < max3 ? state2.src.charCodeAt(pos) : -1;
    if (nextChar === 32 || nextChar === 10) {
      can_open = false;
    }
    if (lastChar === 32 || lastChar === 10) {
      can_close = false;
    }
    if (marker === 95) {
      if (isAlphaNum(lastChar)) {
        can_open = false;
      }
      if (isAlphaNum(nextChar)) {
        can_close = false;
      }
    }
  }
  return {
    can_open,
    can_close,
    delims: count2
  };
}
function emphasis(state2, silent) {
  var startCount, count2, found, oldCount, newCount, stack, res, max3 = state2.posMax, start = state2.pos, marker = state2.src.charCodeAt(start);
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  if (silent) {
    return false;
  }
  res = scanDelims(state2, start);
  startCount = res.delims;
  if (!res.can_open) {
    state2.pos += startCount;
    if (!silent) {
      state2.pending += state2.src.slice(start, state2.pos);
    }
    return true;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  state2.pos = start + startCount;
  stack = [startCount];
  while (state2.pos < max3) {
    if (state2.src.charCodeAt(state2.pos) === marker) {
      res = scanDelims(state2, state2.pos);
      count2 = res.delims;
      if (res.can_close) {
        oldCount = stack.pop();
        newCount = count2;
        while (oldCount !== newCount) {
          if (newCount < oldCount) {
            stack.push(oldCount - newCount);
            break;
          }
          newCount -= oldCount;
          if (stack.length === 0) {
            break;
          }
          state2.pos += oldCount;
          oldCount = stack.pop();
        }
        if (stack.length === 0) {
          startCount = oldCount;
          found = true;
          break;
        }
        state2.pos += count2;
        continue;
      }
      if (res.can_open) {
        stack.push(count2);
      }
      state2.pos += count2;
      continue;
    }
    state2.parser.skipToken(state2);
  }
  if (!found) {
    state2.pos = start;
    return false;
  }
  state2.posMax = state2.pos;
  state2.pos = start + startCount;
  if (!silent) {
    if (startCount === 2 || startCount === 3) {
      state2.push({ type: "strong_open", level: state2.level++ });
    }
    if (startCount === 1 || startCount === 3) {
      state2.push({ type: "em_open", level: state2.level++ });
    }
    state2.parser.tokenize(state2);
    if (startCount === 1 || startCount === 3) {
      state2.push({ type: "em_close", level: --state2.level });
    }
    if (startCount === 2 || startCount === 3) {
      state2.push({ type: "strong_close", level: --state2.level });
    }
  }
  state2.pos = state2.posMax + startCount;
  state2.posMax = max3;
  return true;
}
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;
function sub(state2, silent) {
  var found, content, max3 = state2.posMax, start = state2.pos;
  if (state2.src.charCodeAt(start) !== 126) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 2 >= max3) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  state2.pos = start + 1;
  while (state2.pos < max3) {
    if (state2.src.charCodeAt(state2.pos) === 126) {
      found = true;
      break;
    }
    state2.parser.skipToken(state2);
  }
  if (!found || start + 1 === state2.pos) {
    state2.pos = start;
    return false;
  }
  content = state2.src.slice(start + 1, state2.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state2.pos = start;
    return false;
  }
  state2.posMax = state2.pos;
  state2.pos = start + 1;
  if (!silent) {
    state2.push({
      type: "sub",
      level: state2.level,
      content: content.replace(UNESCAPE_RE, "$1")
    });
  }
  state2.pos = state2.posMax + 1;
  state2.posMax = max3;
  return true;
}
var UNESCAPE_RE$1 = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;
function sup(state2, silent) {
  var found, content, max3 = state2.posMax, start = state2.pos;
  if (state2.src.charCodeAt(start) !== 94) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 2 >= max3) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  state2.pos = start + 1;
  while (state2.pos < max3) {
    if (state2.src.charCodeAt(state2.pos) === 94) {
      found = true;
      break;
    }
    state2.parser.skipToken(state2);
  }
  if (!found || start + 1 === state2.pos) {
    state2.pos = start;
    return false;
  }
  content = state2.src.slice(start + 1, state2.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state2.pos = start;
    return false;
  }
  state2.posMax = state2.pos;
  state2.pos = start + 1;
  if (!silent) {
    state2.push({
      type: "sup",
      level: state2.level,
      content: content.replace(UNESCAPE_RE$1, "$1")
    });
  }
  state2.pos = state2.posMax + 1;
  state2.posMax = max3;
  return true;
}
function links(state2, silent) {
  var labelStart, labelEnd, label, href, title, pos, ref, code2, isImage = false, oldPos = state2.pos, max3 = state2.posMax, start = state2.pos, marker = state2.src.charCodeAt(start);
  if (marker === 33) {
    isImage = true;
    marker = state2.src.charCodeAt(++start);
  }
  if (marker !== 91) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  labelStart = start + 1;
  labelEnd = parseLinkLabel(state2, start);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max3 && state2.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max3; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (code2 !== 32 && code2 !== 10) {
        break;
      }
    }
    if (pos >= max3) {
      return false;
    }
    start = pos;
    if (parseLinkDestination(state2, pos)) {
      href = state2.linkContent;
      pos = state2.pos;
    } else {
      href = "";
    }
    start = pos;
    for (; pos < max3; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (code2 !== 32 && code2 !== 10) {
        break;
      }
    }
    if (pos < max3 && start !== pos && parseLinkTitle(state2, pos)) {
      title = state2.linkContent;
      pos = state2.pos;
      for (; pos < max3; pos++) {
        code2 = state2.src.charCodeAt(pos);
        if (code2 !== 32 && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max3 || state2.src.charCodeAt(pos) !== 41) {
      state2.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (state2.linkLevel > 0) {
      return false;
    }
    for (; pos < max3; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (code2 !== 32 && code2 !== 10) {
        break;
      }
    }
    if (pos < max3 && state2.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = parseLinkLabel(state2, pos);
      if (pos >= 0) {
        label = state2.src.slice(start, pos++);
      } else {
        pos = start - 1;
      }
    }
    if (!label) {
      if (typeof label === "undefined") {
        pos = labelEnd + 1;
      }
      label = state2.src.slice(labelStart, labelEnd);
    }
    ref = state2.env.references[normalizeReference(label)];
    if (!ref) {
      state2.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state2.pos = labelStart;
    state2.posMax = labelEnd;
    if (isImage) {
      state2.push({
        type: "image",
        src: href,
        title,
        alt: state2.src.substr(labelStart, labelEnd - labelStart),
        level: state2.level
      });
    } else {
      state2.push({
        type: "link_open",
        href,
        title,
        level: state2.level++
      });
      state2.linkLevel++;
      state2.parser.tokenize(state2);
      state2.linkLevel--;
      state2.push({ type: "link_close", level: --state2.level });
    }
  }
  state2.pos = pos;
  state2.posMax = max3;
  return true;
}
function footnote_inline(state2, silent) {
  var labelStart, labelEnd, footnoteId, oldLength, max3 = state2.posMax, start = state2.pos;
  if (start + 2 >= max3) {
    return false;
  }
  if (state2.src.charCodeAt(start) !== 94) {
    return false;
  }
  if (state2.src.charCodeAt(start + 1) !== 91) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  labelStart = start + 2;
  labelEnd = parseLinkLabel(state2, start + 1);
  if (labelEnd < 0) {
    return false;
  }
  if (!silent) {
    if (!state2.env.footnotes) {
      state2.env.footnotes = {};
    }
    if (!state2.env.footnotes.list) {
      state2.env.footnotes.list = [];
    }
    footnoteId = state2.env.footnotes.list.length;
    state2.pos = labelStart;
    state2.posMax = labelEnd;
    state2.push({
      type: "footnote_ref",
      id: footnoteId,
      level: state2.level
    });
    state2.linkLevel++;
    oldLength = state2.tokens.length;
    state2.parser.tokenize(state2);
    state2.env.footnotes.list[footnoteId] = { tokens: state2.tokens.splice(oldLength) };
    state2.linkLevel--;
  }
  state2.pos = labelEnd + 1;
  state2.posMax = max3;
  return true;
}
function footnote_ref(state2, silent) {
  var label, pos, footnoteId, footnoteSubId, max3 = state2.posMax, start = state2.pos;
  if (start + 3 > max3) {
    return false;
  }
  if (!state2.env.footnotes || !state2.env.footnotes.refs) {
    return false;
  }
  if (state2.src.charCodeAt(start) !== 91) {
    return false;
  }
  if (state2.src.charCodeAt(start + 1) !== 94) {
    return false;
  }
  if (state2.level >= state2.options.maxNesting) {
    return false;
  }
  for (pos = start + 2; pos < max3; pos++) {
    if (state2.src.charCodeAt(pos) === 32) {
      return false;
    }
    if (state2.src.charCodeAt(pos) === 10) {
      return false;
    }
    if (state2.src.charCodeAt(pos) === 93) {
      break;
    }
  }
  if (pos === start + 2) {
    return false;
  }
  if (pos >= max3) {
    return false;
  }
  pos++;
  label = state2.src.slice(start + 2, pos - 1);
  if (typeof state2.env.footnotes.refs[":" + label] === "undefined") {
    return false;
  }
  if (!silent) {
    if (!state2.env.footnotes.list) {
      state2.env.footnotes.list = [];
    }
    if (state2.env.footnotes.refs[":" + label] < 0) {
      footnoteId = state2.env.footnotes.list.length;
      state2.env.footnotes.list[footnoteId] = { label, count: 0 };
      state2.env.footnotes.refs[":" + label] = footnoteId;
    } else {
      footnoteId = state2.env.footnotes.refs[":" + label];
    }
    footnoteSubId = state2.env.footnotes.list[footnoteId].count;
    state2.env.footnotes.list[footnoteId].count++;
    state2.push({
      type: "footnote_ref",
      id: footnoteId,
      subId: footnoteSubId,
      level: state2.level
    });
  }
  state2.pos = pos;
  state2.posMax = max3;
  return true;
}
var url_schemas = [
  "coap",
  "doi",
  "javascript",
  "aaa",
  "aaas",
  "about",
  "acap",
  "cap",
  "cid",
  "crid",
  "data",
  "dav",
  "dict",
  "dns",
  "file",
  "ftp",
  "geo",
  "go",
  "gopher",
  "h323",
  "http",
  "https",
  "iax",
  "icap",
  "im",
  "imap",
  "info",
  "ipp",
  "iris",
  "iris.beep",
  "iris.xpc",
  "iris.xpcs",
  "iris.lwz",
  "ldap",
  "mailto",
  "mid",
  "msrp",
  "msrps",
  "mtqp",
  "mupdate",
  "news",
  "nfs",
  "ni",
  "nih",
  "nntp",
  "opaquelocktoken",
  "pop",
  "pres",
  "rtsp",
  "service",
  "session",
  "shttp",
  "sieve",
  "sip",
  "sips",
  "sms",
  "snmp",
  "soap.beep",
  "soap.beeps",
  "tag",
  "tel",
  "telnet",
  "tftp",
  "thismessage",
  "tn3270",
  "tip",
  "tv",
  "urn",
  "vemmi",
  "ws",
  "wss",
  "xcon",
  "xcon-userid",
  "xmlrpc.beep",
  "xmlrpc.beeps",
  "xmpp",
  "z39.50r",
  "z39.50s",
  "adiumxtra",
  "afp",
  "afs",
  "aim",
  "apt",
  "attachment",
  "aw",
  "beshare",
  "bitcoin",
  "bolo",
  "callto",
  "chrome",
  "chrome-extension",
  "com-eventbrite-attendee",
  "content",
  "cvs",
  "dlna-playsingle",
  "dlna-playcontainer",
  "dtn",
  "dvb",
  "ed2k",
  "facetime",
  "feed",
  "finger",
  "fish",
  "gg",
  "git",
  "gizmoproject",
  "gtalk",
  "hcp",
  "icon",
  "ipn",
  "irc",
  "irc6",
  "ircs",
  "itms",
  "jar",
  "jms",
  "keyparc",
  "lastfm",
  "ldaps",
  "magnet",
  "maps",
  "market",
  "message",
  "mms",
  "ms-help",
  "msnim",
  "mumble",
  "mvn",
  "notes",
  "oid",
  "palm",
  "paparazzi",
  "platform",
  "proxy",
  "psyc",
  "query",
  "res",
  "resource",
  "rmi",
  "rsync",
  "rtmp",
  "secondlife",
  "sftp",
  "sgn",
  "skype",
  "smb",
  "soldat",
  "spotify",
  "ssh",
  "steam",
  "svn",
  "teamspeak",
  "things",
  "udp",
  "unreal",
  "ut2004",
  "ventrilo",
  "view-source",
  "webcal",
  "wtai",
  "wyciwyg",
  "xfire",
  "xri",
  "ymsgr"
];
var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z.\-]{1,25}):([^<>\x00-\x20]*)>/;
function autolink(state2, silent) {
  var tail2, linkMatch, emailMatch, url, fullUrl, pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  tail2 = state2.src.slice(pos);
  if (tail2.indexOf(">") < 0) {
    return false;
  }
  linkMatch = tail2.match(AUTOLINK_RE);
  if (linkMatch) {
    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) {
      return false;
    }
    url = linkMatch[0].slice(1, -1);
    fullUrl = normalizeLink(url);
    if (!state2.parser.validateLink(url)) {
      return false;
    }
    if (!silent) {
      state2.push({
        type: "link_open",
        href: fullUrl,
        level: state2.level
      });
      state2.push({
        type: "text",
        content: url,
        level: state2.level + 1
      });
      state2.push({ type: "link_close", level: state2.level });
    }
    state2.pos += linkMatch[0].length;
    return true;
  }
  emailMatch = tail2.match(EMAIL_RE);
  if (emailMatch) {
    url = emailMatch[0].slice(1, -1);
    fullUrl = normalizeLink("mailto:" + url);
    if (!state2.parser.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      state2.push({
        type: "link_open",
        href: fullUrl,
        level: state2.level
      });
      state2.push({
        type: "text",
        content: url,
        level: state2.level + 1
      });
      state2.push({ type: "link_close", level: state2.level });
    }
    state2.pos += emailMatch[0].length;
    return true;
  }
  return false;
}
function replace$1(regex2, options) {
  regex2 = regex2.source;
  options = options || "";
  return function self3(name2, val) {
    if (!name2) {
      return new RegExp(regex2, options);
    }
    val = val.source || val;
    regex2 = regex2.replace(name2, val);
    return self3;
  };
}
var attr_name = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;
var unquoted = /[^"'=<>`\x00-\x20]+/;
var single_quoted = /'[^']*'/;
var double_quoted = /"[^"]*"/;
var attr_value = replace$1(/(?:unquoted|single_quoted|double_quoted)/)("unquoted", unquoted)("single_quoted", single_quoted)("double_quoted", double_quoted)();
var attribute = replace$1(/(?:\s+attr_name(?:\s*=\s*attr_value)?)/)("attr_name", attr_name)("attr_value", attr_value)();
var open_tag = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\s*\/?>/)("attribute", attribute)();
var close_tag = /<\/[A-Za-z][A-Za-z0-9]*\s*>/;
var comment = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;
var processing = /<[?].*?[?]>/;
var declaration = /<![A-Z]+\s+[^>]*>/;
var cdata = /<!\[CDATA\[[\s\S]*?\]\]>/;
var HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)("open_tag", open_tag)("close_tag", close_tag)("comment", comment)("processing", processing)("declaration", declaration)("cdata", cdata)();
function isLetter$2(ch) {
  var lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function htmltag(state2, silent) {
  var ch, match3, max3, pos = state2.pos;
  if (!state2.options.html) {
    return false;
  }
  max3 = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 60 || pos + 2 >= max3) {
    return false;
  }
  ch = state2.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter$2(ch)) {
    return false;
  }
  match3 = state2.src.slice(pos).match(HTML_TAG_RE);
  if (!match3) {
    return false;
  }
  if (!silent) {
    state2.push({
      type: "htmltag",
      content: state2.src.slice(pos, pos + match3[0].length),
      level: state2.level
    });
  }
  state2.pos += match3[0].length;
  return true;
}
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state2, silent) {
  var ch, code2, match3, pos = state2.pos, max3 = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 38) {
    return false;
  }
  if (pos + 1 < max3) {
    ch = state2.src.charCodeAt(pos + 1);
    if (ch === 35) {
      match3 = state2.src.slice(pos).match(DIGITAL_RE);
      if (match3) {
        if (!silent) {
          code2 = match3[1][0].toLowerCase() === "x" ? parseInt(match3[1].slice(1), 16) : parseInt(match3[1], 10);
          state2.pending += isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
        }
        state2.pos += match3[0].length;
        return true;
      }
    } else {
      match3 = state2.src.slice(pos).match(NAMED_RE);
      if (match3) {
        var decoded = decodeEntity(match3[1]);
        if (match3[1] !== decoded) {
          if (!silent) {
            state2.pending += decoded;
          }
          state2.pos += match3[0].length;
          return true;
        }
      }
    }
  }
  if (!silent) {
    state2.pending += "&";
  }
  state2.pos++;
  return true;
}
var _rules$2 = [
  ["text", text],
  ["newline", newline],
  ["escape", escape2],
  ["backticks", backticks],
  ["del", del],
  ["ins", ins],
  ["mark", mark],
  ["emphasis", emphasis],
  ["sub", sub],
  ["sup", sup],
  ["links", links],
  ["footnote_inline", footnote_inline],
  ["footnote_ref", footnote_ref],
  ["autolink", autolink],
  ["htmltag", htmltag],
  ["entity", entity]
];
function ParserInline() {
  this.ruler = new Ruler();
  for (var i2 = 0; i2 < _rules$2.length; i2++) {
    this.ruler.push(_rules$2[i2][0], _rules$2[i2][1]);
  }
  this.validateLink = validateLink;
}
ParserInline.prototype.skipToken = function(state2) {
  var rules2 = this.ruler.getRules("");
  var len = rules2.length;
  var pos = state2.pos;
  var i2, cached_pos;
  if ((cached_pos = state2.cacheGet(pos)) > 0) {
    state2.pos = cached_pos;
    return;
  }
  for (i2 = 0; i2 < len; i2++) {
    if (rules2[i2](state2, true)) {
      state2.cacheSet(pos, state2.pos);
      return;
    }
  }
  state2.pos++;
  state2.cacheSet(pos, state2.pos);
};
ParserInline.prototype.tokenize = function(state2) {
  var rules2 = this.ruler.getRules("");
  var len = rules2.length;
  var end = state2.posMax;
  var ok, i2;
  while (state2.pos < end) {
    for (i2 = 0; i2 < len; i2++) {
      ok = rules2[i2](state2, false);
      if (ok) {
        break;
      }
    }
    if (ok) {
      if (state2.pos >= end) {
        break;
      }
      continue;
    }
    state2.pending += state2.src[state2.pos++];
  }
  if (state2.pending) {
    state2.pushPending();
  }
};
ParserInline.prototype.parse = function(str2, options, env, outTokens) {
  var state2 = new StateInline(str2, this, options, env, outTokens);
  this.tokenize(state2);
};
function validateLink(url) {
  var BAD_PROTOCOLS = ["vbscript", "javascript", "file", "data"];
  var str2 = url.trim().toLowerCase();
  str2 = replaceEntities(str2);
  if (str2.indexOf(":") !== -1 && BAD_PROTOCOLS.indexOf(str2.split(":")[0]) !== -1) {
    return false;
  }
  return true;
}
var defaultConfig = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkTarget: "",
    // set target to open link in
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '' for Russian, '' for German.
    quotes: "",
    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "block",
        "inline",
        "references",
        "replacements",
        "smartquotes",
        "references",
        "abbr2",
        "footnote_tail"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fences",
        "footnote",
        "heading",
        "hr",
        "htmlblock",
        "lheading",
        "list",
        "paragraph",
        "table"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "del",
        "emphasis",
        "entity",
        "escape",
        "footnote_ref",
        "htmltag",
        "links",
        "newline",
        "text"
      ]
    }
  }
};
var fullConfig = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkTarget: "",
    // set target to open link in
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '' for Russian, '' for German.
    quotes: "",
    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    // Don't restrict core/block/inline rules
    core: {},
    block: {},
    inline: {}
  }
};
var commonmarkConfig = {
  options: {
    html: true,
    // Enable HTML tags in source
    xhtmlOut: true,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkTarget: "",
    // set target to open link in
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Set doubles to '' for Russian, '' for German.
    quotes: "",
    // Highlighter function. Should return escaped HTML,
    // or '' if input not changed
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "block",
        "inline",
        "references",
        "abbr2"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fences",
        "heading",
        "hr",
        "htmlblock",
        "lheading",
        "list",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "htmltag",
        "links",
        "newline",
        "text"
      ]
    }
  }
};
var config = {
  "default": defaultConfig,
  "full": fullConfig,
  "commonmark": commonmarkConfig
};
function StateCore(instance, str2, env) {
  this.src = str2;
  this.env = env;
  this.options = instance.options;
  this.tokens = [];
  this.inlineMode = false;
  this.inline = instance.inline;
  this.block = instance.block;
  this.renderer = instance.renderer;
  this.typographer = instance.typographer;
}
function Remarkable(preset, options) {
  if (typeof preset !== "string") {
    options = preset;
    preset = "default";
  }
  if (options && options.linkify != null) {
    console.warn(
      "linkify option is removed. Use linkify plugin instead:\n\nimport Remarkable from 'remarkable';\nimport linkify from 'remarkable/linkify';\nnew Remarkable().use(linkify)\n"
    );
  }
  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new Core();
  this.renderer = new Renderer();
  this.ruler = new Ruler();
  this.options = {};
  this.configure(config[preset]);
  this.set(options || {});
}
Remarkable.prototype.set = function(options) {
  assign(this.options, options);
};
Remarkable.prototype.configure = function(presets) {
  var self3 = this;
  if (!presets) {
    throw new Error("Wrong `remarkable` preset, check name/content");
  }
  if (presets.options) {
    self3.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name2) {
      if (presets.components[name2].rules) {
        self3[name2].ruler.enable(presets.components[name2].rules, true);
      }
    });
  }
};
Remarkable.prototype.use = function(plugin7, options) {
  plugin7(this, options);
  return this;
};
Remarkable.prototype.parse = function(str2, env) {
  var state2 = new StateCore(this, str2, env);
  this.core.process(state2);
  return state2.tokens;
};
Remarkable.prototype.render = function(str2, env) {
  env = env || {};
  return this.renderer.render(this.parse(str2, env), this.options, env);
};
Remarkable.prototype.parseInline = function(str2, env) {
  var state2 = new StateCore(this, str2, env);
  state2.inlineMode = true;
  this.core.process(state2);
  return state2.tokens;
};
Remarkable.prototype.renderInline = function(str2, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(str2, env), this.options, env);
};

// node_modules/autolinker/dist/es2015/version.js
var version = "3.16.2";

// node_modules/autolinker/dist/es2015/utils.js
function defaults(dest, src) {
  for (var prop3 in src) {
    if (src.hasOwnProperty(prop3) && dest[prop3] === void 0) {
      dest[prop3] = src[prop3];
    }
  }
  return dest;
}
function ellipsis(str2, truncateLen, ellipsisChars) {
  var ellipsisLength;
  if (str2.length > truncateLen) {
    if (ellipsisChars == null) {
      ellipsisChars = "&hellip;";
      ellipsisLength = 3;
    } else {
      ellipsisLength = ellipsisChars.length;
    }
    str2 = str2.substring(0, truncateLen - ellipsisLength) + ellipsisChars;
  }
  return str2;
}
function indexOf3(arr, element) {
  if (Array.prototype.indexOf) {
    return arr.indexOf(element);
  } else {
    for (var i2 = 0, len = arr.length; i2 < len; i2++) {
      if (arr[i2] === element)
        return i2;
    }
    return -1;
  }
}
function remove4(arr, fn2) {
  for (var i2 = arr.length - 1; i2 >= 0; i2--) {
    if (fn2(arr[i2]) === true) {
      arr.splice(i2, 1);
    }
  }
}
function splitAndCapture(str2, splitRegex) {
  if (!splitRegex.global)
    throw new Error("`splitRegex` must have the 'g' flag set");
  var result = [], lastIdx = 0, match3;
  while (match3 = splitRegex.exec(str2)) {
    result.push(str2.substring(lastIdx, match3.index));
    result.push(match3[0]);
    lastIdx = match3.index + match3[0].length;
  }
  result.push(str2.substring(lastIdx));
  return result;
}
function throwUnhandledCaseError(theValue) {
  throw new Error("Unhandled case for value: '".concat(theValue, "'"));
}

// node_modules/autolinker/dist/es2015/html-tag.js
var HtmlTag = (
  /** @class */
  function() {
    function HtmlTag2(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.tagName = "";
      this.attrs = {};
      this.innerHTML = "";
      this.whitespaceRegex = /\s+/;
      this.tagName = cfg.tagName || "";
      this.attrs = cfg.attrs || {};
      this.innerHTML = cfg.innerHtml || cfg.innerHTML || "";
    }
    HtmlTag2.prototype.setTagName = function(tagName) {
      this.tagName = tagName;
      return this;
    };
    HtmlTag2.prototype.getTagName = function() {
      return this.tagName || "";
    };
    HtmlTag2.prototype.setAttr = function(attrName, attrValue) {
      var tagAttrs = this.getAttrs();
      tagAttrs[attrName] = attrValue;
      return this;
    };
    HtmlTag2.prototype.getAttr = function(attrName) {
      return this.getAttrs()[attrName];
    };
    HtmlTag2.prototype.setAttrs = function(attrs) {
      Object.assign(this.getAttrs(), attrs);
      return this;
    };
    HtmlTag2.prototype.getAttrs = function() {
      return this.attrs || (this.attrs = {});
    };
    HtmlTag2.prototype.setClass = function(cssClass) {
      return this.setAttr("class", cssClass);
    };
    HtmlTag2.prototype.addClass = function(cssClass) {
      var classAttr = this.getClass(), whitespaceRegex = this.whitespaceRegex, classes = !classAttr ? [] : classAttr.split(whitespaceRegex), newClasses = cssClass.split(whitespaceRegex), newClass;
      while (newClass = newClasses.shift()) {
        if (indexOf3(classes, newClass) === -1) {
          classes.push(newClass);
        }
      }
      this.getAttrs()["class"] = classes.join(" ");
      return this;
    };
    HtmlTag2.prototype.removeClass = function(cssClass) {
      var classAttr = this.getClass(), whitespaceRegex = this.whitespaceRegex, classes = !classAttr ? [] : classAttr.split(whitespaceRegex), removeClasses = cssClass.split(whitespaceRegex), removeClass;
      while (classes.length && (removeClass = removeClasses.shift())) {
        var idx = indexOf3(classes, removeClass);
        if (idx !== -1) {
          classes.splice(idx, 1);
        }
      }
      this.getAttrs()["class"] = classes.join(" ");
      return this;
    };
    HtmlTag2.prototype.getClass = function() {
      return this.getAttrs()["class"] || "";
    };
    HtmlTag2.prototype.hasClass = function(cssClass) {
      return (" " + this.getClass() + " ").indexOf(" " + cssClass + " ") !== -1;
    };
    HtmlTag2.prototype.setInnerHTML = function(html2) {
      this.innerHTML = html2;
      return this;
    };
    HtmlTag2.prototype.setInnerHtml = function(html2) {
      return this.setInnerHTML(html2);
    };
    HtmlTag2.prototype.getInnerHTML = function() {
      return this.innerHTML || "";
    };
    HtmlTag2.prototype.getInnerHtml = function() {
      return this.getInnerHTML();
    };
    HtmlTag2.prototype.toAnchorString = function() {
      var tagName = this.getTagName(), attrsStr = this.buildAttrsStr();
      attrsStr = attrsStr ? " " + attrsStr : "";
      return ["<", tagName, attrsStr, ">", this.getInnerHtml(), "</", tagName, ">"].join("");
    };
    HtmlTag2.prototype.buildAttrsStr = function() {
      if (!this.attrs)
        return "";
      var attrs = this.getAttrs(), attrsArr = [];
      for (var prop3 in attrs) {
        if (attrs.hasOwnProperty(prop3)) {
          attrsArr.push(prop3 + '="' + attrs[prop3] + '"');
        }
      }
      return attrsArr.join(" ");
    };
    return HtmlTag2;
  }()
);

// node_modules/autolinker/dist/es2015/truncate/truncate-smart.js
function truncateSmart(url, truncateLen, ellipsisChars) {
  var ellipsisLengthBeforeParsing;
  var ellipsisLength;
  if (ellipsisChars == null) {
    ellipsisChars = "&hellip;";
    ellipsisLength = 3;
    ellipsisLengthBeforeParsing = 8;
  } else {
    ellipsisLength = ellipsisChars.length;
    ellipsisLengthBeforeParsing = ellipsisChars.length;
  }
  var parse_url = function(url2) {
    var urlObj2 = {};
    var urlSub = url2;
    var match3 = urlSub.match(/^([a-z]+):\/\//i);
    if (match3) {
      urlObj2.scheme = match3[1];
      urlSub = urlSub.substr(match3[0].length);
    }
    match3 = urlSub.match(/^(.*?)(?=(\?|#|\/|$))/i);
    if (match3) {
      urlObj2.host = match3[1];
      urlSub = urlSub.substr(match3[0].length);
    }
    match3 = urlSub.match(/^\/(.*?)(?=(\?|#|$))/i);
    if (match3) {
      urlObj2.path = match3[1];
      urlSub = urlSub.substr(match3[0].length);
    }
    match3 = urlSub.match(/^\?(.*?)(?=(#|$))/i);
    if (match3) {
      urlObj2.query = match3[1];
      urlSub = urlSub.substr(match3[0].length);
    }
    match3 = urlSub.match(/^#(.*?)$/i);
    if (match3) {
      urlObj2.fragment = match3[1];
    }
    return urlObj2;
  };
  var buildUrl = function(urlObj2) {
    var url2 = "";
    if (urlObj2.scheme && urlObj2.host) {
      url2 += urlObj2.scheme + "://";
    }
    if (urlObj2.host) {
      url2 += urlObj2.host;
    }
    if (urlObj2.path) {
      url2 += "/" + urlObj2.path;
    }
    if (urlObj2.query) {
      url2 += "?" + urlObj2.query;
    }
    if (urlObj2.fragment) {
      url2 += "#" + urlObj2.fragment;
    }
    return url2;
  };
  var buildSegment = function(segment, remainingAvailableLength3) {
    var remainingAvailableLengthHalf = remainingAvailableLength3 / 2, startOffset = Math.ceil(remainingAvailableLengthHalf), endOffset = -1 * Math.floor(remainingAvailableLengthHalf), end2 = "";
    if (endOffset < 0) {
      end2 = segment.substr(endOffset);
    }
    return segment.substr(0, startOffset) + ellipsisChars + end2;
  };
  if (url.length <= truncateLen) {
    return url;
  }
  var availableLength = truncateLen - ellipsisLength;
  var urlObj = parse_url(url);
  if (urlObj.query) {
    var matchQuery = urlObj.query.match(/^(.*?)(?=(\?|\#))(.*?)$/i);
    if (matchQuery) {
      urlObj.query = urlObj.query.substr(0, matchQuery[1].length);
      url = buildUrl(urlObj);
    }
  }
  if (url.length <= truncateLen) {
    return url;
  }
  if (urlObj.host) {
    urlObj.host = urlObj.host.replace(/^www\./, "");
    url = buildUrl(urlObj);
  }
  if (url.length <= truncateLen) {
    return url;
  }
  var str2 = "";
  if (urlObj.host) {
    str2 += urlObj.host;
  }
  if (str2.length >= availableLength) {
    if (urlObj.host.length == truncateLen) {
      return (urlObj.host.substr(0, truncateLen - ellipsisLength) + ellipsisChars).substr(0, availableLength + ellipsisLengthBeforeParsing);
    }
    return buildSegment(str2, availableLength).substr(0, availableLength + ellipsisLengthBeforeParsing);
  }
  var pathAndQuery = "";
  if (urlObj.path) {
    pathAndQuery += "/" + urlObj.path;
  }
  if (urlObj.query) {
    pathAndQuery += "?" + urlObj.query;
  }
  if (pathAndQuery) {
    if ((str2 + pathAndQuery).length >= availableLength) {
      if ((str2 + pathAndQuery).length == truncateLen) {
        return (str2 + pathAndQuery).substr(0, truncateLen);
      }
      var remainingAvailableLength = availableLength - str2.length;
      return (str2 + buildSegment(pathAndQuery, remainingAvailableLength)).substr(0, availableLength + ellipsisLengthBeforeParsing);
    } else {
      str2 += pathAndQuery;
    }
  }
  if (urlObj.fragment) {
    var fragment2 = "#" + urlObj.fragment;
    if ((str2 + fragment2).length >= availableLength) {
      if ((str2 + fragment2).length == truncateLen) {
        return (str2 + fragment2).substr(0, truncateLen);
      }
      var remainingAvailableLength2 = availableLength - str2.length;
      return (str2 + buildSegment(fragment2, remainingAvailableLength2)).substr(0, availableLength + ellipsisLengthBeforeParsing);
    } else {
      str2 += fragment2;
    }
  }
  if (urlObj.scheme && urlObj.host) {
    var scheme = urlObj.scheme + "://";
    if ((str2 + scheme).length < availableLength) {
      return (scheme + str2).substr(0, truncateLen);
    }
  }
  if (str2.length <= truncateLen) {
    return str2;
  }
  var end = "";
  if (availableLength > 0) {
    end = str2.substr(-1 * Math.floor(availableLength / 2));
  }
  return (str2.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);
}

// node_modules/autolinker/dist/es2015/truncate/truncate-middle.js
function truncateMiddle(url, truncateLen, ellipsisChars) {
  if (url.length <= truncateLen) {
    return url;
  }
  var ellipsisLengthBeforeParsing;
  var ellipsisLength;
  if (ellipsisChars == null) {
    ellipsisChars = "&hellip;";
    ellipsisLengthBeforeParsing = 8;
    ellipsisLength = 3;
  } else {
    ellipsisLengthBeforeParsing = ellipsisChars.length;
    ellipsisLength = ellipsisChars.length;
  }
  var availableLength = truncateLen - ellipsisLength;
  var end = "";
  if (availableLength > 0) {
    end = url.substr(-1 * Math.floor(availableLength / 2));
  }
  return (url.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);
}

// node_modules/autolinker/dist/es2015/truncate/truncate-end.js
function truncateEnd(anchorText, truncateLen, ellipsisChars) {
  return ellipsis(anchorText, truncateLen, ellipsisChars);
}

// node_modules/autolinker/dist/es2015/anchor-tag-builder.js
var AnchorTagBuilder = (
  /** @class */
  function() {
    function AnchorTagBuilder2(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.newWindow = false;
      this.truncate = {};
      this.className = "";
      this.newWindow = cfg.newWindow || false;
      this.truncate = cfg.truncate || {};
      this.className = cfg.className || "";
    }
    AnchorTagBuilder2.prototype.build = function(match3) {
      return new HtmlTag({
        tagName: "a",
        attrs: this.createAttrs(match3),
        innerHtml: this.processAnchorText(match3.getAnchorText())
      });
    };
    AnchorTagBuilder2.prototype.createAttrs = function(match3) {
      var attrs = {
        href: match3.getAnchorHref()
        // we'll always have the `href` attribute
      };
      var cssClass = this.createCssClass(match3);
      if (cssClass) {
        attrs["class"] = cssClass;
      }
      if (this.newWindow) {
        attrs["target"] = "_blank";
        attrs["rel"] = "noopener noreferrer";
      }
      if (this.truncate) {
        if (this.truncate.length && this.truncate.length < match3.getAnchorText().length) {
          attrs["title"] = match3.getAnchorHref();
        }
      }
      return attrs;
    };
    AnchorTagBuilder2.prototype.createCssClass = function(match3) {
      var className = this.className;
      if (!className) {
        return "";
      } else {
        var returnClasses = [className], cssClassSuffixes = match3.getCssClassSuffixes();
        for (var i2 = 0, len = cssClassSuffixes.length; i2 < len; i2++) {
          returnClasses.push(className + "-" + cssClassSuffixes[i2]);
        }
        return returnClasses.join(" ");
      }
    };
    AnchorTagBuilder2.prototype.processAnchorText = function(anchorText) {
      anchorText = this.doTruncate(anchorText);
      return anchorText;
    };
    AnchorTagBuilder2.prototype.doTruncate = function(anchorText) {
      var truncate = this.truncate;
      if (!truncate || !truncate.length)
        return anchorText;
      var truncateLength = truncate.length, truncateLocation = truncate.location;
      if (truncateLocation === "smart") {
        return truncateSmart(anchorText, truncateLength);
      } else if (truncateLocation === "middle") {
        return truncateMiddle(anchorText, truncateLength);
      } else {
        return truncateEnd(anchorText, truncateLength);
      }
    };
    return AnchorTagBuilder2;
  }()
);

// node_modules/autolinker/dist/es2015/match/match.js
var Match = (
  /** @class */
  function() {
    function Match2(cfg) {
      this.__jsduckDummyDocProp = null;
      this.matchedText = "";
      this.offset = 0;
      this.tagBuilder = cfg.tagBuilder;
      this.matchedText = cfg.matchedText;
      this.offset = cfg.offset;
    }
    Match2.prototype.getMatchedText = function() {
      return this.matchedText;
    };
    Match2.prototype.setOffset = function(offset) {
      this.offset = offset;
    };
    Match2.prototype.getOffset = function() {
      return this.offset;
    };
    Match2.prototype.getCssClassSuffixes = function() {
      return [this.getType()];
    };
    Match2.prototype.buildTag = function() {
      return this.tagBuilder.build(this);
    };
    return Match2;
  }()
);

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d2, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
    d3.__proto__ = b2;
  } || function(d3, b2) {
    for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
  };
  return extendStatics(d2, b);
};
function __extends2(d2, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d2, b);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};

// node_modules/autolinker/dist/es2015/match/email-match.js
var EmailMatch = (
  /** @class */
  function(_super) {
    __extends2(EmailMatch2, _super);
    function EmailMatch2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.email = "";
      _this.email = cfg.email;
      return _this;
    }
    EmailMatch2.prototype.getType = function() {
      return "email";
    };
    EmailMatch2.prototype.getEmail = function() {
      return this.email;
    };
    EmailMatch2.prototype.getAnchorHref = function() {
      return "mailto:" + this.email;
    };
    EmailMatch2.prototype.getAnchorText = function() {
      return this.email;
    };
    return EmailMatch2;
  }(Match)
);

// node_modules/autolinker/dist/es2015/match/hashtag-match.js
var HashtagMatch = (
  /** @class */
  function(_super) {
    __extends2(HashtagMatch2, _super);
    function HashtagMatch2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.serviceName = "";
      _this.hashtag = "";
      _this.serviceName = cfg.serviceName;
      _this.hashtag = cfg.hashtag;
      return _this;
    }
    HashtagMatch2.prototype.getType = function() {
      return "hashtag";
    };
    HashtagMatch2.prototype.getServiceName = function() {
      return this.serviceName;
    };
    HashtagMatch2.prototype.getHashtag = function() {
      return this.hashtag;
    };
    HashtagMatch2.prototype.getAnchorHref = function() {
      var serviceName = this.serviceName, hashtag = this.hashtag;
      switch (serviceName) {
        case "twitter":
          return "https://twitter.com/hashtag/" + hashtag;
        case "facebook":
          return "https://www.facebook.com/hashtag/" + hashtag;
        case "instagram":
          return "https://instagram.com/explore/tags/" + hashtag;
        case "tiktok":
          return "https://www.tiktok.com/tag/" + hashtag;
        default:
          throw new Error("Unknown service name to point hashtag to: " + serviceName);
      }
    };
    HashtagMatch2.prototype.getAnchorText = function() {
      return "#" + this.hashtag;
    };
    return HashtagMatch2;
  }(Match)
);

// node_modules/autolinker/dist/es2015/match/mention-match.js
var MentionMatch = (
  /** @class */
  function(_super) {
    __extends2(MentionMatch2, _super);
    function MentionMatch2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.serviceName = "twitter";
      _this.mention = "";
      _this.mention = cfg.mention;
      _this.serviceName = cfg.serviceName;
      return _this;
    }
    MentionMatch2.prototype.getType = function() {
      return "mention";
    };
    MentionMatch2.prototype.getMention = function() {
      return this.mention;
    };
    MentionMatch2.prototype.getServiceName = function() {
      return this.serviceName;
    };
    MentionMatch2.prototype.getAnchorHref = function() {
      switch (this.serviceName) {
        case "twitter":
          return "https://twitter.com/" + this.mention;
        case "instagram":
          return "https://instagram.com/" + this.mention;
        case "soundcloud":
          return "https://soundcloud.com/" + this.mention;
        case "tiktok":
          return "https://www.tiktok.com/@" + this.mention;
        default:
          throw new Error("Unknown service name to point mention to: " + this.serviceName);
      }
    };
    MentionMatch2.prototype.getAnchorText = function() {
      return "@" + this.mention;
    };
    MentionMatch2.prototype.getCssClassSuffixes = function() {
      var cssClassSuffixes = _super.prototype.getCssClassSuffixes.call(this), serviceName = this.getServiceName();
      if (serviceName) {
        cssClassSuffixes.push(serviceName);
      }
      return cssClassSuffixes;
    };
    return MentionMatch2;
  }(Match)
);

// node_modules/autolinker/dist/es2015/match/phone-match.js
var PhoneMatch = (
  /** @class */
  function(_super) {
    __extends2(PhoneMatch2, _super);
    function PhoneMatch2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.number = "";
      _this.plusSign = false;
      _this.number = cfg.number;
      _this.plusSign = cfg.plusSign;
      return _this;
    }
    PhoneMatch2.prototype.getType = function() {
      return "phone";
    };
    PhoneMatch2.prototype.getPhoneNumber = function() {
      return this.number;
    };
    PhoneMatch2.prototype.getNumber = function() {
      return this.getPhoneNumber();
    };
    PhoneMatch2.prototype.getAnchorHref = function() {
      return "tel:" + (this.plusSign ? "+" : "") + this.number;
    };
    PhoneMatch2.prototype.getAnchorText = function() {
      return this.matchedText;
    };
    return PhoneMatch2;
  }(Match)
);

// node_modules/autolinker/dist/es2015/match/url-match.js
var UrlMatch = (
  /** @class */
  function(_super) {
    __extends2(UrlMatch2, _super);
    function UrlMatch2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.url = "";
      _this.urlMatchType = "scheme";
      _this.protocolUrlMatch = false;
      _this.protocolRelativeMatch = false;
      _this.stripPrefix = {
        scheme: true,
        www: true
      };
      _this.stripTrailingSlash = true;
      _this.decodePercentEncoding = true;
      _this.schemePrefixRegex = /^(https?:\/\/)?/i;
      _this.wwwPrefixRegex = /^(https?:\/\/)?(www\.)?/i;
      _this.protocolRelativeRegex = /^\/\//;
      _this.protocolPrepended = false;
      _this.urlMatchType = cfg.urlMatchType;
      _this.url = cfg.url;
      _this.protocolUrlMatch = cfg.protocolUrlMatch;
      _this.protocolRelativeMatch = cfg.protocolRelativeMatch;
      _this.stripPrefix = cfg.stripPrefix;
      _this.stripTrailingSlash = cfg.stripTrailingSlash;
      _this.decodePercentEncoding = cfg.decodePercentEncoding;
      return _this;
    }
    UrlMatch2.prototype.getType = function() {
      return "url";
    };
    UrlMatch2.prototype.getUrlMatchType = function() {
      return this.urlMatchType;
    };
    UrlMatch2.prototype.getUrl = function() {
      var url = this.url;
      if (!this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended) {
        url = this.url = "http://" + url;
        this.protocolPrepended = true;
      }
      return url;
    };
    UrlMatch2.prototype.getAnchorHref = function() {
      var url = this.getUrl();
      return url.replace(/&amp;/g, "&");
    };
    UrlMatch2.prototype.getAnchorText = function() {
      var anchorText = this.getMatchedText();
      if (this.protocolRelativeMatch) {
        anchorText = this.stripProtocolRelativePrefix(anchorText);
      }
      if (this.stripPrefix.scheme) {
        anchorText = this.stripSchemePrefix(anchorText);
      }
      if (this.stripPrefix.www) {
        anchorText = this.stripWwwPrefix(anchorText);
      }
      if (this.stripTrailingSlash) {
        anchorText = this.removeTrailingSlash(anchorText);
      }
      if (this.decodePercentEncoding) {
        anchorText = this.removePercentEncoding(anchorText);
      }
      return anchorText;
    };
    UrlMatch2.prototype.stripSchemePrefix = function(url) {
      return url.replace(this.schemePrefixRegex, "");
    };
    UrlMatch2.prototype.stripWwwPrefix = function(url) {
      return url.replace(this.wwwPrefixRegex, "$1");
    };
    UrlMatch2.prototype.stripProtocolRelativePrefix = function(text3) {
      return text3.replace(this.protocolRelativeRegex, "");
    };
    UrlMatch2.prototype.removeTrailingSlash = function(anchorText) {
      if (anchorText.charAt(anchorText.length - 1) === "/") {
        anchorText = anchorText.slice(0, -1);
      }
      return anchorText;
    };
    UrlMatch2.prototype.removePercentEncoding = function(anchorText) {
      var preProcessedEntityAnchorText = anchorText.replace(/%22/gi, "&quot;").replace(/%26/gi, "&amp;").replace(/%27/gi, "&#39;").replace(/%3C/gi, "&lt;").replace(/%3E/gi, "&gt;");
      try {
        return decodeURIComponent(preProcessedEntityAnchorText);
      } catch (e2) {
        return preProcessedEntityAnchorText;
      }
    };
    return UrlMatch2;
  }(Match)
);

// node_modules/autolinker/dist/es2015/matcher/matcher.js
var Matcher = (
  /** @class */
  /* @__PURE__ */ function() {
    function Matcher2(cfg) {
      this.__jsduckDummyDocProp = null;
      this.tagBuilder = cfg.tagBuilder;
    }
    return Matcher2;
  }()
);

// node_modules/autolinker/dist/es2015/regex-lib.js
var letterRe = /[A-Za-z]/;
var digitRe = /[\d]/;
var nonDigitRe = /[\D]/;
var whitespaceRe = /\s/;
var quoteRe = /['"]/;
var controlCharsRe = /[\x00-\x1F\x7F]/;
var alphaCharsStr = /A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC/.source;
var emojiStr = /\u2700-\u27bf\udde6-\uddff\ud800-\udbff\udc00-\udfff\ufe0e\ufe0f\u0300-\u036f\ufe20-\ufe23\u20d0-\u20f0\ud83c\udffb-\udfff\u200d\u3299\u3297\u303d\u3030\u24c2\ud83c\udd70-\udd71\udd7e-\udd7f\udd8e\udd91-\udd9a\udde6-\uddff\ude01-\ude02\ude1a\ude2f\ude32-\ude3a\ude50-\ude51\u203c\u2049\u25aa-\u25ab\u25b6\u25c0\u25fb-\u25fe\u00a9\u00ae\u2122\u2139\udc04\u2600-\u26FF\u2b05\u2b06\u2b07\u2b1b\u2b1c\u2b50\u2b55\u231a\u231b\u2328\u23cf\u23e9-\u23f3\u23f8-\u23fa\udccf\u2935\u2934\u2190-\u21ff/.source;
var marksStr = /\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F/.source;
var alphaCharsAndMarksStr = alphaCharsStr + emojiStr + marksStr;
var decimalNumbersStr = /0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19/.source;
var alphaNumericCharsStr = alphaCharsAndMarksStr + decimalNumbersStr;
var alphaNumericAndMarksCharsStr = alphaCharsAndMarksStr + decimalNumbersStr;
var alphaNumericAndMarksCharRe = new RegExp("[".concat(alphaNumericAndMarksCharsStr, "]"));
var ipStr = "(?:[" + decimalNumbersStr + "]{1,3}\\.){3}[" + decimalNumbersStr + "]{1,3}";
var domainLabelStr = "[" + alphaNumericAndMarksCharsStr + "](?:[" + alphaNumericAndMarksCharsStr + "\\-_]{0,61}[" + alphaNumericAndMarksCharsStr + "])?";
var getDomainLabelStr = function(group) {
  return "(?=(" + domainLabelStr + "))\\" + group;
};
var getDomainNameStr = function(group) {
  return "(?:" + getDomainLabelStr(group) + "(?:\\." + getDomainLabelStr(group + 1) + "){0,126}|" + ipStr + ")";
};
var domainNameRegex = new RegExp("[" + alphaNumericAndMarksCharsStr + ".\\-]*[" + alphaNumericAndMarksCharsStr + "\\-]");
var domainNameCharRegex = alphaNumericAndMarksCharRe;

// node_modules/autolinker/dist/es2015/matcher/tld-regex.js
var tldRegex = /(?:xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--clchc0ea0b2g2a9gcd|xn--w4r85el8fhu5dnra|northwesternmutual|travelersinsurance|vermgensberatung|xn--5su34j936bgsg|xn--bck1b9a5dre4c|xn--mgbah1a3hjkrd|xn--mgbai9azgqp6j|xn--mgberp4a5d4ar|xn--xkc2dl3a5ee0h|vermgensberater|xn--fzys8d69uvgm|xn--mgba7c0bbn0a|xn--mgbcpq6gpa1a|xn--xkc2al3hye2a|americanexpress|kerryproperties|sandvikcoromant|xn--i1b6b1a6a2e|xn--kcrx77d1x4a|xn--lgbbat1ad8j|xn--mgba3a4f16a|xn--mgbaakc7dvf|xn--mgbc0a9azcg|xn--nqv7fs00ema|americanfamily|bananarepublic|cancerresearch|cookingchannel|kerrylogistics|weatherchannel|xn--54b7fta0cc|xn--6qq986b3xl|xn--80aqecdr1a|xn--b4w605ferd|xn--fiq228c5hs|xn--h2breg3eve|xn--jlq480n2rg|xn--jlq61u9w7b|xn--mgba3a3ejt|xn--mgbaam7a8h|xn--mgbayh7gpa|xn--mgbbh1a71e|xn--mgbca7dzdo|xn--mgbi4ecexp|xn--mgbx4cd0ab|xn--rvc1e0am3e|international|lifeinsurance|travelchannel|wolterskluwer|xn--cckwcxetd|xn--eckvdtc9d|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--h2brj9c8c|xn--tiq49xqyj|xn--yfro4i67o|xn--ygbi2ammx|construction|lplfinancial|scholarships|versicherung|xn--3e0b707e|xn--45br5cyl|xn--4dbrk0ce|xn--80adxhks|xn--80asehdb|xn--8y0a063a|xn--gckr3f0f|xn--mgb9awbf|xn--mgbab2bd|xn--mgbgu82a|xn--mgbpl2fh|xn--mgbt3dhd|xn--mk1bu44c|xn--ngbc5azd|xn--ngbe9e0a|xn--ogbpf8fl|xn--qcka1pmc|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|foodnetwork|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|williamhill|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--2scrj9c|xn--3bst00m|xn--3ds443g|xn--3hcrj9c|xn--42c2d9a|xn--45brj9c|xn--55qw42g|xn--6frz82g|xn--80ao21a|xn--9krt00a|xn--cck2b3b|xn--czr694b|xn--d1acj3b|xn--efvy88h|xn--fct429k|xn--fjq720a|xn--flw351e|xn--g2xx48c|xn--gecrj9c|xn--gk3at1e|xn--h2brj9c|xn--hxt814e|xn--imr513n|xn--j6w193g|xn--jvr189m|xn--kprw13d|xn--kpry57d|xn--mgbbh1a|xn--mgbtx2b|xn--mix891f|xn--nyqy26a|xn--otu796d|xn--pgbs0dh|xn--q9jyb4c|xn--rhqv96g|xn--rovu88b|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--vuq861b|xn--w4rs40l|xn--xhq521b|xn--zfr164b||accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nextdirect|properties|protection|prudential|realestate|republican|restaurant|schaeffler|tatamotors|technology|university|vlaanderen|volkswagen|xn--30rr7y|xn--3pxu8k|xn--45q11c|xn--4gbrim|xn--55qx5d|xn--5tzm5g|xn--80aswg|xn--90a3ac|xn--9dbq2a|xn--9et52u|xn--c2br7g|xn--cg4bki|xn--czrs0t|xn--czru2d|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--io0a7i|xn--kput3i|xn--mxtq1m|xn--o3cw4h|xn--pssy2u|xn--q7ce6a|xn--unup4y|xn--wgbh1c|xn--wgbl6a|xn--y9a3aq|accenture|alfaromeo|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|frontdoor|furniture|goldpoint|hisamitsu|homedepot|homegoods|homesense|institute|insurance|kuokgroup|lancaster|landrover|lifestyle|marketing|marshalls|melbourne|microsoft|panasonic|passagens|pramerica|richardli|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|xn--90ais|xn--c1avg|xn--d1alf|xn--e1a4c|xn--fhbei|xn--j1aef|xn--j1amh|xn--l1acc|xn--ngbrx|xn--nqv7f|xn--p1acf|xn--qxa6a|xn--tckwe|xn--vhquv|yodobashi||abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|builders|business|capetown|catering|catholic|cipriani|cityeats|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|etisalat|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|guardian|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|maserati|mckinsey|memorial|merckmsd|mortgage|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|showtime|softbank|software|stcgroup|supplies|training|vanguard|ventures|verisign|woodside|xn--90ae|xn--node|xn--p1ai|xn--qxam|yokohama||abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|avianca|banamex|bauhaus|bentley|bestbuy|booking|brother|bugatti|capital|caravan|careers|channel|charity|chintai|citadel|clubmed|college|cologne|comcast|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|grocery|guitars|hamburg|hangout|hitachi|holiday|hosting|hoteles|hotmail|hyundai|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lanxess|lasalle|latrobe|leclerc|limited|lincoln|markets|monster|netbank|netflix|network|neustar|okinawa|oldnavy|organic|origins|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|singles|staples|storage|support|surgery|systems|temasek|theater|theatre|tickets|tiffany|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|xfinity|yamaxun|youtube|zuerich|||||||||abarth|abbott|abbvie|africa|agency|airbus|airtel|alipay|alsace|alstom|amazon|anquan|aramco|author|bayern|beauty|berlin|bharti|bostik|boston|broker|camera|career|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hotels|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kinder|kindle|kosher|lancia|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|monash|mormon|moscow|museum|mutual|nagoya|natura|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|pictet|quebec|racing|realty|reisen|repair|report|review|rocher|rogers|ryukyu|safety|sakura|sanofi|school|schule|search|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|vuelos|walter|webcam|xihuan|yachts|yandex|zappos|||||||||||||actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|bosch|build|canon|cards|chase|cheap|cisco|citic|click|cloud|coach|codes|crown|cymru|dabur|dance|deals|delta|drive|dubai|earth|edeka|email|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|irish|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|linde|lipsy|loans|locus|lotte|lotto|macys|mango|media|miami|money|movie|music|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|rugby|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|sport|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|yahoo||||||||||||||aarp|able|adac|aero|akdn|ally|amex|arab|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|dvag|erni|fage|fail|fans|farm|fast|fiat|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|hgtv|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kids|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|loft|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|read|reit|rent|rest|rich|room|rsvp|ruhr|safe|sale|sarl|save|saxo|scot|seat|seek|sexy|shaw|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|yoga|zara|zero|zone||||||||||||||||||||||||||aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|cbs|ceo|cfa|cfd|com|cpa|crs|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gay|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|ibm|ice|icu|ifm|inc|ing|ink|int|ist|itv|jcb|jio|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|llc|llp|lol|lpl|ltd|man|map|mba|med|men|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|one|ong|onl|ooo|org|ott|ovh|pay|pet|phd|pid|pin|pnc|pro|pru|pub|pwc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|sca|scb|ses|sew|sex|sfr|ski|sky|soy|spa|srl|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|xxx|xyz|you|yun|zip||||||||||||||||||||||||||||||||ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||)/;

// node_modules/autolinker/dist/es2015/matcher/email-matcher.js
var localPartCharRegex = new RegExp("[".concat(alphaNumericAndMarksCharsStr, "!#$%&'*+/=?^_`{|}~-]"));
var strictTldRegex = new RegExp("^".concat(tldRegex.source, "$"));
var EmailMatcher = (
  /** @class */
  function(_super) {
    __extends2(EmailMatcher2, _super);
    function EmailMatcher2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.localPartCharRegex = localPartCharRegex;
      _this.strictTldRegex = strictTldRegex;
      return _this;
    }
    EmailMatcher2.prototype.parseMatches = function(text3) {
      var tagBuilder = this.tagBuilder, localPartCharRegex2 = this.localPartCharRegex, strictTldRegex2 = this.strictTldRegex, matches = [], len = text3.length, noCurrentEmailMatch = new CurrentEmailMatch();
      var mailtoTransitions = {
        m: "a",
        a: "i",
        i: "l",
        l: "t",
        t: "o",
        o: ":"
      };
      var charIdx = 0, state2 = 0, currentEmailMatch = noCurrentEmailMatch;
      while (charIdx < len) {
        var char = text3.charAt(charIdx);
        switch (state2) {
          case 0:
            stateNonEmailAddress(char);
            break;
          case 1:
            stateMailTo(text3.charAt(charIdx - 1), char);
            break;
          case 2:
            stateLocalPart(char);
            break;
          case 3:
            stateLocalPartDot(char);
            break;
          case 4:
            stateAtSign(char);
            break;
          case 5:
            stateDomainChar(char);
            break;
          case 6:
            stateDomainHyphen(char);
            break;
          case 7:
            stateDomainDot(char);
            break;
          default:
            throwUnhandledCaseError(state2);
        }
        charIdx++;
      }
      captureMatchIfValidAndReset();
      return matches;
      function stateNonEmailAddress(char2) {
        if (char2 === "m") {
          beginEmailMatch(
            1
            /* Mailto */
          );
        } else if (localPartCharRegex2.test(char2)) {
          beginEmailMatch();
        } else {
        }
      }
      function stateMailTo(prevChar, char2) {
        if (prevChar === ":") {
          if (localPartCharRegex2.test(char2)) {
            state2 = 2;
            currentEmailMatch = new CurrentEmailMatch(__assign(__assign({}, currentEmailMatch), { hasMailtoPrefix: true }));
          } else {
            resetToNonEmailMatchState();
          }
        } else if (mailtoTransitions[prevChar] === char2) {
        } else if (localPartCharRegex2.test(char2)) {
          state2 = 2;
        } else if (char2 === ".") {
          state2 = 3;
        } else if (char2 === "@") {
          state2 = 4;
        } else {
          resetToNonEmailMatchState();
        }
      }
      function stateLocalPart(char2) {
        if (char2 === ".") {
          state2 = 3;
        } else if (char2 === "@") {
          state2 = 4;
        } else if (localPartCharRegex2.test(char2)) {
        } else {
          resetToNonEmailMatchState();
        }
      }
      function stateLocalPartDot(char2) {
        if (char2 === ".") {
          resetToNonEmailMatchState();
        } else if (char2 === "@") {
          resetToNonEmailMatchState();
        } else if (localPartCharRegex2.test(char2)) {
          state2 = 2;
        } else {
          resetToNonEmailMatchState();
        }
      }
      function stateAtSign(char2) {
        if (domainNameCharRegex.test(char2)) {
          state2 = 5;
        } else {
          resetToNonEmailMatchState();
        }
      }
      function stateDomainChar(char2) {
        if (char2 === ".") {
          state2 = 7;
        } else if (char2 === "-") {
          state2 = 6;
        } else if (domainNameCharRegex.test(char2)) {
        } else {
          captureMatchIfValidAndReset();
        }
      }
      function stateDomainHyphen(char2) {
        if (char2 === "-" || char2 === ".") {
          captureMatchIfValidAndReset();
        } else if (domainNameCharRegex.test(char2)) {
          state2 = 5;
        } else {
          captureMatchIfValidAndReset();
        }
      }
      function stateDomainDot(char2) {
        if (char2 === "." || char2 === "-") {
          captureMatchIfValidAndReset();
        } else if (domainNameCharRegex.test(char2)) {
          state2 = 5;
          currentEmailMatch = new CurrentEmailMatch(__assign(__assign({}, currentEmailMatch), { hasDomainDot: true }));
        } else {
          captureMatchIfValidAndReset();
        }
      }
      function beginEmailMatch(newState) {
        if (newState === void 0) {
          newState = 2;
        }
        state2 = newState;
        currentEmailMatch = new CurrentEmailMatch({ idx: charIdx });
      }
      function resetToNonEmailMatchState() {
        state2 = 0;
        currentEmailMatch = noCurrentEmailMatch;
      }
      function captureMatchIfValidAndReset() {
        if (currentEmailMatch.hasDomainDot) {
          var matchedText = text3.slice(currentEmailMatch.idx, charIdx);
          if (/[-.]$/.test(matchedText)) {
            matchedText = matchedText.slice(0, -1);
          }
          var emailAddress = currentEmailMatch.hasMailtoPrefix ? matchedText.slice("mailto:".length) : matchedText;
          if (doesEmailHaveValidTld(emailAddress)) {
            matches.push(new EmailMatch({
              tagBuilder,
              matchedText,
              offset: currentEmailMatch.idx,
              email: emailAddress
            }));
          }
        }
        resetToNonEmailMatchState();
        function doesEmailHaveValidTld(emailAddress2) {
          var emailAddressTld = emailAddress2.split(".").pop() || "";
          var emailAddressNormalized = emailAddressTld.toLowerCase();
          var isValidTld = strictTldRegex2.test(emailAddressNormalized);
          return isValidTld;
        }
      }
    };
    return EmailMatcher2;
  }(Matcher)
);
var CurrentEmailMatch = (
  /** @class */
  /* @__PURE__ */ function() {
    function CurrentEmailMatch2(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.idx = cfg.idx !== void 0 ? cfg.idx : -1;
      this.hasMailtoPrefix = !!cfg.hasMailtoPrefix;
      this.hasDomainDot = !!cfg.hasDomainDot;
    }
    return CurrentEmailMatch2;
  }()
);

// node_modules/autolinker/dist/es2015/matcher/url-match-validator.js
var UrlMatchValidator = (
  /** @class */
  function() {
    function UrlMatchValidator2() {
    }
    UrlMatchValidator2.isValid = function(urlMatch, protocolUrlMatch) {
      if (protocolUrlMatch && !this.isValidUriScheme(protocolUrlMatch) || this.urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) || // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')
      this.urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like "git:1.0"
      !this.isValidIpAddress(urlMatch) || // Except if it's an IP address
      this.containsMultipleDots(urlMatch)) {
        return false;
      }
      return true;
    };
    UrlMatchValidator2.isValidIpAddress = function(uriSchemeMatch) {
      var newRegex = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);
      var uriScheme = uriSchemeMatch.match(newRegex);
      return uriScheme !== null;
    };
    UrlMatchValidator2.containsMultipleDots = function(urlMatch) {
      var stringBeforeSlash = urlMatch;
      if (this.hasFullProtocolRegex.test(urlMatch)) {
        stringBeforeSlash = urlMatch.split("://")[1];
      }
      return stringBeforeSlash.split("/")[0].indexOf("..") > -1;
    };
    UrlMatchValidator2.isValidUriScheme = function(uriSchemeMatch) {
      var uriSchemeMatchArr = uriSchemeMatch.match(this.uriSchemeRegex), uriScheme = uriSchemeMatchArr && uriSchemeMatchArr[0].toLowerCase();
      return uriScheme !== "javascript:" && uriScheme !== "vbscript:";
    };
    UrlMatchValidator2.urlMatchDoesNotHaveProtocolOrDot = function(urlMatch, protocolUrlMatch) {
      return !!urlMatch && (!protocolUrlMatch || !this.hasFullProtocolRegex.test(protocolUrlMatch)) && urlMatch.indexOf(".") === -1;
    };
    UrlMatchValidator2.urlMatchDoesNotHaveAtLeastOneWordChar = function(urlMatch, protocolUrlMatch) {
      if (urlMatch && protocolUrlMatch) {
        return !this.hasFullProtocolRegex.test(protocolUrlMatch) && !this.hasWordCharAfterProtocolRegex.test(urlMatch);
      } else {
        return false;
      }
    };
    UrlMatchValidator2.hasFullProtocolRegex = /^[A-Za-z][-.+A-Za-z0-9]*:\/\//;
    UrlMatchValidator2.uriSchemeRegex = /^[A-Za-z][-.+A-Za-z0-9]*:/;
    UrlMatchValidator2.hasWordCharAfterProtocolRegex = new RegExp(":[^\\s]*?[" + alphaCharsStr + "]");
    UrlMatchValidator2.ipRegex = /[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?\.[0-9][0-9]?[0-9]?(:[0-9]*)?\/?$/;
    return UrlMatchValidator2;
  }()
);

// node_modules/autolinker/dist/es2015/matcher/url-matcher.js
var matcherRegex = function() {
  var schemeRegex = /(?:[A-Za-z][-.+A-Za-z0-9]{0,63}:(?![A-Za-z][-.+A-Za-z0-9]{0,63}:\/\/)(?!\d+\/?)(?:\/\/)?)/, wwwRegex = /(?:www\.)/, urlSuffixRegex = new RegExp("[/?#](?:[" + alphaNumericAndMarksCharsStr + "\\-+&@#/%=~_()|'$*\\[\\]{}?!:,.;^]*[" + alphaNumericAndMarksCharsStr + "\\-+&@#/%=~_()|'$*\\[\\]{}])?");
  return new RegExp([
    "(?:",
    "(",
    schemeRegex.source,
    getDomainNameStr(2),
    ")",
    "|",
    "(",
    "(//)?",
    wwwRegex.source,
    getDomainNameStr(6),
    ")",
    "|",
    "(",
    "(//)?",
    getDomainNameStr(10) + "\\.",
    tldRegex.source,
    "(?![-" + alphaNumericCharsStr + "])",
    ")",
    ")",
    "(?::[0-9]+)?",
    "(?:" + urlSuffixRegex.source + ")?"
    // match for path, query string, and/or hash anchor - optional
  ].join(""), "gi");
}();
var wordCharRegExp = new RegExp("[" + alphaNumericAndMarksCharsStr + "]");
var UrlMatcher = (
  /** @class */
  function(_super) {
    __extends2(UrlMatcher2, _super);
    function UrlMatcher2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.stripPrefix = {
        scheme: true,
        www: true
      };
      _this.stripTrailingSlash = true;
      _this.decodePercentEncoding = true;
      _this.matcherRegex = matcherRegex;
      _this.wordCharRegExp = wordCharRegExp;
      _this.stripPrefix = cfg.stripPrefix;
      _this.stripTrailingSlash = cfg.stripTrailingSlash;
      _this.decodePercentEncoding = cfg.decodePercentEncoding;
      return _this;
    }
    UrlMatcher2.prototype.parseMatches = function(text3) {
      var matcherRegex2 = this.matcherRegex, stripPrefix = this.stripPrefix, stripTrailingSlash = this.stripTrailingSlash, decodePercentEncoding = this.decodePercentEncoding, tagBuilder = this.tagBuilder, matches = [], match3;
      var _loop_1 = function() {
        var matchStr = match3[0], schemeUrlMatch = match3[1], wwwUrlMatch = match3[4], wwwProtocolRelativeMatch = match3[5], tldProtocolRelativeMatch = match3[9], offset = match3.index, protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch, prevChar = text3.charAt(offset - 1);
        if (!UrlMatchValidator.isValid(matchStr, schemeUrlMatch)) {
          return "continue";
        }
        if (offset > 0 && prevChar === "@") {
          return "continue";
        }
        if (offset > 0 && protocolRelativeMatch && this_1.wordCharRegExp.test(prevChar)) {
          return "continue";
        }
        if (/\?$/.test(matchStr)) {
          matchStr = matchStr.substr(0, matchStr.length - 1);
        }
        if (this_1.matchHasUnbalancedClosingParen(matchStr)) {
          matchStr = matchStr.substr(0, matchStr.length - 1);
        } else {
          var pos = this_1.matchHasInvalidCharAfterTld(matchStr, schemeUrlMatch);
          if (pos > -1) {
            matchStr = matchStr.substr(0, pos);
          }
        }
        var foundCommonScheme = ["http://", "https://"].find(function(commonScheme) {
          return !!schemeUrlMatch && schemeUrlMatch.indexOf(commonScheme) !== -1;
        });
        if (foundCommonScheme) {
          var indexOfSchemeStart = matchStr.indexOf(foundCommonScheme);
          matchStr = matchStr.substr(indexOfSchemeStart);
          schemeUrlMatch = schemeUrlMatch.substr(indexOfSchemeStart);
          offset = offset + indexOfSchemeStart;
        }
        var urlMatchType = schemeUrlMatch ? "scheme" : wwwUrlMatch ? "www" : "tld", protocolUrlMatch = !!schemeUrlMatch;
        matches.push(new UrlMatch({
          tagBuilder,
          matchedText: matchStr,
          offset,
          urlMatchType,
          url: matchStr,
          protocolUrlMatch,
          protocolRelativeMatch: !!protocolRelativeMatch,
          stripPrefix,
          stripTrailingSlash,
          decodePercentEncoding
        }));
      };
      var this_1 = this;
      while ((match3 = matcherRegex2.exec(text3)) !== null) {
        _loop_1();
      }
      return matches;
    };
    UrlMatcher2.prototype.matchHasUnbalancedClosingParen = function(matchStr) {
      var endChar = matchStr.charAt(matchStr.length - 1);
      var startChar;
      if (endChar === ")") {
        startChar = "(";
      } else if (endChar === "]") {
        startChar = "[";
      } else if (endChar === "}") {
        startChar = "{";
      } else {
        return false;
      }
      var numOpenBraces = 0;
      for (var i2 = 0, len = matchStr.length - 1; i2 < len; i2++) {
        var char = matchStr.charAt(i2);
        if (char === startChar) {
          numOpenBraces++;
        } else if (char === endChar) {
          numOpenBraces = Math.max(numOpenBraces - 1, 0);
        }
      }
      if (numOpenBraces === 0) {
        return true;
      }
      return false;
    };
    UrlMatcher2.prototype.matchHasInvalidCharAfterTld = function(urlMatch, schemeUrlMatch) {
      if (!urlMatch) {
        return -1;
      }
      var offset = 0;
      if (schemeUrlMatch) {
        offset = urlMatch.indexOf(":");
        urlMatch = urlMatch.slice(offset);
      }
      var re = new RegExp("^((.?//)?[-." + alphaNumericAndMarksCharsStr + "]*[-" + alphaNumericAndMarksCharsStr + "]\\.[-" + alphaNumericAndMarksCharsStr + "]+)");
      var res = re.exec(urlMatch);
      if (res === null) {
        return -1;
      }
      offset += res[1].length;
      urlMatch = urlMatch.slice(res[1].length);
      if (/^[^-.A-Za-z0-9:\/?#]/.test(urlMatch)) {
        return offset;
      }
      return -1;
    };
    return UrlMatcher2;
  }(Matcher)
);

// node_modules/autolinker/dist/es2015/matcher/hashtag-matcher.js
var hashtagTextCharRe = new RegExp("[_".concat(alphaNumericAndMarksCharsStr, "]"));
var HashtagMatcher = (
  /** @class */
  function(_super) {
    __extends2(HashtagMatcher2, _super);
    function HashtagMatcher2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.serviceName = "twitter";
      _this.serviceName = cfg.serviceName;
      return _this;
    }
    HashtagMatcher2.prototype.parseMatches = function(text3) {
      var tagBuilder = this.tagBuilder;
      var serviceName = this.serviceName;
      var matches = [];
      var len = text3.length;
      var charIdx = 0, hashCharIdx = -1, state2 = 0;
      while (charIdx < len) {
        var char = text3.charAt(charIdx);
        switch (state2) {
          case 0:
            stateNone(char);
            break;
          case 1:
            stateNonHashtagWordChar(char);
            break;
          case 2:
            stateHashtagHashChar(char);
            break;
          case 3:
            stateHashtagTextChar(char);
            break;
          default:
            throwUnhandledCaseError(state2);
        }
        charIdx++;
      }
      captureMatchIfValid();
      return matches;
      function stateNone(char2) {
        if (char2 === "#") {
          state2 = 2;
          hashCharIdx = charIdx;
        } else if (alphaNumericAndMarksCharRe.test(char2)) {
          state2 = 1;
        } else {
        }
      }
      function stateNonHashtagWordChar(char2) {
        if (alphaNumericAndMarksCharRe.test(char2)) {
        } else {
          state2 = 0;
        }
      }
      function stateHashtagHashChar(char2) {
        if (hashtagTextCharRe.test(char2)) {
          state2 = 3;
        } else if (alphaNumericAndMarksCharRe.test(char2)) {
          state2 = 1;
        } else {
          state2 = 0;
        }
      }
      function stateHashtagTextChar(char2) {
        if (hashtagTextCharRe.test(char2)) {
        } else {
          captureMatchIfValid();
          hashCharIdx = -1;
          if (alphaNumericAndMarksCharRe.test(char2)) {
            state2 = 1;
          } else {
            state2 = 0;
          }
        }
      }
      function captureMatchIfValid() {
        if (hashCharIdx > -1 && charIdx - hashCharIdx <= 140) {
          var matchedText = text3.slice(hashCharIdx, charIdx);
          var match3 = new HashtagMatch({
            tagBuilder,
            matchedText,
            offset: hashCharIdx,
            serviceName,
            hashtag: matchedText.slice(1)
          });
          matches.push(match3);
        }
      }
    };
    return HashtagMatcher2;
  }(Matcher)
);
var hashtagServices = ["twitter", "facebook", "instagram", "tiktok"];

// node_modules/autolinker/dist/es2015/matcher/phone-matcher.js
var mostPhoneNumbers = /(?:(?:(?:(\+)?\d{1,3}[-\040.]?)?\(?\d{3}\)?[-\040.]?\d{3}[-\040.]?\d{4})|(?:(\+)(?:9[976]\d|8[987530]\d|6[987]\d|5[90]\d|42\d|3[875]\d|2[98654321]\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-\040.]?(?:\d[-\040.]?){6,12}\d+))([,;]+[0-9]+#?)*/;
var japanesePhoneRe = /(0([1-9]{1}-?[1-9]\d{3}|[1-9]{2}-?\d{3}|[1-9]{2}\d{1}-?\d{2}|[1-9]{2}\d{2}-?\d{1})-?\d{4}|0[789]0-?\d{4}-?\d{4}|050-?\d{4}-?\d{4})/;
var phoneMatcherRegex = new RegExp("".concat(mostPhoneNumbers.source, "|").concat(japanesePhoneRe.source), "g");
var PhoneMatcher = (
  /** @class */
  function(_super) {
    __extends2(PhoneMatcher2, _super);
    function PhoneMatcher2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.matcherRegex = phoneMatcherRegex;
      return _this;
    }
    PhoneMatcher2.prototype.parseMatches = function(text3) {
      var matcherRegex2 = this.matcherRegex, tagBuilder = this.tagBuilder, matches = [], match3;
      while ((match3 = matcherRegex2.exec(text3)) !== null) {
        var matchedText = match3[0], cleanNumber = matchedText.replace(/[^0-9,;#]/g, ""), plusSign = !!(match3[1] || match3[2]), before = match3.index == 0 ? "" : text3.substr(match3.index - 1, 1), after = text3.substr(match3.index + matchedText.length, 1), contextClear = !before.match(/\d/) && !after.match(/\d/);
        if (this.testMatch(match3[3]) && this.testMatch(matchedText) && contextClear) {
          matches.push(new PhoneMatch({
            tagBuilder,
            matchedText,
            offset: match3.index,
            number: cleanNumber,
            plusSign
          }));
        }
      }
      return matches;
    };
    PhoneMatcher2.prototype.testMatch = function(text3) {
      return nonDigitRe.test(text3);
    };
    return PhoneMatcher2;
  }(Matcher)
);

// node_modules/autolinker/dist/es2015/matcher/mention-matcher.js
var twitterRegex = new RegExp("@[_".concat(alphaNumericAndMarksCharsStr, "]{1,50}(?![_").concat(alphaNumericAndMarksCharsStr, "])"), "g");
var instagramRegex = new RegExp("@[_.".concat(alphaNumericAndMarksCharsStr, "]{1,30}(?![_").concat(alphaNumericAndMarksCharsStr, "])"), "g");
var soundcloudRegex = new RegExp("@[-_.".concat(alphaNumericAndMarksCharsStr, "]{1,50}(?![-_").concat(alphaNumericAndMarksCharsStr, "])"), "g");
var tiktokRegex = new RegExp("@[_.".concat(alphaNumericAndMarksCharsStr, "]{1,23}[_").concat(alphaNumericAndMarksCharsStr, "](?![_").concat(alphaNumericAndMarksCharsStr, "])"), "g");
var nonWordCharRegex = new RegExp("[^" + alphaNumericAndMarksCharsStr + "]");
var MentionMatcher = (
  /** @class */
  function(_super) {
    __extends2(MentionMatcher2, _super);
    function MentionMatcher2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.serviceName = "twitter";
      _this.matcherRegexes = {
        twitter: twitterRegex,
        instagram: instagramRegex,
        soundcloud: soundcloudRegex,
        tiktok: tiktokRegex
      };
      _this.nonWordCharRegex = nonWordCharRegex;
      _this.serviceName = cfg.serviceName;
      return _this;
    }
    MentionMatcher2.prototype.parseMatches = function(text3) {
      var serviceName = this.serviceName, matcherRegex2 = this.matcherRegexes[this.serviceName], nonWordCharRegex2 = this.nonWordCharRegex, tagBuilder = this.tagBuilder, matches = [], match3;
      if (!matcherRegex2) {
        return matches;
      }
      while ((match3 = matcherRegex2.exec(text3)) !== null) {
        var offset = match3.index, prevChar = text3.charAt(offset - 1);
        if (offset === 0 || nonWordCharRegex2.test(prevChar)) {
          var matchedText = match3[0].replace(/\.+$/g, ""), mention = matchedText.slice(1);
          matches.push(new MentionMatch({
            tagBuilder,
            matchedText,
            offset,
            serviceName,
            mention
          }));
        }
      }
      return matches;
    };
    return MentionMatcher2;
  }(Matcher)
);

// node_modules/autolinker/dist/es2015/htmlParser/parse-html.js
function parseHtml(html2, _a6) {
  var onOpenTag = _a6.onOpenTag, onCloseTag = _a6.onCloseTag, onText = _a6.onText, onComment = _a6.onComment, onDoctype = _a6.onDoctype;
  var noCurrentTag = new CurrentTag();
  var charIdx = 0, len = html2.length, state2 = 0, currentDataIdx = 0, currentTag = noCurrentTag;
  while (charIdx < len) {
    var char = html2.charAt(charIdx);
    switch (state2) {
      case 0:
        stateData(char);
        break;
      case 1:
        stateTagOpen(char);
        break;
      case 2:
        stateEndTagOpen(char);
        break;
      case 3:
        stateTagName(char);
        break;
      case 4:
        stateBeforeAttributeName(char);
        break;
      case 5:
        stateAttributeName(char);
        break;
      case 6:
        stateAfterAttributeName(char);
        break;
      case 7:
        stateBeforeAttributeValue(char);
        break;
      case 8:
        stateAttributeValueDoubleQuoted(char);
        break;
      case 9:
        stateAttributeValueSingleQuoted(char);
        break;
      case 10:
        stateAttributeValueUnquoted(char);
        break;
      case 11:
        stateAfterAttributeValueQuoted(char);
        break;
      case 12:
        stateSelfClosingStartTag(char);
        break;
      case 13:
        stateMarkupDeclarationOpen(char);
        break;
      case 14:
        stateCommentStart(char);
        break;
      case 15:
        stateCommentStartDash(char);
        break;
      case 16:
        stateComment(char);
        break;
      case 17:
        stateCommentEndDash(char);
        break;
      case 18:
        stateCommentEnd(char);
        break;
      case 19:
        stateCommentEndBang(char);
        break;
      case 20:
        stateDoctype(char);
        break;
      default:
        throwUnhandledCaseError(state2);
    }
    charIdx++;
  }
  if (currentDataIdx < charIdx) {
    emitText();
  }
  function stateData(char2) {
    if (char2 === "<") {
      startNewTag();
    }
  }
  function stateTagOpen(char2) {
    if (char2 === "!") {
      state2 = 13;
    } else if (char2 === "/") {
      state2 = 2;
      currentTag = new CurrentTag(__assign(__assign({}, currentTag), { isClosing: true }));
    } else if (char2 === "<") {
      startNewTag();
    } else if (letterRe.test(char2)) {
      state2 = 3;
      currentTag = new CurrentTag(__assign(__assign({}, currentTag), { isOpening: true }));
    } else {
      state2 = 0;
      currentTag = noCurrentTag;
    }
  }
  function stateTagName(char2) {
    if (whitespaceRe.test(char2)) {
      currentTag = new CurrentTag(__assign(__assign({}, currentTag), { name: captureTagName() }));
      state2 = 4;
    } else if (char2 === "<") {
      startNewTag();
    } else if (char2 === "/") {
      currentTag = new CurrentTag(__assign(__assign({}, currentTag), { name: captureTagName() }));
      state2 = 12;
    } else if (char2 === ">") {
      currentTag = new CurrentTag(__assign(__assign({}, currentTag), { name: captureTagName() }));
      emitTagAndPreviousTextNode();
    } else if (!letterRe.test(char2) && !digitRe.test(char2) && char2 !== ":") {
      resetToDataState();
    } else {
    }
  }
  function stateEndTagOpen(char2) {
    if (char2 === ">") {
      resetToDataState();
    } else if (letterRe.test(char2)) {
      state2 = 3;
    } else {
      resetToDataState();
    }
  }
  function stateBeforeAttributeName(char2) {
    if (whitespaceRe.test(char2)) {
    } else if (char2 === "/") {
      state2 = 12;
    } else if (char2 === ">") {
      emitTagAndPreviousTextNode();
    } else if (char2 === "<") {
      startNewTag();
    } else if (char2 === "=" || quoteRe.test(char2) || controlCharsRe.test(char2)) {
      resetToDataState();
    } else {
      state2 = 5;
    }
  }
  function stateAttributeName(char2) {
    if (whitespaceRe.test(char2)) {
      state2 = 6;
    } else if (char2 === "/") {
      state2 = 12;
    } else if (char2 === "=") {
      state2 = 7;
    } else if (char2 === ">") {
      emitTagAndPreviousTextNode();
    } else if (char2 === "<") {
      startNewTag();
    } else if (quoteRe.test(char2)) {
      resetToDataState();
    } else {
    }
  }
  function stateAfterAttributeName(char2) {
    if (whitespaceRe.test(char2)) {
    } else if (char2 === "/") {
      state2 = 12;
    } else if (char2 === "=") {
      state2 = 7;
    } else if (char2 === ">") {
      emitTagAndPreviousTextNode();
    } else if (char2 === "<") {
      startNewTag();
    } else if (quoteRe.test(char2)) {
      resetToDataState();
    } else {
      state2 = 5;
    }
  }
  function stateBeforeAttributeValue(char2) {
    if (whitespaceRe.test(char2)) {
    } else if (char2 === '"') {
      state2 = 8;
    } else if (char2 === "'") {
      state2 = 9;
    } else if (/[>=`]/.test(char2)) {
      resetToDataState();
    } else if (char2 === "<") {
      startNewTag();
    } else {
      state2 = 10;
    }
  }
  function stateAttributeValueDoubleQuoted(char2) {
    if (char2 === '"') {
      state2 = 11;
    } else {
    }
  }
  function stateAttributeValueSingleQuoted(char2) {
    if (char2 === "'") {
      state2 = 11;
    } else {
    }
  }
  function stateAttributeValueUnquoted(char2) {
    if (whitespaceRe.test(char2)) {
      state2 = 4;
    } else if (char2 === ">") {
      emitTagAndPreviousTextNode();
    } else if (char2 === "<") {
      startNewTag();
    } else {
    }
  }
  function stateAfterAttributeValueQuoted(char2) {
    if (whitespaceRe.test(char2)) {
      state2 = 4;
    } else if (char2 === "/") {
      state2 = 12;
    } else if (char2 === ">") {
      emitTagAndPreviousTextNode();
    } else if (char2 === "<") {
      startNewTag();
    } else {
      state2 = 4;
      reconsumeCurrentCharacter();
    }
  }
  function stateSelfClosingStartTag(char2) {
    if (char2 === ">") {
      currentTag = new CurrentTag(__assign(__assign({}, currentTag), { isClosing: true }));
      emitTagAndPreviousTextNode();
    } else {
      state2 = 4;
    }
  }
  function stateMarkupDeclarationOpen(char2) {
    if (html2.substr(charIdx, 2) === "--") {
      charIdx += 2;
      currentTag = new CurrentTag(__assign(__assign({}, currentTag), { type: "comment" }));
      state2 = 14;
    } else if (html2.substr(charIdx, 7).toUpperCase() === "DOCTYPE") {
      charIdx += 7;
      currentTag = new CurrentTag(__assign(__assign({}, currentTag), { type: "doctype" }));
      state2 = 20;
    } else {
      resetToDataState();
    }
  }
  function stateCommentStart(char2) {
    if (char2 === "-") {
      state2 = 15;
    } else if (char2 === ">") {
      resetToDataState();
    } else {
      state2 = 16;
    }
  }
  function stateCommentStartDash(char2) {
    if (char2 === "-") {
      state2 = 18;
    } else if (char2 === ">") {
      resetToDataState();
    } else {
      state2 = 16;
    }
  }
  function stateComment(char2) {
    if (char2 === "-") {
      state2 = 17;
    } else {
    }
  }
  function stateCommentEndDash(char2) {
    if (char2 === "-") {
      state2 = 18;
    } else {
      state2 = 16;
    }
  }
  function stateCommentEnd(char2) {
    if (char2 === ">") {
      emitTagAndPreviousTextNode();
    } else if (char2 === "!") {
      state2 = 19;
    } else if (char2 === "-") {
    } else {
      state2 = 16;
    }
  }
  function stateCommentEndBang(char2) {
    if (char2 === "-") {
      state2 = 17;
    } else if (char2 === ">") {
      emitTagAndPreviousTextNode();
    } else {
      state2 = 16;
    }
  }
  function stateDoctype(char2) {
    if (char2 === ">") {
      emitTagAndPreviousTextNode();
    } else if (char2 === "<") {
      startNewTag();
    } else {
    }
  }
  function resetToDataState() {
    state2 = 0;
    currentTag = noCurrentTag;
  }
  function startNewTag() {
    state2 = 1;
    currentTag = new CurrentTag({ idx: charIdx });
  }
  function emitTagAndPreviousTextNode() {
    var textBeforeTag = html2.slice(currentDataIdx, currentTag.idx);
    if (textBeforeTag) {
      onText(textBeforeTag, currentDataIdx);
    }
    if (currentTag.type === "comment") {
      onComment(currentTag.idx);
    } else if (currentTag.type === "doctype") {
      onDoctype(currentTag.idx);
    } else {
      if (currentTag.isOpening) {
        onOpenTag(currentTag.name, currentTag.idx);
      }
      if (currentTag.isClosing) {
        onCloseTag(currentTag.name, currentTag.idx);
      }
    }
    resetToDataState();
    currentDataIdx = charIdx + 1;
  }
  function emitText() {
    var text3 = html2.slice(currentDataIdx, charIdx);
    onText(text3, currentDataIdx);
    currentDataIdx = charIdx + 1;
  }
  function captureTagName() {
    var startIdx = currentTag.idx + (currentTag.isClosing ? 2 : 1);
    return html2.slice(startIdx, charIdx).toLowerCase();
  }
  function reconsumeCurrentCharacter() {
    charIdx--;
  }
}
var CurrentTag = (
  /** @class */
  /* @__PURE__ */ function() {
    function CurrentTag2(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.idx = cfg.idx !== void 0 ? cfg.idx : -1;
      this.type = cfg.type || "tag";
      this.name = cfg.name || "";
      this.isOpening = !!cfg.isOpening;
      this.isClosing = !!cfg.isClosing;
    }
    return CurrentTag2;
  }()
);

// node_modules/autolinker/dist/es2015/autolinker.js
var Autolinker = (
  /** @class */
  function() {
    function Autolinker2(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.version = Autolinker2.version;
      this.urls = {};
      this.email = true;
      this.phone = true;
      this.hashtag = false;
      this.mention = false;
      this.newWindow = true;
      this.stripPrefix = {
        scheme: true,
        www: true
      };
      this.stripTrailingSlash = true;
      this.decodePercentEncoding = true;
      this.truncate = {
        length: 0,
        location: "end"
      };
      this.className = "";
      this.replaceFn = null;
      this.context = void 0;
      this.sanitizeHtml = false;
      this.matchers = null;
      this.tagBuilder = null;
      this.urls = this.normalizeUrlsCfg(cfg.urls);
      this.email = typeof cfg.email === "boolean" ? cfg.email : this.email;
      this.phone = typeof cfg.phone === "boolean" ? cfg.phone : this.phone;
      this.hashtag = cfg.hashtag || this.hashtag;
      this.mention = cfg.mention || this.mention;
      this.newWindow = typeof cfg.newWindow === "boolean" ? cfg.newWindow : this.newWindow;
      this.stripPrefix = this.normalizeStripPrefixCfg(cfg.stripPrefix);
      this.stripTrailingSlash = typeof cfg.stripTrailingSlash === "boolean" ? cfg.stripTrailingSlash : this.stripTrailingSlash;
      this.decodePercentEncoding = typeof cfg.decodePercentEncoding === "boolean" ? cfg.decodePercentEncoding : this.decodePercentEncoding;
      this.sanitizeHtml = cfg.sanitizeHtml || false;
      var mention = this.mention;
      if (mention !== false && ["twitter", "instagram", "soundcloud", "tiktok"].indexOf(mention) === -1) {
        throw new Error("invalid `mention` cfg '".concat(mention, "' - see docs"));
      }
      var hashtag = this.hashtag;
      if (hashtag !== false && hashtagServices.indexOf(hashtag) === -1) {
        throw new Error("invalid `hashtag` cfg '".concat(hashtag, "' - see docs"));
      }
      this.truncate = this.normalizeTruncateCfg(cfg.truncate);
      this.className = cfg.className || this.className;
      this.replaceFn = cfg.replaceFn || this.replaceFn;
      this.context = cfg.context || this;
    }
    Autolinker2.link = function(textOrHtml, options) {
      var autolinker = new Autolinker2(options);
      return autolinker.link(textOrHtml);
    };
    Autolinker2.parse = function(textOrHtml, options) {
      var autolinker = new Autolinker2(options);
      return autolinker.parse(textOrHtml);
    };
    Autolinker2.prototype.normalizeUrlsCfg = function(urls) {
      if (urls == null)
        urls = true;
      if (typeof urls === "boolean") {
        return { schemeMatches: urls, wwwMatches: urls, tldMatches: urls };
      } else {
        return {
          schemeMatches: typeof urls.schemeMatches === "boolean" ? urls.schemeMatches : true,
          wwwMatches: typeof urls.wwwMatches === "boolean" ? urls.wwwMatches : true,
          tldMatches: typeof urls.tldMatches === "boolean" ? urls.tldMatches : true
        };
      }
    };
    Autolinker2.prototype.normalizeStripPrefixCfg = function(stripPrefix) {
      if (stripPrefix == null)
        stripPrefix = true;
      if (typeof stripPrefix === "boolean") {
        return { scheme: stripPrefix, www: stripPrefix };
      } else {
        return {
          scheme: typeof stripPrefix.scheme === "boolean" ? stripPrefix.scheme : true,
          www: typeof stripPrefix.www === "boolean" ? stripPrefix.www : true
        };
      }
    };
    Autolinker2.prototype.normalizeTruncateCfg = function(truncate) {
      if (typeof truncate === "number") {
        return { length: truncate, location: "end" };
      } else {
        return defaults(truncate || {}, {
          length: Number.POSITIVE_INFINITY,
          location: "end"
        });
      }
    };
    Autolinker2.prototype.parse = function(textOrHtml) {
      var _this = this;
      var skipTagNames = ["a", "style", "script"], skipTagsStackCount = 0, matches = [];
      parseHtml(textOrHtml, {
        onOpenTag: function(tagName) {
          if (skipTagNames.indexOf(tagName) >= 0) {
            skipTagsStackCount++;
          }
        },
        onText: function(text3, offset) {
          if (skipTagsStackCount === 0) {
            var htmlCharacterEntitiesRegex = /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi;
            var textSplit = splitAndCapture(text3, htmlCharacterEntitiesRegex);
            var currentOffset_1 = offset;
            textSplit.forEach(function(splitText, i2) {
              if (i2 % 2 === 0) {
                var textNodeMatches = _this.parseText(splitText, currentOffset_1);
                matches.push.apply(matches, textNodeMatches);
              }
              currentOffset_1 += splitText.length;
            });
          }
        },
        onCloseTag: function(tagName) {
          if (skipTagNames.indexOf(tagName) >= 0) {
            skipTagsStackCount = Math.max(skipTagsStackCount - 1, 0);
          }
        },
        onComment: function(offset) {
        },
        onDoctype: function(offset) {
        }
        // no need to process doctype nodes
      });
      matches = this.compactMatches(matches);
      matches = this.removeUnwantedMatches(matches);
      return matches;
    };
    Autolinker2.prototype.compactMatches = function(matches) {
      matches.sort(function(a2, b) {
        return a2.getOffset() - b.getOffset();
      });
      var i2 = 0;
      while (i2 < matches.length - 1) {
        var match3 = matches[i2], offset = match3.getOffset(), matchedTextLength = match3.getMatchedText().length, endIdx = offset + matchedTextLength;
        if (i2 + 1 < matches.length) {
          if (matches[i2 + 1].getOffset() === offset) {
            var removeIdx = matches[i2 + 1].getMatchedText().length > matchedTextLength ? i2 : i2 + 1;
            matches.splice(removeIdx, 1);
            continue;
          }
          if (matches[i2 + 1].getOffset() < endIdx) {
            matches.splice(i2 + 1, 1);
            continue;
          }
        }
        i2++;
      }
      return matches;
    };
    Autolinker2.prototype.removeUnwantedMatches = function(matches) {
      if (!this.hashtag)
        remove4(matches, function(match3) {
          return match3.getType() === "hashtag";
        });
      if (!this.email)
        remove4(matches, function(match3) {
          return match3.getType() === "email";
        });
      if (!this.phone)
        remove4(matches, function(match3) {
          return match3.getType() === "phone";
        });
      if (!this.mention)
        remove4(matches, function(match3) {
          return match3.getType() === "mention";
        });
      if (!this.urls.schemeMatches) {
        remove4(matches, function(m2) {
          return m2.getType() === "url" && m2.getUrlMatchType() === "scheme";
        });
      }
      if (!this.urls.wwwMatches) {
        remove4(matches, function(m2) {
          return m2.getType() === "url" && m2.getUrlMatchType() === "www";
        });
      }
      if (!this.urls.tldMatches) {
        remove4(matches, function(m2) {
          return m2.getType() === "url" && m2.getUrlMatchType() === "tld";
        });
      }
      return matches;
    };
    Autolinker2.prototype.parseText = function(text3, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      offset = offset || 0;
      var matchers = this.getMatchers(), matches = [];
      for (var i2 = 0, numMatchers = matchers.length; i2 < numMatchers; i2++) {
        var textMatches = matchers[i2].parseMatches(text3);
        for (var j2 = 0, numTextMatches = textMatches.length; j2 < numTextMatches; j2++) {
          textMatches[j2].setOffset(offset + textMatches[j2].getOffset());
        }
        matches.push.apply(matches, textMatches);
      }
      return matches;
    };
    Autolinker2.prototype.link = function(textOrHtml) {
      if (!textOrHtml) {
        return "";
      }
      if (this.sanitizeHtml) {
        textOrHtml = textOrHtml.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      var matches = this.parse(textOrHtml), newHtml = [], lastIndex = 0;
      for (var i2 = 0, len = matches.length; i2 < len; i2++) {
        var match3 = matches[i2];
        newHtml.push(textOrHtml.substring(lastIndex, match3.getOffset()));
        newHtml.push(this.createMatchReturnVal(match3));
        lastIndex = match3.getOffset() + match3.getMatchedText().length;
      }
      newHtml.push(textOrHtml.substring(lastIndex));
      return newHtml.join("");
    };
    Autolinker2.prototype.createMatchReturnVal = function(match3) {
      var replaceFnResult;
      if (this.replaceFn) {
        replaceFnResult = this.replaceFn.call(this.context, match3);
      }
      if (typeof replaceFnResult === "string") {
        return replaceFnResult;
      } else if (replaceFnResult === false) {
        return match3.getMatchedText();
      } else if (replaceFnResult instanceof HtmlTag) {
        return replaceFnResult.toAnchorString();
      } else {
        var anchorTag = match3.buildTag();
        return anchorTag.toAnchorString();
      }
    };
    Autolinker2.prototype.getMatchers = function() {
      if (!this.matchers) {
        var tagBuilder = this.getTagBuilder();
        var matchers = [
          new HashtagMatcher({
            tagBuilder,
            serviceName: this.hashtag
          }),
          new EmailMatcher({ tagBuilder }),
          new PhoneMatcher({ tagBuilder }),
          new MentionMatcher({
            tagBuilder,
            serviceName: this.mention
          }),
          new UrlMatcher({
            tagBuilder,
            stripPrefix: this.stripPrefix,
            stripTrailingSlash: this.stripTrailingSlash,
            decodePercentEncoding: this.decodePercentEncoding
          })
        ];
        return this.matchers = matchers;
      } else {
        return this.matchers;
      }
    };
    Autolinker2.prototype.getTagBuilder = function() {
      var tagBuilder = this.tagBuilder;
      if (!tagBuilder) {
        tagBuilder = this.tagBuilder = new AnchorTagBuilder({
          newWindow: this.newWindow,
          truncate: this.truncate,
          className: this.className
        });
      }
      return tagBuilder;
    };
    Autolinker2.version = version;
    Autolinker2.AnchorTagBuilder = AnchorTagBuilder;
    Autolinker2.HtmlTag = HtmlTag;
    Autolinker2.matcher = {
      Email: EmailMatcher,
      Hashtag: HashtagMatcher,
      Matcher,
      Mention: MentionMatcher,
      Phone: PhoneMatcher,
      Url: UrlMatcher
    };
    Autolinker2.match = {
      Email: EmailMatch,
      Hashtag: HashtagMatch,
      Match,
      Mention: MentionMatch,
      Phone: PhoneMatch,
      Url: UrlMatch
    };
    return Autolinker2;
  }()
);
var autolinker_default = Autolinker;

// node_modules/autolinker/dist/es2015/index.js
var es2015_default = autolinker_default;

// node_modules/remarkable/dist/esm/linkify.js
var LINK_SCAN_RE = /www|@|\:\/\//;
function isLinkOpen(str2) {
  return /^<a[>\s]/i.test(str2);
}
function isLinkClose(str2) {
  return /^<\/a\s*>/i.test(str2);
}
function createLinkifier() {
  var links2 = [];
  var autolinker = new es2015_default({
    stripPrefix: false,
    url: true,
    email: true,
    replaceFn: function(match3) {
      switch (match3.getType()) {
        case "url":
          links2.push({
            text: match3.matchedText,
            url: match3.getUrl()
          });
          break;
        case "email":
          links2.push({
            text: match3.matchedText,
            // normalize email protocol
            url: "mailto:" + match3.getEmail().replace(/^mailto:/i, "")
          });
          break;
      }
      return false;
    }
  });
  return {
    links: links2,
    autolinker
  };
}
function parseTokens(state2) {
  var i2, j2, l2, tokens, token, text3, nodes, ln2, pos, level, htmlLinkLevel, blockTokens = state2.tokens, linkifier = null, links2, autolinker;
  for (j2 = 0, l2 = blockTokens.length; j2 < l2; j2++) {
    if (blockTokens[j2].type !== "inline") {
      continue;
    }
    tokens = blockTokens[j2].children;
    htmlLinkLevel = 0;
    for (i2 = tokens.length - 1; i2 >= 0; i2--) {
      token = tokens[i2];
      if (token.type === "link_close") {
        i2--;
        while (tokens[i2].level !== token.level && tokens[i2].type !== "link_open") {
          i2--;
        }
        continue;
      }
      if (token.type === "htmltag") {
        if (isLinkOpen(token.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(token.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (token.type === "text" && LINK_SCAN_RE.test(token.content)) {
        if (!linkifier) {
          linkifier = createLinkifier();
          links2 = linkifier.links;
          autolinker = linkifier.autolinker;
        }
        text3 = token.content;
        links2.length = 0;
        autolinker.link(text3);
        if (!links2.length) {
          continue;
        }
        nodes = [];
        level = token.level;
        for (ln2 = 0; ln2 < links2.length; ln2++) {
          if (!state2.inline.validateLink(links2[ln2].url)) {
            continue;
          }
          pos = text3.indexOf(links2[ln2].text);
          if (pos) {
            nodes.push({
              type: "text",
              content: text3.slice(0, pos),
              level
            });
          }
          nodes.push({
            type: "link_open",
            href: links2[ln2].url,
            title: "",
            level: level++
          });
          nodes.push({
            type: "text",
            content: links2[ln2].text,
            level
          });
          nodes.push({
            type: "link_close",
            level: --level
          });
          text3 = text3.slice(pos + links2[ln2].text.length);
        }
        if (text3.length) {
          nodes.push({
            type: "text",
            content: text3,
            level
          });
        }
        blockTokens[j2].children = tokens = [].concat(tokens.slice(0, i2), nodes, tokens.slice(i2 + 1));
      }
    }
  }
}
function linkify(md) {
  md.core.ruler.push("linkify", parseTokens);
}

// node_modules/swagger-ui/node_modules/dompurify/dist/purify.es.mjs
var {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf: getPrototypeOf2,
  getOwnPropertyDescriptor: getOwnPropertyDescriptor2
} = Object;
var {
  freeze,
  seal,
  create
} = Object;
var {
  apply: apply3,
  construct: construct3
} = typeof Reflect !== "undefined" && Reflect;
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!apply3) {
  apply3 = function apply4(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct3) {
  construct3 = function construct4(Func, args) {
    return new Func(...args);
  };
}
var arrayForEach = unapply3(Array.prototype.forEach);
var arrayPop = unapply3(Array.prototype.pop);
var arrayPush = unapply3(Array.prototype.push);
var stringToLowerCase = unapply3(String.prototype.toLowerCase);
var stringToString = unapply3(String.prototype.toString);
var stringMatch = unapply3(String.prototype.match);
var stringReplace = unapply3(String.prototype.replace);
var stringIndexOf = unapply3(String.prototype.indexOf);
var stringTrim = unapply3(String.prototype.trim);
var objectHasOwnProperty = unapply3(Object.prototype.hasOwnProperty);
var regExpTest = unapply3(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply3(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply3(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct3(func, args);
  };
}
function addToSet(set4, array2) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set4, null);
  }
  let l2 = array2.length;
  while (l2--) {
    let element = array2[l2];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array2)) {
          array2[l2] = lcElement;
        }
        element = lcElement;
      }
    }
    set4[element] = true;
  }
  return set4;
}
function cleanArray2(array2) {
  for (let index = 0; index < array2.length; index++) {
    const isPropertyExist = objectHasOwnProperty(array2, index);
    if (!isPropertyExist) {
      array2[index] = null;
    }
  }
  return array2;
}
function clone3(object2) {
  const newObject = create(null);
  for (const [property2, value] of entries(object2)) {
    const isPropertyExist = objectHasOwnProperty(object2, property2);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property2] = cleanArray2(value);
      } else if (value && typeof value === "object" && value.constructor === Object) {
        newObject[property2] = clone3(value);
      } else {
        newObject[property2] = value;
      }
    }
  }
  return newObject;
}
function lookupGetter(object2, prop3) {
  while (object2 !== null) {
    const desc = getOwnPropertyDescriptor2(object2, prop3);
    if (desc) {
      if (desc.get) {
        return unapply3(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply3(desc.value);
      }
    }
    object2 = getPrototypeOf2(object2);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text2 = freeze(["#text"]);
var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml2 = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);
var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME,
  CUSTOM_ELEMENT
});
var NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12
  // Deprecated
};
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_2) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.1.6";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document: document2
  } = window2;
  const originalDocument = document2;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node: Node2,
    Element: Element3,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window2;
  const ElementPrototype = Element3.prototype;
  const cloneNode3 = lookupGetter(ElementPrototype, "cloneNode");
  const remove5 = lookupGetter(ElementPrototype, "remove");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = {};
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text2]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml2]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let SAFE_FOR_XML = true;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc = null;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone3(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(
      clone3(DEFAULT_URI_SAFE_ATTRIBUTES),
      // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(
      clone3(DEFAULT_DATA_URI_TAGS),
      // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text2);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml2);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml2);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml2);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone3(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone3(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone3(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  const HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      getParentNode(node).removeChild(node);
    } catch (_2) {
      remove5(node);
    }
  };
  const _removeAttribute = function _removeAttribute2(name2, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name2),
        from: node
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name2);
    if (name2 === "is" && !ALLOWED_ATTR[name2]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_2) {
        }
      } else {
        try {
          node.setAttribute(name2, "");
        } catch (_2) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_2) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createNodeIterator = function _createNodeIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
      null
    );
  };
  const _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(object2) {
    return typeof Node2 === "function" && object2 instanceof Node2;
  };
  const _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content = null;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i2 = childCount - 1; i2 >= 0; --i2) {
            const childClone = cloneNode3(childNodes[i2], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element3 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content = stringReplace(content, expr, " ");
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      ) ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if (value) {
      return false;
    } else ;
    return true;
  };
  const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
    return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    let l2 = attributes.length;
    while (l2--) {
      const attr = attributes[l2];
      const {
        name: name2,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name2);
      let value = name2 === "value" ? attrValue : stringTrim(attrValue);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name2, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name2, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI) ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name2, value);
        } else {
          currentNode.setAttribute(name2, value);
        }
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_2) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment2) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment2);
    _executeHook("beforeSanitizeShadowDOM", fragment2, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment2, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();

// node_modules/swagger-ui/dist/swagger-ui-es-bundle-core.js
var _e = __toESM(require_escapeRegExp());
var ve = __toESM(require_isPlainObject());
var be = __toESM(require_has2());
var we = __toESM(require_set2());
var Ce = { 287: function(e2, t2, r2) {
  const n = r2(987), a2 = r2(362), o4 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
  t2.Buffer = Buffer2, t2.SlowBuffer = function SlowBuffer(e3) {
    +e3 != e3 && (e3 = 0);
    return Buffer2.alloc(+e3);
  }, t2.INSPECT_MAX_BYTES = 50;
  const s2 = 2147483647;
  function createBuffer(e3) {
    if (e3 > s2) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
    const t3 = new Uint8Array(e3);
    return Object.setPrototypeOf(t3, Buffer2.prototype), t3;
  }
  function Buffer2(e3, t3, r3) {
    if ("number" == typeof e3) {
      if ("string" == typeof t3) throw new TypeError('The "string" argument must be of type string. Received type number');
      return allocUnsafe(e3);
    }
    return from2(e3, t3, r3);
  }
  function from2(e3, t3, r3) {
    if ("string" == typeof e3) return function fromString(e4, t4) {
      "string" == typeof t4 && "" !== t4 || (t4 = "utf8");
      if (!Buffer2.isEncoding(t4)) throw new TypeError("Unknown encoding: " + t4);
      const r4 = 0 | byteLength(e4, t4);
      let n3 = createBuffer(r4);
      const a4 = n3.write(e4, t4);
      a4 !== r4 && (n3 = n3.slice(0, a4));
      return n3;
    }(e3, t3);
    if (ArrayBuffer.isView(e3)) return function fromArrayView(e4) {
      if (isInstance(e4, Uint8Array)) {
        const t4 = new Uint8Array(e4);
        return fromArrayBuffer(t4.buffer, t4.byteOffset, t4.byteLength);
      }
      return fromArrayLike(e4);
    }(e3);
    if (null == e3) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
    if (isInstance(e3, ArrayBuffer) || e3 && isInstance(e3.buffer, ArrayBuffer)) return fromArrayBuffer(e3, t3, r3);
    if ("undefined" != typeof SharedArrayBuffer && (isInstance(e3, SharedArrayBuffer) || e3 && isInstance(e3.buffer, SharedArrayBuffer))) return fromArrayBuffer(e3, t3, r3);
    if ("number" == typeof e3) throw new TypeError('The "value" argument must not be of type number. Received type number');
    const n2 = e3.valueOf && e3.valueOf();
    if (null != n2 && n2 !== e3) return Buffer2.from(n2, t3, r3);
    const a3 = function fromObject(e4) {
      if (Buffer2.isBuffer(e4)) {
        const t4 = 0 | checked(e4.length), r4 = createBuffer(t4);
        return 0 === r4.length || e4.copy(r4, 0, 0, t4), r4;
      }
      if (void 0 !== e4.length) return "number" != typeof e4.length || numberIsNaN(e4.length) ? createBuffer(0) : fromArrayLike(e4);
      if ("Buffer" === e4.type && Array.isArray(e4.data)) return fromArrayLike(e4.data);
    }(e3);
    if (a3) return a3;
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive]) return Buffer2.from(e3[Symbol.toPrimitive]("string"), t3, r3);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
  }
  function assertSize(e3) {
    if ("number" != typeof e3) throw new TypeError('"size" argument must be of type number');
    if (e3 < 0) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
  }
  function allocUnsafe(e3) {
    return assertSize(e3), createBuffer(e3 < 0 ? 0 : 0 | checked(e3));
  }
  function fromArrayLike(e3) {
    const t3 = e3.length < 0 ? 0 : 0 | checked(e3.length), r3 = createBuffer(t3);
    for (let n2 = 0; n2 < t3; n2 += 1) r3[n2] = 255 & e3[n2];
    return r3;
  }
  function fromArrayBuffer(e3, t3, r3) {
    if (t3 < 0 || e3.byteLength < t3) throw new RangeError('"offset" is outside of buffer bounds');
    if (e3.byteLength < t3 + (r3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let n2;
    return n2 = void 0 === t3 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, r3), Object.setPrototypeOf(n2, Buffer2.prototype), n2;
  }
  function checked(e3) {
    if (e3 >= s2) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s2.toString(16) + " bytes");
    return 0 | e3;
  }
  function byteLength(e3, t3) {
    if (Buffer2.isBuffer(e3)) return e3.length;
    if (ArrayBuffer.isView(e3) || isInstance(e3, ArrayBuffer)) return e3.byteLength;
    if ("string" != typeof e3) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
    const r3 = e3.length, n2 = arguments.length > 2 && true === arguments[2];
    if (!n2 && 0 === r3) return 0;
    let a3 = false;
    for (; ; ) switch (t3) {
      case "ascii":
      case "latin1":
      case "binary":
        return r3;
      case "utf8":
      case "utf-8":
        return utf8ToBytes(e3).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * r3;
      case "hex":
        return r3 >>> 1;
      case "base64":
        return base64ToBytes(e3).length;
      default:
        if (a3) return n2 ? -1 : utf8ToBytes(e3).length;
        t3 = ("" + t3).toLowerCase(), a3 = true;
    }
  }
  function slowToString(e3, t3, r3) {
    let n2 = false;
    if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length) return "";
    if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0) return "";
    if ((r3 >>>= 0) <= (t3 >>>= 0)) return "";
    for (e3 || (e3 = "utf8"); ; ) switch (e3) {
      case "hex":
        return hexSlice(this, t3, r3);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, t3, r3);
      case "ascii":
        return asciiSlice(this, t3, r3);
      case "latin1":
      case "binary":
        return latin1Slice(this, t3, r3);
      case "base64":
        return base64Slice(this, t3, r3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, t3, r3);
      default:
        if (n2) throw new TypeError("Unknown encoding: " + e3);
        e3 = (e3 + "").toLowerCase(), n2 = true;
    }
  }
  function swap2(e3, t3, r3) {
    const n2 = e3[t3];
    e3[t3] = e3[r3], e3[r3] = n2;
  }
  function bidirectionalIndexOf(e3, t3, r3, n2, a3) {
    if (0 === e3.length) return -1;
    if ("string" == typeof r3 ? (n2 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), numberIsNaN(r3 = +r3) && (r3 = a3 ? 0 : e3.length - 1), r3 < 0 && (r3 = e3.length + r3), r3 >= e3.length) {
      if (a3) return -1;
      r3 = e3.length - 1;
    } else if (r3 < 0) {
      if (!a3) return -1;
      r3 = 0;
    }
    if ("string" == typeof t3 && (t3 = Buffer2.from(t3, n2)), Buffer2.isBuffer(t3)) return 0 === t3.length ? -1 : arrayIndexOf(e3, t3, r3, n2, a3);
    if ("number" == typeof t3) return t3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? a3 ? Uint8Array.prototype.indexOf.call(e3, t3, r3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, r3) : arrayIndexOf(e3, [t3], r3, n2, a3);
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(e3, t3, r3, n2, a3) {
    let o5, s3 = 1, l3 = e3.length, i3 = t3.length;
    if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
      if (e3.length < 2 || t3.length < 2) return -1;
      s3 = 2, l3 /= 2, i3 /= 2, r3 /= 2;
    }
    function read(e4, t4) {
      return 1 === s3 ? e4[t4] : e4.readUInt16BE(t4 * s3);
    }
    if (a3) {
      let n3 = -1;
      for (o5 = r3; o5 < l3; o5++) if (read(e3, o5) === read(t3, -1 === n3 ? 0 : o5 - n3)) {
        if (-1 === n3 && (n3 = o5), o5 - n3 + 1 === i3) return n3 * s3;
      } else -1 !== n3 && (o5 -= o5 - n3), n3 = -1;
    } else for (r3 + i3 > l3 && (r3 = l3 - i3), o5 = r3; o5 >= 0; o5--) {
      let r4 = true;
      for (let n3 = 0; n3 < i3; n3++) if (read(e3, o5 + n3) !== read(t3, n3)) {
        r4 = false;
        break;
      }
      if (r4) return o5;
    }
    return -1;
  }
  function hexWrite(e3, t3, r3, n2) {
    r3 = Number(r3) || 0;
    const a3 = e3.length - r3;
    n2 ? (n2 = Number(n2)) > a3 && (n2 = a3) : n2 = a3;
    const o5 = t3.length;
    let s3;
    for (n2 > o5 / 2 && (n2 = o5 / 2), s3 = 0; s3 < n2; ++s3) {
      const n3 = parseInt(t3.substr(2 * s3, 2), 16);
      if (numberIsNaN(n3)) return s3;
      e3[r3 + s3] = n3;
    }
    return s3;
  }
  function utf8Write(e3, t3, r3, n2) {
    return blitBuffer(utf8ToBytes(t3, e3.length - r3), e3, r3, n2);
  }
  function asciiWrite(e3, t3, r3, n2) {
    return blitBuffer(function asciiToBytes(e4) {
      const t4 = [];
      for (let r4 = 0; r4 < e4.length; ++r4) t4.push(255 & e4.charCodeAt(r4));
      return t4;
    }(t3), e3, r3, n2);
  }
  function base64Write(e3, t3, r3, n2) {
    return blitBuffer(base64ToBytes(t3), e3, r3, n2);
  }
  function ucs2Write(e3, t3, r3, n2) {
    return blitBuffer(function utf16leToBytes(e4, t4) {
      let r4, n3, a3;
      const o5 = [];
      for (let s3 = 0; s3 < e4.length && !((t4 -= 2) < 0); ++s3) r4 = e4.charCodeAt(s3), n3 = r4 >> 8, a3 = r4 % 256, o5.push(a3), o5.push(n3);
      return o5;
    }(t3, e3.length - r3), e3, r3, n2);
  }
  function base64Slice(e3, t3, r3) {
    return 0 === t3 && r3 === e3.length ? n.fromByteArray(e3) : n.fromByteArray(e3.slice(t3, r3));
  }
  function utf8Slice(e3, t3, r3) {
    r3 = Math.min(e3.length, r3);
    const n2 = [];
    let a3 = t3;
    for (; a3 < r3; ) {
      const t4 = e3[a3];
      let o5 = null, s3 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
      if (a3 + s3 <= r3) {
        let r4, n3, l3, i3;
        switch (s3) {
          case 1:
            t4 < 128 && (o5 = t4);
            break;
          case 2:
            r4 = e3[a3 + 1], 128 == (192 & r4) && (i3 = (31 & t4) << 6 | 63 & r4, i3 > 127 && (o5 = i3));
            break;
          case 3:
            r4 = e3[a3 + 1], n3 = e3[a3 + 2], 128 == (192 & r4) && 128 == (192 & n3) && (i3 = (15 & t4) << 12 | (63 & r4) << 6 | 63 & n3, i3 > 2047 && (i3 < 55296 || i3 > 57343) && (o5 = i3));
            break;
          case 4:
            r4 = e3[a3 + 1], n3 = e3[a3 + 2], l3 = e3[a3 + 3], 128 == (192 & r4) && 128 == (192 & n3) && 128 == (192 & l3) && (i3 = (15 & t4) << 18 | (63 & r4) << 12 | (63 & n3) << 6 | 63 & l3, i3 > 65535 && i3 < 1114112 && (o5 = i3));
        }
      }
      null === o5 ? (o5 = 65533, s3 = 1) : o5 > 65535 && (o5 -= 65536, n2.push(o5 >>> 10 & 1023 | 55296), o5 = 56320 | 1023 & o5), n2.push(o5), a3 += s3;
    }
    return function decodeCodePointsArray(e4) {
      const t4 = e4.length;
      if (t4 <= l2) return String.fromCharCode.apply(String, e4);
      let r4 = "", n3 = 0;
      for (; n3 < t4; ) r4 += String.fromCharCode.apply(String, e4.slice(n3, n3 += l2));
      return r4;
    }(n2);
  }
  t2.kMaxLength = s2, Buffer2.TYPED_ARRAY_SUPPORT = function typedArraySupport() {
    try {
      const e3 = new Uint8Array(1), t3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), 42 === e3.foo();
    } catch (e3) {
      return false;
    }
  }(), Buffer2.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(Buffer2.prototype, "parent", { enumerable: true, get: function() {
    if (Buffer2.isBuffer(this)) return this.buffer;
  } }), Object.defineProperty(Buffer2.prototype, "offset", { enumerable: true, get: function() {
    if (Buffer2.isBuffer(this)) return this.byteOffset;
  } }), Buffer2.poolSize = 8192, Buffer2.from = function(e3, t3, r3) {
    return from2(e3, t3, r3);
  }, Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer2, Uint8Array), Buffer2.alloc = function(e3, t3, r3) {
    return function alloc(e4, t4, r4) {
      return assertSize(e4), e4 <= 0 ? createBuffer(e4) : void 0 !== t4 ? "string" == typeof r4 ? createBuffer(e4).fill(t4, r4) : createBuffer(e4).fill(t4) : createBuffer(e4);
    }(e3, t3, r3);
  }, Buffer2.allocUnsafe = function(e3) {
    return allocUnsafe(e3);
  }, Buffer2.allocUnsafeSlow = function(e3) {
    return allocUnsafe(e3);
  }, Buffer2.isBuffer = function isBuffer(e3) {
    return null != e3 && true === e3._isBuffer && e3 !== Buffer2.prototype;
  }, Buffer2.compare = function compare2(e3, t3) {
    if (isInstance(e3, Uint8Array) && (e3 = Buffer2.from(e3, e3.offset, e3.byteLength)), isInstance(t3, Uint8Array) && (t3 = Buffer2.from(t3, t3.offset, t3.byteLength)), !Buffer2.isBuffer(e3) || !Buffer2.isBuffer(t3)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e3 === t3) return 0;
    let r3 = e3.length, n2 = t3.length;
    for (let a3 = 0, o5 = Math.min(r3, n2); a3 < o5; ++a3) if (e3[a3] !== t3[a3]) {
      r3 = e3[a3], n2 = t3[a3];
      break;
    }
    return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
  }, Buffer2.isEncoding = function isEncoding(e3) {
    switch (String(e3).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, Buffer2.concat = function concat4(e3, t3) {
    if (!Array.isArray(e3)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (0 === e3.length) return Buffer2.alloc(0);
    let r3;
    if (void 0 === t3) for (t3 = 0, r3 = 0; r3 < e3.length; ++r3) t3 += e3[r3].length;
    const n2 = Buffer2.allocUnsafe(t3);
    let a3 = 0;
    for (r3 = 0; r3 < e3.length; ++r3) {
      let t4 = e3[r3];
      if (isInstance(t4, Uint8Array)) a3 + t4.length > n2.length ? (Buffer2.isBuffer(t4) || (t4 = Buffer2.from(t4)), t4.copy(n2, a3)) : Uint8Array.prototype.set.call(n2, t4, a3);
      else {
        if (!Buffer2.isBuffer(t4)) throw new TypeError('"list" argument must be an Array of Buffers');
        t4.copy(n2, a3);
      }
      a3 += t4.length;
    }
    return n2;
  }, Buffer2.byteLength = byteLength, Buffer2.prototype._isBuffer = true, Buffer2.prototype.swap16 = function swap16() {
    const e3 = this.length;
    if (e3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t3 = 0; t3 < e3; t3 += 2) swap2(this, t3, t3 + 1);
    return this;
  }, Buffer2.prototype.swap32 = function swap32() {
    const e3 = this.length;
    if (e3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t3 = 0; t3 < e3; t3 += 4) swap2(this, t3, t3 + 3), swap2(this, t3 + 1, t3 + 2);
    return this;
  }, Buffer2.prototype.swap64 = function swap64() {
    const e3 = this.length;
    if (e3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let t3 = 0; t3 < e3; t3 += 8) swap2(this, t3, t3 + 7), swap2(this, t3 + 1, t3 + 6), swap2(this, t3 + 2, t3 + 5), swap2(this, t3 + 3, t3 + 4);
    return this;
  }, Buffer2.prototype.toString = function toString5() {
    const e3 = this.length;
    return 0 === e3 ? "" : 0 === arguments.length ? utf8Slice(this, 0, e3) : slowToString.apply(this, arguments);
  }, Buffer2.prototype.toLocaleString = Buffer2.prototype.toString, Buffer2.prototype.equals = function equals4(e3) {
    if (!Buffer2.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
    return this === e3 || 0 === Buffer2.compare(this, e3);
  }, Buffer2.prototype.inspect = function inspect() {
    let e3 = "";
    const r3 = t2.INSPECT_MAX_BYTES;
    return e3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (e3 += " ... "), "<Buffer " + e3 + ">";
  }, o4 && (Buffer2.prototype[o4] = Buffer2.prototype.inspect), Buffer2.prototype.compare = function compare2(e3, t3, r3, n2, a3) {
    if (isInstance(e3, Uint8Array) && (e3 = Buffer2.from(e3, e3.offset, e3.byteLength)), !Buffer2.isBuffer(e3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
    if (void 0 === t3 && (t3 = 0), void 0 === r3 && (r3 = e3 ? e3.length : 0), void 0 === n2 && (n2 = 0), void 0 === a3 && (a3 = this.length), t3 < 0 || r3 > e3.length || n2 < 0 || a3 > this.length) throw new RangeError("out of range index");
    if (n2 >= a3 && t3 >= r3) return 0;
    if (n2 >= a3) return -1;
    if (t3 >= r3) return 1;
    if (this === e3) return 0;
    let o5 = (a3 >>>= 0) - (n2 >>>= 0), s3 = (r3 >>>= 0) - (t3 >>>= 0);
    const l3 = Math.min(o5, s3), i3 = this.slice(n2, a3), c3 = e3.slice(t3, r3);
    for (let e4 = 0; e4 < l3; ++e4) if (i3[e4] !== c3[e4]) {
      o5 = i3[e4], s3 = c3[e4];
      break;
    }
    return o5 < s3 ? -1 : s3 < o5 ? 1 : 0;
  }, Buffer2.prototype.includes = function includes2(e3, t3, r3) {
    return -1 !== this.indexOf(e3, t3, r3);
  }, Buffer2.prototype.indexOf = function indexOf4(e3, t3, r3) {
    return bidirectionalIndexOf(this, e3, t3, r3, true);
  }, Buffer2.prototype.lastIndexOf = function lastIndexOf3(e3, t3, r3) {
    return bidirectionalIndexOf(this, e3, t3, r3, false);
  }, Buffer2.prototype.write = function write(e3, t3, r3, n2) {
    if (void 0 === t3) n2 = "utf8", r3 = this.length, t3 = 0;
    else if (void 0 === r3 && "string" == typeof t3) n2 = t3, r3 = this.length, t3 = 0;
    else {
      if (!isFinite(t3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      t3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r3, r3 = void 0);
    }
    const a3 = this.length - t3;
    if ((void 0 === r3 || r3 > a3) && (r3 = a3), e3.length > 0 && (r3 < 0 || t3 < 0) || t3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    n2 || (n2 = "utf8");
    let o5 = false;
    for (; ; ) switch (n2) {
      case "hex":
        return hexWrite(this, e3, t3, r3);
      case "utf8":
      case "utf-8":
        return utf8Write(this, e3, t3, r3);
      case "ascii":
      case "latin1":
      case "binary":
        return asciiWrite(this, e3, t3, r3);
      case "base64":
        return base64Write(this, e3, t3, r3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, e3, t3, r3);
      default:
        if (o5) throw new TypeError("Unknown encoding: " + n2);
        n2 = ("" + n2).toLowerCase(), o5 = true;
    }
  }, Buffer2.prototype.toJSON = function toJSON() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  const l2 = 4096;
  function asciiSlice(e3, t3, r3) {
    let n2 = "";
    r3 = Math.min(e3.length, r3);
    for (let a3 = t3; a3 < r3; ++a3) n2 += String.fromCharCode(127 & e3[a3]);
    return n2;
  }
  function latin1Slice(e3, t3, r3) {
    let n2 = "";
    r3 = Math.min(e3.length, r3);
    for (let a3 = t3; a3 < r3; ++a3) n2 += String.fromCharCode(e3[a3]);
    return n2;
  }
  function hexSlice(e3, t3, r3) {
    const n2 = e3.length;
    (!t3 || t3 < 0) && (t3 = 0), (!r3 || r3 < 0 || r3 > n2) && (r3 = n2);
    let a3 = "";
    for (let n3 = t3; n3 < r3; ++n3) a3 += u2[e3[n3]];
    return a3;
  }
  function utf16leSlice(e3, t3, r3) {
    const n2 = e3.slice(t3, r3);
    let a3 = "";
    for (let e4 = 0; e4 < n2.length - 1; e4 += 2) a3 += String.fromCharCode(n2[e4] + 256 * n2[e4 + 1]);
    return a3;
  }
  function checkOffset(e3, t3, r3) {
    if (e3 % 1 != 0 || e3 < 0) throw new RangeError("offset is not uint");
    if (e3 + t3 > r3) throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt(e3, t3, r3, n2, a3, o5) {
    if (!Buffer2.isBuffer(e3)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t3 > a3 || t3 < o5) throw new RangeError('"value" argument is out of bounds');
    if (r3 + n2 > e3.length) throw new RangeError("Index out of range");
  }
  function wrtBigUInt64LE(e3, t3, r3, n2, a3) {
    checkIntBI(t3, n2, a3, e3, r3, 7);
    let o5 = Number(t3 & BigInt(4294967295));
    e3[r3++] = o5, o5 >>= 8, e3[r3++] = o5, o5 >>= 8, e3[r3++] = o5, o5 >>= 8, e3[r3++] = o5;
    let s3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
    return e3[r3++] = s3, s3 >>= 8, e3[r3++] = s3, s3 >>= 8, e3[r3++] = s3, s3 >>= 8, e3[r3++] = s3, r3;
  }
  function wrtBigUInt64BE(e3, t3, r3, n2, a3) {
    checkIntBI(t3, n2, a3, e3, r3, 7);
    let o5 = Number(t3 & BigInt(4294967295));
    e3[r3 + 7] = o5, o5 >>= 8, e3[r3 + 6] = o5, o5 >>= 8, e3[r3 + 5] = o5, o5 >>= 8, e3[r3 + 4] = o5;
    let s3 = Number(t3 >> BigInt(32) & BigInt(4294967295));
    return e3[r3 + 3] = s3, s3 >>= 8, e3[r3 + 2] = s3, s3 >>= 8, e3[r3 + 1] = s3, s3 >>= 8, e3[r3] = s3, r3 + 8;
  }
  function checkIEEE754(e3, t3, r3, n2, a3, o5) {
    if (r3 + n2 > e3.length) throw new RangeError("Index out of range");
    if (r3 < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(e3, t3, r3, n2, o5) {
    return t3 = +t3, r3 >>>= 0, o5 || checkIEEE754(e3, 0, r3, 4), a2.write(e3, t3, r3, n2, 23, 4), r3 + 4;
  }
  function writeDouble(e3, t3, r3, n2, o5) {
    return t3 = +t3, r3 >>>= 0, o5 || checkIEEE754(e3, 0, r3, 8), a2.write(e3, t3, r3, n2, 52, 8), r3 + 8;
  }
  Buffer2.prototype.slice = function slice3(e3, t3) {
    const r3 = this.length;
    (e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t3 = void 0 === t3 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e3 && (t3 = e3);
    const n2 = this.subarray(e3, t3);
    return Object.setPrototypeOf(n2, Buffer2.prototype), n2;
  }, Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || checkOffset(e3, t3, this.length);
    let n2 = this[e3], a3 = 1, o5 = 0;
    for (; ++o5 < t3 && (a3 *= 256); ) n2 += this[e3 + o5] * a3;
    return n2;
  }, Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || checkOffset(e3, t3, this.length);
    let n2 = this[e3 + --t3], a3 = 1;
    for (; t3 > 0 && (a3 *= 256); ) n2 += this[e3 + --t3] * a3;
    return n2;
  }, Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 1, this.length), this[e3];
  }, Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
  }, Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
  }, Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
  }, Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
  }, Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(e3) {
    validateNumber(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || boundsError(e3, this.length - 8);
    const n2 = t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, a3 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + r3 * 2 ** 24;
    return BigInt(n2) + (BigInt(a3) << BigInt(32));
  }), Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(e3) {
    validateNumber(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || boundsError(e3, this.length - 8);
    const n2 = t3 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], a3 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3;
    return (BigInt(n2) << BigInt(32)) + BigInt(a3);
  }), Buffer2.prototype.readIntLE = function readIntLE(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || checkOffset(e3, t3, this.length);
    let n2 = this[e3], a3 = 1, o5 = 0;
    for (; ++o5 < t3 && (a3 *= 256); ) n2 += this[e3 + o5] * a3;
    return a3 *= 128, n2 >= a3 && (n2 -= Math.pow(2, 8 * t3)), n2;
  }, Buffer2.prototype.readIntBE = function readIntBE(e3, t3, r3) {
    e3 >>>= 0, t3 >>>= 0, r3 || checkOffset(e3, t3, this.length);
    let n2 = t3, a3 = 1, o5 = this[e3 + --n2];
    for (; n2 > 0 && (a3 *= 256); ) o5 += this[e3 + --n2] * a3;
    return a3 *= 128, o5 >= a3 && (o5 -= Math.pow(2, 8 * t3)), o5;
  }, Buffer2.prototype.readInt8 = function readInt8(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
  }, Buffer2.prototype.readInt16LE = function readInt16LE(e3, t3) {
    e3 >>>= 0, t3 || checkOffset(e3, 2, this.length);
    const r3 = this[e3] | this[e3 + 1] << 8;
    return 32768 & r3 ? 4294901760 | r3 : r3;
  }, Buffer2.prototype.readInt16BE = function readInt16BE(e3, t3) {
    e3 >>>= 0, t3 || checkOffset(e3, 2, this.length);
    const r3 = this[e3 + 1] | this[e3] << 8;
    return 32768 & r3 ? 4294901760 | r3 : r3;
  }, Buffer2.prototype.readInt32LE = function readInt32LE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
  }, Buffer2.prototype.readInt32BE = function readInt32BE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
  }, Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(e3) {
    validateNumber(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || boundsError(e3, this.length - 8);
    const n2 = this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (r3 << 24);
    return (BigInt(n2) << BigInt(32)) + BigInt(t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
  }), Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(e3) {
    validateNumber(e3 >>>= 0, "offset");
    const t3 = this[e3], r3 = this[e3 + 7];
    void 0 !== t3 && void 0 !== r3 || boundsError(e3, this.length - 8);
    const n2 = (t3 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
    return (BigInt(n2) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3);
  }), Buffer2.prototype.readFloatLE = function readFloatLE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), a2.read(this, e3, true, 23, 4);
  }, Buffer2.prototype.readFloatBE = function readFloatBE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 4, this.length), a2.read(this, e3, false, 23, 4);
  }, Buffer2.prototype.readDoubleLE = function readDoubleLE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 8, this.length), a2.read(this, e3, true, 52, 8);
  }, Buffer2.prototype.readDoubleBE = function readDoubleBE(e3, t3) {
    return e3 >>>= 0, t3 || checkOffset(e3, 8, this.length), a2.read(this, e3, false, 52, 8);
  }, Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(e3, t3, r3, n2) {
    if (e3 = +e3, t3 >>>= 0, r3 >>>= 0, !n2) {
      checkInt(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
    }
    let a3 = 1, o5 = 0;
    for (this[t3] = 255 & e3; ++o5 < r3 && (a3 *= 256); ) this[t3 + o5] = e3 / a3 & 255;
    return t3 + r3;
  }, Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(e3, t3, r3, n2) {
    if (e3 = +e3, t3 >>>= 0, r3 >>>= 0, !n2) {
      checkInt(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
    }
    let a3 = r3 - 1, o5 = 1;
    for (this[t3 + a3] = 255 & e3; --a3 >= 0 && (o5 *= 256); ) this[t3 + a3] = e3 / o5 & 255;
    return t3 + r3;
  }, Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
  }, Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
  }, Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
  }, Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
  }, Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
  }, Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(e3, t3 = 0) {
    return wrtBigUInt64LE(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(e3, t3 = 0) {
    return wrtBigUInt64BE(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
  }), Buffer2.prototype.writeIntLE = function writeIntLE(e3, t3, r3, n2) {
    if (e3 = +e3, t3 >>>= 0, !n2) {
      const n3 = Math.pow(2, 8 * r3 - 1);
      checkInt(this, e3, t3, r3, n3 - 1, -n3);
    }
    let a3 = 0, o5 = 1, s3 = 0;
    for (this[t3] = 255 & e3; ++a3 < r3 && (o5 *= 256); ) e3 < 0 && 0 === s3 && 0 !== this[t3 + a3 - 1] && (s3 = 1), this[t3 + a3] = (e3 / o5 | 0) - s3 & 255;
    return t3 + r3;
  }, Buffer2.prototype.writeIntBE = function writeIntBE(e3, t3, r3, n2) {
    if (e3 = +e3, t3 >>>= 0, !n2) {
      const n3 = Math.pow(2, 8 * r3 - 1);
      checkInt(this, e3, t3, r3, n3 - 1, -n3);
    }
    let a3 = r3 - 1, o5 = 1, s3 = 0;
    for (this[t3 + a3] = 255 & e3; --a3 >= 0 && (o5 *= 256); ) e3 < 0 && 0 === s3 && 0 !== this[t3 + a3 + 1] && (s3 = 1), this[t3 + a3] = (e3 / o5 | 0) - s3 & 255;
    return t3 + r3;
  }, Buffer2.prototype.writeInt8 = function writeInt8(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
  }, Buffer2.prototype.writeInt16LE = function writeInt16LE(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
  }, Buffer2.prototype.writeInt16BE = function writeInt16BE(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
  }, Buffer2.prototype.writeInt32LE = function writeInt32LE(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
  }, Buffer2.prototype.writeInt32BE = function writeInt32BE(e3, t3, r3) {
    return e3 = +e3, t3 >>>= 0, r3 || checkInt(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
  }, Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(e3, t3 = 0) {
    return wrtBigUInt64LE(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(e3, t3 = 0) {
    return wrtBigUInt64BE(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), Buffer2.prototype.writeFloatLE = function writeFloatLE(e3, t3, r3) {
    return writeFloat(this, e3, t3, true, r3);
  }, Buffer2.prototype.writeFloatBE = function writeFloatBE(e3, t3, r3) {
    return writeFloat(this, e3, t3, false, r3);
  }, Buffer2.prototype.writeDoubleLE = function writeDoubleLE(e3, t3, r3) {
    return writeDouble(this, e3, t3, true, r3);
  }, Buffer2.prototype.writeDoubleBE = function writeDoubleBE(e3, t3, r3) {
    return writeDouble(this, e3, t3, false, r3);
  }, Buffer2.prototype.copy = function copy3(e3, t3, r3, n2) {
    if (!Buffer2.isBuffer(e3)) throw new TypeError("argument should be a Buffer");
    if (r3 || (r3 = 0), n2 || 0 === n2 || (n2 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), n2 > 0 && n2 < r3 && (n2 = r3), n2 === r3) return 0;
    if (0 === e3.length || 0 === this.length) return 0;
    if (t3 < 0) throw new RangeError("targetStart out of bounds");
    if (r3 < 0 || r3 >= this.length) throw new RangeError("Index out of range");
    if (n2 < 0) throw new RangeError("sourceEnd out of bounds");
    n2 > this.length && (n2 = this.length), e3.length - t3 < n2 - r3 && (n2 = e3.length - t3 + r3);
    const a3 = n2 - r3;
    return this === e3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t3, r3, n2) : Uint8Array.prototype.set.call(e3, this.subarray(r3, n2), t3), a3;
  }, Buffer2.prototype.fill = function fill(e3, t3, r3, n2) {
    if ("string" == typeof e3) {
      if ("string" == typeof t3 ? (n2 = t3, t3 = 0, r3 = this.length) : "string" == typeof r3 && (n2 = r3, r3 = this.length), void 0 !== n2 && "string" != typeof n2) throw new TypeError("encoding must be a string");
      if ("string" == typeof n2 && !Buffer2.isEncoding(n2)) throw new TypeError("Unknown encoding: " + n2);
      if (1 === e3.length) {
        const t4 = e3.charCodeAt(0);
        ("utf8" === n2 && t4 < 128 || "latin1" === n2) && (e3 = t4);
      }
    } else "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
    if (t3 < 0 || this.length < t3 || this.length < r3) throw new RangeError("Out of range index");
    if (r3 <= t3) return this;
    let a3;
    if (t3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, e3 || (e3 = 0), "number" == typeof e3) for (a3 = t3; a3 < r3; ++a3) this[a3] = e3;
    else {
      const o5 = Buffer2.isBuffer(e3) ? e3 : Buffer2.from(e3, n2), s3 = o5.length;
      if (0 === s3) throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
      for (a3 = 0; a3 < r3 - t3; ++a3) this[a3 + t3] = o5[a3 % s3];
    }
    return this;
  };
  const i2 = {};
  function E(e3, t3, r3) {
    i2[e3] = class NodeError extends r3 {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: t3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, this.stack, delete this.name;
      }
      get code() {
        return e3;
      }
      set code(e4) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
      }
      toString() {
        return `${this.name} [${e3}]: ${this.message}`;
      }
    };
  }
  function addNumericalSeparator(e3) {
    let t3 = "", r3 = e3.length;
    const n2 = "-" === e3[0] ? 1 : 0;
    for (; r3 >= n2 + 4; r3 -= 3) t3 = `_${e3.slice(r3 - 3, r3)}${t3}`;
    return `${e3.slice(0, r3)}${t3}`;
  }
  function checkIntBI(e3, t3, r3, n2, a3, o5) {
    if (e3 > r3 || e3 < t3) {
      const n3 = "bigint" == typeof t3 ? "n" : "";
      let a4;
      throw a4 = o5 > 3 ? 0 === t3 || t3 === BigInt(0) ? `>= 0${n3} and < 2${n3} ** ${8 * (o5 + 1)}${n3}` : `>= -(2${n3} ** ${8 * (o5 + 1) - 1}${n3}) and < 2 ** ${8 * (o5 + 1) - 1}${n3}` : `>= ${t3}${n3} and <= ${r3}${n3}`, new i2.ERR_OUT_OF_RANGE("value", a4, e3);
    }
    !function checkBounds(e4, t4, r4) {
      validateNumber(t4, "offset"), void 0 !== e4[t4] && void 0 !== e4[t4 + r4] || boundsError(t4, e4.length - (r4 + 1));
    }(n2, a3, o5);
  }
  function validateNumber(e3, t3) {
    if ("number" != typeof e3) throw new i2.ERR_INVALID_ARG_TYPE(t3, "number", e3);
  }
  function boundsError(e3, t3, r3) {
    if (Math.floor(e3) !== e3) throw validateNumber(e3, r3), new i2.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", e3);
    if (t3 < 0) throw new i2.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new i2.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${t3}`, e3);
  }
  E("ERR_BUFFER_OUT_OF_BOUNDS", function(e3) {
    return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError), E("ERR_INVALID_ARG_TYPE", function(e3, t3) {
    return `The "${e3}" argument must be of type number. Received type ${typeof t3}`;
  }, TypeError), E("ERR_OUT_OF_RANGE", function(e3, t3, r3) {
    let n2 = `The value of "${e3}" is out of range.`, a3 = r3;
    return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? a3 = addNumericalSeparator(String(r3)) : "bigint" == typeof r3 && (a3 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (a3 = addNumericalSeparator(a3)), a3 += "n"), n2 += ` It must be ${t3}. Received ${a3}`, n2;
  }, RangeError);
  const c2 = /[^+/0-9A-Za-z-_]/g;
  function utf8ToBytes(e3, t3) {
    let r3;
    t3 = t3 || 1 / 0;
    const n2 = e3.length;
    let a3 = null;
    const o5 = [];
    for (let s3 = 0; s3 < n2; ++s3) {
      if (r3 = e3.charCodeAt(s3), r3 > 55295 && r3 < 57344) {
        if (!a3) {
          if (r3 > 56319) {
            (t3 -= 3) > -1 && o5.push(239, 191, 189);
            continue;
          }
          if (s3 + 1 === n2) {
            (t3 -= 3) > -1 && o5.push(239, 191, 189);
            continue;
          }
          a3 = r3;
          continue;
        }
        if (r3 < 56320) {
          (t3 -= 3) > -1 && o5.push(239, 191, 189), a3 = r3;
          continue;
        }
        r3 = 65536 + (a3 - 55296 << 10 | r3 - 56320);
      } else a3 && (t3 -= 3) > -1 && o5.push(239, 191, 189);
      if (a3 = null, r3 < 128) {
        if ((t3 -= 1) < 0) break;
        o5.push(r3);
      } else if (r3 < 2048) {
        if ((t3 -= 2) < 0) break;
        o5.push(r3 >> 6 | 192, 63 & r3 | 128);
      } else if (r3 < 65536) {
        if ((t3 -= 3) < 0) break;
        o5.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
      } else {
        if (!(r3 < 1114112)) throw new Error("Invalid code point");
        if ((t3 -= 4) < 0) break;
        o5.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
      }
    }
    return o5;
  }
  function base64ToBytes(e3) {
    return n.toByteArray(function base64clean(e4) {
      if ((e4 = (e4 = e4.split("=")[0]).trim().replace(c2, "")).length < 2) return "";
      for (; e4.length % 4 != 0; ) e4 += "=";
      return e4;
    }(e3));
  }
  function blitBuffer(e3, t3, r3, n2) {
    let a3;
    for (a3 = 0; a3 < n2 && !(a3 + r3 >= t3.length || a3 >= e3.length); ++a3) t3[a3 + r3] = e3[a3];
    return a3;
  }
  function isInstance(e3, t3) {
    return e3 instanceof t3 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t3.name;
  }
  function numberIsNaN(e3) {
    return e3 != e3;
  }
  const u2 = function() {
    const e3 = "0123456789abcdef", t3 = new Array(256);
    for (let r3 = 0; r3 < 16; ++r3) {
      const n2 = 16 * r3;
      for (let a3 = 0; a3 < 16; ++a3) t3[n2 + a3] = e3[r3] + e3[a3];
    }
    return t3;
  }();
  function defineBigIntMethod(e3) {
    return "undefined" == typeof BigInt ? BufferBigIntNotDefined : e3;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
}, 919: function(e2, t2, r2) {
  var n = r2(287).Buffer;
  function isSpecificValue(e3) {
    return e3 instanceof n || e3 instanceof Date || e3 instanceof RegExp;
  }
  function cloneSpecificValue(e3) {
    if (e3 instanceof n) {
      var t3 = n.alloc ? n.alloc(e3.length) : new n(e3.length);
      return e3.copy(t3), t3;
    }
    if (e3 instanceof Date) return new Date(e3.getTime());
    if (e3 instanceof RegExp) return new RegExp(e3);
    throw new Error("Unexpected situation");
  }
  function deepCloneArray(e3) {
    var t3 = [];
    return e3.forEach(function(e4, r3) {
      "object" == typeof e4 && null !== e4 ? Array.isArray(e4) ? t3[r3] = deepCloneArray(e4) : isSpecificValue(e4) ? t3[r3] = cloneSpecificValue(e4) : t3[r3] = a2({}, e4) : t3[r3] = e4;
    }), t3;
  }
  function safeGetProperty(e3, t3) {
    return "__proto__" === t3 ? void 0 : e3[t3];
  }
  var a2 = e2.exports = function() {
    if (arguments.length < 1 || "object" != typeof arguments[0]) return false;
    if (arguments.length < 2) return arguments[0];
    var e3, t3, r3 = arguments[0];
    return Array.prototype.slice.call(arguments, 1).forEach(function(n2) {
      "object" != typeof n2 || null === n2 || Array.isArray(n2) || Object.keys(n2).forEach(function(o4) {
        return t3 = safeGetProperty(r3, o4), (e3 = safeGetProperty(n2, o4)) === r3 ? void 0 : "object" != typeof e3 || null === e3 ? void (r3[o4] = e3) : Array.isArray(e3) ? void (r3[o4] = deepCloneArray(e3)) : isSpecificValue(e3) ? void (r3[o4] = cloneSpecificValue(e3)) : "object" != typeof t3 || null === t3 || Array.isArray(t3) ? void (r3[o4] = a2({}, e3)) : void (r3[o4] = a2(t3, e3));
      });
    }), r3;
  };
}, 7: function(e2) {
  var t2, r2 = "object" == typeof Reflect ? Reflect : null, n = r2 && "function" == typeof r2.apply ? r2.apply : function ReflectApply(e3, t3, r3) {
    return Function.prototype.apply.call(e3, t3, r3);
  };
  t2 = r2 && "function" == typeof r2.ownKeys ? r2.ownKeys : Object.getOwnPropertySymbols ? function ReflectOwnKeys(e3) {
    return Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3));
  } : function ReflectOwnKeys(e3) {
    return Object.getOwnPropertyNames(e3);
  };
  var a2 = Number.isNaN || function NumberIsNaN(e3) {
    return e3 != e3;
  };
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  e2.exports = EventEmitter, e2.exports.once = function once3(e3, t3) {
    return new Promise(function(r3, n2) {
      function errorListener(r4) {
        e3.removeListener(t3, resolver2), n2(r4);
      }
      function resolver2() {
        "function" == typeof e3.removeListener && e3.removeListener("error", errorListener), r3([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(e3, t3, resolver2, { once: true }), "error" !== t3 && function addErrorHandlerIfEventEmitter(e4, t4, r4) {
        "function" == typeof e4.on && eventTargetAgnosticAddListener(e4, "error", t4, r4);
      }(e3, errorListener, { once: true });
    });
  }, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, EventEmitter.prototype._eventsCount = 0, EventEmitter.prototype._maxListeners = void 0;
  var o4 = 10;
  function checkListener(e3) {
    if ("function" != typeof e3) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e3);
  }
  function _getMaxListeners(e3) {
    return void 0 === e3._maxListeners ? EventEmitter.defaultMaxListeners : e3._maxListeners;
  }
  function _addListener(e3, t3, r3, n2) {
    var a3, o5, s2;
    if (checkListener(r3), void 0 === (o5 = e3._events) ? (o5 = e3._events = /* @__PURE__ */ Object.create(null), e3._eventsCount = 0) : (void 0 !== o5.newListener && (e3.emit("newListener", t3, r3.listener ? r3.listener : r3), o5 = e3._events), s2 = o5[t3]), void 0 === s2) s2 = o5[t3] = r3, ++e3._eventsCount;
    else if ("function" == typeof s2 ? s2 = o5[t3] = n2 ? [r3, s2] : [s2, r3] : n2 ? s2.unshift(r3) : s2.push(r3), (a3 = _getMaxListeners(e3)) > 0 && s2.length > a3 && !s2.warned) {
      s2.warned = true;
      var l2 = new Error("Possible EventEmitter memory leak detected. " + s2.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      l2.name = "MaxListenersExceededWarning", l2.emitter = e3, l2.type = t3, l2.count = s2.length, function ProcessEmitWarning(e4) {
        console && console.warn && console.warn(e4);
      }(l2);
    }
    return e3;
  }
  function onceWrapper() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function _onceWrap(e3, t3, r3) {
    var n2 = { fired: false, wrapFn: void 0, target: e3, type: t3, listener: r3 }, a3 = onceWrapper.bind(n2);
    return a3.listener = r3, n2.wrapFn = a3, a3;
  }
  function _listeners(e3, t3, r3) {
    var n2 = e3._events;
    if (void 0 === n2) return [];
    var a3 = n2[t3];
    return void 0 === a3 ? [] : "function" == typeof a3 ? r3 ? [a3.listener || a3] : [a3] : r3 ? function unwrapListeners(e4) {
      for (var t4 = new Array(e4.length), r4 = 0; r4 < t4.length; ++r4) t4[r4] = e4[r4].listener || e4[r4];
      return t4;
    }(a3) : arrayClone(a3, a3.length);
  }
  function listenerCount(e3) {
    var t3 = this._events;
    if (void 0 !== t3) {
      var r3 = t3[e3];
      if ("function" == typeof r3) return 1;
      if (void 0 !== r3) return r3.length;
    }
    return 0;
  }
  function arrayClone(e3, t3) {
    for (var r3 = new Array(t3), n2 = 0; n2 < t3; ++n2) r3[n2] = e3[n2];
    return r3;
  }
  function eventTargetAgnosticAddListener(e3, t3, r3, n2) {
    if ("function" == typeof e3.on) n2.once ? e3.once(t3, r3) : e3.on(t3, r3);
    else {
      if ("function" != typeof e3.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e3);
      e3.addEventListener(t3, function wrapListener(a3) {
        n2.once && e3.removeEventListener(t3, wrapListener), r3(a3);
      });
    }
  }
  Object.defineProperty(EventEmitter, "defaultMaxListeners", { enumerable: true, get: function() {
    return o4;
  }, set: function(e3) {
    if ("number" != typeof e3 || e3 < 0 || a2(e3)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e3 + ".");
    o4 = e3;
  } }), EventEmitter.init = function() {
    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, EventEmitter.prototype.setMaxListeners = function setMaxListeners(e3) {
    if ("number" != typeof e3 || e3 < 0 || a2(e3)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
    return this._maxListeners = e3, this;
  }, EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  }, EventEmitter.prototype.emit = function emit(e3) {
    for (var t3 = [], r3 = 1; r3 < arguments.length; r3++) t3.push(arguments[r3]);
    var a3 = "error" === e3, o5 = this._events;
    if (void 0 !== o5) a3 = a3 && void 0 === o5.error;
    else if (!a3) return false;
    if (a3) {
      var s2;
      if (t3.length > 0 && (s2 = t3[0]), s2 instanceof Error) throw s2;
      var l2 = new Error("Unhandled error." + (s2 ? " (" + s2.message + ")" : ""));
      throw l2.context = s2, l2;
    }
    var i2 = o5[e3];
    if (void 0 === i2) return false;
    if ("function" == typeof i2) n(i2, this, t3);
    else {
      var c2 = i2.length, u2 = arrayClone(i2, c2);
      for (r3 = 0; r3 < c2; ++r3) n(u2[r3], this, t3);
    }
    return true;
  }, EventEmitter.prototype.addListener = function addListener(e3, t3) {
    return _addListener(this, e3, t3, false);
  }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.prependListener = function prependListener(e3, t3) {
    return _addListener(this, e3, t3, true);
  }, EventEmitter.prototype.once = function once3(e3, t3) {
    return checkListener(t3), this.on(e3, _onceWrap(this, e3, t3)), this;
  }, EventEmitter.prototype.prependOnceListener = function prependOnceListener(e3, t3) {
    return checkListener(t3), this.prependListener(e3, _onceWrap(this, e3, t3)), this;
  }, EventEmitter.prototype.removeListener = function removeListener(e3, t3) {
    var r3, n2, a3, o5, s2;
    if (checkListener(t3), void 0 === (n2 = this._events)) return this;
    if (void 0 === (r3 = n2[e3])) return this;
    if (r3 === t3 || r3.listener === t3) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete n2[e3], n2.removeListener && this.emit("removeListener", e3, r3.listener || t3));
    else if ("function" != typeof r3) {
      for (a3 = -1, o5 = r3.length - 1; o5 >= 0; o5--) if (r3[o5] === t3 || r3[o5].listener === t3) {
        s2 = r3[o5].listener, a3 = o5;
        break;
      }
      if (a3 < 0) return this;
      0 === a3 ? r3.shift() : function spliceOne(e4, t4) {
        for (; t4 + 1 < e4.length; t4++) e4[t4] = e4[t4 + 1];
        e4.pop();
      }(r3, a3), 1 === r3.length && (n2[e3] = r3[0]), void 0 !== n2.removeListener && this.emit("removeListener", e3, s2 || t3);
    }
    return this;
  }, EventEmitter.prototype.off = EventEmitter.prototype.removeListener, EventEmitter.prototype.removeAllListeners = function removeAllListeners(e3) {
    var t3, r3, n2;
    if (void 0 === (r3 = this._events)) return this;
    if (void 0 === r3.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r3[e3] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r3[e3]), this;
    if (0 === arguments.length) {
      var a3, o5 = Object.keys(r3);
      for (n2 = 0; n2 < o5.length; ++n2) "removeListener" !== (a3 = o5[n2]) && this.removeAllListeners(a3);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if ("function" == typeof (t3 = r3[e3])) this.removeListener(e3, t3);
    else if (void 0 !== t3) for (n2 = t3.length - 1; n2 >= 0; n2--) this.removeListener(e3, t3[n2]);
    return this;
  }, EventEmitter.prototype.listeners = function listeners(e3) {
    return _listeners(this, e3, true);
  }, EventEmitter.prototype.rawListeners = function rawListeners(e3) {
    return _listeners(this, e3, false);
  }, EventEmitter.listenerCount = function(e3, t3) {
    return "function" == typeof e3.listenerCount ? e3.listenerCount(t3) : listenerCount.call(e3, t3);
  }, EventEmitter.prototype.listenerCount = listenerCount, EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? t2(this._events) : [];
  };
}, 698: function(e2) {
  "function" == typeof Object.create ? e2.exports = function inherits(e3, t2) {
    t2 && (e3.super_ = t2, e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }));
  } : e2.exports = function inherits(e3, t2) {
    if (t2) {
      e3.super_ = t2;
      var TempCtor = function() {
      };
      TempCtor.prototype = t2.prototype, e3.prototype = new TempCtor(), e3.prototype.constructor = e3;
    }
  };
}, 606: function(e2) {
  var t2, r2, n = e2.exports = {};
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  function runTimeout(e3) {
    if (t2 === setTimeout) return setTimeout(e3, 0);
    if ((t2 === defaultSetTimout || !t2) && setTimeout) return t2 = setTimeout, setTimeout(e3, 0);
    try {
      return t2(e3, 0);
    } catch (r3) {
      try {
        return t2.call(null, e3, 0);
      } catch (r4) {
        return t2.call(this, e3, 0);
      }
    }
  }
  !function() {
    try {
      t2 = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
    } catch (e3) {
      t2 = defaultSetTimout;
    }
    try {
      r2 = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
    } catch (e3) {
      r2 = defaultClearTimeout;
    }
  }();
  var a2, o4 = [], s2 = false, l2 = -1;
  function cleanUpNextTick() {
    s2 && a2 && (s2 = false, a2.length ? o4 = a2.concat(o4) : l2 = -1, o4.length && drainQueue());
  }
  function drainQueue() {
    if (!s2) {
      var e3 = runTimeout(cleanUpNextTick);
      s2 = true;
      for (var t3 = o4.length; t3; ) {
        for (a2 = o4, o4 = []; ++l2 < t3; ) a2 && a2[l2].run();
        l2 = -1, t3 = o4.length;
      }
      a2 = null, s2 = false, function runClearTimeout(e4) {
        if (r2 === clearTimeout) return clearTimeout(e4);
        if ((r2 === defaultClearTimeout || !r2) && clearTimeout) return r2 = clearTimeout, clearTimeout(e4);
        try {
          return r2(e4);
        } catch (t4) {
          try {
            return r2.call(null, e4);
          } catch (t5) {
            return r2.call(this, e4);
          }
        }
      }(e3);
    }
  }
  function Item(e3, t3) {
    this.fun = e3, this.array = t3;
  }
  function noop3() {
  }
  n.nextTick = function(e3) {
    var t3 = new Array(arguments.length - 1);
    if (arguments.length > 1) for (var r3 = 1; r3 < arguments.length; r3++) t3[r3 - 1] = arguments[r3];
    o4.push(new Item(e3, t3)), 1 !== o4.length || s2 || runTimeout(drainQueue);
  }, Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  }, n.title = "browser", n.browser = true, n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = noop3, n.addListener = noop3, n.once = noop3, n.off = noop3, n.removeListener = noop3, n.removeAllListeners = noop3, n.emit = noop3, n.prependListener = noop3, n.prependOnceListener = noop3, n.listeners = function(e3) {
    return [];
  }, n.binding = function(e3) {
    throw new Error("process.binding is not supported");
  }, n.cwd = function() {
    return "/";
  }, n.chdir = function(e3) {
    throw new Error("process.chdir is not supported");
  }, n.umask = function() {
    return 0;
  };
}, 209: function(e2, t2, r2) {
  var n = r2(606), a2 = 65536, o4 = 4294967295;
  var s2 = r2(861).Buffer, l2 = r2.g.crypto || r2.g.msCrypto;
  l2 && l2.getRandomValues ? e2.exports = function randomBytes(e3, t3) {
    if (e3 > o4) throw new RangeError("requested too many random bytes");
    var r3 = s2.allocUnsafe(e3);
    if (e3 > 0) if (e3 > a2) for (var i2 = 0; i2 < e3; i2 += a2) l2.getRandomValues(r3.slice(i2, i2 + a2));
    else l2.getRandomValues(r3);
    if ("function" == typeof t3) return n.nextTick(function() {
      t3(null, r3);
    });
    return r3;
  } : e2.exports = function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
  };
}, 48: function(e2) {
  var t2 = {};
  function createErrorType(e3, r2, n) {
    n || (n = Error);
    var a2 = function(e4) {
      function NodeError(t3, n2, a3) {
        return e4.call(this, function getMessage(e5, t4, n3) {
          return "string" == typeof r2 ? r2 : r2(e5, t4, n3);
        }(t3, n2, a3)) || this;
      }
      return function _inheritsLoose(e5, t3) {
        e5.prototype = Object.create(t3.prototype), e5.prototype.constructor = e5, e5.__proto__ = t3;
      }(NodeError, e4), NodeError;
    }(n);
    a2.prototype.name = n.name, a2.prototype.code = e3, t2[e3] = a2;
  }
  function oneOf(e3, t3) {
    if (Array.isArray(e3)) {
      var r2 = e3.length;
      return e3 = e3.map(function(e4) {
        return String(e4);
      }), r2 > 2 ? "one of ".concat(t3, " ").concat(e3.slice(0, r2 - 1).join(", "), ", or ") + e3[r2 - 1] : 2 === r2 ? "one of ".concat(t3, " ").concat(e3[0], " or ").concat(e3[1]) : "of ".concat(t3, " ").concat(e3[0]);
    }
    return "of ".concat(t3, " ").concat(String(e3));
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(e3, t3) {
    return 'The value "' + t3 + '" is invalid for option "' + e3 + '"';
  }, TypeError), createErrorType("ERR_INVALID_ARG_TYPE", function(e3, t3, r2) {
    var n, a2;
    if ("string" == typeof t3 && function startsWith2(e4, t4, r3) {
      return e4.substr(!r3 || r3 < 0 ? 0 : +r3, t4.length) === t4;
    }(t3, "not ") ? (n = "must not be", t3 = t3.replace(/^not /, "")) : n = "must be", function endsWith2(e4, t4, r3) {
      return (void 0 === r3 || r3 > e4.length) && (r3 = e4.length), e4.substring(r3 - t4.length, r3) === t4;
    }(e3, " argument")) a2 = "The ".concat(e3, " ").concat(n, " ").concat(oneOf(t3, "type"));
    else {
      var o4 = function includes2(e4, t4, r3) {
        return "number" != typeof r3 && (r3 = 0), !(r3 + t4.length > e4.length) && -1 !== e4.indexOf(t4, r3);
      }(e3, ".") ? "property" : "argument";
      a2 = 'The "'.concat(e3, '" ').concat(o4, " ").concat(n, " ").concat(oneOf(t3, "type"));
    }
    return a2 += ". Received type ".concat(typeof r2);
  }, TypeError), createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(e3) {
    return "The " + e3 + " method is not implemented";
  }), createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), createErrorType("ERR_STREAM_DESTROYED", function(e3) {
    return "Cannot call " + e3 + " after a stream was destroyed";
  }), createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end"), createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), createErrorType("ERR_UNKNOWN_ENCODING", function(e3) {
    return "Unknown encoding: " + e3;
  }, TypeError), createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e2.exports.F = t2;
}, 382: function(e2, t2, r2) {
  var n = r2(606), a2 = Object.keys || function(e3) {
    var t3 = [];
    for (var r3 in e3) t3.push(r3);
    return t3;
  };
  e2.exports = Duplex;
  var o4 = r2(412), s2 = r2(708);
  r2(698)(Duplex, o4);
  for (var l2 = a2(s2.prototype), i2 = 0; i2 < l2.length; i2++) {
    var c2 = l2[i2];
    Duplex.prototype[c2] || (Duplex.prototype[c2] = s2.prototype[c2]);
  }
  function Duplex(e3) {
    if (!(this instanceof Duplex)) return new Duplex(e3);
    o4.call(this, e3), s2.call(this, e3), this.allowHalfOpen = true, e3 && (false === e3.readable && (this.readable = false), false === e3.writable && (this.writable = false), false === e3.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", onend)));
  }
  function onend() {
    this._writableState.ended || n.nextTick(onEndNT, this);
  }
  function onEndNT(e3) {
    e3.end();
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", { enumerable: false, get: function get3() {
    return this._writableState.highWaterMark;
  } }), Object.defineProperty(Duplex.prototype, "writableBuffer", { enumerable: false, get: function get3() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(Duplex.prototype, "writableLength", { enumerable: false, get: function get3() {
    return this._writableState.length;
  } }), Object.defineProperty(Duplex.prototype, "destroyed", { enumerable: false, get: function get3() {
    return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
  }, set: function set4(e3) {
    void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e3, this._writableState.destroyed = e3);
  } });
}, 600: function(e2, t2, r2) {
  e2.exports = PassThrough;
  var n = r2(610);
  function PassThrough(e3) {
    if (!(this instanceof PassThrough)) return new PassThrough(e3);
    n.call(this, e3);
  }
  r2(698)(PassThrough, n), PassThrough.prototype._transform = function(e3, t3, r3) {
    r3(null, e3);
  };
}, 412: function(e2, t2, r2) {
  var n, a2 = r2(606);
  e2.exports = Readable, Readable.ReadableState = ReadableState;
  r2(7).EventEmitter;
  var o4 = function EElistenerCount(e3, t3) {
    return e3.listeners(t3).length;
  }, s2 = r2(345), l2 = r2(287).Buffer, i2 = (void 0 !== r2.g ? r2.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var c2, u2 = r2(838);
  c2 = u2 && u2.debuglog ? u2.debuglog("stream") : function debug() {
  };
  var d2, p2, m2, f2 = r2(726), h2 = r2(896), g2 = r2(291).getHighWaterMark, y2 = r2(48).F, S = y2.ERR_INVALID_ARG_TYPE, _2 = y2.ERR_STREAM_PUSH_AFTER_EOF, v2 = y2.ERR_METHOD_NOT_IMPLEMENTED, b = y2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  r2(698)(Readable, s2);
  var w2 = h2.errorOrDestroy, C2 = ["error", "close", "destroy", "pause", "resume"];
  function ReadableState(e3, t3, a3) {
    n = n || r2(382), e3 = e3 || {}, "boolean" != typeof a3 && (a3 = t3 instanceof n), this.objectMode = !!e3.objectMode, a3 && (this.objectMode = this.objectMode || !!e3.readableObjectMode), this.highWaterMark = g2(this, e3, "readableHighWaterMark", a3), this.buffer = new f2(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== e3.emitClose, this.autoDestroy = !!e3.autoDestroy, this.destroyed = false, this.defaultEncoding = e3.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e3.encoding && (d2 || (d2 = r2(141).I), this.decoder = new d2(e3.encoding), this.encoding = e3.encoding);
  }
  function Readable(e3) {
    if (n = n || r2(382), !(this instanceof Readable)) return new Readable(e3);
    var t3 = this instanceof n;
    this._readableState = new ReadableState(e3, this, t3), this.readable = true, e3 && ("function" == typeof e3.read && (this._read = e3.read), "function" == typeof e3.destroy && (this._destroy = e3.destroy)), s2.call(this);
  }
  function readableAddChunk(e3, t3, r3, n2, a3) {
    c2("readableAddChunk", t3);
    var o5, s3 = e3._readableState;
    if (null === t3) s3.reading = false, function onEofChunk(e4, t4) {
      if (c2("onEofChunk"), t4.ended) return;
      if (t4.decoder) {
        var r4 = t4.decoder.end();
        r4 && r4.length && (t4.buffer.push(r4), t4.length += t4.objectMode ? 1 : r4.length);
      }
      t4.ended = true, t4.sync ? emitReadable(e4) : (t4.needReadable = false, t4.emittedReadable || (t4.emittedReadable = true, emitReadable_(e4)));
    }(e3, s3);
    else if (a3 || (o5 = function chunkInvalid(e4, t4) {
      var r4;
      (function _isUint8Array(e5) {
        return l2.isBuffer(e5) || e5 instanceof i2;
      })(t4) || "string" == typeof t4 || void 0 === t4 || e4.objectMode || (r4 = new S("chunk", ["string", "Buffer", "Uint8Array"], t4));
      return r4;
    }(s3, t3)), o5) w2(e3, o5);
    else if (s3.objectMode || t3 && t3.length > 0) if ("string" == typeof t3 || s3.objectMode || Object.getPrototypeOf(t3) === l2.prototype || (t3 = function _uint8ArrayToBuffer(e4) {
      return l2.from(e4);
    }(t3)), n2) s3.endEmitted ? w2(e3, new b()) : addChunk(e3, s3, t3, true);
    else if (s3.ended) w2(e3, new _2());
    else {
      if (s3.destroyed) return false;
      s3.reading = false, s3.decoder && !r3 ? (t3 = s3.decoder.write(t3), s3.objectMode || 0 !== t3.length ? addChunk(e3, s3, t3, false) : maybeReadMore(e3, s3)) : addChunk(e3, s3, t3, false);
    }
    else n2 || (s3.reading = false, maybeReadMore(e3, s3));
    return !s3.ended && (s3.length < s3.highWaterMark || 0 === s3.length);
  }
  function addChunk(e3, t3, r3, n2) {
    t3.flowing && 0 === t3.length && !t3.sync ? (t3.awaitDrain = 0, e3.emit("data", r3)) : (t3.length += t3.objectMode ? 1 : r3.length, n2 ? t3.buffer.unshift(r3) : t3.buffer.push(r3), t3.needReadable && emitReadable(e3)), maybeReadMore(e3, t3);
  }
  Object.defineProperty(Readable.prototype, "destroyed", { enumerable: false, get: function get3() {
    return void 0 !== this._readableState && this._readableState.destroyed;
  }, set: function set4(e3) {
    this._readableState && (this._readableState.destroyed = e3);
  } }), Readable.prototype.destroy = h2.destroy, Readable.prototype._undestroy = h2.undestroy, Readable.prototype._destroy = function(e3, t3) {
    t3(e3);
  }, Readable.prototype.push = function(e3, t3) {
    var r3, n2 = this._readableState;
    return n2.objectMode ? r3 = true : "string" == typeof e3 && ((t3 = t3 || n2.defaultEncoding) !== n2.encoding && (e3 = l2.from(e3, t3), t3 = ""), r3 = true), readableAddChunk(this, e3, t3, false, r3);
  }, Readable.prototype.unshift = function(e3) {
    return readableAddChunk(this, e3, null, true, false);
  }, Readable.prototype.isPaused = function() {
    return false === this._readableState.flowing;
  }, Readable.prototype.setEncoding = function(e3) {
    d2 || (d2 = r2(141).I);
    var t3 = new d2(e3);
    this._readableState.decoder = t3, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var n2 = this._readableState.buffer.head, a3 = ""; null !== n2; ) a3 += t3.write(n2.data), n2 = n2.next;
    return this._readableState.buffer.clear(), "" !== a3 && this._readableState.buffer.push(a3), this._readableState.length = a3.length, this;
  };
  var x2 = 1073741824;
  function howMuchToRead(e3, t3) {
    return e3 <= 0 || 0 === t3.length && t3.ended ? 0 : t3.objectMode ? 1 : e3 != e3 ? t3.flowing && t3.length ? t3.buffer.head.data.length : t3.length : (e3 > t3.highWaterMark && (t3.highWaterMark = function computeNewHighWaterMark(e4) {
      return e4 >= x2 ? e4 = x2 : (e4--, e4 |= e4 >>> 1, e4 |= e4 >>> 2, e4 |= e4 >>> 4, e4 |= e4 >>> 8, e4 |= e4 >>> 16, e4++), e4;
    }(e3)), e3 <= t3.length ? e3 : t3.ended ? t3.length : (t3.needReadable = true, 0));
  }
  function emitReadable(e3) {
    var t3 = e3._readableState;
    c2("emitReadable", t3.needReadable, t3.emittedReadable), t3.needReadable = false, t3.emittedReadable || (c2("emitReadable", t3.flowing), t3.emittedReadable = true, a2.nextTick(emitReadable_, e3));
  }
  function emitReadable_(e3) {
    var t3 = e3._readableState;
    c2("emitReadable_", t3.destroyed, t3.length, t3.ended), t3.destroyed || !t3.length && !t3.ended || (e3.emit("readable"), t3.emittedReadable = false), t3.needReadable = !t3.flowing && !t3.ended && t3.length <= t3.highWaterMark, flow3(e3);
  }
  function maybeReadMore(e3, t3) {
    t3.readingMore || (t3.readingMore = true, a2.nextTick(maybeReadMore_, e3, t3));
  }
  function maybeReadMore_(e3, t3) {
    for (; !t3.reading && !t3.ended && (t3.length < t3.highWaterMark || t3.flowing && 0 === t3.length); ) {
      var r3 = t3.length;
      if (c2("maybeReadMore read 0"), e3.read(0), r3 === t3.length) break;
    }
    t3.readingMore = false;
  }
  function updateReadableListening(e3) {
    var t3 = e3._readableState;
    t3.readableListening = e3.listenerCount("readable") > 0, t3.resumeScheduled && !t3.paused ? t3.flowing = true : e3.listenerCount("data") > 0 && e3.resume();
  }
  function nReadingNextTick(e3) {
    c2("readable nexttick read 0"), e3.read(0);
  }
  function resume_(e3, t3) {
    c2("resume", t3.reading), t3.reading || e3.read(0), t3.resumeScheduled = false, e3.emit("resume"), flow3(e3), t3.flowing && !t3.reading && e3.read(0);
  }
  function flow3(e3) {
    var t3 = e3._readableState;
    for (c2("flow", t3.flowing); t3.flowing && null !== e3.read(); ) ;
  }
  function fromList(e3, t3) {
    return 0 === t3.length ? null : (t3.objectMode ? r3 = t3.buffer.shift() : !e3 || e3 >= t3.length ? (r3 = t3.decoder ? t3.buffer.join("") : 1 === t3.buffer.length ? t3.buffer.first() : t3.buffer.concat(t3.length), t3.buffer.clear()) : r3 = t3.buffer.consume(e3, t3.decoder), r3);
    var r3;
  }
  function endReadable(e3) {
    var t3 = e3._readableState;
    c2("endReadable", t3.endEmitted), t3.endEmitted || (t3.ended = true, a2.nextTick(endReadableNT, t3, e3));
  }
  function endReadableNT(e3, t3) {
    if (c2("endReadableNT", e3.endEmitted, e3.length), !e3.endEmitted && 0 === e3.length && (e3.endEmitted = true, t3.readable = false, t3.emit("end"), e3.autoDestroy)) {
      var r3 = t3._writableState;
      (!r3 || r3.autoDestroy && r3.finished) && t3.destroy();
    }
  }
  function indexOf4(e3, t3) {
    for (var r3 = 0, n2 = e3.length; r3 < n2; r3++) if (e3[r3] === t3) return r3;
    return -1;
  }
  Readable.prototype.read = function(e3) {
    c2("read", e3), e3 = parseInt(e3, 10);
    var t3 = this._readableState, r3 = e3;
    if (0 !== e3 && (t3.emittedReadable = false), 0 === e3 && t3.needReadable && ((0 !== t3.highWaterMark ? t3.length >= t3.highWaterMark : t3.length > 0) || t3.ended)) return c2("read: emitReadable", t3.length, t3.ended), 0 === t3.length && t3.ended ? endReadable(this) : emitReadable(this), null;
    if (0 === (e3 = howMuchToRead(e3, t3)) && t3.ended) return 0 === t3.length && endReadable(this), null;
    var n2, a3 = t3.needReadable;
    return c2("need readable", a3), (0 === t3.length || t3.length - e3 < t3.highWaterMark) && c2("length less than watermark", a3 = true), t3.ended || t3.reading ? c2("reading or ended", a3 = false) : a3 && (c2("do read"), t3.reading = true, t3.sync = true, 0 === t3.length && (t3.needReadable = true), this._read(t3.highWaterMark), t3.sync = false, t3.reading || (e3 = howMuchToRead(r3, t3))), null === (n2 = e3 > 0 ? fromList(e3, t3) : null) ? (t3.needReadable = t3.length <= t3.highWaterMark, e3 = 0) : (t3.length -= e3, t3.awaitDrain = 0), 0 === t3.length && (t3.ended || (t3.needReadable = true), r3 !== e3 && t3.ended && endReadable(this)), null !== n2 && this.emit("data", n2), n2;
  }, Readable.prototype._read = function(e3) {
    w2(this, new v2("_read()"));
  }, Readable.prototype.pipe = function(e3, t3) {
    var r3 = this, n2 = this._readableState;
    switch (n2.pipesCount) {
      case 0:
        n2.pipes = e3;
        break;
      case 1:
        n2.pipes = [n2.pipes, e3];
        break;
      default:
        n2.pipes.push(e3);
    }
    n2.pipesCount += 1, c2("pipe count=%d opts=%j", n2.pipesCount, t3);
    var s3 = (!t3 || false !== t3.end) && e3 !== a2.stdout && e3 !== a2.stderr ? onend : unpipe;
    function onunpipe(t4, a3) {
      c2("onunpipe"), t4 === r3 && a3 && false === a3.hasUnpiped && (a3.hasUnpiped = true, function cleanup() {
        c2("cleanup"), e3.removeListener("close", onclose), e3.removeListener("finish", onfinish), e3.removeListener("drain", l3), e3.removeListener("error", onerror), e3.removeListener("unpipe", onunpipe), r3.removeListener("end", onend), r3.removeListener("end", unpipe), r3.removeListener("data", ondata), i3 = true, !n2.awaitDrain || e3._writableState && !e3._writableState.needDrain || l3();
      }());
    }
    function onend() {
      c2("onend"), e3.end();
    }
    n2.endEmitted ? a2.nextTick(s3) : r3.once("end", s3), e3.on("unpipe", onunpipe);
    var l3 = /* @__PURE__ */ function pipeOnDrain(e4) {
      return function pipeOnDrainFunctionResult() {
        var t4 = e4._readableState;
        c2("pipeOnDrain", t4.awaitDrain), t4.awaitDrain && t4.awaitDrain--, 0 === t4.awaitDrain && o4(e4, "data") && (t4.flowing = true, flow3(e4));
      };
    }(r3);
    e3.on("drain", l3);
    var i3 = false;
    function ondata(t4) {
      c2("ondata");
      var a3 = e3.write(t4);
      c2("dest.write", a3), false === a3 && ((1 === n2.pipesCount && n2.pipes === e3 || n2.pipesCount > 1 && -1 !== indexOf4(n2.pipes, e3)) && !i3 && (c2("false write response, pause", n2.awaitDrain), n2.awaitDrain++), r3.pause());
    }
    function onerror(t4) {
      c2("onerror", t4), unpipe(), e3.removeListener("error", onerror), 0 === o4(e3, "error") && w2(e3, t4);
    }
    function onclose() {
      e3.removeListener("finish", onfinish), unpipe();
    }
    function onfinish() {
      c2("onfinish"), e3.removeListener("close", onclose), unpipe();
    }
    function unpipe() {
      c2("unpipe"), r3.unpipe(e3);
    }
    return r3.on("data", ondata), function prependListener(e4, t4, r4) {
      if ("function" == typeof e4.prependListener) return e4.prependListener(t4, r4);
      e4._events && e4._events[t4] ? Array.isArray(e4._events[t4]) ? e4._events[t4].unshift(r4) : e4._events[t4] = [r4, e4._events[t4]] : e4.on(t4, r4);
    }(e3, "error", onerror), e3.once("close", onclose), e3.once("finish", onfinish), e3.emit("pipe", r3), n2.flowing || (c2("pipe resume"), r3.resume()), e3;
  }, Readable.prototype.unpipe = function(e3) {
    var t3 = this._readableState, r3 = { hasUnpiped: false };
    if (0 === t3.pipesCount) return this;
    if (1 === t3.pipesCount) return e3 && e3 !== t3.pipes || (e3 || (e3 = t3.pipes), t3.pipes = null, t3.pipesCount = 0, t3.flowing = false, e3 && e3.emit("unpipe", this, r3)), this;
    if (!e3) {
      var n2 = t3.pipes, a3 = t3.pipesCount;
      t3.pipes = null, t3.pipesCount = 0, t3.flowing = false;
      for (var o5 = 0; o5 < a3; o5++) n2[o5].emit("unpipe", this, { hasUnpiped: false });
      return this;
    }
    var s3 = indexOf4(t3.pipes, e3);
    return -1 === s3 || (t3.pipes.splice(s3, 1), t3.pipesCount -= 1, 1 === t3.pipesCount && (t3.pipes = t3.pipes[0]), e3.emit("unpipe", this, r3)), this;
  }, Readable.prototype.on = function(e3, t3) {
    var r3 = s2.prototype.on.call(this, e3, t3), n2 = this._readableState;
    return "data" === e3 ? (n2.readableListening = this.listenerCount("readable") > 0, false !== n2.flowing && this.resume()) : "readable" === e3 && (n2.endEmitted || n2.readableListening || (n2.readableListening = n2.needReadable = true, n2.flowing = false, n2.emittedReadable = false, c2("on readable", n2.length, n2.reading), n2.length ? emitReadable(this) : n2.reading || a2.nextTick(nReadingNextTick, this))), r3;
  }, Readable.prototype.addListener = Readable.prototype.on, Readable.prototype.removeListener = function(e3, t3) {
    var r3 = s2.prototype.removeListener.call(this, e3, t3);
    return "readable" === e3 && a2.nextTick(updateReadableListening, this), r3;
  }, Readable.prototype.removeAllListeners = function(e3) {
    var t3 = s2.prototype.removeAllListeners.apply(this, arguments);
    return "readable" !== e3 && void 0 !== e3 || a2.nextTick(updateReadableListening, this), t3;
  }, Readable.prototype.resume = function() {
    var e3 = this._readableState;
    return e3.flowing || (c2("resume"), e3.flowing = !e3.readableListening, function resume(e4, t3) {
      t3.resumeScheduled || (t3.resumeScheduled = true, a2.nextTick(resume_, e4, t3));
    }(this, e3)), e3.paused = false, this;
  }, Readable.prototype.pause = function() {
    return c2("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (c2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  }, Readable.prototype.wrap = function(e3) {
    var t3 = this, r3 = this._readableState, n2 = false;
    for (var a3 in e3.on("end", function() {
      if (c2("wrapped end"), r3.decoder && !r3.ended) {
        var e4 = r3.decoder.end();
        e4 && e4.length && t3.push(e4);
      }
      t3.push(null);
    }), e3.on("data", function(a4) {
      (c2("wrapped data"), r3.decoder && (a4 = r3.decoder.write(a4)), r3.objectMode && null == a4) || (r3.objectMode || a4 && a4.length) && (t3.push(a4) || (n2 = true, e3.pause()));
    }), e3) void 0 === this[a3] && "function" == typeof e3[a3] && (this[a3] = /* @__PURE__ */ function methodWrap(t4) {
      return function methodWrapReturnFunction() {
        return e3[t4].apply(e3, arguments);
      };
    }(a3));
    for (var o5 = 0; o5 < C2.length; o5++) e3.on(C2[o5], this.emit.bind(this, C2[o5]));
    return this._read = function(t4) {
      c2("wrapped _read", t4), n2 && (n2 = false, e3.resume());
    }, this;
  }, "function" == typeof Symbol && (Readable.prototype[Symbol.asyncIterator] = function() {
    return void 0 === p2 && (p2 = r2(955)), p2(this);
  }), Object.defineProperty(Readable.prototype, "readableHighWaterMark", { enumerable: false, get: function get3() {
    return this._readableState.highWaterMark;
  } }), Object.defineProperty(Readable.prototype, "readableBuffer", { enumerable: false, get: function get3() {
    return this._readableState && this._readableState.buffer;
  } }), Object.defineProperty(Readable.prototype, "readableFlowing", { enumerable: false, get: function get3() {
    return this._readableState.flowing;
  }, set: function set4(e3) {
    this._readableState && (this._readableState.flowing = e3);
  } }), Readable._fromList = fromList, Object.defineProperty(Readable.prototype, "readableLength", { enumerable: false, get: function get3() {
    return this._readableState.length;
  } }), "function" == typeof Symbol && (Readable.from = function(e3, t3) {
    return void 0 === m2 && (m2 = r2(157)), m2(Readable, e3, t3);
  });
}, 610: function(e2, t2, r2) {
  e2.exports = Transform;
  var n = r2(48).F, a2 = n.ERR_METHOD_NOT_IMPLEMENTED, o4 = n.ERR_MULTIPLE_CALLBACK, s2 = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, l2 = n.ERR_TRANSFORM_WITH_LENGTH_0, i2 = r2(382);
  function afterTransform(e3, t3) {
    var r3 = this._transformState;
    r3.transforming = false;
    var n2 = r3.writecb;
    if (null === n2) return this.emit("error", new o4());
    r3.writechunk = null, r3.writecb = null, null != t3 && this.push(t3), n2(e3);
    var a3 = this._readableState;
    a3.reading = false, (a3.needReadable || a3.length < a3.highWaterMark) && this._read(a3.highWaterMark);
  }
  function Transform(e3) {
    if (!(this instanceof Transform)) return new Transform(e3);
    i2.call(this, e3), this._transformState = { afterTransform: afterTransform.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e3 && ("function" == typeof e3.transform && (this._transform = e3.transform), "function" == typeof e3.flush && (this._flush = e3.flush)), this.on("prefinish", prefinish);
  }
  function prefinish() {
    var e3 = this;
    "function" != typeof this._flush || this._readableState.destroyed ? done(this, null, null) : this._flush(function(t3, r3) {
      done(e3, t3, r3);
    });
  }
  function done(e3, t3, r3) {
    if (t3) return e3.emit("error", t3);
    if (null != r3 && e3.push(r3), e3._writableState.length) throw new l2();
    if (e3._transformState.transforming) throw new s2();
    return e3.push(null);
  }
  r2(698)(Transform, i2), Transform.prototype.push = function(e3, t3) {
    return this._transformState.needTransform = false, i2.prototype.push.call(this, e3, t3);
  }, Transform.prototype._transform = function(e3, t3, r3) {
    r3(new a2("_transform()"));
  }, Transform.prototype._write = function(e3, t3, r3) {
    var n2 = this._transformState;
    if (n2.writecb = r3, n2.writechunk = e3, n2.writeencoding = t3, !n2.transforming) {
      var a3 = this._readableState;
      (n2.needTransform || a3.needReadable || a3.length < a3.highWaterMark) && this._read(a3.highWaterMark);
    }
  }, Transform.prototype._read = function(e3) {
    var t3 = this._transformState;
    null === t3.writechunk || t3.transforming ? t3.needTransform = true : (t3.transforming = true, this._transform(t3.writechunk, t3.writeencoding, t3.afterTransform));
  }, Transform.prototype._destroy = function(e3, t3) {
    i2.prototype._destroy.call(this, e3, function(e4) {
      t3(e4);
    });
  };
}, 708: function(e2, t2, r2) {
  var n, a2 = r2(606);
  function CorkedRequest(e3) {
    var t3 = this;
    this.next = null, this.entry = null, this.finish = function() {
      !function onCorkedFinish(e4, t4, r3) {
        var n2 = e4.entry;
        e4.entry = null;
        for (; n2; ) {
          var a3 = n2.callback;
          t4.pendingcb--, a3(r3), n2 = n2.next;
        }
        t4.corkedRequestsFree.next = e4;
      }(t3, e3);
    };
  }
  e2.exports = Writable, Writable.WritableState = WritableState;
  var o4 = { deprecate: r2(643) }, s2 = r2(345), l2 = r2(287).Buffer, i2 = (void 0 !== r2.g ? r2.g : "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).Uint8Array || function() {
  };
  var c2, u2 = r2(896), d2 = r2(291).getHighWaterMark, p2 = r2(48).F, m2 = p2.ERR_INVALID_ARG_TYPE, f2 = p2.ERR_METHOD_NOT_IMPLEMENTED, h2 = p2.ERR_MULTIPLE_CALLBACK, g2 = p2.ERR_STREAM_CANNOT_PIPE, y2 = p2.ERR_STREAM_DESTROYED, S = p2.ERR_STREAM_NULL_VALUES, _2 = p2.ERR_STREAM_WRITE_AFTER_END, v2 = p2.ERR_UNKNOWN_ENCODING, b = u2.errorOrDestroy;
  function nop() {
  }
  function WritableState(e3, t3, o5) {
    n = n || r2(382), e3 = e3 || {}, "boolean" != typeof o5 && (o5 = t3 instanceof n), this.objectMode = !!e3.objectMode, o5 && (this.objectMode = this.objectMode || !!e3.writableObjectMode), this.highWaterMark = d2(this, e3, "writableHighWaterMark", o5), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var s3 = false === e3.decodeStrings;
    this.decodeStrings = !s3, this.defaultEncoding = e3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e4) {
      !function onwrite(e5, t4) {
        var r3 = e5._writableState, n2 = r3.sync, o6 = r3.writecb;
        if ("function" != typeof o6) throw new h2();
        if (function onwriteStateUpdate(e6) {
          e6.writing = false, e6.writecb = null, e6.length -= e6.writelen, e6.writelen = 0;
        }(r3), t4) !function onwriteError(e6, t5, r4, n3, o7) {
          --t5.pendingcb, r4 ? (a2.nextTick(o7, n3), a2.nextTick(finishMaybe, e6, t5), e6._writableState.errorEmitted = true, b(e6, n3)) : (o7(n3), e6._writableState.errorEmitted = true, b(e6, n3), finishMaybe(e6, t5));
        }(e5, r3, n2, t4, o6);
        else {
          var s4 = needFinish(r3) || e5.destroyed;
          s4 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || clearBuffer(e5, r3), n2 ? a2.nextTick(afterWrite, e5, r3, s4, o6) : afterWrite(e5, r3, s4, o6);
        }
      }(t3, e4);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== e3.emitClose, this.autoDestroy = !!e3.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest(this);
  }
  function Writable(e3) {
    var t3 = this instanceof (n = n || r2(382));
    if (!t3 && !c2.call(Writable, this)) return new Writable(e3);
    this._writableState = new WritableState(e3, this, t3), this.writable = true, e3 && ("function" == typeof e3.write && (this._write = e3.write), "function" == typeof e3.writev && (this._writev = e3.writev), "function" == typeof e3.destroy && (this._destroy = e3.destroy), "function" == typeof e3.final && (this._final = e3.final)), s2.call(this);
  }
  function doWrite(e3, t3, r3, n2, a3, o5, s3) {
    t3.writelen = n2, t3.writecb = s3, t3.writing = true, t3.sync = true, t3.destroyed ? t3.onwrite(new y2("write")) : r3 ? e3._writev(a3, t3.onwrite) : e3._write(a3, o5, t3.onwrite), t3.sync = false;
  }
  function afterWrite(e3, t3, r3, n2) {
    r3 || function onwriteDrain(e4, t4) {
      0 === t4.length && t4.needDrain && (t4.needDrain = false, e4.emit("drain"));
    }(e3, t3), t3.pendingcb--, n2(), finishMaybe(e3, t3);
  }
  function clearBuffer(e3, t3) {
    t3.bufferProcessing = true;
    var r3 = t3.bufferedRequest;
    if (e3._writev && r3 && r3.next) {
      var n2 = t3.bufferedRequestCount, a3 = new Array(n2), o5 = t3.corkedRequestsFree;
      o5.entry = r3;
      for (var s3 = 0, l3 = true; r3; ) a3[s3] = r3, r3.isBuf || (l3 = false), r3 = r3.next, s3 += 1;
      a3.allBuffers = l3, doWrite(e3, t3, true, t3.length, a3, "", o5.finish), t3.pendingcb++, t3.lastBufferedRequest = null, o5.next ? (t3.corkedRequestsFree = o5.next, o5.next = null) : t3.corkedRequestsFree = new CorkedRequest(t3), t3.bufferedRequestCount = 0;
    } else {
      for (; r3; ) {
        var i3 = r3.chunk, c3 = r3.encoding, u3 = r3.callback;
        if (doWrite(e3, t3, false, t3.objectMode ? 1 : i3.length, i3, c3, u3), r3 = r3.next, t3.bufferedRequestCount--, t3.writing) break;
      }
      null === r3 && (t3.lastBufferedRequest = null);
    }
    t3.bufferedRequest = r3, t3.bufferProcessing = false;
  }
  function needFinish(e3) {
    return e3.ending && 0 === e3.length && null === e3.bufferedRequest && !e3.finished && !e3.writing;
  }
  function callFinal(e3, t3) {
    e3._final(function(r3) {
      t3.pendingcb--, r3 && b(e3, r3), t3.prefinished = true, e3.emit("prefinish"), finishMaybe(e3, t3);
    });
  }
  function finishMaybe(e3, t3) {
    var r3 = needFinish(t3);
    if (r3 && (function prefinish(e4, t4) {
      t4.prefinished || t4.finalCalled || ("function" != typeof e4._final || t4.destroyed ? (t4.prefinished = true, e4.emit("prefinish")) : (t4.pendingcb++, t4.finalCalled = true, a2.nextTick(callFinal, e4, t4)));
    }(e3, t3), 0 === t3.pendingcb && (t3.finished = true, e3.emit("finish"), t3.autoDestroy))) {
      var n2 = e3._readableState;
      (!n2 || n2.autoDestroy && n2.endEmitted) && e3.destroy();
    }
    return r3;
  }
  r2(698)(Writable, s2), WritableState.prototype.getBuffer = function getBuffer() {
    for (var e3 = this.bufferedRequest, t3 = []; e3; ) t3.push(e3), e3 = e3.next;
    return t3;
  }, function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", { get: o4.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
    } catch (e3) {
    }
  }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (c2 = Function.prototype[Symbol.hasInstance], Object.defineProperty(Writable, Symbol.hasInstance, { value: function value(e3) {
    return !!c2.call(this, e3) || this === Writable && (e3 && e3._writableState instanceof WritableState);
  } })) : c2 = function realHasInstance(e3) {
    return e3 instanceof this;
  }, Writable.prototype.pipe = function() {
    b(this, new g2());
  }, Writable.prototype.write = function(e3, t3, r3) {
    var n2 = this._writableState, o5 = false, s3 = !n2.objectMode && function _isUint8Array(e4) {
      return l2.isBuffer(e4) || e4 instanceof i2;
    }(e3);
    return s3 && !l2.isBuffer(e3) && (e3 = function _uint8ArrayToBuffer(e4) {
      return l2.from(e4);
    }(e3)), "function" == typeof t3 && (r3 = t3, t3 = null), s3 ? t3 = "buffer" : t3 || (t3 = n2.defaultEncoding), "function" != typeof r3 && (r3 = nop), n2.ending ? function writeAfterEnd(e4, t4) {
      var r4 = new _2();
      b(e4, r4), a2.nextTick(t4, r4);
    }(this, r3) : (s3 || function validChunk(e4, t4, r4, n3) {
      var o6;
      return null === r4 ? o6 = new S() : "string" == typeof r4 || t4.objectMode || (o6 = new m2("chunk", ["string", "Buffer"], r4)), !o6 || (b(e4, o6), a2.nextTick(n3, o6), false);
    }(this, n2, e3, r3)) && (n2.pendingcb++, o5 = function writeOrBuffer(e4, t4, r4, n3, a3, o6) {
      if (!r4) {
        var s4 = function decodeChunk(e5, t5, r5) {
          e5.objectMode || false === e5.decodeStrings || "string" != typeof t5 || (t5 = l2.from(t5, r5));
          return t5;
        }(t4, n3, a3);
        n3 !== s4 && (r4 = true, a3 = "buffer", n3 = s4);
      }
      var i3 = t4.objectMode ? 1 : n3.length;
      t4.length += i3;
      var c3 = t4.length < t4.highWaterMark;
      c3 || (t4.needDrain = true);
      if (t4.writing || t4.corked) {
        var u3 = t4.lastBufferedRequest;
        t4.lastBufferedRequest = { chunk: n3, encoding: a3, isBuf: r4, callback: o6, next: null }, u3 ? u3.next = t4.lastBufferedRequest : t4.bufferedRequest = t4.lastBufferedRequest, t4.bufferedRequestCount += 1;
      } else doWrite(e4, t4, false, i3, n3, a3, o6);
      return c3;
    }(this, n2, s3, e3, t3, r3)), o5;
  }, Writable.prototype.cork = function() {
    this._writableState.corked++;
  }, Writable.prototype.uncork = function() {
    var e3 = this._writableState;
    e3.corked && (e3.corked--, e3.writing || e3.corked || e3.bufferProcessing || !e3.bufferedRequest || clearBuffer(this, e3));
  }, Writable.prototype.setDefaultEncoding = function setDefaultEncoding(e3) {
    if ("string" == typeof e3 && (e3 = e3.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e3 + "").toLowerCase()) > -1)) throw new v2(e3);
    return this._writableState.defaultEncoding = e3, this;
  }, Object.defineProperty(Writable.prototype, "writableBuffer", { enumerable: false, get: function get3() {
    return this._writableState && this._writableState.getBuffer();
  } }), Object.defineProperty(Writable.prototype, "writableHighWaterMark", { enumerable: false, get: function get3() {
    return this._writableState.highWaterMark;
  } }), Writable.prototype._write = function(e3, t3, r3) {
    r3(new f2("_write()"));
  }, Writable.prototype._writev = null, Writable.prototype.end = function(e3, t3, r3) {
    var n2 = this._writableState;
    return "function" == typeof e3 ? (r3 = e3, e3 = null, t3 = null) : "function" == typeof t3 && (r3 = t3, t3 = null), null != e3 && this.write(e3, t3), n2.corked && (n2.corked = 1, this.uncork()), n2.ending || function endWritable(e4, t4, r4) {
      t4.ending = true, finishMaybe(e4, t4), r4 && (t4.finished ? a2.nextTick(r4) : e4.once("finish", r4));
      t4.ended = true, e4.writable = false;
    }(this, n2, r3), this;
  }, Object.defineProperty(Writable.prototype, "writableLength", { enumerable: false, get: function get3() {
    return this._writableState.length;
  } }), Object.defineProperty(Writable.prototype, "destroyed", { enumerable: false, get: function get3() {
    return void 0 !== this._writableState && this._writableState.destroyed;
  }, set: function set4(e3) {
    this._writableState && (this._writableState.destroyed = e3);
  } }), Writable.prototype.destroy = u2.destroy, Writable.prototype._undestroy = u2.undestroy, Writable.prototype._destroy = function(e3, t3) {
    t3(e3);
  };
}, 955: function(e2, t2, r2) {
  var n, a2 = r2(606);
  function _defineProperty6(e3, t3, r3) {
    return (t3 = function _toPropertyKey6(e4) {
      var t4 = function _toPrimitive6(e5, t5) {
        if ("object" != typeof e5 || null === e5) return e5;
        var r4 = e5[Symbol.toPrimitive];
        if (void 0 !== r4) {
          var n2 = r4.call(e5, t5 || "default");
          if ("object" != typeof n2) return n2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t5 ? String : Number)(e5);
      }(e4, "string");
      return "symbol" == typeof t4 ? t4 : String(t4);
    }(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
  }
  var o4 = r2(238), s2 = Symbol("lastResolve"), l2 = Symbol("lastReject"), i2 = Symbol("error"), c2 = Symbol("ended"), u2 = Symbol("lastPromise"), d2 = Symbol("handlePromise"), p2 = Symbol("stream");
  function createIterResult(e3, t3) {
    return { value: e3, done: t3 };
  }
  function readAndResolve(e3) {
    var t3 = e3[s2];
    if (null !== t3) {
      var r3 = e3[p2].read();
      null !== r3 && (e3[u2] = null, e3[s2] = null, e3[l2] = null, t3(createIterResult(r3, false)));
    }
  }
  function onReadable(e3) {
    a2.nextTick(readAndResolve, e3);
  }
  var m2 = Object.getPrototypeOf(function() {
  }), f2 = Object.setPrototypeOf((_defineProperty6(n = { get stream() {
    return this[p2];
  }, next: function next() {
    var e3 = this, t3 = this[i2];
    if (null !== t3) return Promise.reject(t3);
    if (this[c2]) return Promise.resolve(createIterResult(void 0, true));
    if (this[p2].destroyed) return new Promise(function(t4, r4) {
      a2.nextTick(function() {
        e3[i2] ? r4(e3[i2]) : t4(createIterResult(void 0, true));
      });
    });
    var r3, n2 = this[u2];
    if (n2) r3 = new Promise(/* @__PURE__ */ function wrapForNext(e4, t4) {
      return function(r4, n3) {
        e4.then(function() {
          t4[c2] ? r4(createIterResult(void 0, true)) : t4[d2](r4, n3);
        }, n3);
      };
    }(n2, this));
    else {
      var o5 = this[p2].read();
      if (null !== o5) return Promise.resolve(createIterResult(o5, false));
      r3 = new Promise(this[d2]);
    }
    return this[u2] = r3, r3;
  } }, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty6(n, "return", function _return() {
    var e3 = this;
    return new Promise(function(t3, r3) {
      e3[p2].destroy(null, function(e4) {
        e4 ? r3(e4) : t3(createIterResult(void 0, true));
      });
    });
  }), n), m2);
  e2.exports = function createReadableStreamAsyncIterator(e3) {
    var t3, r3 = Object.create(f2, (_defineProperty6(t3 = {}, p2, { value: e3, writable: true }), _defineProperty6(t3, s2, { value: null, writable: true }), _defineProperty6(t3, l2, { value: null, writable: true }), _defineProperty6(t3, i2, { value: null, writable: true }), _defineProperty6(t3, c2, { value: e3._readableState.endEmitted, writable: true }), _defineProperty6(t3, d2, { value: function value(e4, t4) {
      var n2 = r3[p2].read();
      n2 ? (r3[u2] = null, r3[s2] = null, r3[l2] = null, e4(createIterResult(n2, false))) : (r3[s2] = e4, r3[l2] = t4);
    }, writable: true }), t3));
    return r3[u2] = null, o4(e3, function(e4) {
      if (e4 && "ERR_STREAM_PREMATURE_CLOSE" !== e4.code) {
        var t4 = r3[l2];
        return null !== t4 && (r3[u2] = null, r3[s2] = null, r3[l2] = null, t4(e4)), void (r3[i2] = e4);
      }
      var n2 = r3[s2];
      null !== n2 && (r3[u2] = null, r3[s2] = null, r3[l2] = null, n2(createIterResult(void 0, true))), r3[c2] = true;
    }), e3.on("readable", onReadable.bind(null, r3)), r3;
  };
}, 726: function(e2, t2, r2) {
  function ownKeys5(e3, t3) {
    var r3 = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(e3);
      t3 && (n2 = n2.filter(function(t4) {
        return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
      })), r3.push.apply(r3, n2);
    }
    return r3;
  }
  function _objectSpread5(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var r3 = null != arguments[t3] ? arguments[t3] : {};
      t3 % 2 ? ownKeys5(Object(r3), true).forEach(function(t4) {
        _defineProperty6(e3, t4, r3[t4]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : ownKeys5(Object(r3)).forEach(function(t4) {
        Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
      });
    }
    return e3;
  }
  function _defineProperty6(e3, t3, r3) {
    return (t3 = _toPropertyKey6(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
  }
  function _defineProperties5(e3, t3) {
    for (var r3 = 0; r3 < t3.length; r3++) {
      var n2 = t3[r3];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, _toPropertyKey6(n2.key), n2);
    }
  }
  function _toPropertyKey6(e3) {
    var t3 = function _toPrimitive6(e4, t4) {
      if ("object" != typeof e4 || null === e4) return e4;
      var r3 = e4[Symbol.toPrimitive];
      if (void 0 !== r3) {
        var n2 = r3.call(e4, t4 || "default");
        if ("object" != typeof n2) return n2;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === t4 ? String : Number)(e4);
    }(e3, "string");
    return "symbol" == typeof t3 ? t3 : String(t3);
  }
  var n = r2(287).Buffer, a2 = r2(340).inspect, o4 = a2 && a2.custom || "inspect";
  function copyBuffer(e3, t3, r3) {
    n.prototype.copy.call(e3, t3, r3);
  }
  e2.exports = function() {
    function BufferList() {
      !function _classCallCheck4(e3, t3) {
        if (!(e3 instanceof t3)) throw new TypeError("Cannot call a class as a function");
      }(this, BufferList), this.head = null, this.tail = null, this.length = 0;
    }
    return function _createClass4(e3, t3, r3) {
      return t3 && _defineProperties5(e3.prototype, t3), r3 && _defineProperties5(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
    }(BufferList, [{ key: "push", value: function push(e3) {
      var t3 = { data: e3, next: null };
      this.length > 0 ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
    } }, { key: "unshift", value: function unshift(e3) {
      var t3 = { data: e3, next: this.head };
      0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
    } }, { key: "shift", value: function shift() {
      if (0 !== this.length) {
        var e3 = this.head.data;
        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e3;
      }
    } }, { key: "clear", value: function clear2() {
      this.head = this.tail = null, this.length = 0;
    } }, { key: "join", value: function join2(e3) {
      if (0 === this.length) return "";
      for (var t3 = this.head, r3 = "" + t3.data; t3 = t3.next; ) r3 += e3 + t3.data;
      return r3;
    } }, { key: "concat", value: function concat4(e3) {
      if (0 === this.length) return n.alloc(0);
      for (var t3 = n.allocUnsafe(e3 >>> 0), r3 = this.head, a3 = 0; r3; ) copyBuffer(r3.data, t3, a3), a3 += r3.data.length, r3 = r3.next;
      return t3;
    } }, { key: "consume", value: function consume(e3, t3) {
      var r3;
      return e3 < this.head.data.length ? (r3 = this.head.data.slice(0, e3), this.head.data = this.head.data.slice(e3)) : r3 = e3 === this.head.data.length ? this.shift() : t3 ? this._getString(e3) : this._getBuffer(e3), r3;
    } }, { key: "first", value: function first() {
      return this.head.data;
    } }, { key: "_getString", value: function _getString(e3) {
      var t3 = this.head, r3 = 1, n2 = t3.data;
      for (e3 -= n2.length; t3 = t3.next; ) {
        var a3 = t3.data, o5 = e3 > a3.length ? a3.length : e3;
        if (o5 === a3.length ? n2 += a3 : n2 += a3.slice(0, e3), 0 === (e3 -= o5)) {
          o5 === a3.length ? (++r3, t3.next ? this.head = t3.next : this.head = this.tail = null) : (this.head = t3, t3.data = a3.slice(o5));
          break;
        }
        ++r3;
      }
      return this.length -= r3, n2;
    } }, { key: "_getBuffer", value: function _getBuffer(e3) {
      var t3 = n.allocUnsafe(e3), r3 = this.head, a3 = 1;
      for (r3.data.copy(t3), e3 -= r3.data.length; r3 = r3.next; ) {
        var o5 = r3.data, s2 = e3 > o5.length ? o5.length : e3;
        if (o5.copy(t3, t3.length - e3, 0, s2), 0 === (e3 -= s2)) {
          s2 === o5.length ? (++a3, r3.next ? this.head = r3.next : this.head = this.tail = null) : (this.head = r3, r3.data = o5.slice(s2));
          break;
        }
        ++a3;
      }
      return this.length -= a3, t3;
    } }, { key: o4, value: function value(e3, t3) {
      return a2(this, _objectSpread5(_objectSpread5({}, t3), {}, { depth: 0, customInspect: false }));
    } }]), BufferList;
  }();
}, 896: function(e2, t2, r2) {
  var n = r2(606);
  function emitErrorAndCloseNT(e3, t3) {
    emitErrorNT(e3, t3), emitCloseNT(e3);
  }
  function emitCloseNT(e3) {
    e3._writableState && !e3._writableState.emitClose || e3._readableState && !e3._readableState.emitClose || e3.emit("close");
  }
  function emitErrorNT(e3, t3) {
    e3.emit("error", t3);
  }
  e2.exports = { destroy: function destroy(e3, t3) {
    var r3 = this, a2 = this._readableState && this._readableState.destroyed, o4 = this._writableState && this._writableState.destroyed;
    return a2 || o4 ? (t3 ? t3(e3) : e3 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, n.nextTick(emitErrorNT, this, e3)) : n.nextTick(emitErrorNT, this, e3)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e3 || null, function(e4) {
      !t3 && e4 ? r3._writableState ? r3._writableState.errorEmitted ? n.nextTick(emitCloseNT, r3) : (r3._writableState.errorEmitted = true, n.nextTick(emitErrorAndCloseNT, r3, e4)) : n.nextTick(emitErrorAndCloseNT, r3, e4) : t3 ? (n.nextTick(emitCloseNT, r3), t3(e4)) : n.nextTick(emitCloseNT, r3);
    }), this);
  }, undestroy: function undestroy() {
    this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
  }, errorOrDestroy: function errorOrDestroy(e3, t3) {
    var r3 = e3._readableState, n2 = e3._writableState;
    r3 && r3.autoDestroy || n2 && n2.autoDestroy ? e3.destroy(t3) : e3.emit("error", t3);
  } };
}, 238: function(e2, t2, r2) {
  var n = r2(48).F.ERR_STREAM_PREMATURE_CLOSE;
  function noop3() {
  }
  e2.exports = function eos(e3, t3, r3) {
    if ("function" == typeof t3) return eos(e3, null, t3);
    t3 || (t3 = {}), r3 = /* @__PURE__ */ function once3(e4) {
      var t4 = false;
      return function() {
        if (!t4) {
          t4 = true;
          for (var r4 = arguments.length, n2 = new Array(r4), a3 = 0; a3 < r4; a3++) n2[a3] = arguments[a3];
          e4.apply(this, n2);
        }
      };
    }(r3 || noop3);
    var a2 = t3.readable || false !== t3.readable && e3.readable, o4 = t3.writable || false !== t3.writable && e3.writable, s2 = function onlegacyfinish() {
      e3.writable || i2();
    }, l2 = e3._writableState && e3._writableState.finished, i2 = function onfinish() {
      o4 = false, l2 = true, a2 || r3.call(e3);
    }, c2 = e3._readableState && e3._readableState.endEmitted, u2 = function onend() {
      a2 = false, c2 = true, o4 || r3.call(e3);
    }, d2 = function onerror(t4) {
      r3.call(e3, t4);
    }, p2 = function onclose() {
      var t4;
      return a2 && !c2 ? (e3._readableState && e3._readableState.ended || (t4 = new n()), r3.call(e3, t4)) : o4 && !l2 ? (e3._writableState && e3._writableState.ended || (t4 = new n()), r3.call(e3, t4)) : void 0;
    }, m2 = function onrequest() {
      e3.req.on("finish", i2);
    };
    return !function isRequest(e4) {
      return e4.setHeader && "function" == typeof e4.abort;
    }(e3) ? o4 && !e3._writableState && (e3.on("end", s2), e3.on("close", s2)) : (e3.on("complete", i2), e3.on("abort", p2), e3.req ? m2() : e3.on("request", m2)), e3.on("end", u2), e3.on("finish", i2), false !== t3.error && e3.on("error", d2), e3.on("close", p2), function() {
      e3.removeListener("complete", i2), e3.removeListener("abort", p2), e3.removeListener("request", m2), e3.req && e3.req.removeListener("finish", i2), e3.removeListener("end", s2), e3.removeListener("close", s2), e3.removeListener("finish", i2), e3.removeListener("end", u2), e3.removeListener("error", d2), e3.removeListener("close", p2);
    };
  };
}, 157: function(e2) {
  e2.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
}, 758: function(e2, t2, r2) {
  var n;
  var a2 = r2(48).F, o4 = a2.ERR_MISSING_ARGS, s2 = a2.ERR_STREAM_DESTROYED;
  function noop3(e3) {
    if (e3) throw e3;
  }
  function call3(e3) {
    e3();
  }
  function pipe2(e3, t3) {
    return e3.pipe(t3);
  }
  e2.exports = function pipeline() {
    for (var e3 = arguments.length, t3 = new Array(e3), a3 = 0; a3 < e3; a3++) t3[a3] = arguments[a3];
    var l2, i2 = function popCallback(e4) {
      return e4.length ? "function" != typeof e4[e4.length - 1] ? noop3 : e4.pop() : noop3;
    }(t3);
    if (Array.isArray(t3[0]) && (t3 = t3[0]), t3.length < 2) throw new o4("streams");
    var c2 = t3.map(function(e4, a4) {
      var o5 = a4 < t3.length - 1;
      return function destroyer(e5, t4, a5, o6) {
        o6 = /* @__PURE__ */ function once3(e6) {
          var t5 = false;
          return function() {
            t5 || (t5 = true, e6.apply(void 0, arguments));
          };
        }(o6);
        var l3 = false;
        e5.on("close", function() {
          l3 = true;
        }), void 0 === n && (n = r2(238)), n(e5, { readable: t4, writable: a5 }, function(e6) {
          if (e6) return o6(e6);
          l3 = true, o6();
        });
        var i3 = false;
        return function(t5) {
          if (!l3 && !i3) return i3 = true, function isRequest(e6) {
            return e6.setHeader && "function" == typeof e6.abort;
          }(e5) ? e5.abort() : "function" == typeof e5.destroy ? e5.destroy() : void o6(t5 || new s2("pipe"));
        };
      }(e4, o5, a4 > 0, function(e5) {
        l2 || (l2 = e5), e5 && c2.forEach(call3), o5 || (c2.forEach(call3), i2(l2));
      });
    });
    return t3.reduce(pipe2);
  };
}, 291: function(e2, t2, r2) {
  var n = r2(48).F.ERR_INVALID_OPT_VALUE;
  e2.exports = { getHighWaterMark: function getHighWaterMark(e3, t3, r3, a2) {
    var o4 = function highWaterMarkFrom(e4, t4, r4) {
      return null != e4.highWaterMark ? e4.highWaterMark : t4 ? e4[r4] : null;
    }(t3, a2, r3);
    if (null != o4) {
      if (!isFinite(o4) || Math.floor(o4) !== o4 || o4 < 0) throw new n(a2 ? r3 : "highWaterMark", o4);
      return Math.floor(o4);
    }
    return e3.objectMode ? 16 : 16384;
  } };
}, 345: function(e2, t2, r2) {
  e2.exports = r2(7).EventEmitter;
}, 861: function(e2, t2, r2) {
  var n = r2(287), a2 = n.Buffer;
  function copyProps2(e3, t3) {
    for (var r3 in e3) t3[r3] = e3[r3];
  }
  function SafeBuffer(e3, t3, r3) {
    return a2(e3, t3, r3);
  }
  a2.from && a2.alloc && a2.allocUnsafe && a2.allocUnsafeSlow ? e2.exports = n : (copyProps2(n, t2), t2.Buffer = SafeBuffer), SafeBuffer.prototype = Object.create(a2.prototype), copyProps2(a2, SafeBuffer), SafeBuffer.from = function(e3, t3, r3) {
    if ("number" == typeof e3) throw new TypeError("Argument must not be a number");
    return a2(e3, t3, r3);
  }, SafeBuffer.alloc = function(e3, t3, r3) {
    if ("number" != typeof e3) throw new TypeError("Argument must be a number");
    var n2 = a2(e3);
    return void 0 !== t3 ? "string" == typeof r3 ? n2.fill(t3, r3) : n2.fill(t3) : n2.fill(0), n2;
  }, SafeBuffer.allocUnsafe = function(e3) {
    if ("number" != typeof e3) throw new TypeError("Argument must be a number");
    return a2(e3);
  }, SafeBuffer.allocUnsafeSlow = function(e3) {
    if ("number" != typeof e3) throw new TypeError("Argument must be a number");
    return n.SlowBuffer(e3);
  };
}, 392: function(e2, t2, r2) {
  var n = r2(861).Buffer;
  function Hash(e3, t3) {
    this._block = n.alloc(e3), this._finalSize = t3, this._blockSize = e3, this._len = 0;
  }
  Hash.prototype.update = function(e3, t3) {
    "string" == typeof e3 && (t3 = t3 || "utf8", e3 = n.from(e3, t3));
    for (var r3 = this._block, a2 = this._blockSize, o4 = e3.length, s2 = this._len, l2 = 0; l2 < o4; ) {
      for (var i2 = s2 % a2, c2 = Math.min(o4 - l2, a2 - i2), u2 = 0; u2 < c2; u2++) r3[i2 + u2] = e3[l2 + u2];
      l2 += c2, (s2 += c2) % a2 == 0 && this._update(r3);
    }
    return this._len += o4, this;
  }, Hash.prototype.digest = function(e3) {
    var t3 = this._len % this._blockSize;
    this._block[t3] = 128, this._block.fill(0, t3 + 1), t3 >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var r3 = 8 * this._len;
    if (r3 <= 4294967295) this._block.writeUInt32BE(r3, this._blockSize - 4);
    else {
      var n2 = (4294967295 & r3) >>> 0, a2 = (r3 - n2) / 4294967296;
      this._block.writeUInt32BE(a2, this._blockSize - 8), this._block.writeUInt32BE(n2, this._blockSize - 4);
    }
    this._update(this._block);
    var o4 = this._hash();
    return e3 ? o4.toString(e3) : o4;
  }, Hash.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, e2.exports = Hash;
}, 802: function(e2, t2, r2) {
  var n = e2.exports = function SHA(e3) {
    e3 = e3.toLowerCase();
    var t3 = n[e3];
    if (!t3) throw new Error(e3 + " is not supported (we accept pull requests)");
    return new t3();
  };
  n.sha = r2(816), n.sha1 = r2(737), n.sha224 = r2(710), n.sha256 = r2(107), n.sha384 = r2(827), n.sha512 = r2(890);
}, 816: function(e2, t2, r2) {
  var n = r2(698), a2 = r2(392), o4 = r2(861).Buffer, s2 = [1518500249, 1859775393, -1894007588, -899497514], l2 = new Array(80);
  function Sha() {
    this.init(), this._w = l2, a2.call(this, 64, 56);
  }
  function rotl30(e3) {
    return e3 << 30 | e3 >>> 2;
  }
  function ft(e3, t3, r3, n2) {
    return 0 === e3 ? t3 & r3 | ~t3 & n2 : 2 === e3 ? t3 & r3 | t3 & n2 | r3 & n2 : t3 ^ r3 ^ n2;
  }
  n(Sha, a2), Sha.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  }, Sha.prototype._update = function(e3) {
    for (var t3, r3 = this._w, n2 = 0 | this._a, a3 = 0 | this._b, o5 = 0 | this._c, l3 = 0 | this._d, i2 = 0 | this._e, c2 = 0; c2 < 16; ++c2) r3[c2] = e3.readInt32BE(4 * c2);
    for (; c2 < 80; ++c2) r3[c2] = r3[c2 - 3] ^ r3[c2 - 8] ^ r3[c2 - 14] ^ r3[c2 - 16];
    for (var u2 = 0; u2 < 80; ++u2) {
      var d2 = ~~(u2 / 20), p2 = 0 | ((t3 = n2) << 5 | t3 >>> 27) + ft(d2, a3, o5, l3) + i2 + r3[u2] + s2[d2];
      i2 = l3, l3 = o5, o5 = rotl30(a3), a3 = n2, n2 = p2;
    }
    this._a = n2 + this._a | 0, this._b = a3 + this._b | 0, this._c = o5 + this._c | 0, this._d = l3 + this._d | 0, this._e = i2 + this._e | 0;
  }, Sha.prototype._hash = function() {
    var e3 = o4.allocUnsafe(20);
    return e3.writeInt32BE(0 | this._a, 0), e3.writeInt32BE(0 | this._b, 4), e3.writeInt32BE(0 | this._c, 8), e3.writeInt32BE(0 | this._d, 12), e3.writeInt32BE(0 | this._e, 16), e3;
  }, e2.exports = Sha;
}, 737: function(e2, t2, r2) {
  var n = r2(698), a2 = r2(392), o4 = r2(861).Buffer, s2 = [1518500249, 1859775393, -1894007588, -899497514], l2 = new Array(80);
  function Sha1() {
    this.init(), this._w = l2, a2.call(this, 64, 56);
  }
  function rotl5(e3) {
    return e3 << 5 | e3 >>> 27;
  }
  function rotl30(e3) {
    return e3 << 30 | e3 >>> 2;
  }
  function ft(e3, t3, r3, n2) {
    return 0 === e3 ? t3 & r3 | ~t3 & n2 : 2 === e3 ? t3 & r3 | t3 & n2 | r3 & n2 : t3 ^ r3 ^ n2;
  }
  n(Sha1, a2), Sha1.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  }, Sha1.prototype._update = function(e3) {
    for (var t3, r3 = this._w, n2 = 0 | this._a, a3 = 0 | this._b, o5 = 0 | this._c, l3 = 0 | this._d, i2 = 0 | this._e, c2 = 0; c2 < 16; ++c2) r3[c2] = e3.readInt32BE(4 * c2);
    for (; c2 < 80; ++c2) r3[c2] = (t3 = r3[c2 - 3] ^ r3[c2 - 8] ^ r3[c2 - 14] ^ r3[c2 - 16]) << 1 | t3 >>> 31;
    for (var u2 = 0; u2 < 80; ++u2) {
      var d2 = ~~(u2 / 20), p2 = rotl5(n2) + ft(d2, a3, o5, l3) + i2 + r3[u2] + s2[d2] | 0;
      i2 = l3, l3 = o5, o5 = rotl30(a3), a3 = n2, n2 = p2;
    }
    this._a = n2 + this._a | 0, this._b = a3 + this._b | 0, this._c = o5 + this._c | 0, this._d = l3 + this._d | 0, this._e = i2 + this._e | 0;
  }, Sha1.prototype._hash = function() {
    var e3 = o4.allocUnsafe(20);
    return e3.writeInt32BE(0 | this._a, 0), e3.writeInt32BE(0 | this._b, 4), e3.writeInt32BE(0 | this._c, 8), e3.writeInt32BE(0 | this._d, 12), e3.writeInt32BE(0 | this._e, 16), e3;
  }, e2.exports = Sha1;
}, 710: function(e2, t2, r2) {
  var n = r2(698), a2 = r2(107), o4 = r2(392), s2 = r2(861).Buffer, l2 = new Array(64);
  function Sha224() {
    this.init(), this._w = l2, o4.call(this, 64, 56);
  }
  n(Sha224, a2), Sha224.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, Sha224.prototype._hash = function() {
    var e3 = s2.allocUnsafe(28);
    return e3.writeInt32BE(this._a, 0), e3.writeInt32BE(this._b, 4), e3.writeInt32BE(this._c, 8), e3.writeInt32BE(this._d, 12), e3.writeInt32BE(this._e, 16), e3.writeInt32BE(this._f, 20), e3.writeInt32BE(this._g, 24), e3;
  }, e2.exports = Sha224;
}, 107: function(e2, t2, r2) {
  var n = r2(698), a2 = r2(392), o4 = r2(861).Buffer, s2 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], l2 = new Array(64);
  function Sha256() {
    this.init(), this._w = l2, a2.call(this, 64, 56);
  }
  function ch(e3, t3, r3) {
    return r3 ^ e3 & (t3 ^ r3);
  }
  function maj(e3, t3, r3) {
    return e3 & t3 | r3 & (e3 | t3);
  }
  function sigma0(e3) {
    return (e3 >>> 2 | e3 << 30) ^ (e3 >>> 13 | e3 << 19) ^ (e3 >>> 22 | e3 << 10);
  }
  function sigma1(e3) {
    return (e3 >>> 6 | e3 << 26) ^ (e3 >>> 11 | e3 << 21) ^ (e3 >>> 25 | e3 << 7);
  }
  function gamma0(e3) {
    return (e3 >>> 7 | e3 << 25) ^ (e3 >>> 18 | e3 << 14) ^ e3 >>> 3;
  }
  function gamma1(e3) {
    return (e3 >>> 17 | e3 << 15) ^ (e3 >>> 19 | e3 << 13) ^ e3 >>> 10;
  }
  n(Sha256, a2), Sha256.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  }, Sha256.prototype._update = function(e3) {
    for (var t3 = this._w, r3 = 0 | this._a, n2 = 0 | this._b, a3 = 0 | this._c, o5 = 0 | this._d, l3 = 0 | this._e, i2 = 0 | this._f, c2 = 0 | this._g, u2 = 0 | this._h, d2 = 0; d2 < 16; ++d2) t3[d2] = e3.readInt32BE(4 * d2);
    for (; d2 < 64; ++d2) t3[d2] = gamma1(t3[d2 - 2]) + t3[d2 - 7] + gamma0(t3[d2 - 15]) + t3[d2 - 16] | 0;
    for (var p2 = 0; p2 < 64; ++p2) {
      var m2 = u2 + sigma1(l3) + ch(l3, i2, c2) + s2[p2] + t3[p2] | 0, f2 = sigma0(r3) + maj(r3, n2, a3) | 0;
      u2 = c2, c2 = i2, i2 = l3, l3 = o5 + m2 | 0, o5 = a3, a3 = n2, n2 = r3, r3 = m2 + f2 | 0;
    }
    this._a = r3 + this._a | 0, this._b = n2 + this._b | 0, this._c = a3 + this._c | 0, this._d = o5 + this._d | 0, this._e = l3 + this._e | 0, this._f = i2 + this._f | 0, this._g = c2 + this._g | 0, this._h = u2 + this._h | 0;
  }, Sha256.prototype._hash = function() {
    var e3 = o4.allocUnsafe(32);
    return e3.writeInt32BE(this._a, 0), e3.writeInt32BE(this._b, 4), e3.writeInt32BE(this._c, 8), e3.writeInt32BE(this._d, 12), e3.writeInt32BE(this._e, 16), e3.writeInt32BE(this._f, 20), e3.writeInt32BE(this._g, 24), e3.writeInt32BE(this._h, 28), e3;
  }, e2.exports = Sha256;
}, 827: function(e2, t2, r2) {
  var n = r2(698), a2 = r2(890), o4 = r2(392), s2 = r2(861).Buffer, l2 = new Array(160);
  function Sha384() {
    this.init(), this._w = l2, o4.call(this, 128, 112);
  }
  n(Sha384, a2), Sha384.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, Sha384.prototype._hash = function() {
    var e3 = s2.allocUnsafe(48);
    function writeInt64BE(t3, r3, n2) {
      e3.writeInt32BE(t3, n2), e3.writeInt32BE(r3, n2 + 4);
    }
    return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), e3;
  }, e2.exports = Sha384;
}, 890: function(e2, t2, r2) {
  var n = r2(698), a2 = r2(392), o4 = r2(861).Buffer, s2 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], l2 = new Array(160);
  function Sha512() {
    this.init(), this._w = l2, a2.call(this, 128, 112);
  }
  function Ch(e3, t3, r3) {
    return r3 ^ e3 & (t3 ^ r3);
  }
  function maj(e3, t3, r3) {
    return e3 & t3 | r3 & (e3 | t3);
  }
  function sigma0(e3, t3) {
    return (e3 >>> 28 | t3 << 4) ^ (t3 >>> 2 | e3 << 30) ^ (t3 >>> 7 | e3 << 25);
  }
  function sigma1(e3, t3) {
    return (e3 >>> 14 | t3 << 18) ^ (e3 >>> 18 | t3 << 14) ^ (t3 >>> 9 | e3 << 23);
  }
  function Gamma0(e3, t3) {
    return (e3 >>> 1 | t3 << 31) ^ (e3 >>> 8 | t3 << 24) ^ e3 >>> 7;
  }
  function Gamma0l(e3, t3) {
    return (e3 >>> 1 | t3 << 31) ^ (e3 >>> 8 | t3 << 24) ^ (e3 >>> 7 | t3 << 25);
  }
  function Gamma1(e3, t3) {
    return (e3 >>> 19 | t3 << 13) ^ (t3 >>> 29 | e3 << 3) ^ e3 >>> 6;
  }
  function Gamma1l(e3, t3) {
    return (e3 >>> 19 | t3 << 13) ^ (t3 >>> 29 | e3 << 3) ^ (e3 >>> 6 | t3 << 26);
  }
  function getCarry(e3, t3) {
    return e3 >>> 0 < t3 >>> 0 ? 1 : 0;
  }
  n(Sha512, a2), Sha512.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  }, Sha512.prototype._update = function(e3) {
    for (var t3 = this._w, r3 = 0 | this._ah, n2 = 0 | this._bh, a3 = 0 | this._ch, o5 = 0 | this._dh, l3 = 0 | this._eh, i2 = 0 | this._fh, c2 = 0 | this._gh, u2 = 0 | this._hh, d2 = 0 | this._al, p2 = 0 | this._bl, m2 = 0 | this._cl, f2 = 0 | this._dl, h2 = 0 | this._el, g2 = 0 | this._fl, y2 = 0 | this._gl, S = 0 | this._hl, _2 = 0; _2 < 32; _2 += 2) t3[_2] = e3.readInt32BE(4 * _2), t3[_2 + 1] = e3.readInt32BE(4 * _2 + 4);
    for (; _2 < 160; _2 += 2) {
      var v2 = t3[_2 - 30], b = t3[_2 - 30 + 1], w2 = Gamma0(v2, b), C2 = Gamma0l(b, v2), x2 = Gamma1(v2 = t3[_2 - 4], b = t3[_2 - 4 + 1]), O2 = Gamma1l(b, v2), k = t3[_2 - 14], N2 = t3[_2 - 14 + 1], A2 = t3[_2 - 32], I = t3[_2 - 32 + 1], R2 = C2 + N2 | 0, T3 = w2 + k + getCarry(R2, C2) | 0;
      T3 = (T3 = T3 + x2 + getCarry(R2 = R2 + O2 | 0, O2) | 0) + A2 + getCarry(R2 = R2 + I | 0, I) | 0, t3[_2] = T3, t3[_2 + 1] = R2;
    }
    for (var B2 = 0; B2 < 160; B2 += 2) {
      T3 = t3[B2], R2 = t3[B2 + 1];
      var j2 = maj(r3, n2, a3), P2 = maj(d2, p2, m2), M2 = sigma0(r3, d2), q2 = sigma0(d2, r3), L2 = sigma1(l3, h2), D = sigma1(h2, l3), U = s2[B2], $ = s2[B2 + 1], J = Ch(l3, i2, c2), V = Ch(h2, g2, y2), K = S + D | 0, z = u2 + L2 + getCarry(K, S) | 0;
      z = (z = (z = z + J + getCarry(K = K + V | 0, V) | 0) + U + getCarry(K = K + $ | 0, $) | 0) + T3 + getCarry(K = K + R2 | 0, R2) | 0;
      var F2 = q2 + P2 | 0, W = M2 + j2 + getCarry(F2, q2) | 0;
      u2 = c2, S = y2, c2 = i2, y2 = g2, i2 = l3, g2 = h2, l3 = o5 + z + getCarry(h2 = f2 + K | 0, f2) | 0, o5 = a3, f2 = m2, a3 = n2, m2 = p2, n2 = r3, p2 = d2, r3 = z + W + getCarry(d2 = K + F2 | 0, K) | 0;
    }
    this._al = this._al + d2 | 0, this._bl = this._bl + p2 | 0, this._cl = this._cl + m2 | 0, this._dl = this._dl + f2 | 0, this._el = this._el + h2 | 0, this._fl = this._fl + g2 | 0, this._gl = this._gl + y2 | 0, this._hl = this._hl + S | 0, this._ah = this._ah + r3 + getCarry(this._al, d2) | 0, this._bh = this._bh + n2 + getCarry(this._bl, p2) | 0, this._ch = this._ch + a3 + getCarry(this._cl, m2) | 0, this._dh = this._dh + o5 + getCarry(this._dl, f2) | 0, this._eh = this._eh + l3 + getCarry(this._el, h2) | 0, this._fh = this._fh + i2 + getCarry(this._fl, g2) | 0, this._gh = this._gh + c2 + getCarry(this._gl, y2) | 0, this._hh = this._hh + u2 + getCarry(this._hl, S) | 0;
  }, Sha512.prototype._hash = function() {
    var e3 = o4.allocUnsafe(64);
    function writeInt64BE(t3, r3, n2) {
      e3.writeInt32BE(t3, n2), e3.writeInt32BE(r3, n2 + 4);
    }
    return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), writeInt64BE(this._gh, this._gl, 48), writeInt64BE(this._hh, this._hl, 56), e3;
  }, e2.exports = Sha512;
}, 310: function(e2, t2, r2) {
  e2.exports = Stream;
  var n = r2(7).EventEmitter;
  function Stream() {
    n.call(this);
  }
  r2(698)(Stream, n), Stream.Readable = r2(412), Stream.Writable = r2(708), Stream.Duplex = r2(382), Stream.Transform = r2(610), Stream.PassThrough = r2(600), Stream.finished = r2(238), Stream.pipeline = r2(758), Stream.Stream = Stream, Stream.prototype.pipe = function(e3, t3) {
    var r3 = this;
    function ondata(t4) {
      e3.writable && false === e3.write(t4) && r3.pause && r3.pause();
    }
    function ondrain() {
      r3.readable && r3.resume && r3.resume();
    }
    r3.on("data", ondata), e3.on("drain", ondrain), e3._isStdio || t3 && false === t3.end || (r3.on("end", onend), r3.on("close", onclose));
    var a2 = false;
    function onend() {
      a2 || (a2 = true, e3.end());
    }
    function onclose() {
      a2 || (a2 = true, "function" == typeof e3.destroy && e3.destroy());
    }
    function onerror(e4) {
      if (cleanup(), 0 === n.listenerCount(this, "error")) throw e4;
    }
    function cleanup() {
      r3.removeListener("data", ondata), e3.removeListener("drain", ondrain), r3.removeListener("end", onend), r3.removeListener("close", onclose), r3.removeListener("error", onerror), e3.removeListener("error", onerror), r3.removeListener("end", cleanup), r3.removeListener("close", cleanup), e3.removeListener("close", cleanup);
    }
    return r3.on("error", onerror), e3.on("error", onerror), r3.on("end", cleanup), r3.on("close", cleanup), e3.on("close", cleanup), e3.emit("pipe", r3), e3;
  };
}, 141: function(e2, t2, r2) {
  var n = r2(861).Buffer, a2 = n.isEncoding || function(e3) {
    switch ((e3 = "" + e3) && e3.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function StringDecoder(e3) {
    var t3;
    switch (this.encoding = function normalizeEncoding(e4) {
      var t4 = function _normalizeEncoding(e5) {
        if (!e5) return "utf8";
        for (var t5; ; ) switch (e5) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e5;
          default:
            if (t5) return;
            e5 = ("" + e5).toLowerCase(), t5 = true;
        }
      }(e4);
      if ("string" != typeof t4 && (n.isEncoding === a2 || !a2(e4))) throw new Error("Unknown encoding: " + e4);
      return t4 || e4;
    }(e3), this.encoding) {
      case "utf16le":
        this.text = utf16Text, this.end = utf16End, t3 = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast, t3 = 4;
        break;
      case "base64":
        this.text = base64Text, this.end = base64End, t3 = 3;
        break;
      default:
        return this.write = simpleWrite, void (this.end = simpleEnd);
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(t3);
  }
  function utf8CheckByte(e3) {
    return e3 <= 127 ? 0 : e3 >> 5 == 6 ? 2 : e3 >> 4 == 14 ? 3 : e3 >> 3 == 30 ? 4 : e3 >> 6 == 2 ? -1 : -2;
  }
  function utf8FillLast(e3) {
    var t3 = this.lastTotal - this.lastNeed, r3 = function utf8CheckExtraBytes(e4, t4, r4) {
      if (128 != (192 & t4[0])) return e4.lastNeed = 0, "";
      if (e4.lastNeed > 1 && t4.length > 1) {
        if (128 != (192 & t4[1])) return e4.lastNeed = 1, "";
        if (e4.lastNeed > 2 && t4.length > 2 && 128 != (192 & t4[2])) return e4.lastNeed = 2, "";
      }
    }(this, e3);
    return void 0 !== r3 ? r3 : this.lastNeed <= e3.length ? (e3.copy(this.lastChar, t3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e3.copy(this.lastChar, t3, 0, e3.length), void (this.lastNeed -= e3.length));
  }
  function utf16Text(e3, t3) {
    if ((e3.length - t3) % 2 == 0) {
      var r3 = e3.toString("utf16le", t3);
      if (r3) {
        var n2 = r3.charCodeAt(r3.length - 1);
        if (n2 >= 55296 && n2 <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e3[e3.length - 2], this.lastChar[1] = e3[e3.length - 1], r3.slice(0, -1);
      }
      return r3;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e3[e3.length - 1], e3.toString("utf16le", t3, e3.length - 1);
  }
  function utf16End(e3) {
    var t3 = e3 && e3.length ? this.write(e3) : "";
    if (this.lastNeed) {
      var r3 = this.lastTotal - this.lastNeed;
      return t3 + this.lastChar.toString("utf16le", 0, r3);
    }
    return t3;
  }
  function base64Text(e3, t3) {
    var r3 = (e3.length - t3) % 3;
    return 0 === r3 ? e3.toString("base64", t3) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 === r3 ? this.lastChar[0] = e3[e3.length - 1] : (this.lastChar[0] = e3[e3.length - 2], this.lastChar[1] = e3[e3.length - 1]), e3.toString("base64", t3, e3.length - r3));
  }
  function base64End(e3) {
    var t3 = e3 && e3.length ? this.write(e3) : "";
    return this.lastNeed ? t3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t3;
  }
  function simpleWrite(e3) {
    return e3.toString(this.encoding);
  }
  function simpleEnd(e3) {
    return e3 && e3.length ? this.write(e3) : "";
  }
  t2.I = StringDecoder, StringDecoder.prototype.write = function(e3) {
    if (0 === e3.length) return "";
    var t3, r3;
    if (this.lastNeed) {
      if (void 0 === (t3 = this.fillLast(e3))) return "";
      r3 = this.lastNeed, this.lastNeed = 0;
    } else r3 = 0;
    return r3 < e3.length ? t3 ? t3 + this.text(e3, r3) : this.text(e3, r3) : t3 || "";
  }, StringDecoder.prototype.end = function utf8End(e3) {
    var t3 = e3 && e3.length ? this.write(e3) : "";
    return this.lastNeed ? t3 + "" : t3;
  }, StringDecoder.prototype.text = function utf8Text(e3, t3) {
    var r3 = function utf8CheckIncomplete(e4, t4, r4) {
      var n3 = t4.length - 1;
      if (n3 < r4) return 0;
      var a3 = utf8CheckByte(t4[n3]);
      if (a3 >= 0) return a3 > 0 && (e4.lastNeed = a3 - 1), a3;
      if (--n3 < r4 || -2 === a3) return 0;
      if (a3 = utf8CheckByte(t4[n3]), a3 >= 0) return a3 > 0 && (e4.lastNeed = a3 - 2), a3;
      if (--n3 < r4 || -2 === a3) return 0;
      if (a3 = utf8CheckByte(t4[n3]), a3 >= 0) return a3 > 0 && (2 === a3 ? a3 = 0 : e4.lastNeed = a3 - 3), a3;
      return 0;
    }(this, e3, t3);
    if (!this.lastNeed) return e3.toString("utf8", t3);
    this.lastTotal = r3;
    var n2 = e3.length - (r3 - this.lastNeed);
    return e3.copy(this.lastChar, 0, n2), e3.toString("utf8", t3, n2);
  }, StringDecoder.prototype.fillLast = function(e3) {
    if (this.lastNeed <= e3.length) return e3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    e3.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e3.length), this.lastNeed -= e3.length;
  };
}, 643: function(e2, t2, r2) {
  function config2(e3) {
    try {
      if (!r2.g.localStorage) return false;
    } catch (e4) {
      return false;
    }
    var t3 = r2.g.localStorage[e3];
    return null != t3 && "true" === String(t3).toLowerCase();
  }
  e2.exports = function deprecate(e3, t3) {
    if (config2("noDeprecation")) return e3;
    var r3 = false;
    return function deprecated() {
      if (!r3) {
        if (config2("throwDeprecation")) throw new Error(t3);
        config2("traceDeprecation") ? console.trace(t3) : console.warn(t3), r3 = true;
      }
      return e3.apply(this, arguments);
    };
  };
}, 499: function(e2) {
  var t2 = { "&": "&amp;", '"': "&quot;", "'": "&apos;", "<": "&lt;", ">": "&gt;" };
  e2.exports = function escapeForXML(e3) {
    return e3 && e3.replace ? e3.replace(/([&"<>'])/g, function(e4, r2) {
      return t2[r2];
    }) : e3;
  };
}, 123: function(e2, t2, r2) {
  var n = r2(606), a2 = r2(499), o4 = r2(310).Stream;
  function resolve4(e3, t3, r3) {
    var n2, o5 = function create_indent(e4, t4) {
      return new Array(t4 || 0).join(e4 || "");
    }(t3, r3 = r3 || 0), s2 = e3;
    if ("object" == typeof e3 && ((s2 = e3[n2 = Object.keys(e3)[0]]) && s2._elem)) return s2._elem.name = n2, s2._elem.icount = r3, s2._elem.indent = t3, s2._elem.indents = o5, s2._elem.interrupt = s2, s2._elem;
    var l2, i2 = [], c2 = [];
    function get_attributes(e4) {
      Object.keys(e4).forEach(function(t4) {
        i2.push(function attribute2(e5, t5) {
          return e5 + '="' + a2(t5) + '"';
        }(t4, e4[t4]));
      });
    }
    switch (typeof s2) {
      case "object":
        if (null === s2) break;
        s2._attr && get_attributes(s2._attr), s2._cdata && c2.push(("<![CDATA[" + s2._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>"), s2.forEach && (l2 = false, c2.push(""), s2.forEach(function(e4) {
          "object" == typeof e4 ? "_attr" == Object.keys(e4)[0] ? get_attributes(e4._attr) : c2.push(resolve4(e4, t3, r3 + 1)) : (c2.pop(), l2 = true, c2.push(a2(e4)));
        }), l2 || c2.push(""));
        break;
      default:
        c2.push(a2(s2));
    }
    return { name: n2, interrupt: false, attributes: i2, content: c2, icount: r3, indents: o5, indent: t3 };
  }
  function format(e3, t3, r3) {
    if ("object" != typeof t3) return e3(false, t3);
    var n2 = t3.interrupt ? 1 : t3.content.length;
    function proceed() {
      for (; t3.content.length; ) {
        var a3 = t3.content.shift();
        if (void 0 !== a3) {
          if (interrupt(a3)) return;
          format(e3, a3);
        }
      }
      e3(false, (n2 > 1 ? t3.indents : "") + (t3.name ? "</" + t3.name + ">" : "") + (t3.indent && !r3 ? "\n" : "")), r3 && r3();
    }
    function interrupt(t4) {
      return !!t4.interrupt && (t4.interrupt.append = e3, t4.interrupt.end = proceed, t4.interrupt = false, e3(true), true);
    }
    if (e3(false, t3.indents + (t3.name ? "<" + t3.name : "") + (t3.attributes.length ? " " + t3.attributes.join(" ") : "") + (n2 ? t3.name ? ">" : "" : t3.name ? "/>" : "") + (t3.indent && n2 > 1 ? "\n" : "")), !n2) return e3(false, t3.indent ? "\n" : "");
    interrupt(t3) || proceed();
  }
  e2.exports = function xml3(e3, t3) {
    "object" != typeof t3 && (t3 = { indent: t3 });
    var r3 = t3.stream ? new o4() : null, a3 = "", s2 = false, l2 = t3.indent ? true === t3.indent ? "    " : t3.indent : "", i2 = true;
    function delay(e4) {
      i2 ? n.nextTick(e4) : e4();
    }
    function append3(e4, t4) {
      if (void 0 !== t4 && (a3 += t4), e4 && !s2 && (r3 = r3 || new o4(), s2 = true), e4 && s2) {
        var n2 = a3;
        delay(function() {
          r3.emit("data", n2);
        }), a3 = "";
      }
    }
    function add4(e4, t4) {
      format(append3, resolve4(e4, l2, l2 ? 1 : 0), t4);
    }
    function end() {
      if (r3) {
        var e4 = a3;
        delay(function() {
          r3.emit("data", e4), r3.emit("end"), r3.readable = false, r3.emit("close");
        });
      }
    }
    return delay(function() {
      i2 = false;
    }), t3.declaration && function addXmlDeclaration(e4) {
      var t4 = { version: "1.0", encoding: e4.encoding || "UTF-8" };
      e4.standalone && (t4.standalone = e4.standalone), add4({ "?xml": { _attr: t4 } }), a3 = a3.replace("/>", "?>");
    }(t3.declaration), e3 && e3.forEach ? e3.forEach(function(t4, r4) {
      var n2;
      r4 + 1 === e3.length && (n2 = end), add4(t4, n2);
    }) : add4(e3, end), r3 ? (r3.readable = true, r3) : a3;
  }, e2.exports.element = e2.exports.Element = function element() {
    var e3 = { _elem: resolve4(Array.prototype.slice.call(arguments)), push: function(e4) {
      if (!this.append) throw new Error("not assigned to a parent!");
      var t3 = this, r3 = this._elem.indent;
      format(this.append, resolve4(e4, r3, this._elem.icount + (r3 ? 1 : 0)), function() {
        t3.append(true);
      });
    }, close: function(e4) {
      void 0 !== e4 && this.push(e4), this.end && this.end();
    } };
    return e3;
  };
}, 987: function(t2) {
  t2.exports = e;
}, 362: function(e2) {
  e2.exports = t;
}, 340: function() {
}, 838: function() {
} };
var xe = {};
function __webpack_require__(e2) {
  var t2 = xe[e2];
  if (void 0 !== t2) return t2.exports;
  var r2 = xe[e2] = { exports: {} };
  return Ce[e2](r2, r2.exports, __webpack_require__), r2.exports;
}
__webpack_require__.n = function(e2) {
  var t2 = e2 && e2.__esModule ? function() {
    return e2.default;
  } : function() {
    return e2;
  };
  return __webpack_require__.d(t2, { a: t2 }), t2;
}, __webpack_require__.d = function(e2, t2) {
  for (var r2 in t2) __webpack_require__.o(t2, r2) && !__webpack_require__.o(e2, r2) && Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
}, __webpack_require__.g = function() {
  if ("object" == typeof globalThis) return globalThis;
  try {
    return this || new Function("return this")();
  } catch (e2) {
    if ("object" == typeof window) return window;
  }
}(), __webpack_require__.o = function(e2, t2) {
  return Object.prototype.hasOwnProperty.call(e2, t2);
}, __webpack_require__.r = function(e2) {
  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
};
var Oe = {};
__webpack_require__.d(Oe, { A: function() {
  return nl;
} });
var ke = {};
__webpack_require__.r(ke), __webpack_require__.d(ke, { CLEAR: function() {
  return ct;
}, CLEAR_BY: function() {
  return ut;
}, NEW_AUTH_ERR: function() {
  return it;
}, NEW_SPEC_ERR: function() {
  return st;
}, NEW_SPEC_ERR_BATCH: function() {
  return lt3;
}, NEW_THROWN_ERR: function() {
  return at;
}, NEW_THROWN_ERR_BATCH: function() {
  return ot;
}, clear: function() {
  return clear;
}, clearBy: function() {
  return clearBy;
}, newAuthErr: function() {
  return newAuthErr;
}, newSpecErr: function() {
  return newSpecErr;
}, newSpecErrBatch: function() {
  return newSpecErrBatch;
}, newThrownErr: function() {
  return newThrownErr;
}, newThrownErrBatch: function() {
  return newThrownErrBatch;
} });
var Ne = {};
__webpack_require__.r(Ne), __webpack_require__.d(Ne, { AUTHORIZE: function() {
  return Rt;
}, AUTHORIZE_OAUTH2: function() {
  return jt;
}, CONFIGURE_AUTH: function() {
  return Mt;
}, LOGOUT: function() {
  return Tt;
}, PRE_AUTHORIZE_OAUTH2: function() {
  return Bt;
}, RESTORE_AUTHORIZATION: function() {
  return qt;
}, SHOW_AUTH_POPUP: function() {
  return It;
}, VALIDATE: function() {
  return Pt;
}, authPopup: function() {
  return authPopup;
}, authorize: function() {
  return authorize;
}, authorizeAccessCodeWithBasicAuthentication: function() {
  return authorizeAccessCodeWithBasicAuthentication;
}, authorizeAccessCodeWithFormParams: function() {
  return authorizeAccessCodeWithFormParams;
}, authorizeApplication: function() {
  return authorizeApplication;
}, authorizeOauth2: function() {
  return authorizeOauth2;
}, authorizeOauth2WithPersistOption: function() {
  return authorizeOauth2WithPersistOption;
}, authorizePassword: function() {
  return authorizePassword;
}, authorizeRequest: function() {
  return authorizeRequest;
}, authorizeWithPersistOption: function() {
  return authorizeWithPersistOption;
}, configureAuth: function() {
  return configureAuth;
}, logout: function() {
  return logout;
}, logoutWithPersistOption: function() {
  return logoutWithPersistOption;
}, persistAuthorizationIfNeeded: function() {
  return persistAuthorizationIfNeeded;
}, preAuthorizeImplicit: function() {
  return preAuthorizeImplicit;
}, restoreAuthorization: function() {
  return restoreAuthorization;
}, showDefinitions: function() {
  return showDefinitions;
} });
var Ae = {};
__webpack_require__.r(Ae), __webpack_require__.d(Ae, { authorized: function() {
  return Jt;
}, definitionsForRequirements: function() {
  return definitionsForRequirements;
}, definitionsToAuthorize: function() {
  return $t;
}, getConfigs: function() {
  return Vt;
}, getDefinitionsByNames: function() {
  return getDefinitionsByNames;
}, isAuthorized: function() {
  return isAuthorized;
}, shownDefinitions: function() {
  return Ut;
} });
var Ie = {};
__webpack_require__.r(Ie), __webpack_require__.d(Ie, { TOGGLE_CONFIGS: function() {
  return Xt;
}, UPDATE_CONFIGS: function() {
  return Gt;
}, downloadConfig: function() {
  return downloadConfig;
}, getConfigByUrl: function() {
  return getConfigByUrl;
}, loaded: function() {
  return actions_loaded;
}, toggle: function() {
  return toggle;
}, update: function() {
  return update3;
} });
var Re = {};
__webpack_require__.r(Re), __webpack_require__.d(Re, { get: function() {
  return get2;
} });
var Te = {};
__webpack_require__.r(Te), __webpack_require__.d(Te, { transform: function() {
  return transform;
} });
var Be = {};
__webpack_require__.r(Be), __webpack_require__.d(Be, { transform: function() {
  return parameter_oneof_transform;
} });
var je = {};
__webpack_require__.r(je), __webpack_require__.d(je, { allErrors: function() {
  return lr;
}, lastError: function() {
  return ir;
} });
var Pe = {};
__webpack_require__.r(Pe), __webpack_require__.d(Pe, { SHOW: function() {
  return mr;
}, UPDATE_FILTER: function() {
  return dr;
}, UPDATE_LAYOUT: function() {
  return ur;
}, UPDATE_MODE: function() {
  return pr;
}, changeMode: function() {
  return changeMode;
}, show: function() {
  return actions_show;
}, updateFilter: function() {
  return updateFilter;
}, updateLayout: function() {
  return updateLayout;
} });
var Me = {};
__webpack_require__.r(Me), __webpack_require__.d(Me, { current: function() {
  return current;
}, currentFilter: function() {
  return currentFilter;
}, isShown: function() {
  return isShown;
}, showSummary: function() {
  return hr2;
}, whatMode: function() {
  return whatMode;
} });
var qe = {};
__webpack_require__.r(qe), __webpack_require__.d(qe, { taggedOperations: function() {
  return taggedOperations;
} });
var Le = {};
__webpack_require__.r(Le), __webpack_require__.d(Le, { requestSnippetGenerator_curl_bash: function() {
  return requestSnippetGenerator_curl_bash;
}, requestSnippetGenerator_curl_cmd: function() {
  return requestSnippetGenerator_curl_cmd;
}, requestSnippetGenerator_curl_powershell: function() {
  return requestSnippetGenerator_curl_powershell;
} });
var De = {};
__webpack_require__.r(De), __webpack_require__.d(De, { getActiveLanguage: function() {
  return Er;
}, getDefaultExpanded: function() {
  return Sr;
}, getGenerators: function() {
  return yr;
}, getSnippetGenerators: function() {
  return getSnippetGenerators;
} });
var Ue = {};
__webpack_require__.r(Ue), __webpack_require__.d(Ue, { JsonSchemaArrayItemFile: function() {
  return JsonSchemaArrayItemFile;
}, JsonSchemaArrayItemText: function() {
  return JsonSchemaArrayItemText;
}, JsonSchemaForm: function() {
  return JsonSchemaForm;
}, JsonSchema_array: function() {
  return JsonSchema_array;
}, JsonSchema_boolean: function() {
  return JsonSchema_boolean;
}, JsonSchema_object: function() {
  return JsonSchema_object;
}, JsonSchema_string: function() {
  return JsonSchema_string;
} });
var $e = {};
__webpack_require__.r($e), __webpack_require__.d($e, { allowTryItOutFor: function() {
  return allowTryItOutFor;
}, basePath: function() {
  return pn;
}, canExecuteScheme: function() {
  return canExecuteScheme;
}, consumes: function() {
  return sn;
}, consumesOptionsFor: function() {
  return consumesOptionsFor;
}, contentTypeValues: function() {
  return contentTypeValues;
}, currentProducesFor: function() {
  return currentProducesFor;
}, definitions: function() {
  return dn;
}, externalDocs: function() {
  return en;
}, findDefinition: function() {
  return findDefinition;
}, getOAS3RequiredRequestBodyContentType: function() {
  return getOAS3RequiredRequestBodyContentType;
}, getParameter: function() {
  return getParameter;
}, hasHost: function() {
  return vn;
}, host: function() {
  return mn;
}, info: function() {
  return Zr;
}, isMediaTypeSchemaPropertiesEqual: function() {
  return isMediaTypeSchemaPropertiesEqual;
}, isOAS3: function() {
  return Qr;
}, lastError: function() {
  return Kr;
}, mutatedRequestFor: function() {
  return mutatedRequestFor;
}, mutatedRequests: function() {
  return _n;
}, operationScheme: function() {
  return operationScheme;
}, operationWithMeta: function() {
  return operationWithMeta;
}, operations: function() {
  return on3;
}, operationsWithRootInherited: function() {
  return hn;
}, operationsWithTags: function() {
  return yn;
}, parameterInclusionSettingFor: function() {
  return parameterInclusionSettingFor;
}, parameterValues: function() {
  return parameterValues;
}, parameterWithMeta: function() {
  return parameterWithMeta;
}, parameterWithMetaByIdentity: function() {
  return parameterWithMetaByIdentity;
}, parametersIncludeIn: function() {
  return parametersIncludeIn;
}, parametersIncludeType: function() {
  return parametersIncludeType;
}, paths: function() {
  return nn;
}, produces: function() {
  return ln;
}, producesOptionsFor: function() {
  return producesOptionsFor;
}, requestFor: function() {
  return requestFor;
}, requests: function() {
  return Sn;
}, responseFor: function() {
  return responseFor;
}, responses: function() {
  return En;
}, schemes: function() {
  return fn;
}, security: function() {
  return cn;
}, securityDefinitions: function() {
  return un;
}, semver: function() {
  return rn;
}, spec: function() {
  return spec;
}, specJS: function() {
  return Gr;
}, specJson: function() {
  return Hr;
}, specJsonWithResolvedSubtrees: function() {
  return Yr;
}, specResolved: function() {
  return Xr;
}, specResolvedSubtree: function() {
  return specResolvedSubtree;
}, specSource: function() {
  return Wr;
}, specStr: function() {
  return Fr;
}, tagDetails: function() {
  return tagDetails;
}, taggedOperations: function() {
  return selectors_taggedOperations;
}, tags: function() {
  return gn;
}, url: function() {
  return zr;
}, validOperationMethods: function() {
  return an;
}, validateBeforeExecute: function() {
  return validateBeforeExecute;
}, validationErrors: function() {
  return validationErrors;
}, version: function() {
  return tn;
} });
var Je = {};
__webpack_require__.r(Je), __webpack_require__.d(Je, { CLEAR_REQUEST: function() {
  return qn;
}, CLEAR_RESPONSE: function() {
  return Mn;
}, CLEAR_VALIDATE_PARAMS: function() {
  return Ln;
}, LOG_REQUEST: function() {
  return Pn;
}, SET_MUTATED_REQUEST: function() {
  return jn;
}, SET_REQUEST: function() {
  return Bn;
}, SET_RESPONSE: function() {
  return Tn;
}, SET_SCHEME: function() {
  return Jn;
}, UPDATE_EMPTY_PARAM_INCLUSION: function() {
  return In;
}, UPDATE_JSON: function() {
  return Nn;
}, UPDATE_OPERATION_META_VALUE: function() {
  return Dn;
}, UPDATE_PARAM: function() {
  return An;
}, UPDATE_RESOLVED: function() {
  return Un;
}, UPDATE_RESOLVED_SUBTREE: function() {
  return $n;
}, UPDATE_SPEC: function() {
  return On;
}, UPDATE_URL: function() {
  return kn;
}, VALIDATE_PARAMS: function() {
  return Rn;
}, changeConsumesValue: function() {
  return changeConsumesValue;
}, changeParam: function() {
  return changeParam;
}, changeParamByIdentity: function() {
  return changeParamByIdentity;
}, changeProducesValue: function() {
  return changeProducesValue;
}, clearRequest: function() {
  return clearRequest;
}, clearResponse: function() {
  return clearResponse;
}, clearValidateParams: function() {
  return clearValidateParams;
}, execute: function() {
  return actions_execute;
}, executeRequest: function() {
  return executeRequest;
}, invalidateResolvedSubtreeCache: function() {
  return invalidateResolvedSubtreeCache;
}, logRequest: function() {
  return logRequest;
}, parseToJson: function() {
  return parseToJson;
}, requestResolvedSubtree: function() {
  return requestResolvedSubtree;
}, resolveSpec: function() {
  return resolveSpec;
}, setMutatedRequest: function() {
  return setMutatedRequest;
}, setRequest: function() {
  return setRequest;
}, setResponse: function() {
  return setResponse;
}, setScheme: function() {
  return setScheme;
}, updateEmptyParamInclusion: function() {
  return updateEmptyParamInclusion;
}, updateJsonSpec: function() {
  return updateJsonSpec;
}, updateResolved: function() {
  return updateResolved;
}, updateResolvedSubtree: function() {
  return updateResolvedSubtree;
}, updateSpec: function() {
  return updateSpec;
}, updateUrl: function() {
  return updateUrl;
}, validateParams: function() {
  return validateParams;
} });
var Ve = {};
__webpack_require__.r(Ve), __webpack_require__.d(Ve, { executeRequest: function() {
  return wrap_actions_executeRequest;
}, updateJsonSpec: function() {
  return wrap_actions_updateJsonSpec;
}, updateSpec: function() {
  return wrap_actions_updateSpec;
}, validateParams: function() {
  return wrap_actions_validateParams;
} });
var Ke = {};
__webpack_require__.r(Ke), __webpack_require__.d(Ke, { Button: function() {
  return Button;
}, Col: function() {
  return Col;
}, Collapse: function() {
  return Collapse;
}, Container: function() {
  return Container;
}, Input: function() {
  return Input;
}, Link: function() {
  return Link3;
}, Row: function() {
  return Row;
}, Select: function() {
  return Select;
}, TextArea: function() {
  return TextArea;
} });
var ze = {};
__webpack_require__.r(ze), __webpack_require__.d(ze, { basePath: function() {
  return Wa;
}, consumes: function() {
  return Ha;
}, definitions: function() {
  return Va;
}, findDefinition: function() {
  return Ja;
}, hasHost: function() {
  return Ka;
}, host: function() {
  return Fa;
}, produces: function() {
  return Ga;
}, schemes: function() {
  return Xa;
}, securityDefinitions: function() {
  return za;
}, validOperationMethods: function() {
  return wrap_selectors_validOperationMethods;
} });
var Fe = {};
__webpack_require__.r(Fe), __webpack_require__.d(Fe, { definitionsToAuthorize: function() {
  return Ya;
} });
var We = {};
__webpack_require__.r(We), __webpack_require__.d(We, { callbacksOperations: function() {
  return eo;
}, findSchema: function() {
  return findSchema;
}, isOAS3: function() {
  return selectors_isOAS3;
}, isOAS30: function() {
  return selectors_isOAS30;
}, isSwagger2: function() {
  return selectors_isSwagger2;
}, servers: function() {
  return Za;
} });
var He = {};
__webpack_require__.r(He), __webpack_require__.d(He, { CLEAR_REQUEST_BODY_VALIDATE_ERROR: function() {
  return vo;
}, CLEAR_REQUEST_BODY_VALUE: function() {
  return bo;
}, SET_REQUEST_BODY_VALIDATE_ERROR: function() {
  return _o;
}, UPDATE_ACTIVE_EXAMPLES_MEMBER: function() {
  return go;
}, UPDATE_REQUEST_BODY_INCLUSION: function() {
  return ho;
}, UPDATE_REQUEST_BODY_VALUE: function() {
  return mo;
}, UPDATE_REQUEST_BODY_VALUE_RETAIN_FLAG: function() {
  return fo;
}, UPDATE_REQUEST_CONTENT_TYPE: function() {
  return yo;
}, UPDATE_RESPONSE_CONTENT_TYPE: function() {
  return Eo;
}, UPDATE_SELECTED_SERVER: function() {
  return po;
}, UPDATE_SERVER_VARIABLE_VALUE: function() {
  return So;
}, clearRequestBodyValidateError: function() {
  return clearRequestBodyValidateError;
}, clearRequestBodyValue: function() {
  return clearRequestBodyValue;
}, initRequestBodyValidateError: function() {
  return initRequestBodyValidateError;
}, setActiveExamplesMember: function() {
  return setActiveExamplesMember;
}, setRequestBodyInclusion: function() {
  return setRequestBodyInclusion;
}, setRequestBodyValidateError: function() {
  return setRequestBodyValidateError;
}, setRequestBodyValue: function() {
  return setRequestBodyValue;
}, setRequestContentType: function() {
  return setRequestContentType;
}, setResponseContentType: function() {
  return setResponseContentType;
}, setRetainRequestBodyValueFlag: function() {
  return setRetainRequestBodyValueFlag;
}, setSelectedServer: function() {
  return setSelectedServer;
}, setServerVariableValue: function() {
  return setServerVariableValue;
} });
var Ge = {};
__webpack_require__.r(Ge), __webpack_require__.d(Ge, { activeExamplesMember: function() {
  return Io;
}, hasUserEditedBody: function() {
  return ko;
}, requestBodyErrors: function() {
  return Ao;
}, requestBodyInclusionSetting: function() {
  return No;
}, requestBodyValue: function() {
  return xo;
}, requestContentType: function() {
  return Ro;
}, responseContentType: function() {
  return To;
}, selectDefaultRequestBodyValue: function() {
  return selectDefaultRequestBodyValue;
}, selectedServer: function() {
  return Co;
}, serverEffectiveValue: function() {
  return Po;
}, serverVariableValue: function() {
  return Bo;
}, serverVariables: function() {
  return jo;
}, shouldRetainRequestBodyValue: function() {
  return Oo;
}, validOperationMethods: function() {
  return qo;
}, validateBeforeExecute: function() {
  return Mo;
}, validateShallowRequired: function() {
  return validateShallowRequired;
} });
var Xe = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ Component: function() {
  return r.Component;
}, PureComponent: function() {
  return r.PureComponent;
}, createContext: function() {
  return r.createContext;
}, createElement: function() {
  return r.createElement;
}, default: function() {
  return r.default;
}, forwardRef: function() {
  return r.forwardRef;
}, useCallback: function() {
  return r.useCallback;
}, useContext: function() {
  return r.useContext;
}, useEffect: function() {
  return r.useEffect;
}, useMemo: function() {
  return r.useMemo;
}, useRef: function() {
  return r.useRef;
}, useState: function() {
  return r.useState;
} });
var Ye = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ applyMiddleware: function() {
  return applyMiddleware;
}, bindActionCreators: function() {
  return bindActionCreators;
}, compose: function() {
  return compose;
}, createStore: function() {
  return createStore;
} });
var Qe = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ List: function() {
  return a.List;
}, Map: function() {
  return a.Map;
}, OrderedMap: function() {
  return a.OrderedMap;
}, Seq: function() {
  return a.Seq;
}, Set: function() {
  return a.Set;
}, default: function() {
  return a.default;
}, fromJS: function() {
  return a.fromJS;
} });
var Ze = __webpack_require__(919);
var et = __webpack_require__.n(Ze);
var tt = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ combineReducers: function() {
  return o3.combineReducers;
} });
var rt = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ serializeError: function() {
  return s.serializeError;
} });
var nt = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return l.default;
} });
var at = "err_new_thrown_err";
var ot = "err_new_thrown_err_batch";
var st = "err_new_spec_err";
var lt3 = "err_new_spec_err_batch";
var it = "err_new_auth_err";
var ct = "err_clear";
var ut = "err_clear_by";
function newThrownErr(e2) {
  return { type: at, payload: (0, rt.serializeError)(e2) };
}
function newThrownErrBatch(e2) {
  return { type: ot, payload: e2 };
}
function newSpecErr(e2) {
  return { type: st, payload: e2 };
}
function newSpecErrBatch(e2) {
  return { type: lt3, payload: e2 };
}
function newAuthErr(e2) {
  return { type: it, payload: e2 };
}
function clear(e2 = {}) {
  return { type: ct, payload: e2 };
}
function clearBy(e2 = () => true) {
  return { type: ut, payload: e2 };
}
var dt = function makeWindow() {
  var e2 = { location: {}, history: {}, open: () => {
  }, close: () => {
  }, File: function() {
  }, FormData: function() {
  } };
  if ("undefined" == typeof window) return e2;
  try {
    e2 = window;
    for (var t2 of ["File", "Blob", "FormData"]) t2 in window && (e2[t2] = window[t2]);
  } catch (e3) {
    console.error(e3);
  }
  return e2;
}();
var pt = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ sanitizeUrl: function() {
  return i.sanitizeUrl;
} });
var mt = (function(e2) {
  var t2 = {};
  __webpack_require__.d(t2, e2);
}({}), function(e2) {
  var t2 = {};
  __webpack_require__.d(t2, e2);
}({}), function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return d.default;
} }));
var ht = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return p.default;
} });
var gt3 = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return m.default;
} });
var yt = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return f.default;
} });
var Et = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return h.default;
} });
var St = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return g.default;
} });
var _t = __webpack_require__(209);
var vt = __webpack_require__.n(_t);
var bt = __webpack_require__(802);
var wt = __webpack_require__.n(bt);
var Ct = Qe.default.Set.of("type", "format", "items", "default", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "minLength", "pattern", "maxItems", "minItems", "uniqueItems", "enum", "multipleOf");
function getParameterSchema(e2, { isOAS3: t2 } = {}) {
  if (!Qe.default.Map.isMap(e2)) return { schema: Qe.default.Map(), parameterContentMediaType: null };
  if (!t2) return "body" === e2.get("in") ? { schema: e2.get("schema", Qe.default.Map()), parameterContentMediaType: null } : { schema: e2.filter((e3, t3) => Ct.includes(t3)), parameterContentMediaType: null };
  if (e2.get("content")) {
    const t3 = e2.get("content", Qe.default.Map({})).keySeq().first();
    return { schema: e2.getIn(["content", t3, "schema"], Qe.default.Map()), parameterContentMediaType: t3 };
  }
  return { schema: e2.get("schema") ? e2.get("schema", Qe.default.Map()) : Qe.default.Map(), parameterContentMediaType: null };
}
var xt = __webpack_require__(287).Buffer;
var Ot = "default";
var isImmutable = (e2) => Qe.default.Iterable.isIterable(e2);
function objectify(e2) {
  return isObject5(e2) ? isImmutable(e2) ? e2.toJS() : e2 : {};
}
function fromJSOrdered(e2) {
  if (isImmutable(e2)) return e2;
  if (e2 instanceof dt.File) return e2;
  if (!isObject5(e2)) return e2;
  if (Array.isArray(e2)) return Qe.default.Seq(e2).map(fromJSOrdered).toList();
  if ((0, Et.default)(e2.entries)) {
    const t2 = function createObjWithHashedKeys(e3) {
      if (!(0, Et.default)(e3.entries)) return e3;
      const t3 = {}, r2 = "_**[]", n = {};
      for (let a2 of e3.entries()) if (t3[a2[0]] || n[a2[0]] && n[a2[0]].containsMultiple) {
        if (!n[a2[0]]) {
          n[a2[0]] = { containsMultiple: true, length: 1 }, t3[`${a2[0]}${r2}${n[a2[0]].length}`] = t3[a2[0]], delete t3[a2[0]];
        }
        n[a2[0]].length += 1, t3[`${a2[0]}${r2}${n[a2[0]].length}`] = a2[1];
      } else t3[a2[0]] = a2[1];
      return t3;
    }(e2);
    return Qe.default.OrderedMap(t2).map(fromJSOrdered);
  }
  return Qe.default.OrderedMap(e2).map(fromJSOrdered);
}
function normalizeArray2(e2) {
  return Array.isArray(e2) ? e2 : [e2];
}
function isFn(e2) {
  return "function" == typeof e2;
}
function isObject5(e2) {
  return !!e2 && "object" == typeof e2;
}
function isFunc(e2) {
  return "function" == typeof e2;
}
function isArray3(e2) {
  return Array.isArray(e2);
}
var kt = mt.default;
function objMap(e2, t2) {
  return Object.keys(e2).reduce((r2, n) => (r2[n] = t2(e2[n], n), r2), {});
}
function objReduce(e2, t2) {
  return Object.keys(e2).reduce((r2, n) => {
    let a2 = t2(e2[n], n);
    return a2 && "object" == typeof a2 && Object.assign(r2, a2), r2;
  }, {});
}
function systemThunkMiddleware(e2) {
  return ({ dispatch: t2, getState: r2 }) => (t3) => (r3) => "function" == typeof r3 ? r3(e2()) : t3(r3);
}
function validateValueBySchema(e2, t2, r2, n, a2) {
  if (!t2) return [];
  let o4 = [], s2 = t2.get("nullable"), l2 = t2.get("required"), i2 = t2.get("maximum"), c2 = t2.get("minimum"), u2 = t2.get("type"), d2 = t2.get("format"), p2 = t2.get("maxLength"), m2 = t2.get("minLength"), f2 = t2.get("uniqueItems"), h2 = t2.get("maxItems"), g2 = t2.get("minItems"), y2 = t2.get("pattern");
  const S = r2 || true === l2, _2 = null != e2, v2 = S || _2 && "array" === u2 || !(!S && !_2), b = s2 && null === e2;
  if (S && !_2 && !b && !n && !u2) return o4.push("Required field is not provided"), o4;
  if (b || !u2 || !v2) return [];
  let w2 = "string" === u2 && e2, C2 = "array" === u2 && Array.isArray(e2) && e2.length, x2 = "array" === u2 && Qe.default.List.isList(e2) && e2.count();
  const O2 = [w2, C2, x2, "array" === u2 && "string" == typeof e2 && e2, "file" === u2 && e2 instanceof dt.File, "boolean" === u2 && (e2 || false === e2), "number" === u2 && (e2 || 0 === e2), "integer" === u2 && (e2 || 0 === e2), "object" === u2 && "object" == typeof e2 && null !== e2, "object" === u2 && "string" == typeof e2 && e2].some((e3) => !!e3);
  if (S && !O2 && !n) return o4.push("Required field is not provided"), o4;
  if ("object" === u2 && (null === a2 || "application/json" === a2)) {
    let r3 = e2;
    if ("string" == typeof e2) try {
      r3 = JSON.parse(e2);
    } catch (e3) {
      return o4.push("Parameter string value must be valid JSON"), o4;
    }
    t2 && t2.has("required") && isFunc(l2.isList) && l2.isList() && l2.forEach((e3) => {
      void 0 === r3[e3] && o4.push({ propKey: e3, error: "Required property not found" });
    }), t2 && t2.has("properties") && t2.get("properties").forEach((e3, t3) => {
      const s3 = validateValueBySchema(r3[t3], e3, false, n, a2);
      o4.push(...s3.map((e4) => ({ propKey: t3, error: e4 })));
    });
  }
  if (y2) {
    let t3 = ((e3, t4) => {
      if (!new RegExp(t4).test(e3)) return "Value must follow pattern " + t4;
    })(e2, y2);
    t3 && o4.push(t3);
  }
  if (g2 && "array" === u2) {
    let t3 = ((e3, t4) => {
      if (!e3 && t4 >= 1 || e3 && e3.length < t4) return `Array must contain at least ${t4} item${1 === t4 ? "" : "s"}`;
    })(e2, g2);
    t3 && o4.push(t3);
  }
  if (h2 && "array" === u2) {
    let t3 = ((e3, t4) => {
      if (e3 && e3.length > t4) return `Array must not contain more then ${t4} item${1 === t4 ? "" : "s"}`;
    })(e2, h2);
    t3 && o4.push({ needRemove: true, error: t3 });
  }
  if (f2 && "array" === u2) {
    let t3 = ((e3, t4) => {
      if (e3 && ("true" === t4 || true === t4)) {
        const t5 = (0, Qe.fromJS)(e3), r3 = t5.toSet();
        if (e3.length > r3.size) {
          let e4 = (0, Qe.Set)();
          if (t5.forEach((r4, n2) => {
            t5.filter((e5) => isFunc(e5.equals) ? e5.equals(r4) : e5 === r4).size > 1 && (e4 = e4.add(n2));
          }), 0 !== e4.size) return e4.map((e5) => ({ index: e5, error: "No duplicates allowed." })).toArray();
        }
      }
    })(e2, f2);
    t3 && o4.push(...t3);
  }
  if (p2 || 0 === p2) {
    let t3 = ((e3, t4) => {
      if (e3.length > t4) return `Value must be no longer than ${t4} character${1 !== t4 ? "s" : ""}`;
    })(e2, p2);
    t3 && o4.push(t3);
  }
  if (m2) {
    let t3 = ((e3, t4) => {
      if (e3.length < t4) return `Value must be at least ${t4} character${1 !== t4 ? "s" : ""}`;
    })(e2, m2);
    t3 && o4.push(t3);
  }
  if (i2 || 0 === i2) {
    let t3 = ((e3, t4) => {
      if (e3 > t4) return `Value must be less than ${t4}`;
    })(e2, i2);
    t3 && o4.push(t3);
  }
  if (c2 || 0 === c2) {
    let t3 = ((e3, t4) => {
      if (e3 < t4) return `Value must be greater than ${t4}`;
    })(e2, c2);
    t3 && o4.push(t3);
  }
  if ("string" === u2) {
    let t3;
    if (t3 = "date-time" === d2 ? ((e3) => {
      if (isNaN(Date.parse(e3))) return "Value must be a DateTime";
    })(e2) : "uuid" === d2 ? ((e3) => {
      if (e3 = e3.toString().toLowerCase(), !/^[{(]?[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}[)}]?$/.test(e3)) return "Value must be a Guid";
    })(e2) : ((e3) => {
      if (e3 && "string" != typeof e3) return "Value must be a string";
    })(e2), !t3) return o4;
    o4.push(t3);
  } else if ("boolean" === u2) {
    let t3 = ((e3) => {
      if ("true" !== e3 && "false" !== e3 && true !== e3 && false !== e3) return "Value must be a boolean";
    })(e2);
    if (!t3) return o4;
    o4.push(t3);
  } else if ("number" === u2) {
    let t3 = ((e3) => {
      if (!/^-?\d+(\.?\d+)?$/.test(e3)) return "Value must be a number";
    })(e2);
    if (!t3) return o4;
    o4.push(t3);
  } else if ("integer" === u2) {
    let t3 = ((e3) => {
      if (!/^-?\d+$/.test(e3)) return "Value must be an integer";
    })(e2);
    if (!t3) return o4;
    o4.push(t3);
  } else if ("array" === u2) {
    if (!C2 && !x2) return o4;
    e2 && e2.forEach((e3, r3) => {
      const s3 = validateValueBySchema(e3, t2.get("items"), false, n, a2);
      o4.push(...s3.map((e4) => ({ index: r3, error: e4 })));
    });
  } else if ("file" === u2) {
    let t3 = ((e3) => {
      if (e3 && !(e3 instanceof dt.File)) return "Value must be a file";
    })(e2);
    if (!t3) return o4;
    o4.push(t3);
  }
  return o4;
}
var btoa3 = (e2) => {
  let t2;
  return t2 = e2 instanceof xt ? e2 : xt.from(e2.toString(), "utf-8"), t2.toString("base64");
};
var Nt = { operationsSorter: { alpha: (e2, t2) => e2.get("path").localeCompare(t2.get("path")), method: (e2, t2) => e2.get("method").localeCompare(t2.get("method")) }, tagsSorter: { alpha: (e2, t2) => e2.localeCompare(t2) } };
var buildFormData2 = (e2) => {
  let t2 = [];
  for (let r2 in e2) {
    let n = e2[r2];
    void 0 !== n && "" !== n && t2.push([r2, "=", encodeURIComponent(n).replace(/%20/g, "+")].join(""));
  }
  return t2.join("&");
};
var shallowEqualKeys = (e2, t2, r2) => !!(0, ht.default)(r2, (r3) => (0, yt.default)(e2[r3], t2[r3]));
function sanitizeUrl2(e2) {
  return "string" != typeof e2 || "" === e2 ? "" : (0, pt.sanitizeUrl)(e2);
}
function requiresValidationURL(e2) {
  return !(!e2 || e2.indexOf("localhost") >= 0 || e2.indexOf("127.0.0.1") >= 0 || "none" === e2);
}
var createDeepLinkPath = (e2) => "string" == typeof e2 || e2 instanceof String ? e2.trim().replace(/\s/g, "%20") : "";
var escapeDeepLinkPath = (e2) => (0, St.default)(createDeepLinkPath(e2).replace(/%20/g, "_"));
var getExtensions = (e2) => e2.filter((e3, t2) => /^x-/.test(t2));
var getCommonExtensions = (e2) => e2.filter((e3, t2) => /^pattern|maxLength|minLength|maximum|minimum/.test(t2));
function deeplyStripKey(e2, t2, r2 = () => true) {
  if ("object" != typeof e2 || Array.isArray(e2) || null === e2 || !t2) return e2;
  const n = Object.assign({}, e2);
  return Object.keys(n).forEach((e3) => {
    e3 === t2 && r2(n[e3], e3) ? delete n[e3] : n[e3] = deeplyStripKey(n[e3], t2, r2);
  }), n;
}
function stringify(e2) {
  if ("string" == typeof e2) return e2;
  if (e2 && e2.toJS && (e2 = e2.toJS()), "object" == typeof e2 && null !== e2) try {
    return JSON.stringify(e2, null, 2);
  } catch (t2) {
    return String(e2);
  }
  return null == e2 ? "" : e2.toString();
}
function paramToIdentifier(e2, { returnAll: t2 = false, allowHashes: r2 = true } = {}) {
  if (!Qe.default.Map.isMap(e2)) throw new Error("paramToIdentifier: received a non-Im.Map parameter as input");
  const n = e2.get("name"), a2 = e2.get("in");
  let o4 = [];
  return e2 && e2.hashCode && a2 && n && r2 && o4.push(`${a2}.${n}.hash-${e2.hashCode()}`), a2 && n && o4.push(`${a2}.${n}`), o4.push(n), t2 ? o4 : o4[0] || "";
}
function paramToValue(e2, t2) {
  return paramToIdentifier(e2, { returnAll: true }).map((e3) => t2[e3]).filter((e3) => void 0 !== e3)[0];
}
function b64toB64UrlEncoded(e2) {
  return e2.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
var isEmptyValue = (e2) => !e2 || !(!isImmutable(e2) || !e2.isEmpty());
var idFn = (e2) => e2;
var Store = class {
  constructor(e2 = {}) {
    et()(this, { state: {}, plugins: [], system: { configs: {}, fn: {}, components: {}, rootInjects: {}, statePlugins: {} }, boundSystem: {}, toolbox: {} }, e2), this.getSystem = this._getSystem.bind(this), this.store = function configureStore(e3, t2, r2) {
      return function createStoreWithMiddleware(e4, t3, r3) {
        let n = [systemThunkMiddleware(r3)];
        const a2 = dt.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || Ye.compose;
        return (0, Ye.createStore)(e4, t3, a2((0, Ye.applyMiddleware)(...n)));
      }(e3, t2, r2);
    }(idFn, (0, Qe.fromJS)(this.state), this.getSystem), this.buildSystem(false), this.register(this.plugins);
  }
  getStore() {
    return this.store;
  }
  register(e2, t2 = true) {
    var r2 = combinePlugins(e2, this.getSystem());
    systemExtend(this.system, r2), t2 && this.buildSystem();
    callAfterLoad.call(this.system, e2, this.getSystem()) && this.buildSystem();
  }
  buildSystem(e2 = true) {
    let t2 = this.getStore().dispatch, r2 = this.getStore().getState;
    this.boundSystem = Object.assign({}, this.getRootInjects(), this.getWrappedAndBoundActions(t2), this.getWrappedAndBoundSelectors(r2, this.getSystem), this.getStateThunks(r2), this.getFn(), this.getConfigs()), e2 && this.rebuildReducer();
  }
  _getSystem() {
    return this.boundSystem;
  }
  getRootInjects() {
    return Object.assign({ getSystem: this.getSystem, getStore: this.getStore.bind(this), getComponents: this.getComponents.bind(this), getState: this.getStore().getState, getConfigs: this._getConfigs.bind(this), Im: Qe.default, React: Xe.default }, this.system.rootInjects || {});
  }
  _getConfigs() {
    return this.system.configs;
  }
  getConfigs() {
    return { configs: this.system.configs };
  }
  setConfigs(e2) {
    this.system.configs = e2;
  }
  rebuildReducer() {
    this.store.replaceReducer(function buildReducer(e2) {
      return function allReducers(e3) {
        let t2 = Object.keys(e3).reduce((t3, r2) => (t3[r2] = /* @__PURE__ */ function makeReducer(e4) {
          return (t4 = new Qe.Map(), r3) => {
            if (!e4) return t4;
            let n = e4[r3.type];
            if (n) {
              const e5 = wrapWithTryCatch(n)(t4, r3);
              return null === e5 ? t4 : e5;
            }
            return t4;
          };
        }(e3[r2]), t3), {});
        if (!Object.keys(t2).length) return idFn;
        return (0, tt.combineReducers)(t2);
      }(objMap(e2, (e3) => e3.reducers));
    }(this.system.statePlugins));
  }
  getType(e2) {
    let t2 = e2[0].toUpperCase() + e2.slice(1);
    return objReduce(this.system.statePlugins, (r2, n) => {
      let a2 = r2[e2];
      if (a2) return { [n + t2]: a2 };
    });
  }
  getSelectors() {
    return this.getType("selectors");
  }
  getActions() {
    return objMap(this.getType("actions"), (e2) => objReduce(e2, (e3, t2) => {
      if (isFn(e3)) return { [t2]: e3 };
    }));
  }
  getWrappedAndBoundActions(e2) {
    return objMap(this.getBoundActions(e2), (e3, t2) => {
      let r2 = this.system.statePlugins[t2.slice(0, -7)].wrapActions;
      return r2 ? objMap(e3, (e4, t3) => {
        let n = r2[t3];
        return n ? (Array.isArray(n) || (n = [n]), n.reduce((e5, t4) => {
          let newAction = (...r3) => t4(e5, this.getSystem())(...r3);
          if (!isFn(newAction)) throw new TypeError("wrapActions needs to return a function that returns a new function (ie the wrapped action)");
          return wrapWithTryCatch(newAction);
        }, e4 || Function.prototype)) : e4;
      }) : e3;
    });
  }
  getWrappedAndBoundSelectors(e2, t2) {
    return objMap(this.getBoundSelectors(e2, t2), (t3, r2) => {
      let n = [r2.slice(0, -9)], a2 = this.system.statePlugins[n].wrapSelectors;
      return a2 ? objMap(t3, (t4, r3) => {
        let o4 = a2[r3];
        return o4 ? (Array.isArray(o4) || (o4 = [o4]), o4.reduce((t5, r4) => {
          let wrappedSelector = (...a3) => r4(t5, this.getSystem())(e2().getIn(n), ...a3);
          if (!isFn(wrappedSelector)) throw new TypeError("wrapSelector needs to return a function that returns a new function (ie the wrapped action)");
          return wrappedSelector;
        }, t4 || Function.prototype)) : t4;
      }) : t3;
    });
  }
  getStates(e2) {
    return Object.keys(this.system.statePlugins).reduce((t2, r2) => (t2[r2] = e2.get(r2), t2), {});
  }
  getStateThunks(e2) {
    return Object.keys(this.system.statePlugins).reduce((t2, r2) => (t2[r2] = () => e2().get(r2), t2), {});
  }
  getFn() {
    return { fn: this.system.fn };
  }
  getComponents(e2) {
    const t2 = this.system.components[e2];
    return Array.isArray(t2) ? t2.reduce((e3, t3) => t3(e3, this.getSystem())) : void 0 !== e2 ? this.system.components[e2] : this.system.components;
  }
  getBoundSelectors(e2, t2) {
    return objMap(this.getSelectors(), (r2, n) => {
      let a2 = [n.slice(0, -9)];
      return objMap(r2, (r3) => (...n2) => {
        let o4 = wrapWithTryCatch(r3).apply(null, [e2().getIn(a2), ...n2]);
        return "function" == typeof o4 && (o4 = wrapWithTryCatch(o4)(t2())), o4;
      });
    });
  }
  getBoundActions(e2) {
    e2 = e2 || this.getStore().dispatch;
    const t2 = this.getActions(), process3 = (e3) => "function" != typeof e3 ? objMap(e3, (e4) => process3(e4)) : (...t3) => {
      var r2 = null;
      try {
        r2 = e3(...t3);
      } catch (e4) {
        r2 = { type: at, error: true, payload: (0, rt.serializeError)(e4) };
      } finally {
        return r2;
      }
    };
    return objMap(t2, (t3) => (0, Ye.bindActionCreators)(process3(t3), e2));
  }
  getMapStateToProps() {
    return () => Object.assign({}, this.getSystem());
  }
  getMapDispatchToProps(e2) {
    return (t2) => et()({}, this.getWrappedAndBoundActions(t2), this.getFn(), e2);
  }
};
function combinePlugins(e2, t2) {
  return isObject5(e2) && !isArray3(e2) ? (0, nt.default)({}, e2) : isFunc(e2) ? combinePlugins(e2(t2), t2) : isArray3(e2) ? e2.map((e3) => combinePlugins(e3, t2)).reduce(systemExtend, { components: t2.getComponents() }) : {};
}
function callAfterLoad(e2, t2, { hasLoaded: r2 } = {}) {
  let n = r2;
  return isObject5(e2) && !isArray3(e2) && "function" == typeof e2.afterLoad && (n = true, wrapWithTryCatch(e2.afterLoad).call(this, t2)), isFunc(e2) ? callAfterLoad.call(this, e2(t2), t2, { hasLoaded: n }) : isArray3(e2) ? e2.map((e3) => callAfterLoad.call(this, e3, t2, { hasLoaded: n })) : n;
}
function systemExtend(e2 = {}, t2 = {}) {
  if (!isObject5(e2)) return {};
  if (!isObject5(t2)) return e2;
  t2.wrapComponents && (objMap(t2.wrapComponents, (r3, n) => {
    const a2 = e2.components && e2.components[n];
    a2 && Array.isArray(a2) ? (e2.components[n] = a2.concat([r3]), delete t2.wrapComponents[n]) : a2 && (e2.components[n] = [a2, r3], delete t2.wrapComponents[n]);
  }), Object.keys(t2.wrapComponents).length || delete t2.wrapComponents);
  const { statePlugins: r2 } = e2;
  if (isObject5(r2)) for (let e3 in r2) {
    const n = r2[e3];
    if (!isObject5(n)) continue;
    const { wrapActions: a2, wrapSelectors: o4 } = n;
    if (isObject5(a2)) for (let r3 in a2) {
      let n2 = a2[r3];
      Array.isArray(n2) || (n2 = [n2], a2[r3] = n2), t2 && t2.statePlugins && t2.statePlugins[e3] && t2.statePlugins[e3].wrapActions && t2.statePlugins[e3].wrapActions[r3] && (t2.statePlugins[e3].wrapActions[r3] = a2[r3].concat(t2.statePlugins[e3].wrapActions[r3]));
    }
    if (isObject5(o4)) for (let r3 in o4) {
      let n2 = o4[r3];
      Array.isArray(n2) || (n2 = [n2], o4[r3] = n2), t2 && t2.statePlugins && t2.statePlugins[e3] && t2.statePlugins[e3].wrapSelectors && t2.statePlugins[e3].wrapSelectors[r3] && (t2.statePlugins[e3].wrapSelectors[r3] = o4[r3].concat(t2.statePlugins[e3].wrapSelectors[r3]));
    }
  }
  return et()(e2, t2);
}
function wrapWithTryCatch(e2, { logErrors: t2 = true } = {}) {
  return "function" != typeof e2 ? e2 : function(...r2) {
    try {
      return e2.call(this, ...r2);
    } catch (e3) {
      return t2 && console.error(e3), null;
    }
  };
}
var At = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return y.default;
} });
var It = "show_popup";
var Rt = "authorize";
var Tt = "logout";
var Bt = "pre_authorize_oauth2";
var jt = "authorize_oauth2";
var Pt = "validate";
var Mt = "configure_auth";
var qt = "restore_authorization";
function showDefinitions(e2) {
  return { type: It, payload: e2 };
}
function authorize(e2) {
  return { type: Rt, payload: e2 };
}
var authorizeWithPersistOption = (e2) => ({ authActions: t2 }) => {
  t2.authorize(e2), t2.persistAuthorizationIfNeeded();
};
function logout(e2) {
  return { type: Tt, payload: e2 };
}
var logoutWithPersistOption = (e2) => ({ authActions: t2 }) => {
  t2.logout(e2), t2.persistAuthorizationIfNeeded();
};
var preAuthorizeImplicit = (e2) => ({ authActions: t2, errActions: r2 }) => {
  let { auth: n, token: a2, isValid: o4 } = e2, { schema: s2, name: l2 } = n, i2 = s2.get("flow");
  delete dt.swaggerUIRedirectOauth2, "accessCode" === i2 || o4 || r2.newAuthErr({ authId: l2, source: "auth", level: "warning", message: "Authorization may be unsafe, passed state was changed in server Passed state wasn't returned from auth server" }), a2.error ? r2.newAuthErr({ authId: l2, source: "auth", level: "error", message: JSON.stringify(a2) }) : t2.authorizeOauth2WithPersistOption({ auth: n, token: a2 });
};
function authorizeOauth2(e2) {
  return { type: jt, payload: e2 };
}
var authorizeOauth2WithPersistOption = (e2) => ({ authActions: t2 }) => {
  t2.authorizeOauth2(e2), t2.persistAuthorizationIfNeeded();
};
var authorizePassword = (e2) => ({ authActions: t2 }) => {
  let { schema: r2, name: n, username: a2, password: o4, passwordType: s2, clientId: l2, clientSecret: i2 } = e2, c2 = { grant_type: "password", scope: e2.scopes.join(" "), username: a2, password: o4 }, u2 = {};
  switch (s2) {
    case "request-body":
      !function setClientIdAndSecret(e3, t3, r3) {
        t3 && Object.assign(e3, { client_id: t3 });
        r3 && Object.assign(e3, { client_secret: r3 });
      }(c2, l2, i2);
      break;
    case "basic":
      u2.Authorization = "Basic " + btoa3(l2 + ":" + i2);
      break;
    default:
      console.warn(`Warning: invalid passwordType ${s2} was passed, not including client id and secret`);
  }
  return t2.authorizeRequest({ body: buildFormData2(c2), url: r2.get("tokenUrl"), name: n, headers: u2, query: {}, auth: e2 });
};
var authorizeApplication = (e2) => ({ authActions: t2 }) => {
  let { schema: r2, scopes: n, name: a2, clientId: o4, clientSecret: s2 } = e2, l2 = { Authorization: "Basic " + btoa3(o4 + ":" + s2) }, i2 = { grant_type: "client_credentials", scope: n.join(" ") };
  return t2.authorizeRequest({ body: buildFormData2(i2), name: a2, url: r2.get("tokenUrl"), auth: e2, headers: l2 });
};
var authorizeAccessCodeWithFormParams = ({ auth: e2, redirectUrl: t2 }) => ({ authActions: r2 }) => {
  let { schema: n, name: a2, clientId: o4, clientSecret: s2, codeVerifier: l2 } = e2, i2 = { grant_type: "authorization_code", code: e2.code, client_id: o4, client_secret: s2, redirect_uri: t2, code_verifier: l2 };
  return r2.authorizeRequest({ body: buildFormData2(i2), name: a2, url: n.get("tokenUrl"), auth: e2 });
};
var authorizeAccessCodeWithBasicAuthentication = ({ auth: e2, redirectUrl: t2 }) => ({ authActions: r2 }) => {
  let { schema: n, name: a2, clientId: o4, clientSecret: s2, codeVerifier: l2 } = e2, i2 = { Authorization: "Basic " + btoa3(o4 + ":" + s2) }, c2 = { grant_type: "authorization_code", code: e2.code, client_id: o4, redirect_uri: t2, code_verifier: l2 };
  return r2.authorizeRequest({ body: buildFormData2(c2), name: a2, url: n.get("tokenUrl"), auth: e2, headers: i2 });
};
var authorizeRequest = (e2) => ({ fn: t2, getConfigs: r2, authActions: n, errActions: a2, oas3Selectors: o4, specSelectors: s2, authSelectors: l2 }) => {
  let i2, { body: c2, query: u2 = {}, headers: d2 = {}, name: p2, url: m2, auth: f2 } = e2, { additionalQueryStringParams: h2 } = l2.getConfigs() || {};
  if (s2.isOAS3()) {
    let e3 = o4.serverEffectiveValue(o4.selectedServer());
    i2 = (0, At.default)(m2, e3, true);
  } else i2 = (0, At.default)(m2, s2.url(), true);
  "object" == typeof h2 && (i2.query = Object.assign({}, i2.query, h2));
  const g2 = i2.toString();
  let y2 = Object.assign({ Accept: "application/json, text/plain, */*", "Content-Type": "application/x-www-form-urlencoded", "X-Requested-With": "XMLHttpRequest" }, d2);
  t2.fetch({ url: g2, method: "post", headers: y2, query: u2, body: c2, requestInterceptor: r2().requestInterceptor, responseInterceptor: r2().responseInterceptor }).then(function(e3) {
    let t3 = JSON.parse(e3.data), r3 = t3 && (t3.error || ""), o5 = t3 && (t3.parseError || "");
    e3.ok ? r3 || o5 ? a2.newAuthErr({ authId: p2, level: "error", source: "auth", message: JSON.stringify(t3) }) : n.authorizeOauth2WithPersistOption({ auth: f2, token: t3 }) : a2.newAuthErr({ authId: p2, level: "error", source: "auth", message: e3.statusText });
  }).catch((e3) => {
    let t3 = new Error(e3).message;
    if (e3.response && e3.response.data) {
      const r3 = e3.response.data;
      try {
        const e4 = "string" == typeof r3 ? JSON.parse(r3) : r3;
        e4.error && (t3 += `, error: ${e4.error}`), e4.error_description && (t3 += `, description: ${e4.error_description}`);
      } catch (e4) {
      }
    }
    a2.newAuthErr({ authId: p2, level: "error", source: "auth", message: t3 });
  });
};
function configureAuth(e2) {
  return { type: Mt, payload: e2 };
}
function restoreAuthorization(e2) {
  return { type: qt, payload: e2 };
}
var persistAuthorizationIfNeeded = () => ({ authSelectors: e2, getConfigs: t2 }) => {
  if (!t2().persistAuthorization) return;
  const r2 = e2.authorized().toJS();
  localStorage.setItem("authorized", JSON.stringify(r2));
};
var authPopup = (e2, t2) => () => {
  dt.swaggerUIRedirectOauth2 = t2, dt.open(e2);
};
var Lt = { [It]: (e2, { payload: t2 }) => e2.set("showDefinitions", t2), [Rt]: (e2, { payload: t2 }) => {
  let r2 = (0, Qe.fromJS)(t2), n = e2.get("authorized") || (0, Qe.Map)();
  return r2.entrySeq().forEach(([t3, r3]) => {
    if (!isFunc(r3.getIn)) return e2.set("authorized", n);
    let a2 = r3.getIn(["schema", "type"]);
    if ("apiKey" === a2 || "http" === a2) n = n.set(t3, r3);
    else if ("basic" === a2) {
      let e3 = r3.getIn(["value", "username"]), a3 = r3.getIn(["value", "password"]);
      n = n.setIn([t3, "value"], { username: e3, header: "Basic " + btoa3(e3 + ":" + a3) }), n = n.setIn([t3, "schema"], r3.get("schema"));
    }
  }), e2.set("authorized", n);
}, [jt]: (e2, { payload: t2 }) => {
  let r2, { auth: n, token: a2 } = t2;
  n.token = Object.assign({}, a2), r2 = (0, Qe.fromJS)(n);
  let o4 = e2.get("authorized") || (0, Qe.Map)();
  return o4 = o4.set(r2.get("name"), r2), e2.set("authorized", o4);
}, [Tt]: (e2, { payload: t2 }) => {
  let r2 = e2.get("authorized").withMutations((e3) => {
    t2.forEach((t3) => {
      e3.delete(t3);
    });
  });
  return e2.set("authorized", r2);
}, [Mt]: (e2, { payload: t2 }) => e2.set("configs", t2), [qt]: (e2, { payload: t2 }) => e2.set("authorized", (0, Qe.fromJS)(t2.authorized)) };
var Dt = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ createSelector: function() {
  return createSelector;
} });
var state = (e2) => e2;
var Ut = (0, Dt.createSelector)(state, (e2) => e2.get("showDefinitions"));
var $t = (0, Dt.createSelector)(state, () => ({ specSelectors: e2 }) => {
  let t2 = e2.securityDefinitions() || (0, Qe.Map)({}), r2 = (0, Qe.List)();
  return t2.entrySeq().forEach(([e3, t3]) => {
    let n = (0, Qe.Map)();
    n = n.set(e3, t3), r2 = r2.push(n);
  }), r2;
});
var getDefinitionsByNames = (e2, t2) => ({ specSelectors: e3 }) => {
  console.warn("WARNING: getDefinitionsByNames is deprecated and will be removed in the next major version.");
  let r2 = e3.securityDefinitions(), n = (0, Qe.List)();
  return t2.valueSeq().forEach((e4) => {
    let t3 = (0, Qe.Map)();
    e4.entrySeq().forEach(([e5, n2]) => {
      let a2, o4 = r2.get(e5);
      "oauth2" === o4.get("type") && n2.size && (a2 = o4.get("scopes"), a2.keySeq().forEach((e6) => {
        n2.contains(e6) || (a2 = a2.delete(e6));
      }), o4 = o4.set("allowedScopes", a2)), t3 = t3.set(e5, o4);
    }), n = n.push(t3);
  }), n;
};
var definitionsForRequirements = (e2, t2 = (0, Qe.List)()) => ({ authSelectors: e3 }) => {
  const r2 = e3.definitionsToAuthorize() || (0, Qe.List)();
  let n = (0, Qe.List)();
  return r2.forEach((e4) => {
    let r3 = t2.find((t3) => t3.get(e4.keySeq().first()));
    r3 && (e4.forEach((t3, n2) => {
      if ("oauth2" === t3.get("type")) {
        const a2 = r3.get(n2);
        let o4 = t3.get("scopes");
        Qe.List.isList(a2) && Qe.Map.isMap(o4) && (o4.keySeq().forEach((e5) => {
          a2.contains(e5) || (o4 = o4.delete(e5));
        }), e4 = e4.set(n2, t3.set("scopes", o4)));
      }
    }), n = n.push(e4));
  }), n;
};
var Jt = (0, Dt.createSelector)(state, (e2) => e2.get("authorized") || (0, Qe.Map)());
var isAuthorized = (e2, t2) => ({ authSelectors: e3 }) => {
  let r2 = e3.authorized();
  return Qe.List.isList(t2) ? !!t2.toJS().filter((e4) => -1 === Object.keys(e4).map((e5) => !!r2.get(e5)).indexOf(false)).length : null;
};
var Vt = (0, Dt.createSelector)(state, (e2) => e2.get("configs"));
var execute2 = (e2, { authSelectors: t2, specSelectors: r2 }) => ({ path: n, method: a2, operation: o4, extras: s2 }) => {
  let l2 = { authorized: t2.authorized() && t2.authorized().toJS(), definitions: r2.securityDefinitions() && r2.securityDefinitions().toJS(), specSecurity: r2.security() && r2.security().toJS() };
  return e2({ path: n, method: a2, operation: o4, securities: l2, ...s2 });
};
var loaded = (e2, t2) => (r2) => {
  const { getConfigs: n, authActions: a2 } = t2, o4 = n();
  if (e2(r2), o4.persistAuthorization) {
    const e3 = localStorage.getItem("authorized");
    e3 && a2.restoreAuthorization({ authorized: JSON.parse(e3) });
  }
};
var wrap_actions_authorize = (e2, t2) => (r2) => {
  e2(r2);
  if (t2.getConfigs().persistAuthorization) try {
    const [{ schema: e3, value: t3 }] = Object.values(r2), n = "apiKey" === e3.get("type"), a2 = "cookie" === e3.get("in");
    n && a2 && (document.cookie = `${e3.get("name")}=${t3}; SameSite=None; Secure`);
  } catch (e3) {
    console.error("Error persisting cookie based apiKey in document.cookie.", e3);
  }
};
var wrap_actions_logout = (e2, t2) => (r2) => {
  const n = t2.getConfigs(), a2 = t2.authSelectors.authorized();
  try {
    n.persistAuthorization && Array.isArray(r2) && r2.forEach((e3) => {
      const t3 = a2.get(e3, {}), r3 = "apiKey" === t3.getIn(["schema", "type"]), n2 = "cookie" === t3.getIn(["schema", "in"]);
      if (r3 && n2) {
        const e4 = t3.getIn(["schema", "name"]);
        document.cookie = `${e4}=; Max-Age=-99999999`;
      }
    });
  } catch (e3) {
    console.error("Error deleting cookie based apiKey from document.cookie.", e3);
  }
  e2(r2);
};
var Kt = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return _.default;
} });
var zt = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return v.default;
} });
var LockAuthIcon = class extends Xe.default.Component {
  mapStateToProps(e2, t2) {
    return { state: e2, ownProps: (0, zt.default)(t2, Object.keys(t2.getSystem())) };
  }
  render() {
    const { getComponent: e2, ownProps: t2 } = this.props, r2 = e2("LockIcon");
    return Xe.default.createElement(r2, t2);
  }
};
var Ft = LockAuthIcon;
var UnlockAuthIcon = class extends Xe.default.Component {
  mapStateToProps(e2, t2) {
    return { state: e2, ownProps: (0, zt.default)(t2, Object.keys(t2.getSystem())) };
  }
  render() {
    const { getComponent: e2, ownProps: t2 } = this.props, r2 = e2("UnlockIcon");
    return Xe.default.createElement(r2, t2);
  }
};
var Wt = UnlockAuthIcon;
function auth() {
  return { afterLoad(e2) {
    this.rootInjects = this.rootInjects || {}, this.rootInjects.initOAuth = e2.authActions.configureAuth, this.rootInjects.preauthorizeApiKey = preauthorizeApiKey.bind(null, e2), this.rootInjects.preauthorizeBasic = preauthorizeBasic.bind(null, e2);
  }, components: { LockAuthIcon: Ft, UnlockAuthIcon: Wt, LockAuthOperationIcon: Ft, UnlockAuthOperationIcon: Wt }, statePlugins: { auth: { reducers: Lt, actions: Ne, selectors: Ae, wrapActions: { authorize: wrap_actions_authorize, logout: wrap_actions_logout } }, configs: { wrapActions: { loaded } }, spec: { wrapActions: { execute: execute2 } } } };
}
function preauthorizeBasic(e2, t2, r2, n) {
  const { authActions: { authorize: a2 }, specSelectors: { specJson: o4, isOAS3: s2 } } = e2, l2 = s2() ? ["components", "securitySchemes"] : ["securityDefinitions"], i2 = o4().getIn([...l2, t2]);
  return i2 ? a2({ [t2]: { value: { username: r2, password: n }, schema: i2.toJS() } }) : null;
}
function preauthorizeApiKey(e2, t2, r2) {
  const { authActions: { authorize: n }, specSelectors: { specJson: a2, isOAS3: o4 } } = e2, s2 = o4() ? ["components", "securitySchemes"] : ["securityDefinitions"], l2 = a2().getIn([...s2, t2]);
  return l2 ? n({ [t2]: { value: r2, schema: l2.toJS() } }) : null;
}
var Ht = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ JSON_SCHEMA: function() {
  return JSON_SCHEMA;
}, default: function() {
  return js_yaml_default;
} });
var Gt = "configs_update";
var Xt = "configs_toggle";
function update3(e2, t2) {
  return { type: Gt, payload: { [e2]: t2 } };
}
function toggle(e2) {
  return { type: Xt, payload: e2 };
}
var actions_loaded = () => () => {
};
var downloadConfig = (e2) => (t2) => {
  const { fn: { fetch: r2 } } = t2;
  return r2(e2);
};
var getConfigByUrl = (e2, t2) => (r2) => {
  const { specActions: n, configsActions: a2 } = r2;
  if (e2) return a2.downloadConfig(e2).then(next, next);
  function next(a3) {
    a3 instanceof Error || a3.status >= 400 ? (n.updateLoadingStatus("failedConfig"), n.updateLoadingStatus("failedConfig"), n.updateUrl(""), console.error(a3.statusText + " " + e2.url), t2(null)) : t2(((e3, t3) => {
      try {
        return Ht.default.load(e3);
      } catch (e4) {
        return t3 && t3.errActions.newThrownErr(new Error(e4)), {};
      }
    })(a3.text, r2));
  }
};
var get2 = (e2, t2) => e2.getIn(Array.isArray(t2) ? t2 : [t2]);
var Yt = { [Gt]: (e2, t2) => e2.merge((0, Qe.fromJS)(t2.payload)), [Xt]: (e2, t2) => {
  const r2 = t2.payload, n = e2.get(r2);
  return e2.set(r2, !n);
} };
function configsPlugin() {
  return { statePlugins: { configs: { reducers: Yt, actions: Ie, selectors: Re } } };
}
var setHash = (e2) => e2 ? history.pushState(null, null, `#${e2}`) : window.location.hash = "";
var Qt = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return w.default;
} });
var Zt = "layout_scroll_to";
var er = "layout_clear_scroll";
var tr = { fn: { getScrollParent: function getScrollParent(e2, t2) {
  const r2 = document.documentElement;
  let n = getComputedStyle(e2);
  const a2 = "absolute" === n.position, o4 = t2 ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
  if ("fixed" === n.position) return r2;
  for (let t3 = e2; t3 = t3.parentElement; ) if (n = getComputedStyle(t3), (!a2 || "static" !== n.position) && o4.test(n.overflow + n.overflowY + n.overflowX)) return t3;
  return r2;
} }, statePlugins: { layout: { actions: { scrollToElement: (e2, t2) => (r2) => {
  try {
    t2 = t2 || r2.fn.getScrollParent(e2), Qt.default.createScroller(t2).to(e2);
  } catch (e3) {
    console.error(e3);
  }
}, scrollTo: (e2) => ({ type: Zt, payload: Array.isArray(e2) ? e2 : [e2] }), clearScrollTo: () => ({ type: er }), readyToScroll: (e2, t2) => (r2) => {
  const n = r2.layoutSelectors.getScrollToKey();
  Qe.default.is(n, (0, Qe.fromJS)(e2)) && (r2.layoutActions.scrollToElement(t2), r2.layoutActions.clearScrollTo());
}, parseDeepLinkHash: (e2) => ({ layoutActions: t2, layoutSelectors: r2, getConfigs: n }) => {
  if (n().deepLinking && e2) {
    let n2 = e2.slice(1);
    "!" === n2[0] && (n2 = n2.slice(1)), "/" === n2[0] && (n2 = n2.slice(1));
    const a2 = n2.split("/").map((e3) => e3 || ""), o4 = r2.isShownKeyFromUrlHashArray(a2), [s2, l2 = "", i2 = ""] = o4;
    if ("operations" === s2) {
      const e3 = r2.isShownKeyFromUrlHashArray([l2]);
      l2.indexOf("_") > -1 && (console.warn("Warning: escaping deep link whitespace with `_` will be unsupported in v4.0, use `%20` instead."), t2.show(e3.map((e4) => e4.replace(/_/g, " ")), true)), t2.show(e3, true);
    }
    (l2.indexOf("_") > -1 || i2.indexOf("_") > -1) && (console.warn("Warning: escaping deep link whitespace with `_` will be unsupported in v4.0, use `%20` instead."), t2.show(o4.map((e3) => e3.replace(/_/g, " ")), true)), t2.show(o4, true), t2.scrollTo(o4);
  }
} }, selectors: { getScrollToKey: (e2) => e2.get("scrollToKey"), isShownKeyFromUrlHashArray(e2, t2) {
  const [r2, n] = t2;
  return n ? ["operations", r2, n] : r2 ? ["operations-tag", r2] : [];
}, urlHashArrayFromIsShownKey(e2, t2) {
  let [r2, n, a2] = t2;
  return "operations" == r2 ? [n, a2] : "operations-tag" == r2 ? [n] : [];
} }, reducers: { [Zt]: (e2, t2) => e2.set("scrollToKey", Qe.default.fromJS(t2.payload)), [er]: (e2) => e2.delete("scrollToKey") }, wrapActions: { show: (e2, { getConfigs: t2, layoutSelectors: r2 }) => (...n) => {
  if (e2(...n), t2().deepLinking) try {
    let [e3, t3] = n;
    e3 = Array.isArray(e3) ? e3 : [e3];
    const a2 = r2.urlHashArrayFromIsShownKey(e3);
    if (!a2.length) return;
    const [o4, s2] = a2;
    if (!t3) return setHash("/");
    2 === a2.length ? setHash(createDeepLinkPath(`/${encodeURIComponent(o4)}/${encodeURIComponent(s2)}`)) : 1 === a2.length && setHash(createDeepLinkPath(`/${encodeURIComponent(o4)}`));
  } catch (e3) {
    console.error(e3);
  }
} } } } };
var rr = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return C.default;
} });
var operation_wrapper = (e2, t2) => class OperationWrapper extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onLoad", (e3) => {
      const { operation: r2 } = this.props, { tag: n, operationId: a2 } = r2.toObject();
      let { isShownKey: o4 } = r2.toObject();
      o4 = o4 || ["operations", n, a2], t2.layoutActions.readyToScroll(o4, e3);
    });
  }
  render() {
    return Xe.default.createElement("span", { ref: this.onLoad }, Xe.default.createElement(e2, this.props));
  }
};
var operation_tag_wrapper = (e2, t2) => class OperationTagWrapper extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onLoad", (e3) => {
      const { tag: r2 } = this.props, n = ["operations-tag", r2];
      t2.layoutActions.readyToScroll(n, e3);
    });
  }
  render() {
    return Xe.default.createElement("span", { ref: this.onLoad }, Xe.default.createElement(e2, this.props));
  }
};
function deep_linking() {
  return [tr, { statePlugins: { configs: { wrapActions: { loaded: (e2, t2) => (...r2) => {
    e2(...r2);
    const n = decodeURIComponent(window.location.hash);
    t2.layoutActions.parseDeepLinkHash(n);
  } } } }, wrapComponents: { operation: operation_wrapper, OperationTag: operation_tag_wrapper } }];
}
var nr = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return x.default;
} });
function transform(e2) {
  return e2.map((e3) => {
    let t2 = "is not of a type(s)", r2 = e3.get("message").indexOf(t2);
    if (r2 > -1) {
      let t3 = e3.get("message").slice(r2 + 19).split(",");
      return e3.set("message", e3.get("message").slice(0, r2) + function makeNewMessage(e4) {
        return e4.reduce((e5, t4, r3, n) => r3 === n.length - 1 && n.length > 1 ? e5 + "or " + t4 : n[r3 + 1] && n.length > 2 ? e5 + t4 + ", " : n[r3 + 1] ? e5 + t4 + " " : e5 + t4, "should be a");
      }(t3));
    }
    return e3;
  });
}
var ar = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return O.default;
} });
function parameter_oneof_transform(e2, { jsSpec: t2 }) {
  return e2;
}
var or3 = [Te, Be];
function transformErrors(e2) {
  let t2 = { jsSpec: {} }, r2 = (0, nr.default)(or3, (e3, r3) => {
    try {
      return r3.transform(e3, t2).filter((e4) => !!e4);
    } catch (t3) {
      return console.error("Transformer error:", t3), e3;
    }
  }, e2);
  return r2.filter((e3) => !!e3).map((e3) => (!e3.get("line") && e3.get("path"), e3));
}
var sr = { line: 0, level: "error", message: "Unknown error" };
var lr = (0, Dt.createSelector)((e2) => e2, (e2) => e2.get("errors", (0, Qe.List)()));
var ir = (0, Dt.createSelector)(lr, (e2) => e2.last());
function err(e2) {
  return { statePlugins: { err: { reducers: { [at]: (e3, { payload: t2 }) => {
    let r2 = Object.assign(sr, t2, { type: "thrown" });
    return e3.update("errors", (e4) => (e4 || (0, Qe.List)()).push((0, Qe.fromJS)(r2))).update("errors", (e4) => transformErrors(e4));
  }, [ot]: (e3, { payload: t2 }) => (t2 = t2.map((e4) => (0, Qe.fromJS)(Object.assign(sr, e4, { type: "thrown" }))), e3.update("errors", (e4) => (e4 || (0, Qe.List)()).concat((0, Qe.fromJS)(t2))).update("errors", (e4) => transformErrors(e4))), [st]: (e3, { payload: t2 }) => {
    let r2 = (0, Qe.fromJS)(t2);
    return r2 = r2.set("type", "spec"), e3.update("errors", (e4) => (e4 || (0, Qe.List)()).push((0, Qe.fromJS)(r2)).sortBy((e5) => e5.get("line"))).update("errors", (e4) => transformErrors(e4));
  }, [lt3]: (e3, { payload: t2 }) => (t2 = t2.map((e4) => (0, Qe.fromJS)(Object.assign(sr, e4, { type: "spec" }))), e3.update("errors", (e4) => (e4 || (0, Qe.List)()).concat((0, Qe.fromJS)(t2))).update("errors", (e4) => transformErrors(e4))), [it]: (e3, { payload: t2 }) => {
    let r2 = (0, Qe.fromJS)(Object.assign({}, t2));
    return r2 = r2.set("type", "auth"), e3.update("errors", (e4) => (e4 || (0, Qe.List)()).push((0, Qe.fromJS)(r2))).update("errors", (e4) => transformErrors(e4));
  }, [ct]: (e3, { payload: t2 }) => {
    if (!t2 || !e3.get("errors")) return e3;
    let r2 = e3.get("errors").filter((e4) => e4.keySeq().every((r3) => {
      const n = e4.get(r3), a2 = t2[r3];
      return !a2 || n !== a2;
    }));
    return e3.merge({ errors: r2 });
  }, [ut]: (e3, { payload: t2 }) => {
    if (!t2 || "function" != typeof t2) return e3;
    let r2 = e3.get("errors").filter((e4) => t2(e4));
    return e3.merge({ errors: r2 });
  } }, actions: ke, selectors: je } } };
}
function opsFilter(e2, t2) {
  return e2.filter((e3, r2) => -1 !== r2.indexOf(t2));
}
function filter4() {
  return { fn: { opsFilter } };
}
var cr = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return _extends;
} });
var arrow_up = ({ className: e2 = null, width: t2 = 20, height: r2 = 20, ...n }) => Xe.default.createElement("svg", (0, cr.default)({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", className: e2, width: t2, height: r2, "aria-hidden": "true", focusable: "false" }, n), Xe.default.createElement("path", { d: "M 17.418 14.908 C 17.69 15.176 18.127 15.176 18.397 14.908 C 18.667 14.64 18.668 14.207 18.397 13.939 L 10.489 6.109 C 10.219 5.841 9.782 5.841 9.51 6.109 L 1.602 13.939 C 1.332 14.207 1.332 14.64 1.602 14.908 C 1.873 15.176 2.311 15.176 2.581 14.908 L 10 7.767 L 17.418 14.908 Z" }));
var arrow_down = ({ className: e2 = null, width: t2 = 20, height: r2 = 20, ...n }) => Xe.default.createElement("svg", (0, cr.default)({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", className: e2, width: t2, height: r2, "aria-hidden": "true", focusable: "false" }, n), Xe.default.createElement("path", { d: "M17.418 6.109c.272-.268.709-.268.979 0s.271.701 0 .969l-7.908 7.83c-.27.268-.707.268-.979 0l-7.908-7.83c-.27-.268-.27-.701 0-.969.271-.268.709-.268.979 0L10 13.25l7.418-7.141z" }));
var arrow = ({ className: e2 = null, width: t2 = 20, height: r2 = 20, ...n }) => Xe.default.createElement("svg", (0, cr.default)({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", className: e2, width: t2, height: r2, "aria-hidden": "true", focusable: "false" }, n), Xe.default.createElement("path", { d: "M13.25 10L6.109 2.58c-.268-.27-.268-.707 0-.979.268-.27.701-.27.969 0l7.83 7.908c.268.271.268.709 0 .979l-7.83 7.908c-.268.271-.701.27-.969 0-.268-.269-.268-.707 0-.979L13.25 10z" }));
var components_close = ({ className: e2 = null, width: t2 = 20, height: r2 = 20, ...n }) => Xe.default.createElement("svg", (0, cr.default)({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", className: e2, width: t2, height: r2, "aria-hidden": "true", focusable: "false" }, n), Xe.default.createElement("path", { d: "M14.348 14.849c-.469.469-1.229.469-1.697 0L10 11.819l-2.651 3.029c-.469.469-1.229.469-1.697 0-.469-.469-.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-.469-.469-.469-1.228 0-1.697.469-.469 1.228-.469 1.697 0L10 8.183l2.651-3.031c.469-.469 1.228-.469 1.697 0 .469.469.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c.469.469.469 1.229 0 1.698z" }));
var copy2 = ({ className: e2 = null, width: t2 = 15, height: r2 = 16, ...n }) => Xe.default.createElement("svg", (0, cr.default)({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 15 16", className: e2, width: t2, height: r2, "aria-hidden": "true", focusable: "false" }, n), Xe.default.createElement("g", { transform: "translate(2, -1)" }, Xe.default.createElement("path", { fill: "#ffffff", fillRule: "evenodd", d: "M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z" })));
var lock = ({ className: e2 = null, width: t2 = 20, height: r2 = 20, ...n }) => Xe.default.createElement("svg", (0, cr.default)({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", className: e2, width: t2, height: r2, "aria-hidden": "true", focusable: "false" }, n), Xe.default.createElement("path", { d: "M15.8 8H14V5.6C14 2.703 12.665 1 10 1 7.334 1 6 2.703 6 5.6V8H4c-.553 0-1 .646-1 1.199V17c0 .549.428 1.139.951 1.307l1.197.387C5.672 18.861 6.55 19 7.1 19h5.8c.549 0 1.428-.139 1.951-.307l1.196-.387c.524-.167.953-.757.953-1.306V9.199C17 8.646 16.352 8 15.8 8zM12 8H8V5.199C8 3.754 8.797 3 10 3c1.203 0 2 .754 2 2.199V8z" }));
var unlock = ({ className: e2 = null, width: t2 = 20, height: r2 = 20, ...n }) => Xe.default.createElement("svg", (0, cr.default)({ xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", className: e2, width: t2, height: r2, "aria-hidden": "true", focusable: "false" }, n), Xe.default.createElement("path", { d: "M15.8 8H14V5.6C14 2.703 12.665 1 10 1 7.334 1 6 2.703 6 5.6V6h2v-.801C8 3.754 8.797 3 10 3c1.203 0 2 .754 2 2.199V8H4c-.553 0-1 .646-1 1.199V17c0 .549.428 1.139.951 1.307l1.197.387C5.672 18.861 6.55 19 7.1 19h5.8c.549 0 1.428-.139 1.951-.307l1.196-.387c.524-.167.953-.757.953-1.306V9.199C17 8.646 16.352 8 15.8 8z" }));
var icons = () => ({ components: { ArrowUpIcon: arrow_up, ArrowDownIcon: arrow_down, ArrowIcon: arrow, CloseIcon: components_close, CopyIcon: copy2, LockIcon: lock, UnlockIcon: unlock } });
var ur = "layout_update_layout";
var dr = "layout_update_filter";
var pr = "layout_update_mode";
var mr = "layout_show";
function updateLayout(e2) {
  return { type: ur, payload: e2 };
}
function updateFilter(e2) {
  return { type: dr, payload: e2 };
}
function actions_show(e2, t2 = true) {
  return e2 = normalizeArray2(e2), { type: mr, payload: { thing: e2, shown: t2 } };
}
function changeMode(e2, t2 = "") {
  return e2 = normalizeArray2(e2), { type: pr, payload: { thing: e2, mode: t2 } };
}
var fr = { [ur]: (e2, t2) => e2.set("layout", t2.payload), [dr]: (e2, t2) => e2.set("filter", t2.payload), [mr]: (e2, t2) => {
  const r2 = t2.payload.shown, n = (0, Qe.fromJS)(t2.payload.thing);
  return e2.update("shown", (0, Qe.fromJS)({}), (e3) => e3.set(n, r2));
}, [pr]: (e2, t2) => {
  let r2 = t2.payload.thing, n = t2.payload.mode;
  return e2.setIn(["modes"].concat(r2), (n || "") + "");
} };
var current = (e2) => e2.get("layout");
var currentFilter = (e2) => e2.get("filter");
var isShown = (e2, t2, r2) => (t2 = normalizeArray2(t2), e2.get("shown", (0, Qe.fromJS)({})).get((0, Qe.fromJS)(t2), r2));
var whatMode = (e2, t2, r2 = "") => (t2 = normalizeArray2(t2), e2.getIn(["modes", ...t2], r2));
var hr2 = (0, Dt.createSelector)((e2) => e2, (e2) => !isShown(e2, "editor"));
var taggedOperations = (e2, t2) => (r2, ...n) => {
  let a2 = e2(r2, ...n);
  const { fn: o4, layoutSelectors: s2, getConfigs: l2 } = t2.getSystem(), i2 = l2(), { maxDisplayedTags: c2 } = i2;
  let u2 = s2.currentFilter();
  return u2 && true !== u2 && (a2 = o4.opsFilter(a2, u2)), c2 >= 0 && (a2 = a2.slice(0, c2)), a2;
};
function plugins_layout() {
  return { statePlugins: { layout: { reducers: fr, actions: Pe, selectors: Me }, spec: { wrapSelectors: qe } } };
}
function logs({ configs: e2 }) {
  const t2 = { debug: 0, info: 1, log: 2, warn: 3, error: 4 }, getLevel = (e3) => t2[e3] || -1;
  let { logLevel: r2 } = e2, n = getLevel(r2);
  function log(e3, ...t3) {
    getLevel(e3) >= n && console[e3](...t3);
  }
  return log.warn = log.bind(null, "warn"), log.error = log.bind(null, "error"), log.info = log.bind(null, "info"), log.debug = log.bind(null, "debug"), { rootInjects: { log } };
}
var gr = false;
function on_complete() {
  return { statePlugins: { spec: { wrapActions: { updateSpec: (e2) => (...t2) => (gr = true, e2(...t2)), updateJsonSpec: (e2, t2) => (...r2) => {
    const n = t2.getConfigs().onComplete;
    return gr && "function" == typeof n && (setTimeout(n, 0), gr = false), e2(...r2);
  } } } } };
}
var extractKey = (e2) => {
  const t2 = "_**[]";
  return e2.indexOf(t2) < 0 ? e2 : e2.split(t2)[0].trim();
};
var escapeShell = (e2) => "-d " === e2 || /^[_\/-]/g.test(e2) ? e2 : "'" + e2.replace(/'/g, "'\\''") + "'";
var escapeCMD = (e2) => "-d " === (e2 = e2.replace(/\^/g, "^^").replace(/\\"/g, '\\\\"').replace(/"/g, '""').replace(/\n/g, "^\n")) ? e2.replace(/-d /g, "-d ^\n") : /^[_\/-]/g.test(e2) ? e2 : '"' + e2 + '"';
var escapePowershell = (e2) => {
  if ("-d " === e2) return e2;
  if (/\n/.test(e2)) {
    return `@"
${e2.replace(/`/g, "``").replace(/\$/g, "`$")}
"@`;
  }
  if (!/^[_\/-]/.test(e2)) {
    return `'${e2.replace(/'/g, "''")}'`;
  }
  return e2;
};
var curlify = (e2, t2, r2, n = "") => {
  let a2 = false, o4 = "";
  const addWords = (...e3) => o4 += " " + e3.map(t2).join(" "), addWordsWithoutLeadingSpace = (...e3) => o4 += e3.map(t2).join(" "), addNewLine = () => o4 += ` ${r2}`, addIndent = (e3 = 1) => o4 += "  ".repeat(e3);
  let s2 = e2.get("headers");
  o4 += "curl" + n;
  const l2 = e2.get("curlOptions");
  if (Qe.List.isList(l2) && !l2.isEmpty() && addWords(...e2.get("curlOptions")), addWords("-X", e2.get("method")), addNewLine(), addIndent(), addWordsWithoutLeadingSpace(`${e2.get("url")}`), s2 && s2.size) for (let t3 of e2.get("headers").entries()) {
    addNewLine(), addIndent();
    let [e3, r3] = t3;
    addWordsWithoutLeadingSpace("-H", `${e3}: ${r3}`), a2 = a2 || /^content-type$/i.test(e3) && /^multipart\/form-data$/i.test(r3);
  }
  const i2 = e2.get("body");
  if (i2) if (a2 && ["POST", "PUT", "PATCH"].includes(e2.get("method"))) for (let [e3, t3] of i2.entrySeq()) {
    let r3 = extractKey(e3);
    addNewLine(), addIndent(), addWordsWithoutLeadingSpace("-F"), t3 instanceof dt.File && "string" == typeof t3.valueOf() ? addWords(`${r3}=${t3.data}${t3.type ? `;type=${t3.type}` : ""}`) : t3 instanceof dt.File ? addWords(`${r3}=@${t3.name}${t3.type ? `;type=${t3.type}` : ""}`) : addWords(`${r3}=${t3}`);
  }
  else if (i2 instanceof dt.File) addNewLine(), addIndent(), addWordsWithoutLeadingSpace(`--data-binary '@${i2.name}'`);
  else {
    addNewLine(), addIndent(), addWordsWithoutLeadingSpace("-d ");
    let t3 = i2;
    Qe.Map.isMap(t3) ? addWordsWithoutLeadingSpace(function getStringBodyOfMap(e3) {
      let t4 = [];
      for (let [r3, n2] of e3.get("body").entrySeq()) {
        let e4 = extractKey(r3);
        n2 instanceof dt.File ? t4.push(`  "${e4}": {
    "name": "${n2.name}"${n2.type ? `,
    "type": "${n2.type}"` : ""}
  }`) : t4.push(`  "${e4}": ${JSON.stringify(n2, null, 2).replace(/(\r\n|\r|\n)/g, "\n  ")}`);
      }
      return `{
${t4.join(",\n")}
}`;
    }(e2)) : ("string" != typeof t3 && (t3 = JSON.stringify(t3)), addWordsWithoutLeadingSpace(t3));
  }
  else i2 || "POST" !== e2.get("method") || (addNewLine(), addIndent(), addWordsWithoutLeadingSpace("-d ''"));
  return o4;
};
var requestSnippetGenerator_curl_powershell = (e2) => curlify(e2, escapePowershell, "`\n", ".exe");
var requestSnippetGenerator_curl_bash = (e2) => curlify(e2, escapeShell, "\\\n");
var requestSnippetGenerator_curl_cmd = (e2) => curlify(e2, escapeCMD, "^\n");
var request_snippets_selectors_state = (e2) => e2 || (0, Qe.Map)();
var yr = (0, Dt.createSelector)(request_snippets_selectors_state, (e2) => {
  const t2 = e2.get("languages"), r2 = e2.get("generators", (0, Qe.Map)());
  return !t2 || t2.isEmpty() ? r2 : r2.filter((e3, r3) => t2.includes(r3));
});
var getSnippetGenerators = (e2) => ({ fn: t2 }) => yr(e2).map((e3, r2) => {
  const n = ((e4) => t2[`requestSnippetGenerator_${e4}`])(r2);
  return "function" != typeof n ? null : e3.set("fn", n);
}).filter((e3) => e3);
var Er = (0, Dt.createSelector)(request_snippets_selectors_state, (e2) => e2.get("activeLanguage"));
var Sr = (0, Dt.createSelector)(request_snippets_selectors_state, (e2) => e2.get("defaultExpanded"));
var _r = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return N.default;
} });
var vr = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ CopyToClipboard: function() {
  return A.CopyToClipboard;
} });
var br = { cursor: "pointer", lineHeight: 1, display: "inline-flex", backgroundColor: "rgb(250, 250, 250)", paddingBottom: "0", paddingTop: "0", border: "1px solid rgb(51, 51, 51)", borderRadius: "4px 4px 0 0", boxShadow: "none", borderBottom: "none" };
var wr = { cursor: "pointer", lineHeight: 1, display: "inline-flex", backgroundColor: "rgb(51, 51, 51)", boxShadow: "none", border: "1px solid rgb(51, 51, 51)", paddingBottom: "0", paddingTop: "0", borderRadius: "4px 4px 0 0", marginTop: "-5px", marginRight: "-5px", marginLeft: "-5px", zIndex: "9999", borderBottom: "none" };
var request_snippets = ({ request: e2, requestSnippetsSelectors: t2, getComponent: r2 }) => {
  var _a6;
  const n = (0, Xe.useRef)(null), a2 = r2("ArrowUpIcon"), o4 = r2("ArrowDownIcon"), s2 = r2("SyntaxHighlighter", true), [l2, i2] = (0, Xe.useState)((_a6 = t2.getSnippetGenerators()) == null ? void 0 : _a6.keySeq().first()), [c2, u2] = (0, Xe.useState)(t2 == null ? void 0 : t2.getDefaultExpanded()), d2 = t2.getSnippetGenerators(), p2 = d2.get(l2), m2 = p2.get("fn")(e2), handleSetIsExpanded = () => {
    u2(!c2);
  }, handleGetBtnStyle = (e3) => e3 === l2 ? wr : br, handlePreventYScrollingBeyondElement = (e3) => {
    const { target: t3, deltaY: r3 } = e3, { scrollHeight: n2, offsetHeight: a3, scrollTop: o5 } = t3;
    n2 > a3 && (0 === o5 && r3 < 0 || a3 + o5 >= n2 && r3 > 0) && e3.preventDefault();
  };
  return (0, Xe.useEffect)(() => {
  }, []), (0, Xe.useEffect)(() => {
    const e3 = Array.from(n.current.childNodes).filter((e4) => {
      var _a7;
      return !!e4.nodeType && ((_a7 = e4.classList) == null ? void 0 : _a7.contains("curl-command"));
    });
    return e3.forEach((e4) => e4.addEventListener("mousewheel", handlePreventYScrollingBeyondElement, { passive: false })), () => {
      e3.forEach((e4) => e4.removeEventListener("mousewheel", handlePreventYScrollingBeyondElement));
    };
  }, [e2]), Xe.default.createElement("div", { className: "request-snippets", ref: n }, Xe.default.createElement("div", { style: { width: "100%", display: "flex", justifyContent: "flex-start", alignItems: "center", marginBottom: "15px" } }, Xe.default.createElement("h4", { onClick: () => handleSetIsExpanded(), style: { cursor: "pointer" } }, "Snippets"), Xe.default.createElement("button", { onClick: () => handleSetIsExpanded(), style: { border: "none", background: "none" }, title: c2 ? "Collapse operation" : "Expand operation" }, c2 ? Xe.default.createElement(o4, { className: "arrow", width: "10", height: "10" }) : Xe.default.createElement(a2, { className: "arrow", width: "10", height: "10" }))), c2 && Xe.default.createElement("div", { className: "curl-command" }, Xe.default.createElement("div", { style: { paddingLeft: "15px", paddingRight: "10px", width: "100%", display: "flex" } }, d2.entrySeq().map(([e3, t3]) => Xe.default.createElement("div", { className: (0, _r.default)("btn", { active: e3 === l2 }), style: handleGetBtnStyle(e3), key: e3, onClick: () => ((e4) => {
    l2 !== e4 && i2(e4);
  })(e3) }, Xe.default.createElement("h4", { style: e3 === l2 ? { color: "white" } : {} }, t3.get("title"))))), Xe.default.createElement("div", { className: "copy-to-clipboard" }, Xe.default.createElement(vr.CopyToClipboard, { text: m2 }, Xe.default.createElement("button", null))), Xe.default.createElement("div", null, Xe.default.createElement(s2, { language: p2.get("syntax"), className: "curl microlight", renderPlainText: ({ children: e3, PlainTextViewer: t3 }) => Xe.default.createElement(t3, { className: "curl" }, e3) }, m2))));
};
var plugins_request_snippets = () => ({ components: { RequestSnippets: request_snippets }, fn: Le, statePlugins: { requestSnippets: { selectors: De } } });
var _ModelCollapse = class _ModelCollapse extends Xe.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "toggleCollapsed", () => {
      this.props.onToggle && this.props.onToggle(this.props.modelName, !this.state.expanded), this.setState({ expanded: !this.state.expanded });
    });
    __publicField(this, "onLoad", (e2) => {
      if (e2 && this.props.layoutSelectors) {
        const t2 = this.props.layoutSelectors.getScrollToKey();
        Qe.default.is(t2, this.props.specPath) && this.toggleCollapsed(), this.props.layoutActions.readyToScroll(this.props.specPath, e2.parentElement);
      }
    });
    let { expanded: r2, collapsedContent: n } = this.props;
    this.state = { expanded: r2, collapsedContent: n || _ModelCollapse.defaultProps.collapsedContent };
  }
  componentDidMount() {
    const { hideSelfOnExpand: e2, expanded: t2, modelName: r2 } = this.props;
    e2 && t2 && this.props.onToggle(r2, t2);
  }
  UNSAFE_componentWillReceiveProps(e2) {
    this.props.expanded !== e2.expanded && this.setState({ expanded: e2.expanded });
  }
  render() {
    const { title: e2, classes: t2 } = this.props;
    return this.state.expanded && this.props.hideSelfOnExpand ? Xe.default.createElement("span", { className: t2 || "" }, this.props.children) : Xe.default.createElement("span", { className: t2 || "", ref: this.onLoad }, Xe.default.createElement("button", { "aria-expanded": this.state.expanded, className: "model-box-control", onClick: this.toggleCollapsed }, e2 && Xe.default.createElement("span", { className: "pointer" }, e2), Xe.default.createElement("span", { className: "model-toggle" + (this.state.expanded ? "" : " collapsed") }), !this.state.expanded && Xe.default.createElement("span", null, this.state.collapsedContent)), this.state.expanded && this.props.children);
  }
};
__publicField(_ModelCollapse, "defaultProps", { collapsedContent: "{...}", expanded: false, title: null, onToggle: () => {
}, hideSelfOnExpand: false, specPath: Qe.default.List([]) });
var ModelCollapse = _ModelCollapse;
var useTabs = ({ initialTab: e2, isExecute: t2, schema: r2, example: n }) => {
  const a2 = (0, Xe.useMemo)(() => ({ example: "example", model: "model" }), []), o4 = (0, Xe.useMemo)(() => Object.keys(a2), [a2]).includes(e2) && r2 && !t2 ? e2 : a2.example, s2 = ((e3) => {
    const t3 = (0, Xe.useRef)();
    return (0, Xe.useEffect)(() => {
      t3.current = e3;
    }), t3.current;
  })(t2), [l2, i2] = (0, Xe.useState)(o4), c2 = (0, Xe.useCallback)((e3) => {
    i2(e3.target.dataset.name);
  }, []);
  return (0, Xe.useEffect)(() => {
    s2 && !t2 && n && i2(a2.example);
  }, [s2, t2, n]), { activeTab: l2, onTabChange: c2, tabs: a2 };
};
var model_example = ({ schema: e2, example: t2, isExecute: r2 = false, specPath: n, includeWriteOnly: a2 = false, includeReadOnly: o4 = false, getComponent: s2, getConfigs: l2, specSelectors: i2 }) => {
  const { defaultModelRendering: c2, defaultModelExpandDepth: u2 } = l2(), d2 = s2("ModelWrapper"), p2 = s2("HighlightCode", true), m2 = vt()(5).toString("base64"), f2 = vt()(5).toString("base64"), h2 = vt()(5).toString("base64"), g2 = vt()(5).toString("base64"), y2 = i2.isOAS3(), { activeTab: S, tabs: _2, onTabChange: v2 } = useTabs({ initialTab: c2, isExecute: r2, schema: e2, example: t2 });
  return Xe.default.createElement("div", { className: "model-example" }, Xe.default.createElement("ul", { className: "tab", role: "tablist" }, Xe.default.createElement("li", { className: (0, _r.default)("tabitem", { active: S === _2.example }), role: "presentation" }, Xe.default.createElement("button", { "aria-controls": f2, "aria-selected": S === _2.example, className: "tablinks", "data-name": "example", id: m2, onClick: v2, role: "tab" }, r2 ? "Edit Value" : "Example Value")), e2 && Xe.default.createElement("li", { className: (0, _r.default)("tabitem", { active: S === _2.model }), role: "presentation" }, Xe.default.createElement("button", { "aria-controls": g2, "aria-selected": S === _2.model, className: (0, _r.default)("tablinks", { inactive: r2 }), "data-name": "model", id: h2, onClick: v2, role: "tab" }, y2 ? "Schema" : "Model"))), S === _2.example && Xe.default.createElement("div", { "aria-hidden": S !== _2.example, "aria-labelledby": m2, "data-name": "examplePanel", id: f2, role: "tabpanel", tabIndex: "0" }, t2 || Xe.default.createElement(p2, null, "(no example available")), S === _2.model && Xe.default.createElement("div", { "aria-hidden": S === _2.example, "aria-labelledby": h2, "data-name": "modelPanel", id: g2, role: "tabpanel", tabIndex: "0" }, Xe.default.createElement(d2, { schema: e2, getComponent: s2, getConfigs: l2, specSelectors: i2, expandDepth: u2, specPath: n, includeReadOnly: o4, includeWriteOnly: a2 })));
};
var ModelWrapper = class extends Xe.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onToggle", (e2, t2) => {
      this.props.layoutActions && this.props.layoutActions.show(this.props.fullPath, t2);
    });
  }
  render() {
    let { getComponent: e2, getConfigs: t2 } = this.props;
    const r2 = e2("Model");
    let n;
    return this.props.layoutSelectors && (n = this.props.layoutSelectors.isShown(this.props.fullPath)), Xe.default.createElement("div", { className: "model-box" }, Xe.default.createElement(r2, (0, cr.default)({}, this.props, { getConfigs: t2, expanded: n, depth: 1, onToggle: this.onToggle, expandDepth: this.props.expandDepth || 0 })));
  }
};
var Cr;
var xr = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return react_immutable_pure_component_es_default;
} });
function _extends3() {
  return _extends3 = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n in r2) ({}).hasOwnProperty.call(r2, n) && (e2[n] = r2[n]);
    }
    return e2;
  }, _extends3.apply(null, arguments);
}
var rolling_load = (e2) => Xe.createElement("svg", _extends3({ xmlns: "http://www.w3.org/2000/svg", width: 200, height: 200, className: "rolling-load_svg__lds-rolling", preserveAspectRatio: "xMidYMid", style: { backgroundImage: "none", backgroundPosition: "initial initial", backgroundRepeat: "initial initial" }, viewBox: "0 0 100 100" }, e2), Cr || (Cr = Xe.createElement("circle", { cx: 50, cy: 50, r: 35, fill: "none", stroke: "#555", strokeDasharray: "164.93361431346415 56.97787143782138", strokeWidth: 10 }, Xe.createElement("animateTransform", { attributeName: "transform", begin: "0s", calcMode: "linear", dur: "1s", keyTimes: "0;1", repeatCount: "indefinite", type: "rotate", values: "0 50 50;360 50 50" }))));
var decodeRefName = (e2) => {
  const t2 = e2.replace(/~1/g, "/").replace(/~0/g, "~");
  try {
    return decodeURIComponent(t2);
  } catch {
    return t2;
  }
};
var Model = class extends xr.default {
  constructor() {
    super(...arguments);
    __publicField(this, "getModelName", (e2) => -1 !== e2.indexOf("#/definitions/") ? decodeRefName(e2.replace(/^.*#\/definitions\//, "")) : -1 !== e2.indexOf("#/components/schemas/") ? decodeRefName(e2.replace(/^.*#\/components\/schemas\//, "")) : void 0);
    __publicField(this, "getRefSchema", (e2) => {
      let { specSelectors: t2 } = this.props;
      return t2.findDefinition(e2);
    });
  }
  render() {
    let { getComponent: e2, getConfigs: t2, specSelectors: r2, schema: n, required: a2, name: o4, isRef: s2, specPath: l2, displayName: i2, includeReadOnly: c2, includeWriteOnly: u2 } = this.props;
    const d2 = e2("ObjectModel"), p2 = e2("ArrayModel"), m2 = e2("PrimitiveModel");
    let f2 = "object", h2 = n && n.get("$$ref"), g2 = n && n.get("$ref");
    if (!o4 && h2 && (o4 = this.getModelName(h2)), g2) {
      const e3 = this.getModelName(g2), t3 = this.getRefSchema(e3);
      Qe.Map.isMap(t3) ? (n = t3.mergeDeep(n), h2 || (n = n.set("$$ref", g2), h2 = g2)) : Qe.Map.isMap(n) && 1 === n.size && (n = null, o4 = g2);
    }
    if (!n) return Xe.default.createElement("span", { className: "model model-title" }, Xe.default.createElement("span", { className: "model-title__text" }, i2 || o4), !g2 && Xe.default.createElement(rolling_load, { height: "20px", width: "20px" }));
    const y2 = r2.isOAS3() && n.get("deprecated");
    switch (s2 = void 0 !== s2 ? s2 : !!h2, f2 = n && n.get("type") || f2, f2) {
      case "object":
        return Xe.default.createElement(d2, (0, cr.default)({ className: "object" }, this.props, { specPath: l2, getConfigs: t2, schema: n, name: o4, deprecated: y2, isRef: s2, includeReadOnly: c2, includeWriteOnly: u2 }));
      case "array":
        return Xe.default.createElement(p2, (0, cr.default)({ className: "array" }, this.props, { getConfigs: t2, schema: n, name: o4, deprecated: y2, required: a2, includeReadOnly: c2, includeWriteOnly: u2 }));
      default:
        return Xe.default.createElement(m2, (0, cr.default)({}, this.props, { getComponent: e2, getConfigs: t2, schema: n, name: o4, deprecated: y2, required: a2 }));
    }
  }
};
__publicField(Model, "propTypes", { schema: rr.default.map.isRequired, getComponent: Kt.default.func.isRequired, getConfigs: Kt.default.func.isRequired, specSelectors: Kt.default.object.isRequired, name: Kt.default.string, displayName: Kt.default.string, isRef: Kt.default.bool, required: Kt.default.bool, expandDepth: Kt.default.number, depth: Kt.default.number, specPath: rr.default.list.isRequired, includeReadOnly: Kt.default.bool, includeWriteOnly: Kt.default.bool });
var Models = class extends Xe.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "getSchemaBasePath", () => this.props.specSelectors.isOAS3() ? ["components", "schemas"] : ["definitions"]);
    __publicField(this, "getCollapsedContent", () => " ");
    __publicField(this, "handleToggle", (e2, t2) => {
      const { layoutActions: r2 } = this.props;
      r2.show([...this.getSchemaBasePath(), e2], t2), t2 && this.props.specActions.requestResolvedSubtree([...this.getSchemaBasePath(), e2]);
    });
    __publicField(this, "onLoadModels", (e2) => {
      e2 && this.props.layoutActions.readyToScroll(this.getSchemaBasePath(), e2);
    });
    __publicField(this, "onLoadModel", (e2) => {
      if (e2) {
        const t2 = e2.getAttribute("data-name");
        this.props.layoutActions.readyToScroll([...this.getSchemaBasePath(), t2], e2);
      }
    });
  }
  render() {
    let { specSelectors: e2, getComponent: t2, layoutSelectors: r2, layoutActions: n, getConfigs: a2 } = this.props, o4 = e2.definitions(), { docExpansion: s2, defaultModelsExpandDepth: l2 } = a2();
    if (!o4.size || l2 < 0) return null;
    const i2 = this.getSchemaBasePath();
    let c2 = r2.isShown(i2, l2 > 0 && "none" !== s2);
    const u2 = e2.isOAS3(), d2 = t2("ModelWrapper"), p2 = t2("Collapse"), m2 = t2("ModelCollapse"), f2 = t2("JumpToPath", true), h2 = t2("ArrowUpIcon"), g2 = t2("ArrowDownIcon");
    return Xe.default.createElement("section", { className: c2 ? "models is-open" : "models", ref: this.onLoadModels }, Xe.default.createElement("h4", null, Xe.default.createElement("button", { "aria-expanded": c2, className: "models-control", onClick: () => n.show(i2, !c2) }, Xe.default.createElement("span", null, u2 ? "Schemas" : "Models"), c2 ? Xe.default.createElement(h2, null) : Xe.default.createElement(g2, null))), Xe.default.createElement(p2, { isOpened: c2 }, o4.entrySeq().map(([o5]) => {
      const s3 = [...i2, o5], c3 = Qe.default.List(s3), u3 = e2.specResolvedSubtree(s3), p3 = e2.specJson().getIn(s3), h3 = Qe.Map.isMap(u3) ? u3 : Qe.default.Map(), g3 = Qe.Map.isMap(p3) ? p3 : Qe.default.Map(), y2 = h3.get("title") || g3.get("title") || o5, S = r2.isShown(s3, false);
      S && 0 === h3.size && g3.size > 0 && this.props.specActions.requestResolvedSubtree(s3);
      const _2 = Xe.default.createElement(d2, { name: o5, expandDepth: l2, schema: h3 || Qe.default.Map(), displayName: y2, fullPath: s3, specPath: c3, getComponent: t2, specSelectors: e2, getConfigs: a2, layoutSelectors: r2, layoutActions: n, includeReadOnly: true, includeWriteOnly: true }), v2 = Xe.default.createElement("span", { className: "model-box" }, Xe.default.createElement("span", { className: "model model-title" }, y2));
      return Xe.default.createElement("div", { id: `model-${o5}`, className: "model-container", key: `models-section-${o5}`, "data-name": o5, ref: this.onLoadModel }, Xe.default.createElement("span", { className: "models-jump-to-path" }, Xe.default.createElement(f2, { specPath: c3 })), Xe.default.createElement(m2, { classes: "model-box", collapsedContent: this.getCollapsedContent(o5), onToggle: this.handleToggle, title: v2, displayName: y2, modelName: o5, specPath: c3, layoutSelectors: r2, layoutActions: n, hideSelfOnExpand: true, expanded: l2 > 0 && S }, _2));
    }).toArray()));
  }
};
var enum_model = ({ value: e2, getComponent: t2 }) => {
  let r2 = t2("ModelCollapse"), n = Xe.default.createElement("span", null, "Array [ ", e2.count(), " ]");
  return Xe.default.createElement("span", { className: "prop-enum" }, "Enum:", Xe.default.createElement("br", null), Xe.default.createElement(r2, { collapsedContent: n }, "[ ", e2.map(String).join(", "), " ]"));
};
var ObjectModel = class extends Xe.Component {
  render() {
    let { schema: e2, name: t2, displayName: r2, isRef: n, getComponent: a2, getConfigs: o4, depth: s2, onToggle: l2, expanded: i2, specPath: c2, ...u2 } = this.props, { specSelectors: d2, expandDepth: p2, includeReadOnly: m2, includeWriteOnly: f2 } = u2;
    const { isOAS3: h2 } = d2;
    if (!e2) return null;
    const { showExtensions: g2 } = o4();
    let y2 = e2.get("description"), S = e2.get("properties"), _2 = e2.get("additionalProperties"), v2 = e2.get("title") || r2 || t2, b = e2.get("required"), w2 = e2.filter((e3, t3) => -1 !== ["maxProperties", "minProperties", "nullable", "example"].indexOf(t3)), C2 = e2.get("deprecated"), x2 = e2.getIn(["externalDocs", "url"]), O2 = e2.getIn(["externalDocs", "description"]);
    const k = a2("JumpToPath", true), N2 = a2("Markdown", true), A2 = a2("Model"), I = a2("ModelCollapse"), R2 = a2("Property"), T3 = a2("Link"), JumpToPathSection = () => Xe.default.createElement("span", { className: "model-jump-to-path" }, Xe.default.createElement(k, { specPath: c2 })), B2 = Xe.default.createElement("span", null, Xe.default.createElement("span", null, "{"), "...", Xe.default.createElement("span", null, "}"), n ? Xe.default.createElement(JumpToPathSection, null) : ""), j2 = d2.isOAS3() ? e2.get("allOf") : null, P2 = d2.isOAS3() ? e2.get("anyOf") : null, M2 = d2.isOAS3() ? e2.get("oneOf") : null, q2 = d2.isOAS3() ? e2.get("not") : null, L2 = v2 && Xe.default.createElement("span", { className: "model-title" }, n && e2.get("$$ref") && Xe.default.createElement("span", { className: "model-hint" }, e2.get("$$ref")), Xe.default.createElement("span", { className: "model-title__text" }, v2));
    return Xe.default.createElement("span", { className: "model" }, Xe.default.createElement(I, { modelName: t2, title: L2, onToggle: l2, expanded: !!i2 || s2 <= p2, collapsedContent: B2 }, Xe.default.createElement("span", { className: "brace-open object" }, "{"), n ? Xe.default.createElement(JumpToPathSection, null) : null, Xe.default.createElement("span", { className: "inner-object" }, Xe.default.createElement("table", { className: "model" }, Xe.default.createElement("tbody", null, y2 ? Xe.default.createElement("tr", { className: "description" }, Xe.default.createElement("td", null, "description:"), Xe.default.createElement("td", null, Xe.default.createElement(N2, { source: y2 }))) : null, x2 && Xe.default.createElement("tr", { className: "external-docs" }, Xe.default.createElement("td", null, "externalDocs:"), Xe.default.createElement("td", null, Xe.default.createElement(T3, { target: "_blank", href: sanitizeUrl2(x2) }, O2 || x2))), C2 ? Xe.default.createElement("tr", { className: "property" }, Xe.default.createElement("td", null, "deprecated:"), Xe.default.createElement("td", null, "true")) : null, S && S.size ? S.entrySeq().filter(([, e3]) => (!e3.get("readOnly") || m2) && (!e3.get("writeOnly") || f2)).map(([e3, r3]) => {
      let n2 = h2() && r3.get("deprecated"), l3 = Qe.List.isList(b) && b.contains(e3), i3 = ["property-row"];
      return n2 && i3.push("deprecated"), l3 && i3.push("required"), Xe.default.createElement("tr", { key: e3, className: i3.join(" ") }, Xe.default.createElement("td", null, e3, l3 && Xe.default.createElement("span", { className: "star" }, "*")), Xe.default.createElement("td", null, Xe.default.createElement(A2, (0, cr.default)({ key: `object-${t2}-${e3}_${r3}` }, u2, { required: l3, getComponent: a2, specPath: c2.push("properties", e3), getConfigs: o4, schema: r3, depth: s2 + 1 }))));
    }).toArray() : null, g2 ? Xe.default.createElement("tr", null, Xe.default.createElement("td", null, "")) : null, g2 ? e2.entrySeq().map(([e3, t3]) => {
      if ("x-" !== e3.slice(0, 2)) return;
      const r3 = t3 ? t3.toJS ? t3.toJS() : t3 : null;
      return Xe.default.createElement("tr", { key: e3, className: "extension" }, Xe.default.createElement("td", null, e3), Xe.default.createElement("td", null, JSON.stringify(r3)));
    }).toArray() : null, _2 && _2.size ? Xe.default.createElement("tr", null, Xe.default.createElement("td", null, "< * >:"), Xe.default.createElement("td", null, Xe.default.createElement(A2, (0, cr.default)({}, u2, { required: false, getComponent: a2, specPath: c2.push("additionalProperties"), getConfigs: o4, schema: _2, depth: s2 + 1 })))) : null, j2 ? Xe.default.createElement("tr", null, Xe.default.createElement("td", null, "allOf ->"), Xe.default.createElement("td", null, j2.map((e3, t3) => Xe.default.createElement("div", { key: t3 }, Xe.default.createElement(A2, (0, cr.default)({}, u2, { required: false, getComponent: a2, specPath: c2.push("allOf", t3), getConfigs: o4, schema: e3, depth: s2 + 1 })))))) : null, P2 ? Xe.default.createElement("tr", null, Xe.default.createElement("td", null, "anyOf ->"), Xe.default.createElement("td", null, P2.map((e3, t3) => Xe.default.createElement("div", { key: t3 }, Xe.default.createElement(A2, (0, cr.default)({}, u2, { required: false, getComponent: a2, specPath: c2.push("anyOf", t3), getConfigs: o4, schema: e3, depth: s2 + 1 })))))) : null, M2 ? Xe.default.createElement("tr", null, Xe.default.createElement("td", null, "oneOf ->"), Xe.default.createElement("td", null, M2.map((e3, t3) => Xe.default.createElement("div", { key: t3 }, Xe.default.createElement(A2, (0, cr.default)({}, u2, { required: false, getComponent: a2, specPath: c2.push("oneOf", t3), getConfigs: o4, schema: e3, depth: s2 + 1 })))))) : null, q2 ? Xe.default.createElement("tr", null, Xe.default.createElement("td", null, "not ->"), Xe.default.createElement("td", null, Xe.default.createElement("div", null, Xe.default.createElement(A2, (0, cr.default)({}, u2, { required: false, getComponent: a2, specPath: c2.push("not"), getConfigs: o4, schema: q2, depth: s2 + 1 }))))) : null))), Xe.default.createElement("span", { className: "brace-close" }, "}")), w2.size ? w2.entrySeq().map(([e3, t3]) => Xe.default.createElement(R2, { key: `${e3}-${t3}`, propKey: e3, propVal: t3, propClass: "property" })) : null);
  }
};
var ArrayModel = class extends Xe.Component {
  render() {
    let { getComponent: e2, getConfigs: t2, schema: r2, depth: n, expandDepth: a2, name: o4, displayName: s2, specPath: l2 } = this.props, i2 = r2.get("description"), c2 = r2.get("items"), u2 = r2.get("title") || s2 || o4, d2 = r2.filter((e3, t3) => -1 === ["type", "items", "description", "$$ref", "externalDocs"].indexOf(t3)), p2 = r2.getIn(["externalDocs", "url"]), m2 = r2.getIn(["externalDocs", "description"]);
    const f2 = e2("Markdown", true), h2 = e2("ModelCollapse"), g2 = e2("Model"), y2 = e2("Property"), S = e2("Link"), _2 = u2 && Xe.default.createElement("span", { className: "model-title" }, Xe.default.createElement("span", { className: "model-title__text" }, u2));
    return Xe.default.createElement("span", { className: "model" }, Xe.default.createElement(h2, { title: _2, expanded: n <= a2, collapsedContent: "[...]" }, "[", d2.size ? d2.entrySeq().map(([e3, t3]) => Xe.default.createElement(y2, { key: `${e3}-${t3}`, propKey: e3, propVal: t3, propClass: "property" })) : null, i2 ? Xe.default.createElement(f2, { source: i2 }) : d2.size ? Xe.default.createElement("div", { className: "markdown" }) : null, p2 && Xe.default.createElement("div", { className: "external-docs" }, Xe.default.createElement(S, { target: "_blank", href: sanitizeUrl2(p2) }, m2 || p2)), Xe.default.createElement("span", null, Xe.default.createElement(g2, (0, cr.default)({}, this.props, { getConfigs: t2, specPath: l2.push("items"), name: null, schema: c2, required: false, depth: n + 1 }))), "]"));
  }
};
var Or = "property primitive";
var Primitive = class extends Xe.Component {
  render() {
    let { schema: e2, getComponent: t2, getConfigs: r2, name: n, displayName: a2, depth: o4, expandDepth: s2 } = this.props;
    const { showExtensions: l2 } = r2();
    if (!e2 || !e2.get) return Xe.default.createElement("div", null);
    let i2 = e2.get("type"), c2 = e2.get("format"), u2 = e2.get("xml"), d2 = e2.get("enum"), p2 = e2.get("title") || a2 || n, m2 = e2.get("description"), f2 = getExtensions(e2), h2 = e2.filter((e3, t3) => -1 === ["enum", "type", "format", "description", "$$ref", "externalDocs"].indexOf(t3)).filterNot((e3, t3) => f2.has(t3)), g2 = e2.getIn(["externalDocs", "url"]), y2 = e2.getIn(["externalDocs", "description"]);
    const S = t2("Markdown", true), _2 = t2("EnumModel"), v2 = t2("Property"), b = t2("ModelCollapse"), w2 = t2("Link"), C2 = p2 && Xe.default.createElement("span", { className: "model-title" }, Xe.default.createElement("span", { className: "model-title__text" }, p2));
    return Xe.default.createElement("span", { className: "model" }, Xe.default.createElement(b, { title: C2, expanded: o4 <= s2, collapsedContent: "[...]" }, Xe.default.createElement("span", { className: "prop" }, n && o4 > 1 && Xe.default.createElement("span", { className: "prop-name" }, p2), Xe.default.createElement("span", { className: "prop-type" }, i2), c2 && Xe.default.createElement("span", { className: "prop-format" }, "($", c2, ")"), h2.size ? h2.entrySeq().map(([e3, t3]) => Xe.default.createElement(v2, { key: `${e3}-${t3}`, propKey: e3, propVal: t3, propClass: Or })) : null, l2 && f2.size ? f2.entrySeq().map(([e3, t3]) => Xe.default.createElement(v2, { key: `${e3}-${t3}`, propKey: e3, propVal: t3, propClass: Or })) : null, m2 ? Xe.default.createElement(S, { source: m2 }) : null, g2 && Xe.default.createElement("div", { className: "external-docs" }, Xe.default.createElement(w2, { target: "_blank", href: sanitizeUrl2(g2) }, y2 || g2)), u2 && u2.size ? Xe.default.createElement("span", null, Xe.default.createElement("br", null), Xe.default.createElement("span", { className: Or }, "xml:"), u2.entrySeq().map(([e3, t3]) => Xe.default.createElement("span", { key: `${e3}-${t3}`, className: Or }, Xe.default.createElement("br", null), "", e3, ": ", String(t3))).toArray()) : null, d2 && Xe.default.createElement(_2, { value: d2, getComponent: t2 }))));
  }
};
var Schemes = class extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onChange", (e2) => {
      this.setScheme(e2.target.value);
    });
    __publicField(this, "setScheme", (e2) => {
      let { path: t2, method: r2, specActions: n } = this.props;
      n.setScheme(e2, t2, r2);
    });
  }
  UNSAFE_componentWillMount() {
    let { schemes: e2 } = this.props;
    this.setScheme(e2.first());
  }
  UNSAFE_componentWillReceiveProps(e2) {
    this.props.currentScheme && e2.schemes.includes(this.props.currentScheme) || this.setScheme(e2.schemes.first());
  }
  render() {
    let { schemes: e2, currentScheme: t2 } = this.props;
    return Xe.default.createElement("label", { htmlFor: "schemes" }, Xe.default.createElement("span", { className: "schemes-title" }, "Schemes"), Xe.default.createElement("select", { onChange: this.onChange, value: t2, id: "schemes" }, e2.valueSeq().map((e3) => Xe.default.createElement("option", { value: e3, key: e3 }, e3)).toArray()));
  }
};
var SchemesContainer = class extends Xe.default.Component {
  render() {
    const { specActions: e2, specSelectors: t2, getComponent: r2 } = this.props, n = t2.operationScheme(), a2 = t2.schemes(), o4 = r2("schemes");
    return a2 && a2.size ? Xe.default.createElement(o4, { currentScheme: n, schemes: a2, specActions: e2 }) : null;
  }
};
var kr = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return R.default;
} });
var Nr = { value: "", onChange: () => {
}, schema: {}, keyName: "", required: false, errors: (0, Qe.List)() };
var JsonSchemaForm = class extends Xe.Component {
  componentDidMount() {
    const { dispatchInitialValue: e2, value: t2, onChange: r2 } = this.props;
    e2 ? r2(t2) : false === e2 && r2("");
  }
  render() {
    let { schema: e2, errors: t2, value: r2, onChange: n, getComponent: a2, fn: o4, disabled: s2 } = this.props;
    const l2 = e2 && e2.get ? e2.get("format") : null, i2 = e2 && e2.get ? e2.get("type") : null;
    let getComponentSilently = (e3) => a2(e3, false, { failSilently: true }), c2 = i2 ? getComponentSilently(l2 ? `JsonSchema_${i2}_${l2}` : `JsonSchema_${i2}`) : a2("JsonSchema_string");
    return c2 || (c2 = a2("JsonSchema_string")), Xe.default.createElement(c2, (0, cr.default)({}, this.props, { errors: t2, fn: o4, getComponent: a2, value: r2, onChange: n, schema: e2, disabled: s2 }));
  }
};
__publicField(JsonSchemaForm, "defaultProps", Nr);
var JsonSchema_string = class extends Xe.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onChange", (e2) => {
      const t2 = this.props.schema && "file" === this.props.schema.get("type") ? e2.target.files[0] : e2.target.value;
      this.props.onChange(t2, this.props.keyName);
    });
    __publicField(this, "onEnumChange", (e2) => this.props.onChange(e2));
  }
  render() {
    let { getComponent: e2, value: t2, schema: r2, errors: n, required: a2, description: o4, disabled: s2 } = this.props;
    const l2 = r2 && r2.get ? r2.get("enum") : null, i2 = r2 && r2.get ? r2.get("format") : null, c2 = r2 && r2.get ? r2.get("type") : null, u2 = r2 && r2.get ? r2.get("in") : null;
    if (t2 || (t2 = ""), n = n.toJS ? n.toJS() : [], l2) {
      const r3 = e2("Select");
      return Xe.default.createElement(r3, { className: n.length ? "invalid" : "", title: n.length ? n : "", allowedValues: [...l2], value: t2, allowEmptyValue: !a2, disabled: s2, onChange: this.onEnumChange });
    }
    const d2 = s2 || u2 && "formData" === u2 && !("FormData" in window), p2 = e2("Input");
    return c2 && "file" === c2 ? Xe.default.createElement(p2, { type: "file", className: n.length ? "invalid" : "", title: n.length ? n : "", onChange: this.onChange, disabled: d2 }) : Xe.default.createElement(kr.default, { type: i2 && "password" === i2 ? "password" : "text", className: n.length ? "invalid" : "", title: n.length ? n : "", value: t2, minLength: 0, debounceTimeout: 350, placeholder: o4, onChange: this.onChange, disabled: d2 });
  }
};
__publicField(JsonSchema_string, "defaultProps", Nr);
var JsonSchema_array = class extends Xe.PureComponent {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "onChange", () => {
      this.props.onChange(this.state.value);
    });
    __publicField(this, "onItemChange", (e2, t2) => {
      this.setState(({ value: r2 }) => ({ value: r2.set(t2, e2) }), this.onChange);
    });
    __publicField(this, "removeItem", (e2) => {
      this.setState(({ value: t2 }) => ({ value: t2.delete(e2) }), this.onChange);
    });
    __publicField(this, "addItem", () => {
      const { fn: e2 } = this.props;
      let t2 = valueOrEmptyList(this.state.value);
      this.setState(() => ({ value: t2.push(e2.getSampleSchema(this.state.schema.get("items"), false, { includeWriteOnly: true })) }), this.onChange);
    });
    __publicField(this, "onEnumChange", (e2) => {
      this.setState(() => ({ value: e2 }), this.onChange);
    });
    this.state = { value: valueOrEmptyList(e2.value), schema: e2.schema };
  }
  UNSAFE_componentWillReceiveProps(e2) {
    const t2 = valueOrEmptyList(e2.value);
    t2 !== this.state.value && this.setState({ value: t2 }), e2.schema !== this.state.schema && this.setState({ schema: e2.schema });
  }
  render() {
    let { getComponent: e2, required: t2, schema: r2, errors: n, fn: a2, disabled: o4 } = this.props;
    n = n.toJS ? n.toJS() : Array.isArray(n) ? n : [];
    const s2 = n.filter((e3) => "string" == typeof e3), l2 = n.filter((e3) => void 0 !== e3.needRemove).map((e3) => e3.error), i2 = this.state.value, c2 = !!(i2 && i2.count && i2.count() > 0), u2 = r2.getIn(["items", "enum"]), d2 = r2.getIn(["items", "type"]), p2 = r2.getIn(["items", "format"]), m2 = r2.get("items");
    let f2, h2 = false, g2 = "file" === d2 || "string" === d2 && "binary" === p2;
    if (d2 && p2 ? f2 = e2(`JsonSchema_${d2}_${p2}`) : "boolean" !== d2 && "array" !== d2 && "object" !== d2 || (f2 = e2(`JsonSchema_${d2}`)), f2 || g2 || (h2 = true), u2) {
      const r3 = e2("Select");
      return Xe.default.createElement(r3, { className: n.length ? "invalid" : "", title: n.length ? n : "", multiple: true, value: i2, disabled: o4, allowedValues: u2, allowEmptyValue: !t2, onChange: this.onEnumChange });
    }
    const y2 = e2("Button");
    return Xe.default.createElement("div", { className: "json-schema-array" }, c2 ? i2.map((t3, r3) => {
      const s3 = (0, Qe.fromJS)([...n.filter((e3) => e3.index === r3).map((e3) => e3.error)]);
      return Xe.default.createElement("div", { key: r3, className: "json-schema-form-item" }, g2 ? Xe.default.createElement(JsonSchemaArrayItemFile, { value: t3, onChange: (e3) => this.onItemChange(e3, r3), disabled: o4, errors: s3, getComponent: e2 }) : h2 ? Xe.default.createElement(JsonSchemaArrayItemText, { value: t3, onChange: (e3) => this.onItemChange(e3, r3), disabled: o4, errors: s3 }) : Xe.default.createElement(f2, (0, cr.default)({}, this.props, { value: t3, onChange: (e3) => this.onItemChange(e3, r3), disabled: o4, errors: s3, schema: m2, getComponent: e2, fn: a2 })), o4 ? null : Xe.default.createElement(y2, { className: `btn btn-sm json-schema-form-item-remove ${l2.length ? "invalid" : null}`, title: l2.length ? l2 : "", onClick: () => this.removeItem(r3) }, " - "));
    }) : null, o4 ? null : Xe.default.createElement(y2, { className: `btn btn-sm json-schema-form-item-add ${s2.length ? "invalid" : null}`, title: s2.length ? s2 : "", onClick: this.addItem }, "Add ", d2 ? `${d2} ` : "", "item"));
  }
};
__publicField(JsonSchema_array, "defaultProps", Nr);
var JsonSchemaArrayItemText = class extends Xe.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onChange", (e2) => {
      const t2 = e2.target.value;
      this.props.onChange(t2, this.props.keyName);
    });
  }
  render() {
    let { value: e2, errors: t2, description: r2, disabled: n } = this.props;
    return e2 || (e2 = ""), t2 = t2.toJS ? t2.toJS() : [], Xe.default.createElement(kr.default, { type: "text", className: t2.length ? "invalid" : "", title: t2.length ? t2 : "", value: e2, minLength: 0, debounceTimeout: 350, placeholder: r2, onChange: this.onChange, disabled: n });
  }
};
__publicField(JsonSchemaArrayItemText, "defaultProps", Nr);
var JsonSchemaArrayItemFile = class extends Xe.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onFileChange", (e2) => {
      const t2 = e2.target.files[0];
      this.props.onChange(t2, this.props.keyName);
    });
  }
  render() {
    let { getComponent: e2, errors: t2, disabled: r2 } = this.props;
    const n = e2("Input"), a2 = r2 || !("FormData" in window);
    return Xe.default.createElement(n, { type: "file", className: t2.length ? "invalid" : "", title: t2.length ? t2 : "", onChange: this.onFileChange, disabled: a2 });
  }
};
__publicField(JsonSchemaArrayItemFile, "defaultProps", Nr);
var JsonSchema_boolean = class extends Xe.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onEnumChange", (e2) => this.props.onChange(e2));
  }
  render() {
    let { getComponent: e2, value: t2, errors: r2, schema: n, required: a2, disabled: o4 } = this.props;
    r2 = r2.toJS ? r2.toJS() : [];
    let s2 = n && n.get ? n.get("enum") : null, l2 = !s2 || !a2, i2 = !s2 && ["true", "false"];
    const c2 = e2("Select");
    return Xe.default.createElement(c2, { className: r2.length ? "invalid" : "", title: r2.length ? r2 : "", value: String(t2), disabled: o4, allowedValues: s2 ? [...s2] : i2, allowEmptyValue: l2, onChange: this.onEnumChange });
  }
};
__publicField(JsonSchema_boolean, "defaultProps", Nr);
var stringifyObjectErrors = (e2) => e2.map((e3) => {
  const t2 = void 0 !== e3.propKey ? e3.propKey : e3.index;
  let r2 = "string" == typeof e3 ? e3 : "string" == typeof e3.error ? e3.error : null;
  if (!t2 && r2) return r2;
  let n = e3.error, a2 = `/${e3.propKey}`;
  for (; "object" == typeof n; ) {
    const e4 = void 0 !== n.propKey ? n.propKey : n.index;
    if (void 0 === e4) break;
    if (a2 += `/${e4}`, !n.error) break;
    n = n.error;
  }
  return `${a2}: ${n}`;
});
var JsonSchema_object = class extends Xe.PureComponent {
  constructor() {
    super();
    __publicField(this, "onChange", (e2) => {
      this.props.onChange(e2);
    });
    __publicField(this, "handleOnChange", (e2) => {
      const t2 = e2.target.value;
      this.onChange(t2);
    });
  }
  render() {
    let { getComponent: e2, value: t2, errors: r2, disabled: n } = this.props;
    const a2 = e2("TextArea");
    return r2 = r2.toJS ? r2.toJS() : Array.isArray(r2) ? r2 : [], Xe.default.createElement("div", null, Xe.default.createElement(a2, { className: (0, _r.default)({ invalid: r2.length }), title: r2.length ? stringifyObjectErrors(r2).join(", ") : "", value: stringify(t2), disabled: n, onChange: this.handleOnChange }));
  }
};
__publicField(JsonSchema_object, "defaultProps", Nr);
function valueOrEmptyList(e2) {
  return Qe.List.isList(e2) ? e2 : Array.isArray(e2) ? (0, Qe.fromJS)(e2) : (0, Qe.List)();
}
var json_schema_5 = () => ({ components: { modelExample: model_example, ModelWrapper, ModelCollapse, Model, Models, EnumModel: enum_model, ObjectModel, ArrayModel, PrimitiveModel: Primitive, schemes: Schemes, SchemesContainer, ...Ue } });
var Ar = __webpack_require__(123);
var Ir = __webpack_require__.n(Ar);
var Rr = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return T2.default;
} });
var Tr = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return B.default;
} });
var shallowArrayEquals = (e2) => (t2) => Array.isArray(e2) && Array.isArray(t2) && e2.length === t2.length && e2.every((e3, r2) => e3 === t2[r2]);
var list3 = (...e2) => e2;
var Cache = class extends Map {
  delete(e2) {
    const t2 = Array.from(this.keys()).find(shallowArrayEquals(e2));
    return super.delete(t2);
  }
  get(e2) {
    const t2 = Array.from(this.keys()).find(shallowArrayEquals(e2));
    return super.get(t2);
  }
  has(e2) {
    return -1 !== Array.from(this.keys()).findIndex(shallowArrayEquals(e2));
  }
};
var utils_memoizeN = (e2, t2 = list3) => {
  const { Cache: r2 } = mt.default;
  mt.default.Cache = Cache;
  const n = (0, mt.default)(e2, t2);
  return mt.default.Cache = r2, n;
};
var Br = { string: (e2) => e2.pattern ? ((e3) => {
  try {
    return new Rr.default(e3).gen();
  } catch (e4) {
    return "string";
  }
})(e2.pattern) : "string", string_email: () => "user@example.com", "string_date-time": () => (/* @__PURE__ */ new Date()).toISOString(), string_date: () => (/* @__PURE__ */ new Date()).toISOString().substring(0, 10), string_uuid: () => "3fa85f64-5717-4562-b3fc-2c963f66afa6", string_hostname: () => "example.com", string_ipv4: () => "198.51.100.42", string_ipv6: () => "2001:0db8:5b96:0000:0000:426f:8e17:642a", number: () => 0, number_float: () => 0, integer: () => 0, boolean: (e2) => "boolean" != typeof e2.default || e2.default };
var primitive = (e2) => {
  e2 = objectify(e2);
  let { type: t2, format: r2 } = e2, n = Br[`${t2}_${r2}`] || Br[t2];
  return isFunc(n) ? n(e2) : "Unknown Type: " + e2.type;
};
var sanitizeRef = (e2) => deeplyStripKey(e2, "$$ref", (e3) => "string" == typeof e3 && e3.indexOf("#") > -1);
var jr = ["maxProperties", "minProperties"];
var Pr = ["minItems", "maxItems"];
var Mr = ["minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum"];
var qr = ["minLength", "maxLength"];
var mergeJsonSchema = (e2, t2, r2 = {}) => {
  const n = { ...e2 };
  if (["example", "default", "enum", "xml", "type", ...jr, ...Pr, ...Mr, ...qr].forEach((e3) => ((e4) => {
    void 0 === n[e4] && void 0 !== t2[e4] && (n[e4] = t2[e4]);
  })(e3)), void 0 !== t2.required && Array.isArray(t2.required) && (void 0 !== n.required && n.required.length || (n.required = []), t2.required.forEach((e3) => {
    n.required.includes(e3) || n.required.push(e3);
  })), t2.properties) {
    n.properties || (n.properties = {});
    let e3 = objectify(t2.properties);
    for (let a2 in e3) Object.prototype.hasOwnProperty.call(e3, a2) && (e3[a2] && e3[a2].deprecated || e3[a2] && e3[a2].readOnly && !r2.includeReadOnly || e3[a2] && e3[a2].writeOnly && !r2.includeWriteOnly || n.properties[a2] || (n.properties[a2] = e3[a2], !t2.required && Array.isArray(t2.required) && -1 !== t2.required.indexOf(a2) && (n.required ? n.required.push(a2) : n.required = [a2])));
  }
  return t2.items && (n.items || (n.items = {}), n.items = mergeJsonSchema(n.items, t2.items, r2)), n;
};
var sampleFromSchemaGeneric = (e2, t2 = {}, r2 = void 0, n = false) => {
  e2 && isFunc(e2.toJS) && (e2 = e2.toJS());
  let a2 = void 0 !== r2 || e2 && void 0 !== e2.example || e2 && void 0 !== e2.default;
  const o4 = !a2 && e2 && e2.oneOf && e2.oneOf.length > 0, s2 = !a2 && e2 && e2.anyOf && e2.anyOf.length > 0;
  if (!a2 && (o4 || s2)) {
    const r3 = objectify(o4 ? e2.oneOf[0] : e2.anyOf[0]);
    if (!(e2 = mergeJsonSchema(e2, r3, t2)).xml && r3.xml && (e2.xml = r3.xml), void 0 !== e2.example && void 0 !== r3.example) a2 = true;
    else if (r3.properties) {
      e2.properties || (e2.properties = {});
      let n2 = objectify(r3.properties);
      for (let a3 in n2) Object.prototype.hasOwnProperty.call(n2, a3) && (n2[a3] && n2[a3].deprecated || n2[a3] && n2[a3].readOnly && !t2.includeReadOnly || n2[a3] && n2[a3].writeOnly && !t2.includeWriteOnly || e2.properties[a3] || (e2.properties[a3] = n2[a3], !r3.required && Array.isArray(r3.required) && -1 !== r3.required.indexOf(a3) && (e2.required ? e2.required.push(a3) : e2.required = [a3])));
    }
  }
  const l2 = {};
  let { xml: i2, type: c2, example: u2, properties: d2, additionalProperties: p2, items: m2 } = e2 || {}, { includeReadOnly: f2, includeWriteOnly: h2 } = t2;
  i2 = i2 || {};
  let g2, { name: y2, prefix: S, namespace: _2 } = i2, v2 = {};
  if (n && (y2 = y2 || "notagname", g2 = (S ? S + ":" : "") + y2, _2)) {
    l2[S ? "xmlns:" + S : "xmlns"] = _2;
  }
  n && (v2[g2] = []);
  const schemaHasAny = (t3) => t3.some((t4) => Object.prototype.hasOwnProperty.call(e2, t4));
  e2 && !c2 && (d2 || p2 || schemaHasAny(jr) ? c2 = "object" : m2 || schemaHasAny(Pr) ? c2 = "array" : schemaHasAny(Mr) ? (c2 = "number", e2.type = "number") : a2 || e2.enum || (c2 = "string", e2.type = "string"));
  const handleMinMaxItems = (t3) => {
    if (null != (e2 == null ? void 0 : e2.maxItems) && (t3 = t3.slice(0, e2 == null ? void 0 : e2.maxItems)), null != (e2 == null ? void 0 : e2.minItems)) {
      let r3 = 0;
      for (; t3.length < (e2 == null ? void 0 : e2.minItems); ) t3.push(t3[r3++ % t3.length]);
    }
    return t3;
  }, b = objectify(d2);
  let w2, C2 = 0;
  const hasExceededMaxProperties = () => e2 && null !== e2.maxProperties && void 0 !== e2.maxProperties && C2 >= e2.maxProperties, canAddProperty = (t3) => !e2 || null === e2.maxProperties || void 0 === e2.maxProperties || !hasExceededMaxProperties() && (!((t4) => !(e2 && e2.required && e2.required.length && e2.required.includes(t4)))(t3) || e2.maxProperties - C2 - (() => {
    if (!e2 || !e2.required) return 0;
    let t4 = 0;
    return n ? e2.required.forEach((e3) => t4 += void 0 === v2[e3] ? 0 : 1) : e2.required.forEach((e3) => {
      var _a6;
      return t4 += void 0 === ((_a6 = v2[g2]) == null ? void 0 : _a6.find((t5) => void 0 !== t5[e3])) ? 0 : 1;
    }), e2.required.length - t4;
  })() > 0);
  if (w2 = n ? (r3, a3 = void 0) => {
    if (e2 && b[r3]) {
      if (b[r3].xml = b[r3].xml || {}, b[r3].xml.attribute) {
        const e3 = Array.isArray(b[r3].enum) ? b[r3].enum[0] : void 0, t3 = b[r3].example, n2 = b[r3].default;
        return void (l2[b[r3].xml.name || r3] = void 0 !== t3 ? t3 : void 0 !== n2 ? n2 : void 0 !== e3 ? e3 : primitive(b[r3]));
      }
      b[r3].xml.name = b[r3].xml.name || r3;
    } else b[r3] || false === p2 || (b[r3] = { xml: { name: r3 } });
    let o5 = sampleFromSchemaGeneric(e2 && b[r3] || void 0, t2, a3, n);
    canAddProperty(r3) && (C2++, Array.isArray(o5) ? v2[g2] = v2[g2].concat(o5) : v2[g2].push(o5));
  } : (r3, a3) => {
    if (canAddProperty(r3)) {
      if (Object.prototype.hasOwnProperty.call(e2, "discriminator") && e2.discriminator && Object.prototype.hasOwnProperty.call(e2.discriminator, "mapping") && e2.discriminator.mapping && Object.prototype.hasOwnProperty.call(e2, "$$ref") && e2.$$ref && e2.discriminator.propertyName === r3) {
        for (let t3 in e2.discriminator.mapping) if (-1 !== e2.$$ref.search(e2.discriminator.mapping[t3])) {
          v2[r3] = t3;
          break;
        }
      } else v2[r3] = sampleFromSchemaGeneric(b[r3], t2, a3, n);
      C2++;
    }
  }, a2) {
    let a3;
    if (a3 = sanitizeRef(void 0 !== r2 ? r2 : void 0 !== u2 ? u2 : e2.default), !n) {
      if ("number" == typeof a3 && "string" === c2) return `${a3}`;
      if ("string" != typeof a3 || "string" === c2) return a3;
      try {
        return JSON.parse(a3);
      } catch (e3) {
        return a3;
      }
    }
    if (e2 || (c2 = Array.isArray(a3) ? "array" : typeof a3), "array" === c2) {
      if (!Array.isArray(a3)) {
        if ("string" == typeof a3) return a3;
        a3 = [a3];
      }
      const r3 = e2 ? e2.items : void 0;
      r3 && (r3.xml = r3.xml || i2 || {}, r3.xml.name = r3.xml.name || i2.name);
      let o5 = a3.map((e3) => sampleFromSchemaGeneric(r3, t2, e3, n));
      return o5 = handleMinMaxItems(o5), i2.wrapped ? (v2[g2] = o5, (0, Tr.default)(l2) || v2[g2].push({ _attr: l2 })) : v2 = o5, v2;
    }
    if ("object" === c2) {
      if ("string" == typeof a3) return a3;
      for (let t3 in a3) Object.prototype.hasOwnProperty.call(a3, t3) && (e2 && b[t3] && b[t3].readOnly && !f2 || e2 && b[t3] && b[t3].writeOnly && !h2 || (e2 && b[t3] && b[t3].xml && b[t3].xml.attribute ? l2[b[t3].xml.name || t3] = a3[t3] : w2(t3, a3[t3])));
      return (0, Tr.default)(l2) || v2[g2].push({ _attr: l2 }), v2;
    }
    return v2[g2] = (0, Tr.default)(l2) ? a3 : [{ _attr: l2 }, a3], v2;
  }
  if ("object" === c2) {
    for (let e3 in b) Object.prototype.hasOwnProperty.call(b, e3) && (b[e3] && b[e3].deprecated || b[e3] && b[e3].readOnly && !f2 || b[e3] && b[e3].writeOnly && !h2 || w2(e3));
    if (n && l2 && v2[g2].push({ _attr: l2 }), hasExceededMaxProperties()) return v2;
    if (true === p2) n ? v2[g2].push({ additionalProp: "Anything can be here" }) : v2.additionalProp1 = {}, C2++;
    else if (p2) {
      const r3 = objectify(p2), a3 = sampleFromSchemaGeneric(r3, t2, void 0, n);
      if (n && r3.xml && r3.xml.name && "notagname" !== r3.xml.name) v2[g2].push(a3);
      else {
        const t3 = null !== e2.minProperties && void 0 !== e2.minProperties && C2 < e2.minProperties ? e2.minProperties - C2 : 3;
        for (let e3 = 1; e3 <= t3; e3++) {
          if (hasExceededMaxProperties()) return v2;
          if (n) {
            const t4 = {};
            t4["additionalProp" + e3] = a3.notagname, v2[g2].push(t4);
          } else v2["additionalProp" + e3] = a3;
          C2++;
        }
      }
    }
    return v2;
  }
  if ("array" === c2) {
    if (!m2) return;
    let r3;
    if (n && (m2.xml = m2.xml || (e2 == null ? void 0 : e2.xml) || {}, m2.xml.name = m2.xml.name || i2.name), Array.isArray(m2.anyOf)) r3 = m2.anyOf.map((e3) => sampleFromSchemaGeneric(mergeJsonSchema(e3, m2, t2), t2, void 0, n));
    else if (Array.isArray(m2.oneOf)) r3 = m2.oneOf.map((e3) => sampleFromSchemaGeneric(mergeJsonSchema(e3, m2, t2), t2, void 0, n));
    else {
      if (!(!n || n && i2.wrapped)) return sampleFromSchemaGeneric(m2, t2, void 0, n);
      r3 = [sampleFromSchemaGeneric(m2, t2, void 0, n)];
    }
    return r3 = handleMinMaxItems(r3), n && i2.wrapped ? (v2[g2] = r3, (0, Tr.default)(l2) || v2[g2].push({ _attr: l2 }), v2) : r3;
  }
  let x2;
  if (e2 && Array.isArray(e2.enum)) x2 = normalizeArray2(e2.enum)[0];
  else {
    if (!e2) return;
    if (x2 = primitive(e2), "number" == typeof x2) {
      let t3 = e2.minimum;
      null != t3 && (e2.exclusiveMinimum && t3++, x2 = t3);
      let r3 = e2.maximum;
      null != r3 && (e2.exclusiveMaximum && r3--, x2 = r3);
    }
    if ("string" == typeof x2 && (null !== e2.maxLength && void 0 !== e2.maxLength && (x2 = x2.slice(0, e2.maxLength)), null !== e2.minLength && void 0 !== e2.minLength)) {
      let t3 = 0;
      for (; x2.length < e2.minLength; ) x2 += x2[t3++ % x2.length];
    }
  }
  if ("file" !== c2) return n ? (v2[g2] = (0, Tr.default)(l2) ? x2 : [{ _attr: l2 }, x2], v2) : x2;
};
var inferSchema = (e2) => (e2.schema && (e2 = e2.schema), e2.properties && (e2.type = "object"), e2);
var createXMLExample = (e2, t2, r2) => {
  const n = sampleFromSchemaGeneric(e2, t2, r2, true);
  if (n) return "string" == typeof n ? n : Ir()(n, { declaration: true, indent: "	" });
};
var sampleFromSchema = (e2, t2, r2) => sampleFromSchemaGeneric(e2, t2, r2, false);
var resolver = (e2, t2, r2) => [e2, JSON.stringify(t2), JSON.stringify(r2)];
var Lr = utils_memoizeN(createXMLExample, resolver);
var Dr = utils_memoizeN(sampleFromSchema, resolver);
var Ur = [{ when: /json/, shouldStringifyTypes: ["string"] }];
var $r = ["object"];
var get_json_sample_schema = (e2) => (t2, r2, n, a2) => {
  const { fn: o4 } = e2(), s2 = o4.memoizedSampleFromSchema(t2, r2, a2), l2 = typeof s2, i2 = Ur.reduce((e3, t3) => t3.when.test(n) ? [...e3, ...t3.shouldStringifyTypes] : e3, $r);
  return (0, gt3.default)(i2, (e3) => e3 === l2) ? JSON.stringify(s2, null, 2) : s2;
};
var get_yaml_sample_schema = (e2) => (t2, r2, n, a2) => {
  const { fn: o4 } = e2(), s2 = o4.getJsonSampleSchema(t2, r2, n, a2);
  let l2;
  try {
    l2 = Ht.default.dump(Ht.default.load(s2), { lineWidth: -1 }, { schema: Ht.JSON_SCHEMA }), "\n" === l2[l2.length - 1] && (l2 = l2.slice(0, l2.length - 1));
  } catch (e3) {
    return console.error(e3), "error: could not generate yaml example";
  }
  return l2.replace(/\t/g, "  ");
};
var get_xml_sample_schema = (e2) => (t2, r2, n) => {
  const { fn: a2 } = e2();
  if (t2 && !t2.xml && (t2.xml = {}), t2 && !t2.xml.name) {
    if (!t2.$$ref && (t2.type || t2.items || t2.properties || t2.additionalProperties)) return '<?xml version="1.0" encoding="UTF-8"?>\n<!-- XML example cannot be generated; root element name is undefined -->';
    if (t2.$$ref) {
      let e3 = t2.$$ref.match(/\S*\/(\S+)$/);
      t2.xml.name = e3[1];
    }
  }
  return a2.memoizedCreateXMLExample(t2, r2, n);
};
var get_sample_schema = (e2) => (t2, r2 = "", n = {}, a2 = void 0) => {
  const { fn: o4 } = e2();
  return "function" == typeof (t2 == null ? void 0 : t2.toJS) && (t2 = t2.toJS()), "function" == typeof (a2 == null ? void 0 : a2.toJS) && (a2 = a2.toJS()), /xml/.test(r2) ? o4.getXmlSampleSchema(t2, n, a2) : /(yaml|yml)/.test(r2) ? o4.getYamlSampleSchema(t2, n, r2, a2) : o4.getJsonSampleSchema(t2, n, r2, a2);
};
var json_schema_5_samples = ({ getSystem: e2 }) => {
  const t2 = get_json_sample_schema(e2), r2 = get_yaml_sample_schema(e2), n = get_xml_sample_schema(e2), a2 = get_sample_schema(e2);
  return { fn: { jsonSchema5: { inferSchema, sampleFromSchema, sampleFromSchemaGeneric, createXMLExample, memoizedSampleFromSchema: Dr, memoizedCreateXMLExample: Lr, getJsonSampleSchema: t2, getYamlSampleSchema: r2, getXmlSampleSchema: n, getSampleSchema: a2, mergeJsonSchema }, inferSchema, sampleFromSchema, sampleFromSchemaGeneric, createXMLExample, memoizedSampleFromSchema: Dr, memoizedCreateXMLExample: Lr, getJsonSampleSchema: t2, getYamlSampleSchema: r2, getXmlSampleSchema: n, getSampleSchema: a2, mergeJsonSchema } };
};
var Jr = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return j.default;
} });
var Vr = ["get", "put", "post", "delete", "options", "head", "patch", "trace"];
var spec_selectors_state = (e2) => e2 || (0, Qe.Map)();
var Kr = (0, Dt.createSelector)(spec_selectors_state, (e2) => e2.get("lastError"));
var zr = (0, Dt.createSelector)(spec_selectors_state, (e2) => e2.get("url"));
var Fr = (0, Dt.createSelector)(spec_selectors_state, (e2) => e2.get("spec") || "");
var Wr = (0, Dt.createSelector)(spec_selectors_state, (e2) => e2.get("specSource") || "not-editor");
var Hr = (0, Dt.createSelector)(spec_selectors_state, (e2) => e2.get("json", (0, Qe.Map)()));
var Gr = (0, Dt.createSelector)(Hr, (e2) => e2.toJS());
var Xr = (0, Dt.createSelector)(spec_selectors_state, (e2) => e2.get("resolved", (0, Qe.Map)()));
var specResolvedSubtree = (e2, t2) => e2.getIn(["resolvedSubtrees", ...t2], void 0);
var mergerFn = (e2, t2) => Qe.Map.isMap(e2) && Qe.Map.isMap(t2) ? t2.get("$$ref") ? t2 : (0, Qe.OrderedMap)().mergeWith(mergerFn, e2, t2) : t2;
var Yr = (0, Dt.createSelector)(spec_selectors_state, (e2) => (0, Qe.OrderedMap)().mergeWith(mergerFn, e2.get("json"), e2.get("resolvedSubtrees")));
var spec = (e2) => Hr(e2);
var Qr = (0, Dt.createSelector)(spec, () => false);
var Zr = (0, Dt.createSelector)(spec, (e2) => returnSelfOrNewMap(e2 && e2.get("info")));
var en = (0, Dt.createSelector)(spec, (e2) => returnSelfOrNewMap(e2 && e2.get("externalDocs")));
var tn = (0, Dt.createSelector)(Zr, (e2) => e2 && e2.get("version"));
var rn = (0, Dt.createSelector)(tn, (e2) => /v?([0-9]*)\.([0-9]*)\.([0-9]*)/i.exec(e2).slice(1));
var nn = (0, Dt.createSelector)(Yr, (e2) => e2.get("paths"));
var an = (0, Jr.default)(["get", "put", "post", "delete", "options", "head", "patch"]);
var on3 = (0, Dt.createSelector)(nn, (e2) => {
  if (!e2 || e2.size < 1) return (0, Qe.List)();
  let t2 = (0, Qe.List)();
  return e2 && e2.forEach ? (e2.forEach((e3, r2) => {
    if (!e3 || !e3.forEach) return {};
    e3.forEach((e4, n) => {
      Vr.indexOf(n) < 0 || (t2 = t2.push((0, Qe.fromJS)({ path: r2, method: n, operation: e4, id: `${n}-${r2}` })));
    });
  }), t2) : (0, Qe.List)();
});
var sn = (0, Dt.createSelector)(spec, (e2) => (0, Qe.Set)(e2.get("consumes")));
var ln = (0, Dt.createSelector)(spec, (e2) => (0, Qe.Set)(e2.get("produces")));
var cn = (0, Dt.createSelector)(spec, (e2) => e2.get("security", (0, Qe.List)()));
var un = (0, Dt.createSelector)(spec, (e2) => e2.get("securityDefinitions"));
var findDefinition = (e2, t2) => {
  const r2 = e2.getIn(["resolvedSubtrees", "definitions", t2], null), n = e2.getIn(["json", "definitions", t2], null);
  return r2 || n || null;
};
var dn = (0, Dt.createSelector)(spec, (e2) => {
  const t2 = e2.get("definitions");
  return Qe.Map.isMap(t2) ? t2 : (0, Qe.Map)();
});
var pn = (0, Dt.createSelector)(spec, (e2) => e2.get("basePath"));
var mn = (0, Dt.createSelector)(spec, (e2) => e2.get("host"));
var fn = (0, Dt.createSelector)(spec, (e2) => e2.get("schemes", (0, Qe.Map)()));
var hn = (0, Dt.createSelector)([on3, sn, ln], (e2, t2, r2) => e2.map((e3) => e3.update("operation", (e4) => {
  if (e4) {
    if (!Qe.Map.isMap(e4)) return;
    return e4.withMutations((e5) => (e5.get("consumes") || e5.update("consumes", (e6) => (0, Qe.Set)(e6).merge(t2)), e5.get("produces") || e5.update("produces", (e6) => (0, Qe.Set)(e6).merge(r2)), e5));
  }
  return (0, Qe.Map)();
})));
var gn = (0, Dt.createSelector)(spec, (e2) => {
  const t2 = e2.get("tags", (0, Qe.List)());
  return Qe.List.isList(t2) ? t2.filter((e3) => Qe.Map.isMap(e3)) : (0, Qe.List)();
});
var tagDetails = (e2, t2) => (gn(e2) || (0, Qe.List)()).filter(Qe.Map.isMap).find((e3) => e3.get("name") === t2, (0, Qe.Map)());
var yn = (0, Dt.createSelector)(hn, gn, (e2, t2) => e2.reduce((e3, t3) => {
  let r2 = (0, Qe.Set)(t3.getIn(["operation", "tags"]));
  return r2.count() < 1 ? e3.update("default", (0, Qe.List)(), (e4) => e4.push(t3)) : r2.reduce((e4, r3) => e4.update(r3, (0, Qe.List)(), (e5) => e5.push(t3)), e3);
}, t2.reduce((e3, t3) => e3.set(t3.get("name"), (0, Qe.List)()), (0, Qe.OrderedMap)())));
var selectors_taggedOperations = (e2) => ({ getConfigs: t2 }) => {
  let { tagsSorter: r2, operationsSorter: n } = t2();
  return yn(e2).sortBy((e3, t3) => t3, (e3, t3) => {
    let n2 = "function" == typeof r2 ? r2 : Nt.tagsSorter[r2];
    return n2 ? n2(e3, t3) : null;
  }).map((t3, r3) => {
    let a2 = "function" == typeof n ? n : Nt.operationsSorter[n], o4 = a2 ? t3.sort(a2) : t3;
    return (0, Qe.Map)({ tagDetails: tagDetails(e2, r3), operations: o4 });
  });
};
var En = (0, Dt.createSelector)(spec_selectors_state, (e2) => e2.get("responses", (0, Qe.Map)()));
var Sn = (0, Dt.createSelector)(spec_selectors_state, (e2) => e2.get("requests", (0, Qe.Map)()));
var _n = (0, Dt.createSelector)(spec_selectors_state, (e2) => e2.get("mutatedRequests", (0, Qe.Map)()));
var responseFor = (e2, t2, r2) => En(e2).getIn([t2, r2], null);
var requestFor = (e2, t2, r2) => Sn(e2).getIn([t2, r2], null);
var mutatedRequestFor = (e2, t2, r2) => _n(e2).getIn([t2, r2], null);
var allowTryItOutFor = () => true;
var parameterWithMetaByIdentity = (e2, t2, r2) => {
  const n = Yr(e2).getIn(["paths", ...t2, "parameters"], (0, Qe.OrderedMap)()), a2 = e2.getIn(["meta", "paths", ...t2, "parameters"], (0, Qe.OrderedMap)());
  return n.map((e3) => {
    const t3 = a2.get(`${r2.get("in")}.${r2.get("name")}`), n2 = a2.get(`${r2.get("in")}.${r2.get("name")}.hash-${r2.hashCode()}`);
    return (0, Qe.OrderedMap)().merge(e3, t3, n2);
  }).find((e3) => e3.get("in") === r2.get("in") && e3.get("name") === r2.get("name"), (0, Qe.OrderedMap)());
};
var parameterInclusionSettingFor = (e2, t2, r2, n) => {
  const a2 = `${n}.${r2}`;
  return e2.getIn(["meta", "paths", ...t2, "parameter_inclusions", a2], false);
};
var parameterWithMeta = (e2, t2, r2, n) => {
  const a2 = Yr(e2).getIn(["paths", ...t2, "parameters"], (0, Qe.OrderedMap)()).find((e3) => e3.get("in") === n && e3.get("name") === r2, (0, Qe.OrderedMap)());
  return parameterWithMetaByIdentity(e2, t2, a2);
};
var operationWithMeta = (e2, t2, r2) => {
  const n = Yr(e2).getIn(["paths", t2, r2], (0, Qe.OrderedMap)()), a2 = e2.getIn(["meta", "paths", t2, r2], (0, Qe.OrderedMap)()), o4 = n.get("parameters", (0, Qe.List)()).map((n2) => parameterWithMetaByIdentity(e2, [t2, r2], n2));
  return (0, Qe.OrderedMap)().merge(n, a2).set("parameters", o4);
};
function getParameter(e2, t2, r2, n) {
  return t2 = t2 || [], e2.getIn(["meta", "paths", ...t2, "parameters"], (0, Qe.fromJS)([])).find((e3) => Qe.Map.isMap(e3) && e3.get("name") === r2 && e3.get("in") === n) || (0, Qe.Map)();
}
var vn = (0, Dt.createSelector)(spec, (e2) => {
  const t2 = e2.get("host");
  return "string" == typeof t2 && t2.length > 0 && "/" !== t2[0];
});
function parameterValues(e2, t2, r2) {
  return t2 = t2 || [], operationWithMeta(e2, ...t2).get("parameters", (0, Qe.List)()).reduce((e3, t3) => {
    let n = r2 && "body" === t3.get("in") ? t3.get("value_xml") : t3.get("value");
    return Qe.List.isList(n) && (n = n.filter((e4) => "" !== e4)), e3.set(paramToIdentifier(t3, { allowHashes: false }), n);
  }, (0, Qe.fromJS)({}));
}
function parametersIncludeIn(e2, t2 = "") {
  if (Qe.List.isList(e2)) return e2.some((e3) => Qe.Map.isMap(e3) && e3.get("in") === t2);
}
function parametersIncludeType(e2, t2 = "") {
  if (Qe.List.isList(e2)) return e2.some((e3) => Qe.Map.isMap(e3) && e3.get("type") === t2);
}
function contentTypeValues(e2, t2) {
  t2 = t2 || [];
  let r2 = Yr(e2).getIn(["paths", ...t2], (0, Qe.fromJS)({})), n = e2.getIn(["meta", "paths", ...t2], (0, Qe.fromJS)({})), a2 = currentProducesFor(e2, t2);
  const o4 = r2.get("parameters") || new Qe.List(), s2 = n.get("consumes_value") ? n.get("consumes_value") : parametersIncludeType(o4, "file") ? "multipart/form-data" : parametersIncludeType(o4, "formData") ? "application/x-www-form-urlencoded" : void 0;
  return (0, Qe.fromJS)({ requestContentType: s2, responseContentType: a2 });
}
function currentProducesFor(e2, t2) {
  t2 = t2 || [];
  const r2 = Yr(e2).getIn(["paths", ...t2], null);
  if (null === r2) return;
  const n = e2.getIn(["meta", "paths", ...t2, "produces_value"], null), a2 = r2.getIn(["produces", 0], null);
  return n || a2 || "application/json";
}
function producesOptionsFor(e2, t2) {
  t2 = t2 || [];
  const r2 = Yr(e2), n = r2.getIn(["paths", ...t2], null);
  if (null === n) return;
  const [a2] = t2, o4 = n.get("produces", null), s2 = r2.getIn(["paths", a2, "produces"], null), l2 = r2.getIn(["produces"], null);
  return o4 || s2 || l2;
}
function consumesOptionsFor(e2, t2) {
  t2 = t2 || [];
  const r2 = Yr(e2), n = r2.getIn(["paths", ...t2], null);
  if (null === n) return;
  const [a2] = t2, o4 = n.get("consumes", null), s2 = r2.getIn(["paths", a2, "consumes"], null), l2 = r2.getIn(["consumes"], null);
  return o4 || s2 || l2;
}
var operationScheme = (e2, t2, r2) => {
  let n = e2.get("url").match(/^([a-z][a-z0-9+\-.]*):/), a2 = Array.isArray(n) ? n[1] : null;
  return e2.getIn(["scheme", t2, r2]) || e2.getIn(["scheme", "_defaultScheme"]) || a2 || "";
};
var canExecuteScheme = (e2, t2, r2) => ["http", "https"].indexOf(operationScheme(e2, t2, r2)) > -1;
var validationErrors = (e2, t2) => {
  t2 = t2 || [];
  const r2 = e2.getIn(["meta", "paths", ...t2, "parameters"], (0, Qe.fromJS)([])), n = [];
  if (0 === r2.length) return n;
  const getErrorsWithPaths = (e3, t3 = []) => {
    const getNestedErrorsWithPaths = (e4, t4) => {
      const r3 = [...t4, e4.get("propKey") || e4.get("index")];
      return Qe.Map.isMap(e4.get("error")) ? getErrorsWithPaths(e4.get("error"), r3) : { error: e4.get("error"), path: r3 };
    };
    return Qe.List.isList(e3) ? e3.map((e4) => Qe.Map.isMap(e4) ? getNestedErrorsWithPaths(e4, t3) : { error: e4, path: t3 }) : getNestedErrorsWithPaths(e3, t3);
  };
  return r2.forEach((e3, t3) => {
    const r3 = t3.split(".").slice(1, -1).join("."), a2 = e3.get("errors");
    if (a2 && a2.count()) {
      getErrorsWithPaths(a2).forEach(({ error: e4, path: t4 }) => {
        n.push(((e5, t5, r4) => `For '${r4}'${(t5 = t5.reduce((e6, t6) => "number" == typeof t6 ? `${e6}[${t6}]` : e6 ? `${e6}.${t6}` : t6, "")) ? ` at path '${t5}'` : ""}: ${e5}.`)(e4, t4, r3));
      });
    }
  }), n;
};
var validateBeforeExecute = (e2, t2) => 0 === validationErrors(e2, t2).length;
var getOAS3RequiredRequestBodyContentType = (e2, t2) => {
  let r2 = { requestBody: false, requestContentType: {} }, n = e2.getIn(["resolvedSubtrees", "paths", ...t2, "requestBody"], (0, Qe.fromJS)([]));
  return n.size < 1 || (n.getIn(["required"]) && (r2.requestBody = n.getIn(["required"])), n.getIn(["content"]).entrySeq().forEach((e3) => {
    const t3 = e3[0];
    if (e3[1].getIn(["schema", "required"])) {
      const n2 = e3[1].getIn(["schema", "required"]).toJS();
      r2.requestContentType[t3] = n2;
    }
  })), r2;
};
var isMediaTypeSchemaPropertiesEqual = (e2, t2, r2, n) => {
  if ((r2 || n) && r2 === n) return true;
  let a2 = e2.getIn(["resolvedSubtrees", "paths", ...t2, "requestBody", "content"], (0, Qe.fromJS)([]));
  if (a2.size < 2 || !r2 || !n) return false;
  let o4 = a2.getIn([r2, "schema", "properties"], (0, Qe.fromJS)([])), s2 = a2.getIn([n, "schema", "properties"], (0, Qe.fromJS)([]));
  return !!o4.equals(s2);
};
function returnSelfOrNewMap(e2) {
  return Qe.Map.isMap(e2) ? e2 : new Qe.Map();
}
var bn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return P.default;
} });
var wn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return M.default;
} });
var Cn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return q.default;
} });
var xn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return L.default;
} });
var On = "spec_update_spec";
var kn = "spec_update_url";
var Nn = "spec_update_json";
var An = "spec_update_param";
var In = "spec_update_empty_param_inclusion";
var Rn = "spec_validate_param";
var Tn = "spec_set_response";
var Bn = "spec_set_request";
var jn = "spec_set_mutated_request";
var Pn = "spec_log_request";
var Mn = "spec_clear_response";
var qn = "spec_clear_request";
var Ln = "spec_clear_validate_param";
var Dn = "spec_update_operation_meta_value";
var Un = "spec_update_resolved";
var $n = "spec_update_resolved_subtree";
var Jn = "set_scheme";
var toStr = (e2) => (0, bn.default)(e2) ? e2 : "";
function updateSpec(e2) {
  const t2 = toStr(e2).replace(/\t/g, "  ");
  if ("string" == typeof e2) return { type: On, payload: t2 };
}
function updateResolved(e2) {
  return { type: Un, payload: e2 };
}
function updateUrl(e2) {
  return { type: kn, payload: e2 };
}
function updateJsonSpec(e2) {
  return { type: Nn, payload: e2 };
}
var parseToJson = (e2) => ({ specActions: t2, specSelectors: r2, errActions: n }) => {
  let { specStr: a2 } = r2, o4 = null;
  try {
    e2 = e2 || a2(), n.clear({ source: "parser" }), o4 = Ht.default.load(e2, { schema: Ht.JSON_SCHEMA });
  } catch (e3) {
    return console.error(e3), n.newSpecErr({ source: "parser", level: "error", message: e3.reason, line: e3.mark && e3.mark.line ? e3.mark.line + 1 : void 0 });
  }
  return o4 && "object" == typeof o4 ? t2.updateJsonSpec(o4) : {};
};
var Vn = false;
var resolveSpec = (e2, t2) => ({ specActions: r2, specSelectors: n, errActions: a2, fn: { fetch: o4, resolve: s2, AST: l2 = {} }, getConfigs: i2 }) => {
  Vn || (console.warn("specActions.resolveSpec is deprecated since v3.10.0 and will be removed in v4.0.0; use requestResolvedSubtree instead!"), Vn = true);
  const { modelPropertyMacro: c2, parameterMacro: u2, requestInterceptor: d2, responseInterceptor: p2 } = i2();
  void 0 === e2 && (e2 = n.specJson()), void 0 === t2 && (t2 = n.url());
  let m2 = l2.getLineNumberForPath ? l2.getLineNumberForPath : () => {
  }, f2 = n.specStr();
  return s2({ fetch: o4, spec: e2, baseDoc: String(new URL(t2, document.baseURI)), modelPropertyMacro: c2, parameterMacro: u2, requestInterceptor: d2, responseInterceptor: p2 }).then(({ spec: e3, errors: t3 }) => {
    if (a2.clear({ type: "thrown" }), Array.isArray(t3) && t3.length > 0) {
      let e4 = t3.map((e5) => (console.error(e5), e5.line = e5.fullPath ? m2(f2, e5.fullPath) : null, e5.path = e5.fullPath ? e5.fullPath.join(".") : null, e5.level = "error", e5.type = "thrown", e5.source = "resolver", Object.defineProperty(e5, "message", { enumerable: true, value: e5.message }), e5));
      a2.newThrownErrBatch(e4);
    }
    return r2.updateResolved(e3);
  });
};
var Kn = [];
var zn = (0, wn.default)(() => {
  const e2 = Kn.reduce((e3, { path: t2, system: r2 }) => (e3.has(r2) || e3.set(r2, []), e3.get(r2).push(t2), e3), /* @__PURE__ */ new Map());
  Kn = [], e2.forEach(async (e3, t2) => {
    if (!t2) return void console.error("debResolveSubtrees: don't have a system to operate on, aborting.");
    if (!t2.fn.resolveSubtree) return void console.error("Error: Swagger-Client did not provide a `resolveSubtree` method, doing nothing.");
    const { errActions: r2, errSelectors: n, fn: { resolveSubtree: a2, fetch: o4, AST: s2 = {} }, specSelectors: l2, specActions: i2 } = t2, c2 = s2.getLineNumberForPath ?? (0, Jr.default)(void 0), u2 = l2.specStr(), { modelPropertyMacro: d2, parameterMacro: p2, requestInterceptor: m2, responseInterceptor: f2 } = t2.getConfigs();
    try {
      const t3 = await e3.reduce(async (e4, t4) => {
        let { resultMap: s3, specWithCurrentSubtrees: i3 } = await e4;
        const { errors: h2, spec: g2 } = await a2(i3, t4, { baseDoc: String(new URL(l2.url(), document.baseURI)), modelPropertyMacro: d2, parameterMacro: p2, requestInterceptor: m2, responseInterceptor: f2 });
        if (n.allErrors().size && r2.clearBy((e5) => "thrown" !== e5.get("type") || "resolver" !== e5.get("source") || !e5.get("fullPath").every((e6, r3) => e6 === t4[r3] || void 0 === t4[r3])), Array.isArray(h2) && h2.length > 0) {
          let e5 = h2.map((e6) => (e6.line = e6.fullPath ? c2(u2, e6.fullPath) : null, e6.path = e6.fullPath ? e6.fullPath.join(".") : null, e6.level = "error", e6.type = "thrown", e6.source = "resolver", Object.defineProperty(e6, "message", { enumerable: true, value: e6.message }), e6));
          r2.newThrownErrBatch(e5);
        }
        return g2 && l2.isOAS3() && "components" === t4[0] && "securitySchemes" === t4[1] && await Promise.all(Object.values(g2).filter((e5) => "openIdConnect" === e5.type).map(async (e5) => {
          const t5 = { url: e5.openIdConnectUrl, requestInterceptor: m2, responseInterceptor: f2 };
          try {
            const r3 = await o4(t5);
            r3 instanceof Error || r3.status >= 400 ? console.error(r3.statusText + " " + t5.url) : e5.openIdConnectData = JSON.parse(r3.text);
          } catch (e6) {
            console.error(e6);
          }
        })), (0, Cn.default)(s3, t4, g2), i3 = (0, xn.default)(t4, g2, i3), { resultMap: s3, specWithCurrentSubtrees: i3 };
      }, Promise.resolve({ resultMap: (l2.specResolvedSubtree([]) || (0, Qe.Map)()).toJS(), specWithCurrentSubtrees: l2.specJS() }));
      i2.updateResolvedSubtree([], t3.resultMap);
    } catch (e4) {
      console.error(e4);
    }
  });
}, 35);
var requestResolvedSubtree = (e2) => (t2) => {
  Kn.find(({ path: r2, system: n }) => n === t2 && r2.toString() === e2.toString()) || (Kn.push({ path: e2, system: t2 }), zn());
};
function changeParam(e2, t2, r2, n, a2) {
  return { type: An, payload: { path: e2, value: n, paramName: t2, paramIn: r2, isXml: a2 } };
}
function changeParamByIdentity(e2, t2, r2, n) {
  return { type: An, payload: { path: e2, param: t2, value: r2, isXml: n } };
}
var updateResolvedSubtree = (e2, t2) => ({ type: $n, payload: { path: e2, value: t2 } });
var invalidateResolvedSubtreeCache = () => ({ type: $n, payload: { path: [], value: (0, Qe.Map)() } });
var validateParams = (e2, t2) => ({ type: Rn, payload: { pathMethod: e2, isOAS3: t2 } });
var updateEmptyParamInclusion = (e2, t2, r2, n) => ({ type: In, payload: { pathMethod: e2, paramName: t2, paramIn: r2, includeEmptyValue: n } });
function clearValidateParams(e2) {
  return { type: Ln, payload: { pathMethod: e2 } };
}
function changeConsumesValue(e2, t2) {
  return { type: Dn, payload: { path: e2, value: t2, key: "consumes_value" } };
}
function changeProducesValue(e2, t2) {
  return { type: Dn, payload: { path: e2, value: t2, key: "produces_value" } };
}
var setResponse = (e2, t2, r2) => ({ payload: { path: e2, method: t2, res: r2 }, type: Tn });
var setRequest = (e2, t2, r2) => ({ payload: { path: e2, method: t2, req: r2 }, type: Bn });
var setMutatedRequest = (e2, t2, r2) => ({ payload: { path: e2, method: t2, req: r2 }, type: jn });
var logRequest = (e2) => ({ payload: e2, type: Pn });
var executeRequest = (e2) => ({ fn: t2, specActions: r2, specSelectors: n, getConfigs: a2, oas3Selectors: o4 }) => {
  let { pathName: s2, method: l2, operation: i2 } = e2, { requestInterceptor: c2, responseInterceptor: u2 } = a2(), d2 = i2.toJS();
  if (i2 && i2.get("parameters") && i2.get("parameters").filter((e3) => e3 && true === e3.get("allowEmptyValue")).forEach((t3) => {
    if (n.parameterInclusionSettingFor([s2, l2], t3.get("name"), t3.get("in"))) {
      e2.parameters = e2.parameters || {};
      const r3 = paramToValue(t3, e2.parameters);
      (!r3 || r3 && 0 === r3.size) && (e2.parameters[t3.get("name")] = "");
    }
  }), e2.contextUrl = (0, At.default)(n.url()).toString(), d2 && d2.operationId ? e2.operationId = d2.operationId : d2 && s2 && l2 && (e2.operationId = t2.opId(d2, s2, l2)), n.isOAS3()) {
    const t3 = `${s2}:${l2}`;
    e2.server = o4.selectedServer(t3) || o4.selectedServer();
    const r3 = o4.serverVariables({ server: e2.server, namespace: t3 }).toJS(), n2 = o4.serverVariables({ server: e2.server }).toJS();
    e2.serverVariables = Object.keys(r3).length ? r3 : n2, e2.requestContentType = o4.requestContentType(s2, l2), e2.responseContentType = o4.responseContentType(s2, l2) || "*/*";
    const a3 = o4.requestBodyValue(s2, l2), i3 = o4.requestBodyInclusionSetting(s2, l2);
    a3 && a3.toJS ? e2.requestBody = a3.map((e3) => Qe.Map.isMap(e3) ? e3.get("value") : e3).filter((e3, t4) => (Array.isArray(e3) ? 0 !== e3.length : !isEmptyValue(e3)) || i3.get(t4)).toJS() : e2.requestBody = a3;
  }
  let p2 = Object.assign({}, e2);
  p2 = t2.buildRequest(p2), r2.setRequest(e2.pathName, e2.method, p2);
  e2.requestInterceptor = async (t3) => {
    let n2 = await c2.apply(void 0, [t3]), a3 = Object.assign({}, n2);
    return r2.setMutatedRequest(e2.pathName, e2.method, a3), n2;
  }, e2.responseInterceptor = u2;
  const m2 = Date.now();
  return t2.execute(e2).then((t3) => {
    t3.duration = Date.now() - m2, r2.setResponse(e2.pathName, e2.method, t3);
  }).catch((t3) => {
    "Failed to fetch" === t3.message && (t3.name = "", t3.message = '**Failed to fetch.**  \n**Possible Reasons:** \n  - CORS \n  - Network Failure \n  - URL scheme must be "http" or "https" for CORS request.'), r2.setResponse(e2.pathName, e2.method, { error: true, err: t3 });
  });
};
var actions_execute = ({ path: e2, method: t2, ...r2 } = {}) => (n) => {
  let { fn: { fetch: a2 }, specSelectors: o4, specActions: s2 } = n, l2 = o4.specJsonWithResolvedSubtrees().toJS(), i2 = o4.operationScheme(e2, t2), { requestContentType: c2, responseContentType: u2 } = o4.contentTypeValues([e2, t2]).toJS(), d2 = /xml/i.test(c2), p2 = o4.parameterValues([e2, t2], d2).toJS();
  return s2.executeRequest({ ...r2, fetch: a2, spec: l2, pathName: e2, method: t2, parameters: p2, requestContentType: c2, scheme: i2, responseContentType: u2 });
};
function clearResponse(e2, t2) {
  return { type: Mn, payload: { path: e2, method: t2 } };
}
function clearRequest(e2, t2) {
  return { type: qn, payload: { path: e2, method: t2 } };
}
function setScheme(e2, t2, r2) {
  return { type: Jn, payload: { scheme: e2, path: t2, method: r2 } };
}
var Fn = { [On]: (e2, t2) => "string" == typeof t2.payload ? e2.set("spec", t2.payload) : e2, [kn]: (e2, t2) => e2.set("url", t2.payload + ""), [Nn]: (e2, t2) => e2.set("json", fromJSOrdered(t2.payload)), [Un]: (e2, t2) => e2.setIn(["resolved"], fromJSOrdered(t2.payload)), [$n]: (e2, t2) => {
  const { value: r2, path: n } = t2.payload;
  return e2.setIn(["resolvedSubtrees", ...n], fromJSOrdered(r2));
}, [An]: (e2, { payload: t2 }) => {
  let { path: r2, paramName: n, paramIn: a2, param: o4, value: s2, isXml: l2 } = t2, i2 = o4 ? paramToIdentifier(o4) : `${a2}.${n}`;
  const c2 = l2 ? "value_xml" : "value";
  return e2.setIn(["meta", "paths", ...r2, "parameters", i2, c2], (0, Qe.fromJS)(s2));
}, [In]: (e2, { payload: t2 }) => {
  let { pathMethod: r2, paramName: n, paramIn: a2, includeEmptyValue: o4 } = t2;
  if (!n || !a2) return console.warn("Warning: UPDATE_EMPTY_PARAM_INCLUSION could not generate a paramKey."), e2;
  const s2 = `${a2}.${n}`;
  return e2.setIn(["meta", "paths", ...r2, "parameter_inclusions", s2], o4);
}, [Rn]: (e2, { payload: { pathMethod: t2, isOAS3: r2 } }) => {
  const n = Yr(e2).getIn(["paths", ...t2]), a2 = parameterValues(e2, t2).toJS();
  return e2.updateIn(["meta", "paths", ...t2, "parameters"], (0, Qe.fromJS)({}), (o4) => n.get("parameters", (0, Qe.List)()).reduce((n2, o5) => {
    const s2 = paramToValue(o5, a2), l2 = parameterInclusionSettingFor(e2, t2, o5.get("name"), o5.get("in")), i2 = ((e3, t3, { isOAS3: r3 = false, bypassRequiredCheck: n3 = false } = {}) => {
      let a3 = e3.get("required"), { schema: o6, parameterContentMediaType: s3 } = getParameterSchema(e3, { isOAS3: r3 });
      return validateValueBySchema(t3, o6, a3, n3, s3);
    })(o5, s2, { bypassRequiredCheck: l2, isOAS3: r2 });
    return n2.setIn([paramToIdentifier(o5), "errors"], (0, Qe.fromJS)(i2));
  }, o4));
}, [Ln]: (e2, { payload: { pathMethod: t2 } }) => e2.updateIn(["meta", "paths", ...t2, "parameters"], (0, Qe.fromJS)([]), (e3) => e3.map((e4) => e4.set("errors", (0, Qe.fromJS)([])))), [Tn]: (e2, { payload: { res: t2, path: r2, method: n } }) => {
  let a2;
  a2 = t2.error ? Object.assign({ error: true, name: t2.err.name, message: t2.err.message, statusCode: t2.err.statusCode }, t2.err.response) : t2, a2.headers = a2.headers || {};
  let o4 = e2.setIn(["responses", r2, n], fromJSOrdered(a2));
  return dt.Blob && a2.data instanceof dt.Blob && (o4 = o4.setIn(["responses", r2, n, "text"], a2.data)), o4;
}, [Bn]: (e2, { payload: { req: t2, path: r2, method: n } }) => e2.setIn(["requests", r2, n], fromJSOrdered(t2)), [jn]: (e2, { payload: { req: t2, path: r2, method: n } }) => e2.setIn(["mutatedRequests", r2, n], fromJSOrdered(t2)), [Dn]: (e2, { payload: { path: t2, value: r2, key: n } }) => {
  let a2 = ["paths", ...t2], o4 = ["meta", "paths", ...t2];
  return e2.getIn(["json", ...a2]) || e2.getIn(["resolved", ...a2]) || e2.getIn(["resolvedSubtrees", ...a2]) ? e2.setIn([...o4, n], (0, Qe.fromJS)(r2)) : e2;
}, [Mn]: (e2, { payload: { path: t2, method: r2 } }) => e2.deleteIn(["responses", t2, r2]), [qn]: (e2, { payload: { path: t2, method: r2 } }) => e2.deleteIn(["requests", t2, r2]), [Jn]: (e2, { payload: { scheme: t2, path: r2, method: n } }) => r2 && n ? e2.setIn(["scheme", r2, n], t2) : r2 || n ? void 0 : e2.setIn(["scheme", "_defaultScheme"], t2) };
var wrap_actions_updateSpec = (e2, { specActions: t2 }) => (...r2) => {
  e2(...r2), t2.parseToJson(...r2);
};
var wrap_actions_updateJsonSpec = (e2, { specActions: t2 }) => (...r2) => {
  e2(...r2), t2.invalidateResolvedSubtreeCache();
  const [n] = r2, a2 = (0, ar.default)(n, ["paths"]) || {};
  Object.keys(a2).forEach((e3) => {
    (0, ar.default)(a2, [e3]).$ref && t2.requestResolvedSubtree(["paths", e3]);
  }), t2.requestResolvedSubtree(["components", "securitySchemes"]);
};
var wrap_actions_executeRequest = (e2, { specActions: t2 }) => (r2) => (t2.logRequest(r2), e2(r2));
var wrap_actions_validateParams = (e2, { specSelectors: t2 }) => (r2) => e2(r2, t2.isOAS3());
var plugins_spec = () => ({ statePlugins: { spec: { wrapActions: { ...Ve }, reducers: { ...Fn }, actions: { ...Je }, selectors: { ...$e } } } });
var Wn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return generic_default;
} });
var Hn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return openapi_2_default;
} });
var Gn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return openapi_3_0_default;
} });
var Xn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return openapi_3_1_apidom_default;
} });
var Yn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ makeResolve: function() {
  return makeResolve;
} });
var Qn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ buildRequest: function() {
  return buildRequest3;
}, execute: function() {
  return execute;
} });
var Zn = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return http;
}, makeHttp: function() {
  return makeHttp;
}, serializeRes: function() {
  return serializeResponse;
} });
var ea = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ makeResolveSubtree: function() {
  return makeResolveSubtree;
} });
var ta = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ opId: function() {
  return opId;
} });
var configs_wrap_actions_loaded = (e2, t2) => (...r2) => {
  e2(...r2);
  const n = t2.getConfigs().withCredentials;
  t2.fn.fetch.withCredentials = n;
};
function swagger_client({ configs: e2, getConfigs: t2 }) {
  return { fn: { fetch: (0, Zn.makeHttp)(Zn.default, e2.preFetch, e2.postFetch), buildRequest: Qn.buildRequest, execute: Qn.execute, resolve: (0, Yn.makeResolve)({ strategies: [Xn.default, Gn.default, Hn.default, Wn.default] }), resolveSubtree: async (e3, r2, n = {}) => {
    const a2 = t2(), o4 = { modelPropertyMacro: a2.modelPropertyMacro, parameterMacro: a2.parameterMacro, requestInterceptor: a2.requestInterceptor, responseInterceptor: a2.responseInterceptor, strategies: [Xn.default, Gn.default, Hn.default, Wn.default] };
    return (0, ea.makeResolveSubtree)(o4)(e3, r2, n);
  }, serializeRes: Zn.serializeRes, opId: ta.opId }, statePlugins: { configs: { wrapActions: { loaded: configs_wrap_actions_loaded } } } };
}
function util() {
  return { fn: { shallowEqualKeys } };
}
var ra = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return H.default;
} });
var na = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ Provider: function() {
  return Provider_default;
}, connect: function() {
  return connect_default;
} });
var aa = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return X.default;
} });
var withSystem = (e2) => (t2) => {
  const { fn: r2 } = e2();
  class WithSystem extends Xe.Component {
    render() {
      return Xe.default.createElement(t2, (0, cr.default)({}, e2(), this.props, this.context));
    }
  }
  return WithSystem.displayName = `WithSystem(${r2.getDisplayName(t2)})`, WithSystem;
};
var withRoot = (e2, t2) => (r2) => {
  const { fn: n } = e2();
  class WithRoot extends Xe.Component {
    render() {
      return Xe.default.createElement(na.Provider, { store: t2 }, Xe.default.createElement(r2, (0, cr.default)({}, this.props, this.context)));
    }
  }
  return WithRoot.displayName = `WithRoot(${n.getDisplayName(r2)})`, WithRoot;
};
var withConnect = (e2, t2, r2) => (0, Ye.compose)(r2 ? withRoot(e2, r2) : aa.default, (0, na.connect)((r3, n) => {
  var _a6;
  const a2 = { ...n, ...e2() }, o4 = ((_a6 = t2.prototype) == null ? void 0 : _a6.mapStateToProps) || ((e3) => ({ state: e3 }));
  return o4(r3, a2);
}), withSystem(e2))(t2);
var handleProps = (e2, t2, r2, n) => {
  for (const a2 in t2) {
    const o4 = t2[a2];
    "function" == typeof o4 && o4(r2[a2], n[a2], e2());
  }
};
var withMappedContainer = (e2, t2, r2) => (t3, n) => {
  const { fn: a2 } = e2(), o4 = r2(t3, "root");
  class WithMappedContainer extends Xe.Component {
    constructor(t4, r3) {
      super(t4, r3), handleProps(e2, n, t4, {});
    }
    UNSAFE_componentWillReceiveProps(t4) {
      handleProps(e2, n, t4, this.props);
    }
    render() {
      const e3 = (0, zt.default)(this.props, n ? Object.keys(n) : []);
      return Xe.default.createElement(o4, e3);
    }
  }
  return WithMappedContainer.displayName = `WithMappedContainer(${a2.getDisplayName(o4)})`, WithMappedContainer;
};
var render = (e2, t2, r2, n) => (a2) => {
  const o4 = r2(e2, t2, n)("App", "root"), { createRoot: s2 } = ra.default;
  s2(a2).render(Xe.default.createElement(o4, null));
};
var getComponent = (e2, t2, r2) => (n, a2, o4 = {}) => {
  if ("string" != typeof n) throw new TypeError("Need a string, to fetch a component. Was given a " + typeof n);
  const s2 = r2(n);
  return s2 ? a2 ? "root" === a2 ? withConnect(e2, s2, t2()) : withConnect(e2, s2) : s2 : (o4.failSilently || e2().log.warn("Could not find component:", n), null);
};
var getDisplayName = (e2) => e2.displayName || e2.name || "Component";
var view3 = ({ getComponents: e2, getStore: t2, getSystem: r2 }) => {
  const n = (a2 = getComponent(r2, t2, e2), kt(a2, (...e3) => JSON.stringify(e3)));
  var a2;
  const o4 = ((e3) => utils_memoizeN(e3, (...e4) => e4))(withMappedContainer(r2, 0, n));
  return { rootInjects: { getComponent: n, makeMappedContainer: o4, render: render(r2, t2, getComponent, e2) }, fn: { getDisplayName } };
};
var view_legacy = ({ React: e2, getSystem: t2, getStore: r2, getComponents: n }) => {
  const a2 = {}, o4 = parseInt(e2 == null ? void 0 : e2.version, 10);
  return o4 >= 16 && o4 < 18 && (a2.render = /* @__PURE__ */ ((e3, t3, r3, n2) => (a3) => {
    const o5 = r3(e3, t3, n2)("App", "root");
    ra.default.render(Xe.default.createElement(o5, null), a3);
  })(t2, r2, getComponent, n)), { rootInjects: a2 };
};
function downloadUrlPlugin(e2) {
  let { fn: t2 } = e2;
  const r2 = { download: (e3) => ({ errActions: r3, specSelectors: n2, specActions: a2, getConfigs: o4 }) => {
    let { fetch: s2 } = t2;
    const l2 = o4();
    function next(t3) {
      if (t3 instanceof Error || t3.status >= 400) return a2.updateLoadingStatus("failed"), r3.newThrownErr(Object.assign(new Error((t3.message || t3.statusText) + " " + e3), { source: "fetch" })), void (!t3.status && t3 instanceof Error && function checkPossibleFailReasons() {
        try {
          let t4;
          if ("URL" in dt ? t4 = new URL(e3) : (t4 = document.createElement("a"), t4.href = e3), "https:" !== t4.protocol && "https:" === dt.location.protocol) {
            const e4 = Object.assign(new Error(`Possible mixed-content issue? The page was loaded over https:// but a ${t4.protocol}// URL was specified. Check that you are not attempting to load mixed content.`), { source: "fetch" });
            return void r3.newThrownErr(e4);
          }
          if (t4.origin !== dt.location.origin) {
            const e4 = Object.assign(new Error(`Possible cross-origin (CORS) issue? The URL origin (${t4.origin}) does not match the page (${dt.location.origin}). Check the server returns the correct 'Access-Control-Allow-*' headers.`), { source: "fetch" });
            r3.newThrownErr(e4);
          }
        } catch (e4) {
          return;
        }
      }());
      a2.updateLoadingStatus("success"), a2.updateSpec(t3.text), n2.url() !== e3 && a2.updateUrl(e3);
    }
    e3 = e3 || n2.url(), a2.updateLoadingStatus("loading"), r3.clear({ source: "fetch" }), s2({ url: e3, loadSpec: true, requestInterceptor: l2.requestInterceptor || ((e4) => e4), responseInterceptor: l2.responseInterceptor || ((e4) => e4), credentials: "same-origin", headers: { Accept: "application/json,*/*" } }).then(next, next);
  }, updateLoadingStatus: (e3) => {
    let t3 = [null, "loading", "failed", "success", "failedConfig"];
    return -1 === t3.indexOf(e3) && console.error(`Error: ${e3} is not one of ${JSON.stringify(t3)}`), { type: "spec_update_loading_status", payload: e3 };
  } };
  let n = { loadingStatus: (0, Dt.createSelector)((e3) => e3 || (0, Qe.Map)(), (e3) => e3.get("loadingStatus") || null) };
  return { statePlugins: { spec: { actions: r2, reducers: { spec_update_loading_status: (e3, t3) => "string" == typeof t3.payload ? e3.set("loadingStatus", t3.payload) : e3 }, selectors: n } } };
}
var oa = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return light_default;
} });
var sa = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return javascript_default;
} });
var la = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return json_default4;
} });
var ia = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return xml_default3;
} });
var ca = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return bash_default;
} });
var ua = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return yaml_default;
} });
var da = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return http_default;
} });
var pa = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return powershell_default;
} });
var after_load = () => {
  oa.default.registerLanguage("json", la.default), oa.default.registerLanguage("js", sa.default), oa.default.registerLanguage("xml", ia.default), oa.default.registerLanguage("yaml", ua.default), oa.default.registerLanguage("http", da.default), oa.default.registerLanguage("bash", ca.default), oa.default.registerLanguage("powershell", pa.default), oa.default.registerLanguage("javascript", sa.default);
};
var ma = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return agate_default;
} });
var fa = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return arta_default;
} });
var ha = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return monokai_default;
} });
var ga = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return nord_default;
} });
var ya = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return obsidian_default;
} });
var Ea = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return tomorrow_night_default;
} });
var Sa = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return idea_default;
} });
var _a = { agate: ma.default, arta: fa.default, monokai: ha.default, nord: ga.default, obsidian: ya.default, "tomorrow-night": Ea.default, idea: Sa.default };
var va = ma.default;
var components_SyntaxHighlighter = ({ language: e2, className: t2 = "", getConfigs: r2, syntaxHighlighting: n = {}, children: a2 = "" }) => {
  const o4 = r2().syntaxHighlight.theme, { styles: s2, defaultStyle: l2 } = n, i2 = (s2 == null ? void 0 : s2[o4]) ?? l2;
  return Xe.default.createElement(oa.default, { language: e2, className: t2, style: i2 }, a2);
};
var ba = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return pe.default;
} });
var components_HighlightCode = ({ fileName: e2 = "response.txt", className: t2, downloadable: r2, getComponent: n, canCopy: a2, language: o4, children: s2 }) => {
  const l2 = (0, Xe.useRef)(null), i2 = n("SyntaxHighlighter", true), handlePreventYScrollingBeyondElement = (e3) => {
    const { target: t3, deltaY: r3 } = e3, { scrollHeight: n2, offsetHeight: a3, scrollTop: o5 } = t3;
    n2 > a3 && (0 === o5 && r3 < 0 || a3 + o5 >= n2 && r3 > 0) && e3.preventDefault();
  };
  return (0, Xe.useEffect)(() => {
    const e3 = Array.from(l2.current.childNodes).filter((e4) => !!e4.nodeType && e4.classList.contains("microlight"));
    return e3.forEach((e4) => e4.addEventListener("mousewheel", handlePreventYScrollingBeyondElement, { passive: false })), () => {
      e3.forEach((e4) => e4.removeEventListener("mousewheel", handlePreventYScrollingBeyondElement));
    };
  }, [s2, t2, o4]), Xe.default.createElement("div", { className: "highlight-code", ref: l2 }, a2 && Xe.default.createElement("div", { className: "copy-to-clipboard" }, Xe.default.createElement(vr.CopyToClipboard, { text: s2 }, Xe.default.createElement("button", null))), r2 ? Xe.default.createElement("button", { className: "download-contents", onClick: () => {
    (0, ba.default)(s2, e2);
  } }, "Download") : null, Xe.default.createElement(i2, { language: o4, className: (0, _r.default)(t2, "microlight"), renderPlainText: ({ children: e3, PlainTextViewer: r3 }) => Xe.default.createElement(r3, { className: t2 }, e3) }, s2));
};
var components_PlainTextViewer = ({ className: e2 = "", children: t2 }) => Xe.default.createElement("pre", { className: (0, _r.default)("microlight", e2) }, t2);
var wrap_components_SyntaxHighlighter = (e2, t2) => ({ renderPlainText: r2, children: n, ...a2 }) => {
  const o4 = t2.getConfigs().syntaxHighlight.activated, s2 = t2.getComponent("PlainTextViewer");
  return o4 || "function" != typeof r2 ? o4 ? Xe.default.createElement(e2, a2, n) : Xe.default.createElement(s2, null, n) : r2({ children: n, PlainTextViewer: s2 });
};
var SyntaxHighlightingPlugin1 = () => ({ afterLoad: after_load, rootInjects: { syntaxHighlighting: { styles: _a, defaultStyle: va } }, components: { SyntaxHighlighter: components_SyntaxHighlighter, HighlightCode: components_HighlightCode, PlainTextViewer: components_PlainTextViewer } });
var SyntaxHighlightingPlugin2 = () => ({ wrapComponents: { SyntaxHighlighter: wrap_components_SyntaxHighlighter } });
var syntax_highlighting = () => [SyntaxHighlightingPlugin1, SyntaxHighlightingPlugin2];
var versions_after_load = () => {
  const { GIT_DIRTY: e2, GIT_COMMIT: t2, PACKAGE_VERSION: r2, BUILD_TIME: n } = { PACKAGE_VERSION: "5.18.2", GIT_COMMIT: "g1dd1f7cc", GIT_DIRTY: true, BUILD_TIME: "Thu, 07 Nov 2024 14:01:17 GMT" };
  dt.versions = dt.versions || {}, dt.versions.swaggerUI = { version: r2, gitRevision: t2, gitDirty: e2, buildTimestamp: n };
};
var versions = () => ({ afterLoad: versions_after_load });
var wa = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return me.default;
} });
var Ca = console.error;
var withErrorBoundary = (e2) => (t2) => {
  const { getComponent: r2, fn: n } = e2(), a2 = r2("ErrorBoundary"), o4 = n.getDisplayName(t2);
  class WithErrorBoundary extends Xe.Component {
    render() {
      return Xe.default.createElement(a2, { targetName: o4, getComponent: r2, fn: n }, Xe.default.createElement(t2, (0, cr.default)({}, this.props, this.context)));
    }
  }
  var s2;
  return WithErrorBoundary.displayName = `WithErrorBoundary(${o4})`, (s2 = t2).prototype && s2.prototype.isReactComponent && (WithErrorBoundary.prototype.mapStateToProps = t2.prototype.mapStateToProps), WithErrorBoundary;
};
var fallback = ({ name: e2 }) => Xe.default.createElement("div", { className: "fallback" }, " ", Xe.default.createElement("i", null, "Could not render ", "t" === e2 ? "this component" : e2, ", see the console."));
var ErrorBoundary = class extends Xe.Component {
  static getDerivedStateFromError(e2) {
    return { hasError: true, error: e2 };
  }
  constructor(...e2) {
    super(...e2), this.state = { hasError: false, error: null };
  }
  componentDidCatch(e2, t2) {
    this.props.fn.componentDidCatch(e2, t2);
  }
  render() {
    const { getComponent: e2, targetName: t2, children: r2 } = this.props;
    if (this.state.hasError) {
      const r3 = e2("Fallback");
      return Xe.default.createElement(r3, { name: t2 });
    }
    return r2;
  }
};
__publicField(ErrorBoundary, "defaultProps", { targetName: "this component", getComponent: () => fallback, fn: { componentDidCatch: Ca }, children: null });
var xa = ErrorBoundary;
var safe_render = ({ componentList: e2 = [], fullOverride: t2 = false } = {}) => ({ getSystem: r2 }) => {
  const n = t2 ? e2 : ["App", "BaseLayout", "VersionPragmaFilter", "InfoContainer", "ServersContainer", "SchemesContainer", "AuthorizeBtnContainer", "FilterContainer", "Operations", "OperationContainer", "parameters", "responses", "OperationServers", "Models", "ModelWrapper", ...e2], a2 = (0, wa.default)(n, Array(n.length).fill((e3, { fn: t3 }) => t3.withErrorBoundary(e3)));
  return { fn: { componentDidCatch: Ca, withErrorBoundary: withErrorBoundary(r2) }, components: { ErrorBoundary: xa, Fallback: fallback }, wrapComponents: a2 };
};
var App = class extends Xe.default.Component {
  getLayout() {
    const { getComponent: e2, layoutSelectors: t2 } = this.props, r2 = t2.current(), n = e2(r2, true);
    return n || (() => Xe.default.createElement("h1", null, ' No layout defined for "', r2, '" '));
  }
  render() {
    const e2 = this.getLayout();
    return Xe.default.createElement(e2, null);
  }
};
var Oa = App;
var AuthorizationPopup = class extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "close", () => {
      let { authActions: e2 } = this.props;
      e2.showDefinitions(false);
    });
  }
  render() {
    let { authSelectors: e2, authActions: t2, getComponent: r2, errSelectors: n, specSelectors: a2, fn: { AST: o4 = {} } } = this.props, s2 = e2.shownDefinitions();
    const l2 = r2("auths"), i2 = r2("CloseIcon");
    return Xe.default.createElement("div", { className: "dialog-ux" }, Xe.default.createElement("div", { className: "backdrop-ux" }), Xe.default.createElement("div", { className: "modal-ux" }, Xe.default.createElement("div", { className: "modal-dialog-ux" }, Xe.default.createElement("div", { className: "modal-ux-inner" }, Xe.default.createElement("div", { className: "modal-ux-header" }, Xe.default.createElement("h3", null, "Available authorizations"), Xe.default.createElement("button", { type: "button", className: "close-modal", onClick: this.close }, Xe.default.createElement(i2, null))), Xe.default.createElement("div", { className: "modal-ux-content" }, s2.valueSeq().map((s3, i3) => Xe.default.createElement(l2, { key: i3, AST: o4, definitions: s3, getComponent: r2, errSelectors: n, authSelectors: e2, authActions: t2, specSelectors: a2 })))))));
  }
};
var AuthorizeBtn = class extends Xe.default.Component {
  render() {
    let { isAuthorized: e2, showPopup: t2, onClick: r2, getComponent: n } = this.props;
    const a2 = n("authorizationPopup", true), o4 = n("LockAuthIcon", true), s2 = n("UnlockAuthIcon", true);
    return Xe.default.createElement("div", { className: "auth-wrapper" }, Xe.default.createElement("button", { className: e2 ? "btn authorize locked" : "btn authorize unlocked", onClick: r2 }, Xe.default.createElement("span", null, "Authorize"), e2 ? Xe.default.createElement(o4, null) : Xe.default.createElement(s2, null)), t2 && Xe.default.createElement(a2, null));
  }
};
var AuthorizeBtnContainer = class extends Xe.default.Component {
  render() {
    const { authActions: e2, authSelectors: t2, specSelectors: r2, getComponent: n } = this.props, a2 = r2.securityDefinitions(), o4 = t2.definitionsToAuthorize(), s2 = n("authorizeBtn");
    return a2 ? Xe.default.createElement(s2, { onClick: () => e2.showDefinitions(o4), isAuthorized: !!t2.authorized().size, showPopup: !!t2.shownDefinitions(), getComponent: n }) : null;
  }
};
var AuthorizeOperationBtn = class extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onClick", (e2) => {
      e2.stopPropagation();
      let { onClick: t2 } = this.props;
      t2 && t2();
    });
  }
  render() {
    let { isAuthorized: e2, getComponent: t2 } = this.props;
    const r2 = t2("LockAuthOperationIcon", true), n = t2("UnlockAuthOperationIcon", true);
    return Xe.default.createElement("button", { className: "authorization__btn", "aria-label": e2 ? "authorization button locked" : "authorization button unlocked", onClick: this.onClick }, e2 ? Xe.default.createElement(r2, { className: "locked" }) : Xe.default.createElement(n, { className: "unlocked" }));
  }
};
var Auths = class extends Xe.default.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "onAuthChange", (e2) => {
      let { name: t2 } = e2;
      this.setState({ [t2]: e2 });
    });
    __publicField(this, "submitAuth", (e2) => {
      e2.preventDefault();
      let { authActions: t2 } = this.props;
      t2.authorizeWithPersistOption(this.state);
    });
    __publicField(this, "logoutClick", (e2) => {
      e2.preventDefault();
      let { authActions: t2, definitions: r2 } = this.props, n = r2.map((e3, t3) => t3).toArray();
      this.setState(n.reduce((e3, t3) => (e3[t3] = "", e3), {})), t2.logoutWithPersistOption(n);
    });
    __publicField(this, "close", (e2) => {
      e2.preventDefault();
      let { authActions: t2 } = this.props;
      t2.showDefinitions(false);
    });
    this.state = {};
  }
  render() {
    let { definitions: e2, getComponent: t2, authSelectors: r2, errSelectors: n } = this.props;
    const a2 = t2("AuthItem"), o4 = t2("oauth2", true), s2 = t2("Button");
    let l2 = r2.authorized(), i2 = e2.filter((e3, t3) => !!l2.get(t3)), c2 = e2.filter((e3) => "oauth2" !== e3.get("type")), u2 = e2.filter((e3) => "oauth2" === e3.get("type"));
    return Xe.default.createElement("div", { className: "auth-container" }, !!c2.size && Xe.default.createElement("form", { onSubmit: this.submitAuth }, c2.map((e3, r3) => Xe.default.createElement(a2, { key: r3, schema: e3, name: r3, getComponent: t2, onAuthChange: this.onAuthChange, authorized: l2, errSelectors: n })).toArray(), Xe.default.createElement("div", { className: "auth-btn-wrapper" }, c2.size === i2.size ? Xe.default.createElement(s2, { className: "btn modal-btn auth", onClick: this.logoutClick, "aria-label": "Remove authorization" }, "Logout") : Xe.default.createElement(s2, { type: "submit", className: "btn modal-btn auth authorize", "aria-label": "Apply credentials" }, "Authorize"), Xe.default.createElement(s2, { className: "btn modal-btn auth btn-done", onClick: this.close }, "Close"))), u2 && u2.size ? Xe.default.createElement("div", null, Xe.default.createElement("div", { className: "scope-def" }, Xe.default.createElement("p", null, "Scopes are used to grant an application different levels of access to data on behalf of the end user. Each API may declare one or more scopes."), Xe.default.createElement("p", null, "API requires the following scopes. Select which ones you want to grant to Swagger UI.")), e2.filter((e3) => "oauth2" === e3.get("type")).map((e3, t3) => Xe.default.createElement("div", { key: t3 }, Xe.default.createElement(o4, { authorized: l2, schema: e3, name: t3 }))).toArray()) : null);
  }
};
var auth_item_Auths = class extends Xe.default.Component {
  render() {
    let { schema: e2, name: t2, getComponent: r2, onAuthChange: n, authorized: a2, errSelectors: o4 } = this.props;
    const s2 = r2("apiKeyAuth"), l2 = r2("basicAuth");
    let i2;
    const c2 = e2.get("type");
    switch (c2) {
      case "apiKey":
        i2 = Xe.default.createElement(s2, { key: t2, schema: e2, name: t2, errSelectors: o4, authorized: a2, getComponent: r2, onChange: n });
        break;
      case "basic":
        i2 = Xe.default.createElement(l2, { key: t2, schema: e2, name: t2, errSelectors: o4, authorized: a2, getComponent: r2, onChange: n });
        break;
      default:
        i2 = Xe.default.createElement("div", { key: t2 }, "Unknown security definition type ", c2);
    }
    return Xe.default.createElement("div", { key: `${t2}-jump` }, i2);
  }
};
var AuthError = class extends Xe.default.Component {
  render() {
    let { error: e2 } = this.props, t2 = e2.get("level"), r2 = e2.get("message"), n = e2.get("source");
    return Xe.default.createElement("div", { className: "errors" }, Xe.default.createElement("b", null, n, " ", t2), Xe.default.createElement("span", null, r2));
  }
};
var ApiKeyAuth = class extends Xe.default.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "onChange", (e2) => {
      let { onChange: t2 } = this.props, r2 = e2.target.value, n = Object.assign({}, this.state, { value: r2 });
      this.setState(n), t2(n);
    });
    let { name: r2, schema: n } = this.props, a2 = this.getValue();
    this.state = { name: r2, schema: n, value: a2 };
  }
  getValue() {
    let { name: e2, authorized: t2 } = this.props;
    return t2 && t2.getIn([e2, "value"]);
  }
  render() {
    let { schema: e2, getComponent: t2, errSelectors: r2, name: n } = this.props;
    const a2 = t2("Input"), o4 = t2("Row"), s2 = t2("Col"), l2 = t2("authError"), i2 = t2("Markdown", true), c2 = t2("JumpToPath", true);
    let u2 = this.getValue(), d2 = r2.allErrors().filter((e3) => e3.get("authId") === n);
    return Xe.default.createElement("div", null, Xe.default.createElement("h4", null, Xe.default.createElement("code", null, n || e2.get("name")), "(apiKey)", Xe.default.createElement(c2, { path: ["securityDefinitions", n] })), u2 && Xe.default.createElement("h6", null, "Authorized"), Xe.default.createElement(o4, null, Xe.default.createElement(i2, { source: e2.get("description") })), Xe.default.createElement(o4, null, Xe.default.createElement("p", null, "Name: ", Xe.default.createElement("code", null, e2.get("name")))), Xe.default.createElement(o4, null, Xe.default.createElement("p", null, "In: ", Xe.default.createElement("code", null, e2.get("in")))), Xe.default.createElement(o4, null, Xe.default.createElement("label", { htmlFor: "api_key_value" }, "Value:"), u2 ? Xe.default.createElement("code", null, " ****** ") : Xe.default.createElement(s2, null, Xe.default.createElement(a2, { id: "api_key_value", type: "text", onChange: this.onChange, autoFocus: true }))), d2.valueSeq().map((e3, t3) => Xe.default.createElement(l2, { error: e3, key: t3 })));
  }
};
var BasicAuth = class extends Xe.default.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "onChange", (e2) => {
      let { onChange: t2 } = this.props, { value: r2, name: n } = e2.target, a2 = this.state.value;
      a2[n] = r2, this.setState({ value: a2 }), t2(this.state);
    });
    let { schema: r2, name: n } = this.props, a2 = this.getValue().username;
    this.state = { name: n, schema: r2, value: a2 ? { username: a2 } : {} };
  }
  getValue() {
    let { authorized: e2, name: t2 } = this.props;
    return e2 && e2.getIn([t2, "value"]) || {};
  }
  render() {
    let { schema: e2, getComponent: t2, name: r2, errSelectors: n } = this.props;
    const a2 = t2("Input"), o4 = t2("Row"), s2 = t2("Col"), l2 = t2("authError"), i2 = t2("JumpToPath", true), c2 = t2("Markdown", true);
    let u2 = this.getValue().username, d2 = n.allErrors().filter((e3) => e3.get("authId") === r2);
    return Xe.default.createElement("div", null, Xe.default.createElement("h4", null, "Basic authorization", Xe.default.createElement(i2, { path: ["securityDefinitions", r2] })), u2 && Xe.default.createElement("h6", null, "Authorized"), Xe.default.createElement(o4, null, Xe.default.createElement(c2, { source: e2.get("description") })), Xe.default.createElement(o4, null, Xe.default.createElement("label", { htmlFor: "auth_username" }, "Username:"), u2 ? Xe.default.createElement("code", null, " ", u2, " ") : Xe.default.createElement(s2, null, Xe.default.createElement(a2, { id: "auth_username", type: "text", required: "required", name: "username", onChange: this.onChange, autoFocus: true }))), Xe.default.createElement(o4, null, Xe.default.createElement("label", { htmlFor: "auth_password" }, "Password:"), u2 ? Xe.default.createElement("code", null, " ****** ") : Xe.default.createElement(s2, null, Xe.default.createElement(a2, { id: "auth_password", autoComplete: "new-password", name: "password", type: "password", onChange: this.onChange }))), d2.valueSeq().map((e3, t3) => Xe.default.createElement(l2, { error: e3, key: t3 })));
  }
};
function Example3(e2) {
  const { example: t2, showValue: r2, getComponent: n } = e2, a2 = n("Markdown", true), o4 = n("HighlightCode", true);
  return t2 ? Xe.default.createElement("div", { className: "example" }, t2.get("description") ? Xe.default.createElement("section", { className: "example__section" }, Xe.default.createElement("div", { className: "example__section-header" }, "Example Description"), Xe.default.createElement("p", null, Xe.default.createElement(a2, { source: t2.get("description") }))) : null, r2 && t2.has("value") ? Xe.default.createElement("section", { className: "example__section" }, Xe.default.createElement("div", { className: "example__section-header" }, "Example Value"), Xe.default.createElement(o4, null, stringify(t2.get("value")))) : null) : null;
}
var ExamplesSelect = class extends Xe.default.PureComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "_onSelect", (e2, { isSyntheticChange: t2 = false } = {}) => {
      "function" == typeof this.props.onSelect && this.props.onSelect(e2, { isSyntheticChange: t2 });
    });
    __publicField(this, "_onDomSelect", (e2) => {
      if ("function" == typeof this.props.onSelect) {
        const t2 = e2.target.selectedOptions[0].getAttribute("value");
        this._onSelect(t2, { isSyntheticChange: false });
      }
    });
    __publicField(this, "getCurrentExample", () => {
      const { examples: e2, currentExampleKey: t2 } = this.props, r2 = e2.get(t2), n = e2.keySeq().first(), a2 = e2.get(n);
      return r2 || a2 || Map({});
    });
  }
  componentDidMount() {
    const { onSelect: e2, examples: t2 } = this.props;
    if ("function" == typeof e2) {
      const e3 = t2.first(), r2 = t2.keyOf(e3);
      this._onSelect(r2, { isSyntheticChange: true });
    }
  }
  UNSAFE_componentWillReceiveProps(e2) {
    const { currentExampleKey: t2, examples: r2 } = e2;
    if (r2 !== this.props.examples && !r2.has(t2)) {
      const e3 = r2.first(), t3 = r2.keyOf(e3);
      this._onSelect(t3, { isSyntheticChange: true });
    }
  }
  render() {
    const { examples: e2, currentExampleKey: t2, isValueModified: r2, isModifiedValueAvailable: n, showLabels: a2 } = this.props;
    return Xe.default.createElement("div", { className: "examples-select" }, a2 ? Xe.default.createElement("span", { className: "examples-select__section-label" }, "Examples: ") : null, Xe.default.createElement("select", { className: "examples-select-element", onChange: this._onDomSelect, value: n && r2 ? "__MODIFIED__VALUE__" : t2 || "" }, n ? Xe.default.createElement("option", { value: "__MODIFIED__VALUE__" }, "[Modified value]") : null, e2.map((e3, t3) => Xe.default.createElement("option", { key: t3, value: t3 }, e3.get("summary") || t3)).valueSeq()));
  }
};
__publicField(ExamplesSelect, "defaultProps", { examples: Qe.default.Map({}), onSelect: (...e2) => console.log("DEBUG: ExamplesSelect was not given an onSelect callback", ...e2), currentExampleKey: null, showLabels: true });
var stringifyUnlessList = (e2) => Qe.List.isList(e2) ? e2 : stringify(e2);
var ExamplesSelectValueRetainer = class extends Xe.default.PureComponent {
  constructor(e2) {
    super(e2);
    __publicField(this, "_getStateForCurrentNamespace", () => {
      const { currentNamespace: e2 } = this.props;
      return (this.state[e2] || (0, Qe.Map)()).toObject();
    });
    __publicField(this, "_setStateForCurrentNamespace", (e2) => {
      const { currentNamespace: t2 } = this.props;
      return this._setStateForNamespace(t2, e2);
    });
    __publicField(this, "_setStateForNamespace", (e2, t2) => {
      const r2 = (this.state[e2] || (0, Qe.Map)()).mergeDeep(t2);
      return this.setState({ [e2]: r2 });
    });
    __publicField(this, "_isCurrentUserInputSameAsExampleValue", () => {
      const { currentUserInputValue: e2 } = this.props;
      return this._getCurrentExampleValue() === e2;
    });
    __publicField(this, "_getValueForExample", (e2, t2) => {
      const { examples: r2 } = t2 || this.props;
      return stringifyUnlessList((r2 || (0, Qe.Map)({})).getIn([e2, "value"]));
    });
    __publicField(this, "_getCurrentExampleValue", (e2) => {
      const { currentKey: t2 } = e2 || this.props;
      return this._getValueForExample(t2, e2 || this.props);
    });
    __publicField(this, "_onExamplesSelect", (e2, { isSyntheticChange: t2 } = {}, ...r2) => {
      const { onSelect: n, updateValue: a2, currentUserInputValue: o4, userHasEditedBody: s2 } = this.props, { lastUserEditedValue: l2 } = this._getStateForCurrentNamespace(), i2 = this._getValueForExample(e2);
      if ("__MODIFIED__VALUE__" === e2) return a2(stringifyUnlessList(l2)), this._setStateForCurrentNamespace({ isModifiedValueSelected: true });
      "function" == typeof n && n(e2, { isSyntheticChange: t2 }, ...r2), this._setStateForCurrentNamespace({ lastDownstreamValue: i2, isModifiedValueSelected: t2 && s2 || !!o4 && o4 !== i2 }), t2 || "function" == typeof a2 && a2(stringifyUnlessList(i2));
    });
    const t2 = this._getCurrentExampleValue();
    this.state = { [e2.currentNamespace]: (0, Qe.Map)({ lastUserEditedValue: this.props.currentUserInputValue, lastDownstreamValue: t2, isModifiedValueSelected: this.props.userHasEditedBody || this.props.currentUserInputValue !== t2 }) };
  }
  componentWillUnmount() {
    this.props.setRetainRequestBodyValueFlag(false);
  }
  UNSAFE_componentWillReceiveProps(e2) {
    const { currentUserInputValue: t2, examples: r2, onSelect: n, userHasEditedBody: a2 } = e2, { lastUserEditedValue: o4, lastDownstreamValue: s2 } = this._getStateForCurrentNamespace(), l2 = this._getValueForExample(e2.currentKey, e2), i2 = r2.filter((e3) => e3.get("value") === t2 || stringify(e3.get("value")) === t2);
    if (i2.size) {
      let t3;
      t3 = i2.has(e2.currentKey) ? e2.currentKey : i2.keySeq().first(), n(t3, { isSyntheticChange: true });
    } else t2 !== this.props.currentUserInputValue && t2 !== o4 && t2 !== s2 && (this.props.setRetainRequestBodyValueFlag(true), this._setStateForNamespace(e2.currentNamespace, { lastUserEditedValue: e2.currentUserInputValue, isModifiedValueSelected: a2 || t2 !== l2 }));
  }
  render() {
    const { currentUserInputValue: e2, examples: t2, currentKey: r2, getComponent: n, userHasEditedBody: a2 } = this.props, { lastDownstreamValue: o4, lastUserEditedValue: s2, isModifiedValueSelected: l2 } = this._getStateForCurrentNamespace(), i2 = n("ExamplesSelect");
    return Xe.default.createElement(i2, { examples: t2, currentExampleKey: r2, onSelect: this._onExamplesSelect, isModifiedValueAvailable: !!s2 && s2 !== o4, isValueModified: void 0 !== e2 && l2 && e2 !== this._getCurrentExampleValue() || a2 });
  }
};
__publicField(ExamplesSelectValueRetainer, "defaultProps", { userHasEditedBody: false, examples: (0, Qe.Map)({}), currentNamespace: "__DEFAULT__NAMESPACE__", setRetainRequestBodyValueFlag: () => {
}, onSelect: (...e2) => console.log("ExamplesSelectValueRetainer: no `onSelect` function was provided", ...e2), updateValue: (...e2) => console.log("ExamplesSelectValueRetainer: no `updateValue` function was provided", ...e2) });
function oauth2_authorize_authorize({ auth: e2, authActions: t2, errActions: r2, configs: n, authConfigs: a2 = {}, currentServer: o4 }) {
  let { schema: s2, scopes: l2, name: i2, clientId: c2 } = e2, u2 = s2.get("flow"), d2 = [];
  switch (u2) {
    case "password":
      return void t2.authorizePassword(e2);
    case "application":
    case "clientCredentials":
    case "client_credentials":
      return void t2.authorizeApplication(e2);
    case "accessCode":
    case "authorizationCode":
    case "authorization_code":
      d2.push("response_type=code");
      break;
    case "implicit":
      d2.push("response_type=token");
  }
  "string" == typeof c2 && d2.push("client_id=" + encodeURIComponent(c2));
  let p2 = n.oauth2RedirectUrl;
  if (void 0 === p2) return void r2.newAuthErr({ authId: i2, source: "validation", level: "error", message: "oauth2RedirectUrl configuration is not passed. Oauth2 authorization cannot be performed." });
  d2.push("redirect_uri=" + encodeURIComponent(p2));
  let m2 = [];
  if (Array.isArray(l2) ? m2 = l2 : Qe.default.List.isList(l2) && (m2 = l2.toArray()), m2.length > 0) {
    let e3 = a2.scopeSeparator || " ";
    d2.push("scope=" + encodeURIComponent(m2.join(e3)));
  }
  let f2 = btoa3(/* @__PURE__ */ new Date());
  if (d2.push("state=" + encodeURIComponent(f2)), void 0 !== a2.realm && d2.push("realm=" + encodeURIComponent(a2.realm)), ("authorizationCode" === u2 || "authorization_code" === u2 || "accessCode" === u2) && a2.usePkceWithAuthorizationCodeGrant) {
    const t3 = function generateCodeVerifier() {
      return b64toB64UrlEncoded(vt()(32).toString("base64"));
    }(), r3 = function createCodeChallenge(e3) {
      return b64toB64UrlEncoded(wt()("sha256").update(e3).digest("base64"));
    }(t3);
    d2.push("code_challenge=" + r3), d2.push("code_challenge_method=S256"), e2.codeVerifier = t3;
  }
  let { additionalQueryStringParams: h2 } = a2;
  for (let e3 in h2) void 0 !== h2[e3] && d2.push([e3, h2[e3]].map(encodeURIComponent).join("="));
  const g2 = s2.get("authorizationUrl");
  let y2;
  y2 = o4 ? (0, At.default)(sanitizeUrl2(g2), o4, true).toString() : sanitizeUrl2(g2);
  let S, _2 = [y2, d2.join("&")].join(-1 === g2.indexOf("?") ? "?" : "&");
  S = "implicit" === u2 ? t2.preAuthorizeImplicit : a2.useBasicAuthenticationWithAccessCodeGrant ? t2.authorizeAccessCodeWithBasicAuthentication : t2.authorizeAccessCodeWithFormParams, t2.authPopup(_2, { auth: e2, state: f2, redirectUrl: p2, callback: S, errCb: r2.newAuthErr });
}
var Oauth2 = class extends Xe.default.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "close", (e2) => {
      e2.preventDefault();
      let { authActions: t2 } = this.props;
      t2.showDefinitions(false);
    });
    __publicField(this, "authorize", () => {
      let { authActions: e2, errActions: t2, getConfigs: r2, authSelectors: n, oas3Selectors: a2 } = this.props, o4 = r2(), s2 = n.getConfigs();
      t2.clear({ authId: name, type: "auth", source: "auth" }), oauth2_authorize_authorize({ auth: this.state, currentServer: a2.serverEffectiveValue(a2.selectedServer()), authActions: e2, errActions: t2, configs: o4, authConfigs: s2 });
    });
    __publicField(this, "onScopeChange", (e2) => {
      let { target: t2 } = e2, { checked: r2 } = t2, n = t2.dataset.value;
      if (r2 && -1 === this.state.scopes.indexOf(n)) {
        let e3 = this.state.scopes.concat([n]);
        this.setState({ scopes: e3 });
      } else !r2 && this.state.scopes.indexOf(n) > -1 && this.setState({ scopes: this.state.scopes.filter((e3) => e3 !== n) });
    });
    __publicField(this, "onInputChange", (e2) => {
      let { target: { dataset: { name: t2 }, value: r2 } } = e2, n = { [t2]: r2 };
      this.setState(n);
    });
    __publicField(this, "selectScopes", (e2) => {
      e2.target.dataset.all ? this.setState({ scopes: Array.from((this.props.schema.get("allowedScopes") || this.props.schema.get("scopes")).keys()) }) : this.setState({ scopes: [] });
    });
    __publicField(this, "logout", (e2) => {
      e2.preventDefault();
      let { authActions: t2, errActions: r2, name: n } = this.props;
      r2.clear({ authId: n, type: "auth", source: "auth" }), t2.logoutWithPersistOption([n]);
    });
    let { name: r2, schema: n, authorized: a2, authSelectors: o4 } = this.props, s2 = a2 && a2.get(r2), l2 = o4.getConfigs() || {}, i2 = s2 && s2.get("username") || "", c2 = s2 && s2.get("clientId") || l2.clientId || "", u2 = s2 && s2.get("clientSecret") || l2.clientSecret || "", d2 = s2 && s2.get("passwordType") || "basic", p2 = s2 && s2.get("scopes") || l2.scopes || [];
    "string" == typeof p2 && (p2 = p2.split(l2.scopeSeparator || " ")), this.state = { appName: l2.appName, name: r2, schema: n, scopes: p2, clientId: c2, clientSecret: u2, username: i2, password: "", passwordType: d2 };
  }
  render() {
    let { schema: e2, getComponent: t2, authSelectors: r2, errSelectors: n, name: a2, specSelectors: o4 } = this.props;
    const s2 = t2("Input"), l2 = t2("Row"), i2 = t2("Col"), c2 = t2("Button"), u2 = t2("authError"), d2 = t2("JumpToPath", true), p2 = t2("Markdown", true), m2 = t2("InitializedInput"), { isOAS3: f2 } = o4;
    let h2 = f2() ? e2.get("openIdConnectUrl") : null;
    const g2 = "implicit", y2 = "password", S = f2() ? h2 ? "authorization_code" : "authorizationCode" : "accessCode", _2 = f2() ? h2 ? "client_credentials" : "clientCredentials" : "application";
    let v2 = !!(r2.getConfigs() || {}).usePkceWithAuthorizationCodeGrant, b = e2.get("flow"), w2 = b === S && v2 ? b + " with PKCE" : b, C2 = e2.get("allowedScopes") || e2.get("scopes"), x2 = !!r2.authorized().get(a2), O2 = n.allErrors().filter((e3) => e3.get("authId") === a2), k = !O2.filter((e3) => "validation" === e3.get("source")).size, N2 = e2.get("description");
    return Xe.default.createElement("div", null, Xe.default.createElement("h4", null, a2, " (OAuth2, ", w2, ") ", Xe.default.createElement(d2, { path: ["securityDefinitions", a2] })), this.state.appName ? Xe.default.createElement("h5", null, "Application: ", this.state.appName, " ") : null, N2 && Xe.default.createElement(p2, { source: e2.get("description") }), x2 && Xe.default.createElement("h6", null, "Authorized"), h2 && Xe.default.createElement("p", null, "OpenID Connect URL: ", Xe.default.createElement("code", null, h2)), (b === g2 || b === S) && Xe.default.createElement("p", null, "Authorization URL: ", Xe.default.createElement("code", null, e2.get("authorizationUrl"))), (b === y2 || b === S || b === _2) && Xe.default.createElement("p", null, "Token URL:", Xe.default.createElement("code", null, " ", e2.get("tokenUrl"))), Xe.default.createElement("p", { className: "flow" }, "Flow: ", Xe.default.createElement("code", null, w2)), b !== y2 ? null : Xe.default.createElement(l2, null, Xe.default.createElement(l2, null, Xe.default.createElement("label", { htmlFor: "oauth_username" }, "username:"), x2 ? Xe.default.createElement("code", null, " ", this.state.username, " ") : Xe.default.createElement(i2, { tablet: 10, desktop: 10 }, Xe.default.createElement("input", { id: "oauth_username", type: "text", "data-name": "username", onChange: this.onInputChange, autoFocus: true }))), Xe.default.createElement(l2, null, Xe.default.createElement("label", { htmlFor: "oauth_password" }, "password:"), x2 ? Xe.default.createElement("code", null, " ****** ") : Xe.default.createElement(i2, { tablet: 10, desktop: 10 }, Xe.default.createElement("input", { id: "oauth_password", type: "password", "data-name": "password", onChange: this.onInputChange }))), Xe.default.createElement(l2, null, Xe.default.createElement("label", { htmlFor: "password_type" }, "Client credentials location:"), x2 ? Xe.default.createElement("code", null, " ", this.state.passwordType, " ") : Xe.default.createElement(i2, { tablet: 10, desktop: 10 }, Xe.default.createElement("select", { id: "password_type", "data-name": "passwordType", onChange: this.onInputChange }, Xe.default.createElement("option", { value: "basic" }, "Authorization header"), Xe.default.createElement("option", { value: "request-body" }, "Request body"))))), (b === _2 || b === g2 || b === S || b === y2) && (!x2 || x2 && this.state.clientId) && Xe.default.createElement(l2, null, Xe.default.createElement("label", { htmlFor: `client_id_${b}` }, "client_id:"), x2 ? Xe.default.createElement("code", null, " ****** ") : Xe.default.createElement(i2, { tablet: 10, desktop: 10 }, Xe.default.createElement(m2, { id: `client_id_${b}`, type: "text", required: b === y2, initialValue: this.state.clientId, "data-name": "clientId", onChange: this.onInputChange }))), (b === _2 || b === S || b === y2) && Xe.default.createElement(l2, null, Xe.default.createElement("label", { htmlFor: `client_secret_${b}` }, "client_secret:"), x2 ? Xe.default.createElement("code", null, " ****** ") : Xe.default.createElement(i2, { tablet: 10, desktop: 10 }, Xe.default.createElement(m2, { id: `client_secret_${b}`, initialValue: this.state.clientSecret, type: "password", "data-name": "clientSecret", onChange: this.onInputChange }))), !x2 && C2 && C2.size ? Xe.default.createElement("div", { className: "scopes" }, Xe.default.createElement("h2", null, "Scopes:", Xe.default.createElement("a", { onClick: this.selectScopes, "data-all": true }, "select all"), Xe.default.createElement("a", { onClick: this.selectScopes }, "select none")), C2.map((e3, t3) => Xe.default.createElement(l2, { key: t3 }, Xe.default.createElement("div", { className: "checkbox" }, Xe.default.createElement(s2, { "data-value": t3, id: `${t3}-${b}-checkbox-${this.state.name}`, disabled: x2, checked: this.state.scopes.includes(t3), type: "checkbox", onChange: this.onScopeChange }), Xe.default.createElement("label", { htmlFor: `${t3}-${b}-checkbox-${this.state.name}` }, Xe.default.createElement("span", { className: "item" }), Xe.default.createElement("div", { className: "text" }, Xe.default.createElement("p", { className: "name" }, t3), Xe.default.createElement("p", { className: "description" }, e3)))))).toArray()) : null, O2.valueSeq().map((e3, t3) => Xe.default.createElement(u2, { error: e3, key: t3 })), Xe.default.createElement("div", { className: "auth-btn-wrapper" }, k && (x2 ? Xe.default.createElement(c2, { className: "btn modal-btn auth authorize", onClick: this.logout, "aria-label": "Remove authorization" }, "Logout") : Xe.default.createElement(c2, { className: "btn modal-btn auth authorize", onClick: this.authorize, "aria-label": "Apply given OAuth2 credentials" }, "Authorize")), Xe.default.createElement(c2, { className: "btn modal-btn auth btn-done", onClick: this.close }, "Close")));
  }
};
var Clear = class extends Xe.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onClick", () => {
      let { specActions: e2, path: t2, method: r2 } = this.props;
      e2.clearResponse(t2, r2), e2.clearRequest(t2, r2);
    });
  }
  render() {
    return Xe.default.createElement("button", { className: "btn btn-clear opblock-control__btn", onClick: this.onClick }, "Clear");
  }
};
var Headers3 = ({ headers: e2 }) => Xe.default.createElement("div", null, Xe.default.createElement("h5", null, "Response headers"), Xe.default.createElement("pre", { className: "microlight" }, e2));
var Duration = ({ duration: e2 }) => Xe.default.createElement("div", null, Xe.default.createElement("h5", null, "Request duration"), Xe.default.createElement("pre", { className: "microlight" }, e2, " ms"));
var LiveResponse = class extends Xe.default.Component {
  shouldComponentUpdate(e2) {
    return this.props.response !== e2.response || this.props.path !== e2.path || this.props.method !== e2.method || this.props.displayRequestDuration !== e2.displayRequestDuration;
  }
  render() {
    const { response: e2, getComponent: t2, getConfigs: r2, displayRequestDuration: n, specSelectors: a2, path: o4, method: s2 } = this.props, { showMutatedRequest: l2, requestSnippetsEnabled: i2 } = r2(), c2 = l2 ? a2.mutatedRequestFor(o4, s2) : a2.requestFor(o4, s2), u2 = e2.get("status"), d2 = c2.get("url"), p2 = e2.get("headers").toJS(), m2 = e2.get("notDocumented"), f2 = e2.get("error"), h2 = e2.get("text"), g2 = e2.get("duration"), y2 = Object.keys(p2), S = p2["content-type"] || p2["Content-Type"], _2 = t2("responseBody"), v2 = y2.map((e3) => {
      var t3 = Array.isArray(p2[e3]) ? p2[e3].join() : p2[e3];
      return Xe.default.createElement("span", { className: "headerline", key: e3 }, " ", e3, ": ", t3, " ");
    }), b = 0 !== v2.length, w2 = t2("Markdown", true), C2 = t2("RequestSnippets", true), x2 = t2("curl", true);
    return Xe.default.createElement("div", null, c2 && i2 ? Xe.default.createElement(C2, { request: c2 }) : Xe.default.createElement(x2, { request: c2 }), d2 && Xe.default.createElement("div", null, Xe.default.createElement("div", { className: "request-url" }, Xe.default.createElement("h4", null, "Request URL"), Xe.default.createElement("pre", { className: "microlight" }, d2))), Xe.default.createElement("h4", null, "Server response"), Xe.default.createElement("table", { className: "responses-table live-responses-table" }, Xe.default.createElement("thead", null, Xe.default.createElement("tr", { className: "responses-header" }, Xe.default.createElement("td", { className: "col_header response-col_status" }, "Code"), Xe.default.createElement("td", { className: "col_header response-col_description" }, "Details"))), Xe.default.createElement("tbody", null, Xe.default.createElement("tr", { className: "response" }, Xe.default.createElement("td", { className: "response-col_status" }, u2, m2 ? Xe.default.createElement("div", { className: "response-undocumented" }, Xe.default.createElement("i", null, " Undocumented ")) : null), Xe.default.createElement("td", { className: "response-col_description" }, f2 ? Xe.default.createElement(w2, { source: `${"" !== e2.get("name") ? `${e2.get("name")}: ` : ""}${e2.get("message")}` }) : null, h2 ? Xe.default.createElement(_2, { content: h2, contentType: S, url: d2, headers: p2, getConfigs: r2, getComponent: t2 }) : null, b ? Xe.default.createElement(Headers3, { headers: v2 }) : null, n && g2 ? Xe.default.createElement(Duration, { duration: g2 }) : null)))));
  }
};
var OnlineValidatorBadge = class extends Xe.default.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "getDefinitionUrl", () => {
      let { specSelectors: e2 } = this.props;
      return new At.default(e2.url(), dt.location).toString();
    });
    let { getConfigs: r2 } = e2, { validatorUrl: n } = r2();
    this.state = { url: this.getDefinitionUrl(), validatorUrl: void 0 === n ? "https://validator.swagger.io/validator" : n };
  }
  UNSAFE_componentWillReceiveProps(e2) {
    let { getConfigs: t2 } = e2, { validatorUrl: r2 } = t2();
    this.setState({ url: this.getDefinitionUrl(), validatorUrl: void 0 === r2 ? "https://validator.swagger.io/validator" : r2 });
  }
  render() {
    let { getConfigs: e2 } = this.props, { spec: t2 } = e2(), r2 = sanitizeUrl2(this.state.validatorUrl);
    return "object" == typeof t2 && Object.keys(t2).length ? null : this.state.url && requiresValidationURL(this.state.validatorUrl) && requiresValidationURL(this.state.url) ? Xe.default.createElement("span", { className: "float-right" }, Xe.default.createElement("a", { target: "_blank", rel: "noopener noreferrer", href: `${r2}/debug?url=${encodeURIComponent(this.state.url)}` }, Xe.default.createElement(ValidatorImage, { src: `${r2}?url=${encodeURIComponent(this.state.url)}`, alt: "Online validator badge" }))) : null;
  }
};
var ValidatorImage = class extends Xe.default.Component {
  constructor(e2) {
    super(e2), this.state = { loaded: false, error: false };
  }
  componentDidMount() {
    const e2 = new Image();
    e2.onload = () => {
      this.setState({ loaded: true });
    }, e2.onerror = () => {
      this.setState({ error: true });
    }, e2.src = this.props.src;
  }
  UNSAFE_componentWillReceiveProps(e2) {
    if (e2.src !== this.props.src) {
      const t2 = new Image();
      t2.onload = () => {
        this.setState({ loaded: true });
      }, t2.onerror = () => {
        this.setState({ error: true });
      }, t2.src = e2.src;
    }
  }
  render() {
    return this.state.error ? Xe.default.createElement("img", { alt: "Error" }) : this.state.loaded ? Xe.default.createElement("img", { src: this.props.src, alt: this.props.alt }) : null;
  }
};
var Operations = class extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "renderOperationTag", (e2, t2) => {
      const { specSelectors: r2, getComponent: n, oas3Selectors: a2, layoutSelectors: o4, layoutActions: s2, getConfigs: l2 } = this.props, i2 = r2.validOperationMethods(), c2 = n("OperationContainer", true), u2 = n("OperationTag"), d2 = e2.get("operations");
      return Xe.default.createElement(u2, { key: "operation-" + t2, tagObj: e2, tag: t2, oas3Selectors: a2, layoutSelectors: o4, layoutActions: s2, getConfigs: l2, getComponent: n, specUrl: r2.url() }, Xe.default.createElement("div", { className: "operation-tag-content" }, d2.map((e3) => {
        const r3 = e3.get("path"), n2 = e3.get("method"), a3 = Qe.default.List(["paths", r3, n2]);
        return -1 === i2.indexOf(n2) ? null : Xe.default.createElement(c2, { key: `${r3}-${n2}`, specPath: a3, op: e3, path: r3, method: n2, tag: t2 });
      }).toArray()));
    });
  }
  render() {
    let { specSelectors: e2 } = this.props;
    const t2 = e2.taggedOperations();
    return 0 === t2.size ? Xe.default.createElement("h3", null, " No operations defined in spec!") : Xe.default.createElement("div", null, t2.map(this.renderOperationTag).toArray(), t2.size < 1 ? Xe.default.createElement("h3", null, " No operations defined in spec! ") : null);
  }
};
function isAbsoluteUrl(e2) {
  return e2.match(/^(?:[a-z]+:)?\/\//i);
}
function buildBaseUrl(e2, t2) {
  return e2 ? isAbsoluteUrl(e2) ? function addProtocol(e3) {
    return e3.match(/^\/\//i) ? `${window.location.protocol}${e3}` : e3;
  }(e2) : new URL(e2, t2).href : t2;
}
function safeBuildUrl(e2, t2, { selectedServer: r2 = "" } = {}) {
  try {
    return function buildUrl(e3, t3, { selectedServer: r3 = "" } = {}) {
      if (!e3) return;
      if (isAbsoluteUrl(e3)) return e3;
      const n = buildBaseUrl(r3, t3);
      return isAbsoluteUrl(n) ? new URL(e3, n).href : new URL(e3, window.location.href).href;
    }(e2, t2, { selectedServer: r2 });
  } catch {
    return;
  }
}
var OperationTag = class extends Xe.default.Component {
  render() {
    const { tagObj: e2, tag: t2, children: r2, oas3Selectors: n, layoutSelectors: a2, layoutActions: o4, getConfigs: s2, getComponent: l2, specUrl: i2 } = this.props;
    let { docExpansion: c2, deepLinking: u2 } = s2();
    const d2 = l2("Collapse"), p2 = l2("Markdown", true), m2 = l2("DeepLink"), f2 = l2("Link"), h2 = l2("ArrowUpIcon"), g2 = l2("ArrowDownIcon");
    let y2, S = e2.getIn(["tagDetails", "description"], null), _2 = e2.getIn(["tagDetails", "externalDocs", "description"]), v2 = e2.getIn(["tagDetails", "externalDocs", "url"]);
    y2 = isFunc(n) && isFunc(n.selectedServer) ? safeBuildUrl(v2, i2, { selectedServer: n.selectedServer() }) : v2;
    let b = ["operations-tag", t2], w2 = a2.isShown(b, "full" === c2 || "list" === c2);
    return Xe.default.createElement("div", { className: w2 ? "opblock-tag-section is-open" : "opblock-tag-section" }, Xe.default.createElement("h3", { onClick: () => o4.show(b, !w2), className: S ? "opblock-tag" : "opblock-tag no-desc", id: b.map((e3) => escapeDeepLinkPath(e3)).join("-"), "data-tag": t2, "data-is-open": w2 }, Xe.default.createElement(m2, { enabled: u2, isShown: w2, path: createDeepLinkPath(t2), text: t2 }), S ? Xe.default.createElement("small", null, Xe.default.createElement(p2, { source: S })) : Xe.default.createElement("small", null), y2 ? Xe.default.createElement("div", { className: "info__externaldocs" }, Xe.default.createElement("small", null, Xe.default.createElement(f2, { href: sanitizeUrl2(y2), onClick: (e3) => e3.stopPropagation(), target: "_blank" }, _2 || y2))) : null, Xe.default.createElement("button", { "aria-expanded": w2, className: "expand-operation", title: w2 ? "Collapse operation" : "Expand operation", onClick: () => o4.show(b, !w2) }, w2 ? Xe.default.createElement(h2, { className: "arrow" }) : Xe.default.createElement(g2, { className: "arrow" }))), Xe.default.createElement(d2, { isOpened: w2 }, r2));
  }
};
__publicField(OperationTag, "defaultProps", { tagObj: Qe.default.fromJS({}), tag: "" });
var Operation3 = class extends Xe.PureComponent {
  render() {
    let { specPath: e2, response: t2, request: r2, toggleShown: n, onTryoutClick: a2, onResetClick: o4, onCancelClick: s2, onExecute: l2, fn: i2, getComponent: c2, getConfigs: u2, specActions: d2, specSelectors: p2, authActions: m2, authSelectors: f2, oas3Actions: h2, oas3Selectors: g2 } = this.props, y2 = this.props.operation, { deprecated: S, isShown: _2, path: v2, method: b, op: w2, tag: C2, operationId: x2, allowTryItOut: O2, displayRequestDuration: k, tryItOutEnabled: N2, executeInProgress: A2 } = y2.toJS(), { description: I, externalDocs: R2, schemes: T3 } = w2;
    const B2 = R2 ? safeBuildUrl(R2.url, p2.url(), { selectedServer: g2.selectedServer() }) : "";
    let j2 = y2.getIn(["op"]), P2 = j2.get("responses"), M2 = function getList(e3, t3) {
      if (!Qe.default.Iterable.isIterable(e3)) return Qe.default.List();
      let r3 = e3.getIn(Array.isArray(t3) ? t3 : [t3]);
      return Qe.default.List.isList(r3) ? r3 : Qe.default.List();
    }(j2, ["parameters"]), q2 = p2.operationScheme(v2, b), L2 = ["operations", C2, x2], D = getExtensions(j2);
    const U = c2("responses"), $ = c2("parameters"), J = c2("execute"), V = c2("clear"), K = c2("Collapse"), z = c2("Markdown", true), F2 = c2("schemes"), W = c2("OperationServers"), H2 = c2("OperationExt"), G = c2("OperationSummary"), X2 = c2("Link"), { showExtensions: Y2 } = u2();
    if (P2 && t2 && t2.size > 0) {
      let e3 = !P2.get(String(t2.get("status"))) && !P2.get("default");
      t2 = t2.set("notDocumented", e3);
    }
    let Q = [v2, b];
    const Z = p2.validationErrors([v2, b]);
    return Xe.default.createElement("div", { className: S ? "opblock opblock-deprecated" : _2 ? `opblock opblock-${b} is-open` : `opblock opblock-${b}`, id: escapeDeepLinkPath(L2.join("-")) }, Xe.default.createElement(G, { operationProps: y2, isShown: _2, toggleShown: n, getComponent: c2, authActions: m2, authSelectors: f2, specPath: e2 }), Xe.default.createElement(K, { isOpened: _2 }, Xe.default.createElement("div", { className: "opblock-body" }, j2 && j2.size || null === j2 ? null : Xe.default.createElement(rolling_load, { height: "32px", width: "32px", className: "opblock-loading-animation" }), S && Xe.default.createElement("h4", { className: "opblock-title_normal" }, " Warning: Deprecated"), I && Xe.default.createElement("div", { className: "opblock-description-wrapper" }, Xe.default.createElement("div", { className: "opblock-description" }, Xe.default.createElement(z, { source: I }))), B2 ? Xe.default.createElement("div", { className: "opblock-external-docs-wrapper" }, Xe.default.createElement("h4", { className: "opblock-title_normal" }, "Find more details"), Xe.default.createElement("div", { className: "opblock-external-docs" }, R2.description && Xe.default.createElement("span", { className: "opblock-external-docs__description" }, Xe.default.createElement(z, { source: R2.description })), Xe.default.createElement(X2, { target: "_blank", className: "opblock-external-docs__link", href: sanitizeUrl2(B2) }, B2))) : null, j2 && j2.size ? Xe.default.createElement($, { parameters: M2, specPath: e2.push("parameters"), operation: j2, onChangeKey: Q, onTryoutClick: a2, onResetClick: o4, onCancelClick: s2, tryItOutEnabled: N2, allowTryItOut: O2, fn: i2, getComponent: c2, specActions: d2, specSelectors: p2, pathMethod: [v2, b], getConfigs: u2, oas3Actions: h2, oas3Selectors: g2 }) : null, N2 ? Xe.default.createElement(W, { getComponent: c2, path: v2, method: b, operationServers: j2.get("servers"), pathServers: p2.paths().getIn([v2, "servers"]), getSelectedServer: g2.selectedServer, setSelectedServer: h2.setSelectedServer, setServerVariableValue: h2.setServerVariableValue, getServerVariable: g2.serverVariableValue, getEffectiveServerValue: g2.serverEffectiveValue }) : null, N2 && O2 && T3 && T3.size ? Xe.default.createElement("div", { className: "opblock-schemes" }, Xe.default.createElement(F2, { schemes: T3, path: v2, method: b, specActions: d2, currentScheme: q2 })) : null, !N2 || !O2 || Z.length <= 0 ? null : Xe.default.createElement("div", { className: "validation-errors errors-wrapper" }, "Please correct the following validation errors and try again.", Xe.default.createElement("ul", null, Z.map((e3, t3) => Xe.default.createElement("li", { key: t3 }, " ", e3, " ")))), Xe.default.createElement("div", { className: N2 && t2 && O2 ? "btn-group" : "execute-wrapper" }, N2 && O2 ? Xe.default.createElement(J, { operation: j2, specActions: d2, specSelectors: p2, oas3Selectors: g2, oas3Actions: h2, path: v2, method: b, onExecute: l2, disabled: A2 }) : null, N2 && t2 && O2 ? Xe.default.createElement(V, { specActions: d2, path: v2, method: b }) : null), A2 ? Xe.default.createElement("div", { className: "loading-container" }, Xe.default.createElement("div", { className: "loading" })) : null, P2 ? Xe.default.createElement(U, { responses: P2, request: r2, tryItOutResponse: t2, getComponent: c2, getConfigs: u2, specSelectors: p2, oas3Actions: h2, oas3Selectors: g2, specActions: d2, produces: p2.producesOptionsFor([v2, b]), producesValue: p2.currentProducesFor([v2, b]), specPath: e2.push("responses"), path: v2, method: b, displayRequestDuration: k, fn: i2 }) : null, Y2 && D.size ? Xe.default.createElement(H2, { extensions: D, getComponent: c2 }) : null)));
  }
};
__publicField(Operation3, "defaultProps", { operation: null, response: null, request: null, specPath: (0, Qe.List)(), summary: "" });
var OperationContainer = class extends Xe.PureComponent {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "toggleShown", () => {
      let { layoutActions: e2, tag: t2, operationId: r2, isShown: n } = this.props;
      const a2 = this.getResolvedSubtree();
      n || void 0 !== a2 || this.requestResolvedSubtree(), e2.show(["operations", t2, r2], !n);
    });
    __publicField(this, "onCancelClick", () => {
      this.setState({ tryItOutEnabled: !this.state.tryItOutEnabled });
    });
    __publicField(this, "onTryoutClick", () => {
      this.setState({ tryItOutEnabled: !this.state.tryItOutEnabled });
    });
    __publicField(this, "onResetClick", (e2) => {
      const t2 = this.props.oas3Selectors.selectDefaultRequestBodyValue(...e2);
      this.props.oas3Actions.setRequestBodyValue({ value: t2, pathMethod: e2 });
    });
    __publicField(this, "onExecute", () => {
      this.setState({ executeInProgress: true });
    });
    __publicField(this, "getResolvedSubtree", () => {
      const { specSelectors: e2, path: t2, method: r2, specPath: n } = this.props;
      return n ? e2.specResolvedSubtree(n.toJS()) : e2.specResolvedSubtree(["paths", t2, r2]);
    });
    __publicField(this, "requestResolvedSubtree", () => {
      const { specActions: e2, path: t2, method: r2, specPath: n } = this.props;
      return n ? e2.requestResolvedSubtree(n.toJS()) : e2.requestResolvedSubtree(["paths", t2, r2]);
    });
    const { tryItOutEnabled: r2 } = e2.getConfigs();
    this.state = { tryItOutEnabled: r2, executeInProgress: false };
  }
  mapStateToProps(e2, t2) {
    const { op: r2, layoutSelectors: n, getConfigs: a2 } = t2, { docExpansion: o4, deepLinking: s2, displayOperationId: l2, displayRequestDuration: i2, supportedSubmitMethods: c2 } = a2(), u2 = n.showSummary(), d2 = r2.getIn(["operation", "__originalOperationId"]) || r2.getIn(["operation", "operationId"]) || (0, ta.opId)(r2.get("operation"), t2.path, t2.method) || r2.get("id"), p2 = ["operations", t2.tag, d2], m2 = c2.indexOf(t2.method) >= 0 && (void 0 === t2.allowTryItOut ? t2.specSelectors.allowTryItOutFor(t2.path, t2.method) : t2.allowTryItOut), f2 = r2.getIn(["operation", "security"]) || t2.specSelectors.security();
    return { operationId: d2, isDeepLinkingEnabled: s2, showSummary: u2, displayOperationId: l2, displayRequestDuration: i2, allowTryItOut: m2, security: f2, isAuthorized: t2.authSelectors.isAuthorized(f2), isShown: n.isShown(p2, "full" === o4), jumpToKey: `paths.${t2.path}.${t2.method}`, response: t2.specSelectors.responseFor(t2.path, t2.method), request: t2.specSelectors.requestFor(t2.path, t2.method) };
  }
  componentDidMount() {
    const { isShown: e2 } = this.props, t2 = this.getResolvedSubtree();
    e2 && void 0 === t2 && this.requestResolvedSubtree();
  }
  UNSAFE_componentWillReceiveProps(e2) {
    const { response: t2, isShown: r2 } = e2, n = this.getResolvedSubtree();
    t2 !== this.props.response && this.setState({ executeInProgress: false }), r2 && void 0 === n && this.requestResolvedSubtree();
  }
  render() {
    let { op: e2, tag: t2, path: r2, method: n, security: a2, isAuthorized: o4, operationId: s2, showSummary: l2, isShown: i2, jumpToKey: c2, allowTryItOut: u2, response: d2, request: p2, displayOperationId: m2, displayRequestDuration: f2, isDeepLinkingEnabled: h2, specPath: g2, specSelectors: y2, specActions: S, getComponent: _2, getConfigs: v2, layoutSelectors: b, layoutActions: w2, authActions: C2, authSelectors: x2, oas3Actions: O2, oas3Selectors: k, fn: N2 } = this.props;
    const A2 = _2("operation"), I = this.getResolvedSubtree() || (0, Qe.Map)(), R2 = (0, Qe.fromJS)({ op: I, tag: t2, path: r2, summary: e2.getIn(["operation", "summary"]) || "", deprecated: I.get("deprecated") || e2.getIn(["operation", "deprecated"]) || false, method: n, security: a2, isAuthorized: o4, operationId: s2, originalOperationId: I.getIn(["operation", "__originalOperationId"]), showSummary: l2, isShown: i2, jumpToKey: c2, allowTryItOut: u2, request: p2, displayOperationId: m2, displayRequestDuration: f2, isDeepLinkingEnabled: h2, executeInProgress: this.state.executeInProgress, tryItOutEnabled: this.state.tryItOutEnabled });
    return Xe.default.createElement(A2, { operation: R2, response: d2, request: p2, isShown: i2, toggleShown: this.toggleShown, onTryoutClick: this.onTryoutClick, onResetClick: this.onResetClick, onCancelClick: this.onCancelClick, onExecute: this.onExecute, specPath: g2, specActions: S, specSelectors: y2, oas3Actions: O2, oas3Selectors: k, layoutActions: w2, layoutSelectors: b, authActions: C2, authSelectors: x2, getComponent: _2, getConfigs: v2, fn: N2 });
  }
};
__publicField(OperationContainer, "defaultProps", { showSummary: true, response: null, allowTryItOut: true, displayOperationId: false, displayRequestDuration: false });
var ka = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return fe.default;
} });
var OperationSummary = class extends Xe.PureComponent {
  render() {
    let { isShown: e2, toggleShown: t2, getComponent: r2, authActions: n, authSelectors: a2, operationProps: o4, specPath: s2 } = this.props, { summary: l2, isAuthorized: i2, method: c2, op: u2, showSummary: d2, path: p2, operationId: m2, originalOperationId: f2, displayOperationId: h2 } = o4.toJS(), { summary: g2 } = u2, y2 = o4.get("security");
    const S = r2("authorizeOperationBtn", true), _2 = r2("OperationSummaryMethod"), v2 = r2("OperationSummaryPath"), b = r2("JumpToPath", true), w2 = r2("CopyToClipboardBtn", true), C2 = r2("ArrowUpIcon"), x2 = r2("ArrowDownIcon"), O2 = y2 && !!y2.count(), k = O2 && 1 === y2.size && y2.first().isEmpty(), N2 = !O2 || k;
    return Xe.default.createElement("div", { className: `opblock-summary opblock-summary-${c2}` }, Xe.default.createElement("button", { "aria-expanded": e2, className: "opblock-summary-control", onClick: t2 }, Xe.default.createElement(_2, { method: c2 }), Xe.default.createElement("div", { className: "opblock-summary-path-description-wrapper" }, Xe.default.createElement(v2, { getComponent: r2, operationProps: o4, specPath: s2 }), d2 ? Xe.default.createElement("div", { className: "opblock-summary-description" }, (0, ka.default)(g2 || l2)) : null), h2 && (f2 || m2) ? Xe.default.createElement("span", { className: "opblock-summary-operation-id" }, f2 || m2) : null), Xe.default.createElement(w2, { textToCopy: `${s2.get(1)}` }), N2 ? null : Xe.default.createElement(S, { isAuthorized: i2, onClick: () => {
      const e3 = a2.definitionsForRequirements(y2);
      n.showDefinitions(e3);
    } }), Xe.default.createElement(b, { path: s2 }), Xe.default.createElement("button", { "aria-label": `${c2} ${p2.replace(/\//g, "/")}`, className: "opblock-control-arrow", "aria-expanded": e2, tabIndex: "-1", onClick: t2 }, e2 ? Xe.default.createElement(C2, { className: "arrow" }) : Xe.default.createElement(x2, { className: "arrow" })));
  }
};
__publicField(OperationSummary, "defaultProps", { operationProps: null, specPath: (0, Qe.List)(), summary: "" });
var OperationSummaryMethod = class extends Xe.PureComponent {
  render() {
    let { method: e2 } = this.props;
    return Xe.default.createElement("span", { className: "opblock-summary-method" }, e2.toUpperCase());
  }
};
__publicField(OperationSummaryMethod, "defaultProps", { operationProps: null });
var OperationSummaryPath = class extends Xe.PureComponent {
  render() {
    let { getComponent: e2, operationProps: t2 } = this.props, { deprecated: r2, isShown: n, path: a2, tag: o4, operationId: s2, isDeepLinkingEnabled: l2 } = t2.toJS();
    const i2 = a2.split(/(?=\/)/g);
    for (let e3 = 1; e3 < i2.length; e3 += 2) i2.splice(e3, 0, Xe.default.createElement("wbr", { key: e3 }));
    const c2 = e2("DeepLink");
    return Xe.default.createElement("span", { className: r2 ? "opblock-summary-path__deprecated" : "opblock-summary-path", "data-path": a2 }, Xe.default.createElement(c2, { enabled: l2, isShown: n, path: createDeepLinkPath(`${o4}/${s2}`), text: i2 }));
  }
};
var operation_extensions = ({ extensions: e2, getComponent: t2 }) => {
  let r2 = t2("OperationExtRow");
  return Xe.default.createElement("div", { className: "opblock-section" }, Xe.default.createElement("div", { className: "opblock-section-header" }, Xe.default.createElement("h4", null, "Extensions")), Xe.default.createElement("div", { className: "table-container" }, Xe.default.createElement("table", null, Xe.default.createElement("thead", null, Xe.default.createElement("tr", null, Xe.default.createElement("td", { className: "col_header" }, "Field"), Xe.default.createElement("td", { className: "col_header" }, "Value"))), Xe.default.createElement("tbody", null, e2.entrySeq().map(([e3, t3]) => Xe.default.createElement(r2, { key: `${e3}-${t3}`, xKey: e3, xVal: t3 }))))));
};
var operation_extension_row = ({ xKey: e2, xVal: t2 }) => {
  const r2 = t2 ? t2.toJS ? t2.toJS() : t2 : null;
  return Xe.default.createElement("tr", null, Xe.default.createElement("td", null, e2), Xe.default.createElement("td", null, JSON.stringify(r2)));
};
function createHtmlReadyId(e2, t2 = "_") {
  return e2.replace(/[^\w-]/g, t2);
}
var _Responses = class _Responses extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onChangeProducesWrapper", (e2) => this.props.specActions.changeProducesValue([this.props.path, this.props.method], e2));
    __publicField(this, "onResponseContentTypeChange", ({ controlsAcceptHeader: e2, value: t2 }) => {
      const { oas3Actions: r2, path: n, method: a2 } = this.props;
      e2 && r2.setResponseContentType({ value: t2, path: n, method: a2 });
    });
  }
  render() {
    let { responses: e2, tryItOutResponse: t2, getComponent: r2, getConfigs: n, specSelectors: a2, fn: o4, producesValue: s2, displayRequestDuration: l2, specPath: i2, path: c2, method: u2, oas3Selectors: d2, oas3Actions: p2 } = this.props, m2 = function defaultStatusCode(e3) {
      let t3 = e3.keySeq();
      return t3.contains(Ot) ? Ot : t3.filter((e4) => "2" === (e4 + "")[0]).sort().first();
    }(e2);
    const f2 = r2("contentType"), h2 = r2("liveResponse"), g2 = r2("response");
    let y2 = this.props.produces && this.props.produces.size ? this.props.produces : _Responses.defaultProps.produces;
    const S = a2.isOAS3() ? function getAcceptControllingResponse(e3) {
      if (!Qe.default.OrderedMap.isOrderedMap(e3)) return null;
      if (!e3.size) return null;
      const t3 = e3.find((e4, t4) => t4.startsWith("2") && Object.keys(e4.get("content") || {}).length > 0), r3 = e3.get("default") || Qe.default.OrderedMap(), n2 = (r3.get("content") || Qe.default.OrderedMap()).keySeq().toJS().length ? r3 : null;
      return t3 || n2;
    }(e2) : null, _2 = createHtmlReadyId(`${u2}${c2}_responses`), v2 = `${_2}_select`;
    return Xe.default.createElement("div", { className: "responses-wrapper" }, Xe.default.createElement("div", { className: "opblock-section-header" }, Xe.default.createElement("h4", null, "Responses"), a2.isOAS3() ? null : Xe.default.createElement("label", { htmlFor: v2 }, Xe.default.createElement("span", null, "Response content type"), Xe.default.createElement(f2, { value: s2, ariaControls: _2, ariaLabel: "Response content type", className: "execute-content-type", contentTypes: y2, controlId: v2, onChange: this.onChangeProducesWrapper }))), Xe.default.createElement("div", { className: "responses-inner" }, t2 ? Xe.default.createElement("div", null, Xe.default.createElement(h2, { response: t2, getComponent: r2, getConfigs: n, specSelectors: a2, path: this.props.path, method: this.props.method, displayRequestDuration: l2 }), Xe.default.createElement("h4", null, "Responses")) : null, Xe.default.createElement("table", { "aria-live": "polite", className: "responses-table", id: _2, role: "region" }, Xe.default.createElement("thead", null, Xe.default.createElement("tr", { className: "responses-header" }, Xe.default.createElement("td", { className: "col_header response-col_status" }, "Code"), Xe.default.createElement("td", { className: "col_header response-col_description" }, "Description"), a2.isOAS3() ? Xe.default.createElement("td", { className: "col col_header response-col_links" }, "Links") : null)), Xe.default.createElement("tbody", null, e2.entrySeq().map(([e3, l3]) => {
      let f3 = t2 && t2.get("status") == e3 ? "response_current" : "";
      return Xe.default.createElement(g2, { key: e3, path: c2, method: u2, specPath: i2.push(e3), isDefault: m2 === e3, fn: o4, className: f3, code: e3, response: l3, specSelectors: a2, controlsAcceptHeader: l3 === S, onContentTypeChange: this.onResponseContentTypeChange, contentType: s2, getConfigs: n, activeExamplesKey: d2.activeExamplesMember(c2, u2, "responses", e3), oas3Actions: p2, getComponent: r2 });
    }).toArray()))));
  }
};
__publicField(_Responses, "defaultProps", { tryItOutResponse: null, produces: (0, Qe.fromJS)(["application/json"]), displayRequestDuration: false });
var Responses3 = _Responses;
function getKnownSyntaxHighlighterLanguage(e2) {
  return function canJsonParse(e3) {
    try {
      return !!JSON.parse(e3);
    } catch (e4) {
      return null;
    }
  }(e2) ? "json" : null;
}
var Response5 = class extends Xe.default.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "_onContentTypeChange", (e2) => {
      const { onContentTypeChange: t2, controlsAcceptHeader: r2 } = this.props;
      this.setState({ responseContentType: e2 }), t2({ value: e2, controlsAcceptHeader: r2 });
    });
    __publicField(this, "getTargetExamplesKey", () => {
      const { response: e2, contentType: t2, activeExamplesKey: r2 } = this.props, n = this.state.responseContentType || t2, a2 = e2.getIn(["content", n], (0, Qe.Map)({})).get("examples", null).keySeq().first();
      return r2 || a2;
    });
    this.state = { responseContentType: "" };
  }
  render() {
    var _a6;
    let { path: e2, method: t2, code: r2, response: n, className: a2, specPath: o4, fn: s2, getComponent: l2, getConfigs: i2, specSelectors: c2, contentType: u2, controlsAcceptHeader: d2, oas3Actions: p2 } = this.props, { inferSchema: m2, getSampleSchema: f2 } = s2, h2 = c2.isOAS3();
    const { showExtensions: g2 } = i2();
    let y2 = g2 ? getExtensions(n) : null, S = n.get("headers"), _2 = n.get("links");
    const v2 = l2("ResponseExtension"), b = l2("headers"), w2 = l2("HighlightCode", true), C2 = l2("modelExample"), x2 = l2("Markdown", true), O2 = l2("operationLink"), k = l2("contentType"), N2 = l2("ExamplesSelect"), A2 = l2("Example");
    var I, R2;
    const T3 = this.state.responseContentType || u2, B2 = n.getIn(["content", T3], (0, Qe.Map)({})), j2 = B2.get("examples", null);
    if (h2) {
      const e3 = B2.get("schema");
      I = e3 ? m2(e3.toJS()) : null, R2 = e3 ? (0, Qe.List)(["content", this.state.responseContentType, "schema"]) : o4;
    } else I = n.get("schema"), R2 = n.has("schema") ? o4.push("schema") : o4;
    let P2, M2, q2 = false, L2 = { includeReadOnly: true };
    if (h2) if (M2 = (_a6 = B2.get("schema")) == null ? void 0 : _a6.toJS(), Qe.Map.isMap(j2) && !j2.isEmpty()) {
      const e3 = this.getTargetExamplesKey(), getMediaTypeExample = (e4) => e4.get("value");
      P2 = getMediaTypeExample(j2.get(e3, (0, Qe.Map)({}))), void 0 === P2 && (P2 = getMediaTypeExample(j2.values().next().value)), q2 = true;
    } else void 0 !== B2.get("example") && (P2 = B2.get("example"), q2 = true);
    else {
      M2 = I, L2 = { ...L2, includeWriteOnly: true };
      const e3 = n.getIn(["examples", T3]);
      e3 && (P2 = e3, q2 = true);
    }
    const D = ((e3, t3) => {
      if (null == e3) return null;
      const r3 = getKnownSyntaxHighlighterLanguage(e3) ? "json" : null;
      return Xe.default.createElement("div", null, Xe.default.createElement(t3, { className: "example", language: r3 }, stringify(e3)));
    })(f2(M2, T3, L2, q2 ? P2 : void 0), w2);
    return Xe.default.createElement("tr", { className: "response " + (a2 || ""), "data-code": r2 }, Xe.default.createElement("td", { className: "response-col_status" }, r2), Xe.default.createElement("td", { className: "response-col_description" }, Xe.default.createElement("div", { className: "response-col_description__inner" }, Xe.default.createElement(x2, { source: n.get("description") })), g2 && y2.size ? y2.entrySeq().map(([e3, t3]) => Xe.default.createElement(v2, { key: `${e3}-${t3}`, xKey: e3, xVal: t3 })) : null, h2 && n.get("content") ? Xe.default.createElement("section", { className: "response-controls" }, Xe.default.createElement("div", { className: (0, _r.default)("response-control-media-type", { "response-control-media-type--accept-controller": d2 }) }, Xe.default.createElement("small", { className: "response-control-media-type__title" }, "Media type"), Xe.default.createElement(k, { value: this.state.responseContentType, contentTypes: n.get("content") ? n.get("content").keySeq() : (0, Qe.Seq)(), onChange: this._onContentTypeChange, ariaLabel: "Media Type" }), d2 ? Xe.default.createElement("small", { className: "response-control-media-type__accept-message" }, "Controls ", Xe.default.createElement("code", null, "Accept"), " header.") : null), Qe.Map.isMap(j2) && !j2.isEmpty() ? Xe.default.createElement("div", { className: "response-control-examples" }, Xe.default.createElement("small", { className: "response-control-examples__title" }, "Examples"), Xe.default.createElement(N2, { examples: j2, currentExampleKey: this.getTargetExamplesKey(), onSelect: (n2) => p2.setActiveExamplesMember({ name: n2, pathMethod: [e2, t2], contextType: "responses", contextName: r2 }), showLabels: false })) : null) : null, D || I ? Xe.default.createElement(C2, { specPath: R2, getComponent: l2, getConfigs: i2, specSelectors: c2, schema: fromJSOrdered(I), example: D, includeReadOnly: true }) : null, h2 && j2 ? Xe.default.createElement(A2, { example: j2.get(this.getTargetExamplesKey(), (0, Qe.Map)({})), getComponent: l2, getConfigs: i2, omitValue: true }) : null, S ? Xe.default.createElement(b, { headers: S, getComponent: l2 }) : null), h2 ? Xe.default.createElement("td", { className: "response-col_links" }, _2 ? _2.toSeq().entrySeq().map(([e3, t3]) => Xe.default.createElement(O2, { key: e3, name: e3, link: t3, getComponent: l2 })) : Xe.default.createElement("i", null, "No links")) : null);
  }
};
__publicField(Response5, "defaultProps", { response: (0, Qe.fromJS)({}), onContentTypeChange: () => {
} });
var response_extension = ({ xKey: e2, xVal: t2 }) => Xe.default.createElement("div", { className: "response__extension" }, e2, ": ", String(t2));
var Na = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return he.default;
} });
var Aa = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return ge.default;
} });
var ResponseBody = class extends Xe.default.PureComponent {
  constructor() {
    super(...arguments);
    __publicField(this, "state", { parsedContent: null });
    __publicField(this, "updateParsedContent", (e2) => {
      const { content: t2 } = this.props;
      if (e2 !== t2) if (t2 && t2 instanceof Blob) {
        var r2 = new FileReader();
        r2.onload = () => {
          this.setState({ parsedContent: r2.result });
        }, r2.readAsText(t2);
      } else this.setState({ parsedContent: t2.toString() });
    });
  }
  componentDidMount() {
    this.updateParsedContent(null);
  }
  componentDidUpdate(e2) {
    this.updateParsedContent(e2.content);
  }
  render() {
    let { content: e2, contentType: t2, url: r2, headers: n = {}, getComponent: a2 } = this.props;
    const { parsedContent: o4 } = this.state, s2 = a2("HighlightCode", true), l2 = "response_" + (/* @__PURE__ */ new Date()).getTime();
    let i2, c2;
    if (r2 = r2 || "", (/^application\/octet-stream/i.test(t2) || n["Content-Disposition"] && /attachment/i.test(n["Content-Disposition"]) || n["content-disposition"] && /attachment/i.test(n["content-disposition"]) || n["Content-Description"] && /File Transfer/i.test(n["Content-Description"]) || n["content-description"] && /File Transfer/i.test(n["content-description"])) && (e2.size > 0 || e2.length > 0)) if ("Blob" in window) {
      let a3 = t2 || "text/html", o5 = e2 instanceof Blob ? e2 : new Blob([e2], { type: a3 }), s3 = window.URL.createObjectURL(o5), l3 = [a3, r2.substr(r2.lastIndexOf("/") + 1), s3].join(":"), i3 = n["content-disposition"] || n["Content-Disposition"];
      if (void 0 !== i3) {
        let e3 = function extractFileNameFromContentDispositionHeader(e4) {
          let t3;
          if ([/filename\*=[^']+'\w*'"([^"]+)";?/i, /filename\*=[^']+'\w*'([^;]+);?/i, /filename="([^;]*);?"/i, /filename=([^;]*);?/i].some((r3) => (t3 = r3.exec(e4), null !== t3)), null !== t3 && t3.length > 1) try {
            return decodeURIComponent(t3[1]);
          } catch (e5) {
            console.error(e5);
          }
          return null;
        }(i3);
        null !== e3 && (l3 = e3);
      }
      c2 = dt.navigator && dt.navigator.msSaveOrOpenBlob ? Xe.default.createElement("div", null, Xe.default.createElement("a", { href: s3, onClick: () => dt.navigator.msSaveOrOpenBlob(o5, l3) }, "Download file")) : Xe.default.createElement("div", null, Xe.default.createElement("a", { href: s3, download: l3 }, "Download file"));
    } else c2 = Xe.default.createElement("pre", { className: "microlight" }, "Download headers detected but your browser does not support downloading binary via XHR (Blob).");
    else if (/json/i.test(t2)) {
      let t3 = null;
      getKnownSyntaxHighlighterLanguage(e2) && (t3 = "json");
      try {
        i2 = JSON.stringify(JSON.parse(e2), null, "  ");
      } catch (t4) {
        i2 = "can't parse JSON.  Raw result:\n\n" + e2;
      }
      c2 = Xe.default.createElement(s2, { language: t3, downloadable: true, fileName: `${l2}.json`, canCopy: true }, i2);
    } else /xml/i.test(t2) ? (i2 = (0, Na.default)(e2, { textNodesOnSameLine: true, indentor: "  " }), c2 = Xe.default.createElement(s2, { downloadable: true, fileName: `${l2}.xml`, canCopy: true }, i2)) : c2 = "text/html" === (0, Aa.default)(t2) || /text\/plain/.test(t2) ? Xe.default.createElement(s2, { downloadable: true, fileName: `${l2}.html`, canCopy: true }, e2) : "text/csv" === (0, Aa.default)(t2) || /text\/csv/.test(t2) ? Xe.default.createElement(s2, { downloadable: true, fileName: `${l2}.csv`, canCopy: true }, e2) : /^image\//i.test(t2) ? t2.includes("svg") ? Xe.default.createElement("div", null, " ", e2, " ") : Xe.default.createElement("img", { src: window.URL.createObjectURL(e2) }) : /^audio\//i.test(t2) ? Xe.default.createElement("pre", { className: "microlight" }, Xe.default.createElement("audio", { controls: true, key: r2 }, Xe.default.createElement("source", { src: r2, type: t2 }))) : "string" == typeof e2 ? Xe.default.createElement(s2, { downloadable: true, fileName: `${l2}.txt`, canCopy: true }, e2) : e2.size > 0 ? o4 ? Xe.default.createElement("div", null, Xe.default.createElement("p", { className: "i" }, "Unrecognized response type; displaying content as text."), Xe.default.createElement(s2, { downloadable: true, fileName: `${l2}.txt`, canCopy: true }, o4)) : Xe.default.createElement("p", { className: "i" }, "Unrecognized response type; unable to display.") : null;
    return c2 ? Xe.default.createElement("div", null, Xe.default.createElement("h5", null, "Response body"), c2) : null;
  }
};
var Parameters = class extends Xe.Component {
  constructor(e2) {
    super(e2);
    __publicField(this, "onChange", (e2, t2, r2) => {
      let { specActions: { changeParamByIdentity: n }, onChangeKey: a2 } = this.props;
      n(a2, e2, t2, r2);
    });
    __publicField(this, "onChangeConsumesWrapper", (e2) => {
      let { specActions: { changeConsumesValue: t2 }, onChangeKey: r2 } = this.props;
      t2(r2, e2);
    });
    __publicField(this, "toggleTab", (e2) => "parameters" === e2 ? this.setState({ parametersVisible: true, callbackVisible: false }) : "callbacks" === e2 ? this.setState({ callbackVisible: true, parametersVisible: false }) : void 0);
    __publicField(this, "onChangeMediaType", ({ value: e2, pathMethod: t2 }) => {
      let { specActions: r2, oas3Selectors: n, oas3Actions: a2 } = this.props;
      const o4 = n.hasUserEditedBody(...t2), s2 = n.shouldRetainRequestBodyValue(...t2);
      a2.setRequestContentType({ value: e2, pathMethod: t2 }), a2.initRequestBodyValidateError({ pathMethod: t2 }), o4 || (s2 || a2.setRequestBodyValue({ value: void 0, pathMethod: t2 }), r2.clearResponse(...t2), r2.clearRequest(...t2), r2.clearValidateParams(t2));
    });
    this.state = { callbackVisible: false, parametersVisible: true };
  }
  render() {
    let { onTryoutClick: e2, onResetClick: t2, parameters: r2, allowTryItOut: n, tryItOutEnabled: a2, specPath: o4, fn: s2, getComponent: l2, getConfigs: i2, specSelectors: c2, specActions: u2, pathMethod: d2, oas3Actions: p2, oas3Selectors: m2, operation: f2 } = this.props;
    const h2 = l2("parameterRow"), g2 = l2("TryItOutButton"), y2 = l2("contentType"), S = l2("Callbacks", true), _2 = l2("RequestBody", true), v2 = a2 && n, b = c2.isOAS3(), w2 = `${createHtmlReadyId(`${d2[1]}${d2[0]}_requests`)}_select`, C2 = f2.get("requestBody"), x2 = Object.values(r2.reduce((e3, t3) => {
      const r3 = t3.get("in");
      return e3[r3] ?? (e3[r3] = []), e3[r3].push(t3), e3;
    }, {})).reduce((e3, t3) => e3.concat(t3), []);
    return Xe.default.createElement("div", { className: "opblock-section" }, Xe.default.createElement("div", { className: "opblock-section-header" }, b ? Xe.default.createElement("div", { className: "tab-header" }, Xe.default.createElement("div", { onClick: () => this.toggleTab("parameters"), className: `tab-item ${this.state.parametersVisible && "active"}` }, Xe.default.createElement("h4", { className: "opblock-title" }, Xe.default.createElement("span", null, "Parameters"))), f2.get("callbacks") ? Xe.default.createElement("div", { onClick: () => this.toggleTab("callbacks"), className: `tab-item ${this.state.callbackVisible && "active"}` }, Xe.default.createElement("h4", { className: "opblock-title" }, Xe.default.createElement("span", null, "Callbacks"))) : null) : Xe.default.createElement("div", { className: "tab-header" }, Xe.default.createElement("h4", { className: "opblock-title" }, "Parameters")), n ? Xe.default.createElement(g2, { isOAS3: c2.isOAS3(), hasUserEditedBody: m2.hasUserEditedBody(...d2), enabled: a2, onCancelClick: this.props.onCancelClick, onTryoutClick: e2, onResetClick: () => t2(d2) }) : null), this.state.parametersVisible ? Xe.default.createElement("div", { className: "parameters-container" }, x2.length ? Xe.default.createElement("div", { className: "table-container" }, Xe.default.createElement("table", { className: "parameters" }, Xe.default.createElement("thead", null, Xe.default.createElement("tr", null, Xe.default.createElement("th", { className: "col_header parameters-col_name" }, "Name"), Xe.default.createElement("th", { className: "col_header parameters-col_description" }, "Description"))), Xe.default.createElement("tbody", null, x2.map((e3, t3) => Xe.default.createElement(h2, { fn: s2, specPath: o4.push(t3.toString()), getComponent: l2, getConfigs: i2, rawParam: e3, param: c2.parameterWithMetaByIdentity(d2, e3), key: `${e3.get("in")}.${e3.get("name")}`, onChange: this.onChange, onChangeConsumes: this.onChangeConsumesWrapper, specSelectors: c2, specActions: u2, oas3Actions: p2, oas3Selectors: m2, pathMethod: d2, isExecute: v2 }))))) : Xe.default.createElement("div", { className: "opblock-description-wrapper" }, Xe.default.createElement("p", null, "No parameters"))) : null, this.state.callbackVisible ? Xe.default.createElement("div", { className: "callbacks-container opblock-description-wrapper" }, Xe.default.createElement(S, { callbacks: (0, Qe.Map)(f2.get("callbacks")), specPath: o4.slice(0, -1).push("callbacks") })) : null, b && C2 && this.state.parametersVisible && Xe.default.createElement("div", { className: "opblock-section opblock-section-request-body" }, Xe.default.createElement("div", { className: "opblock-section-header" }, Xe.default.createElement("h4", { className: `opblock-title parameter__name ${C2.get("required") && "required"}` }, "Request body"), Xe.default.createElement("label", { id: w2 }, Xe.default.createElement(y2, { value: m2.requestContentType(...d2), contentTypes: C2.get("content", (0, Qe.List)()).keySeq(), onChange: (e3) => {
      this.onChangeMediaType({ value: e3, pathMethod: d2 });
    }, className: "body-param-content-type", ariaLabel: "Request content type", controlId: w2 }))), Xe.default.createElement("div", { className: "opblock-description-wrapper" }, Xe.default.createElement(_2, { setRetainRequestBodyValueFlag: (e3) => p2.setRetainRequestBodyValueFlag({ value: e3, pathMethod: d2 }), userHasEditedBody: m2.hasUserEditedBody(...d2), specPath: o4.slice(0, -1).push("requestBody"), requestBody: C2, requestBodyValue: m2.requestBodyValue(...d2), requestBodyInclusionSetting: m2.requestBodyInclusionSetting(...d2), requestBodyErrors: m2.requestBodyErrors(...d2), isExecute: v2, getConfigs: i2, activeExamplesKey: m2.activeExamplesMember(...d2, "requestBody", "requestBody"), updateActiveExamplesKey: (e3) => {
      this.props.oas3Actions.setActiveExamplesMember({ name: e3, pathMethod: this.props.pathMethod, contextType: "requestBody", contextName: "requestBody" });
    }, onChange: (e3, t3) => {
      if (t3) {
        const r3 = m2.requestBodyValue(...d2), n2 = Qe.Map.isMap(r3) ? r3 : (0, Qe.Map)();
        return p2.setRequestBodyValue({ pathMethod: d2, value: n2.setIn(t3, e3) });
      }
      p2.setRequestBodyValue({ value: e3, pathMethod: d2 });
    }, onChangeIncludeEmpty: (e3, t3) => {
      p2.setRequestBodyInclusion({ pathMethod: d2, value: t3, name: e3 });
    }, contentType: m2.requestContentType(...d2) }))));
  }
};
__publicField(Parameters, "defaultProps", { onTryoutClick: Function.prototype, onCancelClick: Function.prototype, tryItOutEnabled: false, allowTryItOut: true, onChangeKey: [], specPath: [] });
var parameter_extension = ({ xKey: e2, xVal: t2 }) => Xe.default.createElement("div", { className: "parameter__extension" }, e2, ": ", String(t2));
var Ia = { onChange: () => {
}, isIncludedOptions: {} };
var ParameterIncludeEmpty = class extends Xe.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onCheckboxChange", (e2) => {
      const { onChange: t2 } = this.props;
      t2(e2.target.checked);
    });
  }
  componentDidMount() {
    const { isIncludedOptions: e2, onChange: t2 } = this.props, { shouldDispatchInit: r2, defaultValue: n } = e2;
    r2 && t2(n);
  }
  render() {
    let { isIncluded: e2, isDisabled: t2 } = this.props;
    return Xe.default.createElement("div", null, Xe.default.createElement("label", { htmlFor: "include_empty_value", className: (0, _r.default)("parameter__empty_value_toggle", { disabled: t2 }) }, Xe.default.createElement("input", { id: "include_empty_value", type: "checkbox", disabled: t2, checked: !t2 && e2, onChange: this.onCheckboxChange }), "Send empty value"));
  }
};
__publicField(ParameterIncludeEmpty, "defaultProps", Ia);
var ParameterRow = class extends Xe.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "onChangeWrapper", (e2, t2 = false) => {
      let r2, { onChange: n, rawParam: a2 } = this.props;
      return r2 = "" === e2 || e2 && 0 === e2.size ? null : e2, n(a2, r2, t2);
    });
    __publicField(this, "_onExampleSelect", (e2) => {
      this.props.oas3Actions.setActiveExamplesMember({ name: e2, pathMethod: this.props.pathMethod, contextType: "parameters", contextName: this.getParamKey() });
    });
    __publicField(this, "onChangeIncludeEmpty", (e2) => {
      let { specActions: t2, param: r2, pathMethod: n } = this.props;
      const a2 = r2.get("name"), o4 = r2.get("in");
      return t2.updateEmptyParamInclusion(n, a2, o4, e2);
    });
    __publicField(this, "setDefaultValue", () => {
      let { specSelectors: e2, pathMethod: t2, rawParam: r2, oas3Selectors: n, fn: a2 } = this.props;
      const o4 = e2.parameterWithMetaByIdentity(t2, r2) || (0, Qe.Map)();
      let { schema: s2 } = getParameterSchema(o4, { isOAS3: e2.isOAS3() });
      const l2 = o4.get("content", (0, Qe.Map)()).keySeq().first(), i2 = s2 ? a2.getSampleSchema(s2.toJS(), l2, { includeWriteOnly: true }) : null;
      if (o4 && void 0 === o4.get("value") && "body" !== o4.get("in")) {
        let r3;
        if (e2.isSwagger2()) r3 = void 0 !== o4.get("x-example") ? o4.get("x-example") : void 0 !== o4.getIn(["schema", "example"]) ? o4.getIn(["schema", "example"]) : s2 && s2.getIn(["default"]);
        else if (e2.isOAS3()) {
          s2 = this.composeJsonSchema(s2);
          const e3 = n.activeExamplesMember(...t2, "parameters", this.getParamKey());
          r3 = void 0 !== o4.getIn(["examples", e3, "value"]) ? o4.getIn(["examples", e3, "value"]) : void 0 !== o4.getIn(["content", l2, "example"]) ? o4.getIn(["content", l2, "example"]) : void 0 !== o4.get("example") ? o4.get("example") : void 0 !== (s2 && s2.get("example")) ? s2 && s2.get("example") : void 0 !== (s2 && s2.get("default")) ? s2 && s2.get("default") : o4.get("default");
        }
        void 0 === r3 || Qe.List.isList(r3) || (r3 = stringify(r3)), void 0 !== r3 ? this.onChangeWrapper(r3) : s2 && "object" === s2.get("type") && i2 && !o4.get("examples") && this.onChangeWrapper(Qe.List.isList(i2) ? i2 : stringify(i2));
      }
    });
    this.setDefaultValue();
  }
  UNSAFE_componentWillReceiveProps(e2) {
    let t2, { specSelectors: r2, pathMethod: n, rawParam: a2 } = e2, o4 = r2.isOAS3(), s2 = r2.parameterWithMetaByIdentity(n, a2) || new Qe.Map();
    if (s2 = s2.isEmpty() ? a2 : s2, o4) {
      let { schema: e3 } = getParameterSchema(s2, { isOAS3: o4 });
      t2 = e3 ? e3.get("enum") : void 0;
    } else t2 = s2 ? s2.get("enum") : void 0;
    let l2, i2 = s2 ? s2.get("value") : void 0;
    void 0 !== i2 ? l2 = i2 : a2.get("required") && t2 && t2.size && (l2 = t2.first()), void 0 !== l2 && l2 !== i2 && this.onChangeWrapper(function numberToString(e3) {
      return "number" == typeof e3 ? e3.toString() : e3;
    }(l2)), this.setDefaultValue();
  }
  getParamKey() {
    const { param: e2 } = this.props;
    return e2 ? `${e2.get("name")}-${e2.get("in")}` : null;
  }
  composeJsonSchema(e2) {
    var _a6, _b, _c, _d;
    const { fn: t2 } = this.props, r2 = (_b = (_a6 = e2.get("oneOf")) == null ? void 0 : _a6.get(0)) == null ? void 0 : _b.toJS(), n = (_d = (_c = e2.get("anyOf")) == null ? void 0 : _c.get(0)) == null ? void 0 : _d.toJS();
    return (0, Qe.fromJS)(t2.mergeJsonSchema(e2.toJS(), r2 ?? n ?? {}));
  }
  render() {
    let { param: e2, rawParam: t2, getComponent: r2, getConfigs: n, isExecute: a2, fn: o4, onChangeConsumes: s2, specSelectors: l2, pathMethod: i2, specPath: c2, oas3Selectors: u2 } = this.props, d2 = l2.isOAS3();
    const { showExtensions: p2, showCommonExtensions: m2 } = n();
    if (e2 || (e2 = t2), !t2) return null;
    const f2 = r2("JsonSchemaForm"), h2 = r2("ParamBody");
    let g2 = e2.get("in"), y2 = "body" !== g2 ? null : Xe.default.createElement(h2, { getComponent: r2, getConfigs: n, fn: o4, param: e2, consumes: l2.consumesOptionsFor(i2), consumesValue: l2.contentTypeValues(i2).get("requestContentType"), onChange: this.onChangeWrapper, onChangeConsumes: s2, isExecute: a2, specSelectors: l2, pathMethod: i2 });
    const S = r2("modelExample"), _2 = r2("Markdown", true), v2 = r2("ParameterExt"), b = r2("ParameterIncludeEmpty"), w2 = r2("ExamplesSelectValueRetainer"), C2 = r2("Example");
    let { schema: x2 } = getParameterSchema(e2, { isOAS3: d2 }), O2 = l2.parameterWithMetaByIdentity(i2, t2) || (0, Qe.Map)();
    d2 && (x2 = this.composeJsonSchema(x2));
    let k, N2, A2, I, R2 = x2 ? x2.get("format") : null, T3 = x2 ? x2.get("type") : null, B2 = x2 ? x2.getIn(["items", "type"]) : null, j2 = "formData" === g2, P2 = "FormData" in dt, M2 = e2.get("required"), q2 = O2 ? O2.get("value") : "", L2 = m2 ? getCommonExtensions(x2) : null, D = p2 ? getExtensions(e2) : null, U = false;
    return void 0 !== e2 && x2 && (k = x2.get("items")), void 0 !== k ? (N2 = k.get("enum"), A2 = k.get("default")) : x2 && (N2 = x2.get("enum")), N2 && N2.size && N2.size > 0 && (U = true), void 0 !== e2 && (x2 && (A2 = x2.get("default")), void 0 === A2 && (A2 = e2.get("default")), I = e2.get("example"), void 0 === I && (I = e2.get("x-example"))), Xe.default.createElement("tr", { "data-param-name": e2.get("name"), "data-param-in": e2.get("in") }, Xe.default.createElement("td", { className: "parameters-col_name" }, Xe.default.createElement("div", { className: M2 ? "parameter__name required" : "parameter__name" }, e2.get("name"), M2 ? Xe.default.createElement("span", null, "*") : null), Xe.default.createElement("div", { className: "parameter__type" }, T3, B2 && `[${B2}]`, R2 && Xe.default.createElement("span", { className: "prop-format" }, "($", R2, ")")), Xe.default.createElement("div", { className: "parameter__deprecated" }, d2 && e2.get("deprecated") ? "deprecated" : null), Xe.default.createElement("div", { className: "parameter__in" }, "(", e2.get("in"), ")")), Xe.default.createElement("td", { className: "parameters-col_description" }, e2.get("description") ? Xe.default.createElement(_2, { source: e2.get("description") }) : null, !y2 && a2 || !U ? null : Xe.default.createElement(_2, { className: "parameter__enum", source: "<i>Available values</i> : " + N2.map(function(e3) {
      return e3;
    }).toArray().map(String).join(", ") }), !y2 && a2 || void 0 === A2 ? null : Xe.default.createElement(_2, { className: "parameter__default", source: "<i>Default value</i> : " + A2 }), !y2 && a2 || void 0 === I ? null : Xe.default.createElement(_2, { source: "<i>Example</i> : " + I }), j2 && !P2 && Xe.default.createElement("div", null, "Error: your browser does not support FormData"), d2 && e2.get("examples") ? Xe.default.createElement("section", { className: "parameter-controls" }, Xe.default.createElement(w2, { examples: e2.get("examples"), onSelect: this._onExampleSelect, updateValue: this.onChangeWrapper, getComponent: r2, defaultToFirstExample: true, currentKey: u2.activeExamplesMember(...i2, "parameters", this.getParamKey()), currentUserInputValue: q2 })) : null, y2 ? null : Xe.default.createElement(f2, { fn: o4, getComponent: r2, value: q2, required: M2, disabled: !a2, description: e2.get("name"), onChange: this.onChangeWrapper, errors: O2.get("errors"), schema: x2 }), y2 && x2 ? Xe.default.createElement(S, { getComponent: r2, specPath: c2.push("schema"), getConfigs: n, isExecute: a2, specSelectors: l2, schema: x2, example: y2, includeWriteOnly: true }) : null, !y2 && a2 && e2.get("allowEmptyValue") ? Xe.default.createElement(b, { onChange: this.onChangeIncludeEmpty, isIncluded: l2.parameterInclusionSettingFor(i2, e2.get("name"), e2.get("in")), isDisabled: !isEmptyValue(q2) }) : null, d2 && e2.get("examples") ? Xe.default.createElement(C2, { example: e2.getIn(["examples", u2.activeExamplesMember(...i2, "parameters", this.getParamKey())]), getComponent: r2, getConfigs: n }) : null, m2 && L2.size ? L2.entrySeq().map(([e3, t3]) => Xe.default.createElement(v2, { key: `${e3}-${t3}`, xKey: e3, xVal: t3 })) : null, p2 && D.size ? D.entrySeq().map(([e3, t3]) => Xe.default.createElement(v2, { key: `${e3}-${t3}`, xKey: e3, xVal: t3 })) : null));
  }
};
var Execute = class extends Xe.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "handleValidateParameters", () => {
      let { specSelectors: e2, specActions: t2, path: r2, method: n } = this.props;
      return t2.validateParams([r2, n]), e2.validateBeforeExecute([r2, n]);
    });
    __publicField(this, "handleValidateRequestBody", () => {
      let { path: e2, method: t2, specSelectors: r2, oas3Selectors: n, oas3Actions: a2 } = this.props, o4 = { missingBodyValue: false, missingRequiredKeys: [] };
      a2.clearRequestBodyValidateError({ path: e2, method: t2 });
      let s2 = r2.getOAS3RequiredRequestBodyContentType([e2, t2]), l2 = n.requestBodyValue(e2, t2), i2 = n.validateBeforeExecute([e2, t2]), c2 = n.requestContentType(e2, t2);
      if (!i2) return o4.missingBodyValue = true, a2.setRequestBodyValidateError({ path: e2, method: t2, validationErrors: o4 }), false;
      if (!s2) return true;
      let u2 = n.validateShallowRequired({ oas3RequiredRequestBodyContentType: s2, oas3RequestContentType: c2, oas3RequestBodyValue: l2 });
      return !u2 || u2.length < 1 || (u2.forEach((e3) => {
        o4.missingRequiredKeys.push(e3);
      }), a2.setRequestBodyValidateError({ path: e2, method: t2, validationErrors: o4 }), false);
    });
    __publicField(this, "handleValidationResultPass", () => {
      let { specActions: e2, operation: t2, path: r2, method: n } = this.props;
      this.props.onExecute && this.props.onExecute(), e2.execute({ operation: t2, path: r2, method: n });
    });
    __publicField(this, "handleValidationResultFail", () => {
      let { specActions: e2, path: t2, method: r2 } = this.props;
      e2.clearValidateParams([t2, r2]), setTimeout(() => {
        e2.validateParams([t2, r2]);
      }, 40);
    });
    __publicField(this, "handleValidationResult", (e2) => {
      e2 ? this.handleValidationResultPass() : this.handleValidationResultFail();
    });
    __publicField(this, "onClick", () => {
      let e2 = this.handleValidateParameters(), t2 = this.handleValidateRequestBody(), r2 = e2 && t2;
      this.handleValidationResult(r2);
    });
    __publicField(this, "onChangeProducesWrapper", (e2) => this.props.specActions.changeProducesValue([this.props.path, this.props.method], e2));
  }
  render() {
    const { disabled: e2 } = this.props;
    return Xe.default.createElement("button", { className: "btn execute opblock-control__btn", onClick: this.onClick, disabled: e2 }, "Execute");
  }
};
var headers_Headers = class extends Xe.default.Component {
  render() {
    let { headers: e2, getComponent: t2 } = this.props;
    const r2 = t2("Property"), n = t2("Markdown", true);
    return e2 && e2.size ? Xe.default.createElement("div", { className: "headers-wrapper" }, Xe.default.createElement("h4", { className: "headers__title" }, "Headers:"), Xe.default.createElement("table", { className: "headers" }, Xe.default.createElement("thead", null, Xe.default.createElement("tr", { className: "header-row" }, Xe.default.createElement("th", { className: "header-col" }, "Name"), Xe.default.createElement("th", { className: "header-col" }, "Description"), Xe.default.createElement("th", { className: "header-col" }, "Type"))), Xe.default.createElement("tbody", null, e2.entrySeq().map(([e3, t3]) => {
      if (!Qe.default.Map.isMap(t3)) return null;
      const a2 = t3.get("description"), o4 = t3.getIn(["schema"]) ? t3.getIn(["schema", "type"]) : t3.getIn(["type"]), s2 = t3.getIn(["schema", "example"]);
      return Xe.default.createElement("tr", { key: e3 }, Xe.default.createElement("td", { className: "header-col" }, e3), Xe.default.createElement("td", { className: "header-col" }, a2 ? Xe.default.createElement(n, { source: a2 }) : null), Xe.default.createElement("td", { className: "header-col" }, o4, " ", s2 ? Xe.default.createElement(r2, { propKey: "Example", propVal: s2, propClass: "header-example" }) : null));
    }).toArray()))) : null;
  }
};
var Errors = class extends Xe.default.Component {
  render() {
    let { editorActions: e2, errSelectors: t2, layoutSelectors: r2, layoutActions: n, getComponent: a2 } = this.props;
    const o4 = a2("Collapse");
    if (e2 && e2.jumpToLine) var s2 = e2.jumpToLine;
    let l2 = t2.allErrors().filter((e3) => "thrown" === e3.get("type") || "error" === e3.get("level"));
    if (!l2 || l2.count() < 1) return null;
    let i2 = r2.isShown(["errorPane"], true), c2 = l2.sortBy((e3) => e3.get("line"));
    return Xe.default.createElement("pre", { className: "errors-wrapper" }, Xe.default.createElement("hgroup", { className: "error" }, Xe.default.createElement("h4", { className: "errors__title" }, "Errors"), Xe.default.createElement("button", { className: "btn errors__clear-btn", onClick: () => n.show(["errorPane"], !i2) }, i2 ? "Hide" : "Show")), Xe.default.createElement(o4, { isOpened: i2, animated: true }, Xe.default.createElement("div", { className: "errors" }, c2.map((e3, t3) => {
      let r3 = e3.get("type");
      return "thrown" === r3 || "auth" === r3 ? Xe.default.createElement(ThrownErrorItem, { key: t3, error: e3.get("error") || e3, jumpToLine: s2 }) : "spec" === r3 ? Xe.default.createElement(SpecErrorItem, { key: t3, error: e3, jumpToLine: s2 }) : void 0;
    }))));
  }
};
var ThrownErrorItem = ({ error: e2, jumpToLine: t2 }) => {
  if (!e2) return null;
  let r2 = e2.get("line");
  return Xe.default.createElement("div", { className: "error-wrapper" }, e2 ? Xe.default.createElement("div", null, Xe.default.createElement("h4", null, e2.get("source") && e2.get("level") ? toTitleCase(e2.get("source")) + " " + e2.get("level") : "", e2.get("path") ? Xe.default.createElement("small", null, " at ", e2.get("path")) : null), Xe.default.createElement("span", { className: "message thrown" }, e2.get("message")), Xe.default.createElement("div", { className: "error-line" }, r2 && t2 ? Xe.default.createElement("a", { onClick: t2.bind(null, r2) }, "Jump to line ", r2) : null)) : null);
};
var SpecErrorItem = ({ error: e2, jumpToLine: t2 = null }) => {
  let r2 = null;
  return e2.get("path") ? r2 = Qe.List.isList(e2.get("path")) ? Xe.default.createElement("small", null, "at ", e2.get("path").join(".")) : Xe.default.createElement("small", null, "at ", e2.get("path")) : e2.get("line") && !t2 && (r2 = Xe.default.createElement("small", null, "on line ", e2.get("line"))), Xe.default.createElement("div", { className: "error-wrapper" }, e2 ? Xe.default.createElement("div", null, Xe.default.createElement("h4", null, toTitleCase(e2.get("source")) + " " + e2.get("level"), "", r2), Xe.default.createElement("span", { className: "message" }, e2.get("message")), Xe.default.createElement("div", { className: "error-line" }, t2 ? Xe.default.createElement("a", { onClick: t2.bind(null, e2.get("line")) }, "Jump to line ", e2.get("line")) : null)) : null);
};
function toTitleCase(e2) {
  return (e2 || "").split(" ").map((e3) => e3[0].toUpperCase() + e3.slice(1)).join(" ");
}
var content_type_noop = () => {
};
var ContentType = class extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onChangeWrapper", (e2) => this.props.onChange(e2.target.value));
  }
  componentDidMount() {
    this.props.contentTypes && this.props.onChange(this.props.contentTypes.first());
  }
  UNSAFE_componentWillReceiveProps(e2) {
    e2.contentTypes && e2.contentTypes.size && (e2.contentTypes.includes(e2.value) || e2.onChange(e2.contentTypes.first()));
  }
  render() {
    let { ariaControls: e2, ariaLabel: t2, className: r2, contentTypes: n, controlId: a2, value: o4 } = this.props;
    return n && n.size ? Xe.default.createElement("div", { className: "content-type-wrapper " + (r2 || "") }, Xe.default.createElement("select", { "aria-controls": e2, "aria-label": t2, className: "content-type", id: a2, onChange: this.onChangeWrapper, value: o4 || "" }, n.map((e3) => Xe.default.createElement("option", { key: e3, value: e3 }, e3)).toArray())) : null;
  }
};
__publicField(ContentType, "defaultProps", { onChange: content_type_noop, value: null, contentTypes: (0, Qe.fromJS)(["application/json"]) });
function xclass(...e2) {
  return e2.filter((e3) => !!e3).join(" ").trim();
}
var Container = class extends Xe.default.Component {
  render() {
    let { fullscreen: e2, full: t2, ...r2 } = this.props;
    if (e2) return Xe.default.createElement("section", r2);
    let n = "swagger-container" + (t2 ? "-full" : "");
    return Xe.default.createElement("section", (0, cr.default)({}, r2, { className: xclass(r2.className, n) }));
  }
};
var Ra = { mobile: "", tablet: "-tablet", desktop: "-desktop", large: "-hd" };
var Col = class extends Xe.default.Component {
  render() {
    const { hide: e2, keepContents: t2, mobile: r2, tablet: n, desktop: a2, large: o4, ...s2 } = this.props;
    if (e2 && !t2) return Xe.default.createElement("span", null);
    let l2 = [];
    for (let e3 in Ra) {
      if (!Object.prototype.hasOwnProperty.call(Ra, e3)) continue;
      let t3 = Ra[e3];
      if (e3 in this.props) {
        let r3 = this.props[e3];
        if (r3 < 1) {
          l2.push("none" + t3);
          continue;
        }
        l2.push("block" + t3), l2.push("col-" + r3 + t3);
      }
    }
    e2 && l2.push("hidden");
    let i2 = xclass(s2.className, ...l2);
    return Xe.default.createElement("section", (0, cr.default)({}, s2, { className: i2 }));
  }
};
var Row = class extends Xe.default.Component {
  render() {
    return Xe.default.createElement("div", (0, cr.default)({}, this.props, { className: xclass(this.props.className, "wrapper") }));
  }
};
var Button = class extends Xe.default.Component {
  render() {
    return Xe.default.createElement("button", (0, cr.default)({}, this.props, { className: xclass(this.props.className, "button") }));
  }
};
__publicField(Button, "defaultProps", { className: "" });
var TextArea = (e2) => Xe.default.createElement("textarea", e2);
var Input = (e2) => Xe.default.createElement("input", e2);
var Select = class extends Xe.default.Component {
  constructor(e2, t2) {
    let r2;
    super(e2, t2);
    __publicField(this, "onChange", (e2) => {
      let t2, { onChange: r2, multiple: n } = this.props, a2 = [].slice.call(e2.target.options);
      t2 = n ? a2.filter(function(e3) {
        return e3.selected;
      }).map(function(e3) {
        return e3.value;
      }) : e2.target.value, this.setState({ value: t2 }), r2 && r2(t2);
    });
    r2 = e2.value ? e2.value : e2.multiple ? [""] : "", this.state = { value: r2 };
  }
  UNSAFE_componentWillReceiveProps(e2) {
    e2.value !== this.props.value && this.setState({ value: e2.value });
  }
  render() {
    var _a6, _b;
    let { allowedValues: e2, multiple: t2, allowEmptyValue: r2, disabled: n } = this.props, a2 = ((_b = (_a6 = this.state.value) == null ? void 0 : _a6.toJS) == null ? void 0 : _b.call(_a6)) || this.state.value;
    return Xe.default.createElement("select", { className: this.props.className, multiple: t2, value: a2, onChange: this.onChange, disabled: n }, r2 ? Xe.default.createElement("option", { value: "" }, "--") : null, e2.map(function(e3, t3) {
      return Xe.default.createElement("option", { key: t3, value: String(e3) }, String(e3));
    }));
  }
};
__publicField(Select, "defaultProps", { multiple: false, allowEmptyValue: true });
var Link3 = class extends Xe.default.Component {
  render() {
    return Xe.default.createElement("a", (0, cr.default)({}, this.props, { rel: "noopener noreferrer", className: xclass(this.props.className, "link") }));
  }
};
var NoMargin = ({ children: e2 }) => Xe.default.createElement("div", { className: "no-margin" }, " ", e2, " ");
var Collapse = class extends Xe.default.Component {
  renderNotAnimated() {
    return this.props.isOpened ? Xe.default.createElement(NoMargin, null, this.props.children) : Xe.default.createElement("noscript", null);
  }
  render() {
    let { animated: e2, isOpened: t2, children: r2 } = this.props;
    return e2 ? (r2 = t2 ? r2 : null, Xe.default.createElement(NoMargin, null, r2)) : this.renderNotAnimated();
  }
};
__publicField(Collapse, "defaultProps", { isOpened: false, animated: false });
var Overview = class extends Xe.default.Component {
  constructor(...e2) {
    super(...e2), this.setTagShown = this._setTagShown.bind(this);
  }
  _setTagShown(e2, t2) {
    this.props.layoutActions.show(e2, t2);
  }
  showOp(e2, t2) {
    let { layoutActions: r2 } = this.props;
    r2.show(e2, t2);
  }
  render() {
    let { specSelectors: e2, layoutSelectors: t2, layoutActions: r2, getComponent: n } = this.props, a2 = e2.taggedOperations();
    const o4 = n("Collapse");
    return Xe.default.createElement("div", null, Xe.default.createElement("h4", { className: "overview-title" }, "Overview"), a2.map((e3, n2) => {
      let a3 = e3.get("operations"), s2 = ["overview-tags", n2], l2 = t2.isShown(s2, true);
      return Xe.default.createElement("div", { key: "overview-" + n2 }, Xe.default.createElement("h4", { onClick: () => r2.show(s2, !l2), className: "link overview-tag" }, " ", l2 ? "-" : "+", n2), Xe.default.createElement(o4, { isOpened: l2, animated: true }, a3.map((e4) => {
        let { path: n3, method: a4, id: o5 } = e4.toObject(), s3 = "operations", l3 = o5, i2 = t2.isShown([s3, l3]);
        return Xe.default.createElement(OperationLink, { key: o5, path: n3, method: a4, id: n3 + "-" + a4, shown: i2, showOpId: l3, showOpIdPrefix: s3, href: `#operation-${l3}`, onClick: r2.show });
      }).toArray()));
    }).toArray(), a2.size < 1 && Xe.default.createElement("h3", null, " No operations defined in spec! "));
  }
};
var OperationLink = class extends Xe.default.Component {
  constructor(e2) {
    super(e2), this.onClick = this._onClick.bind(this);
  }
  _onClick() {
    let { showOpId: e2, showOpIdPrefix: t2, onClick: r2, shown: n } = this.props;
    r2([t2, e2], !n);
  }
  render() {
    let { id: e2, method: t2, shown: r2, href: n } = this.props;
    return Xe.default.createElement(Link3, { href: n, onClick: this.onClick, className: "block opblock-link " + (r2 ? "shown" : "") }, Xe.default.createElement("div", null, Xe.default.createElement("small", { className: `bold-label-${t2}` }, t2.toUpperCase()), Xe.default.createElement("span", { className: "bold-label" }, e2)));
  }
};
var InitializedInput = class extends Xe.default.Component {
  componentDidMount() {
    this.props.initialValue && (this.inputRef.value = this.props.initialValue);
  }
  render() {
    const { value: e2, defaultValue: t2, initialValue: r2, ...n } = this.props;
    return Xe.default.createElement("input", (0, cr.default)({}, n, { ref: (e3) => this.inputRef = e3 }));
  }
};
var InfoBasePath = class extends Xe.default.Component {
  render() {
    const { host: e2, basePath: t2 } = this.props;
    return Xe.default.createElement("pre", { className: "base-url" }, "[ Base URL: ", e2, t2, " ]");
  }
};
var InfoUrl = class extends Xe.default.PureComponent {
  render() {
    const { url: e2, getComponent: t2 } = this.props, r2 = t2("Link");
    return Xe.default.createElement(r2, { target: "_blank", href: sanitizeUrl2(e2) }, Xe.default.createElement("span", { className: "url" }, " ", e2));
  }
};
var Info3 = class extends Xe.default.Component {
  render() {
    const { info: e2, url: t2, host: r2, basePath: n, getComponent: a2, externalDocs: o4, selectedServer: s2, url: l2 } = this.props, i2 = e2.get("version"), c2 = e2.get("description"), u2 = e2.get("title"), d2 = safeBuildUrl(e2.get("termsOfService"), l2, { selectedServer: s2 }), p2 = e2.get("contact"), m2 = e2.get("license"), f2 = safeBuildUrl(o4 && o4.get("url"), l2, { selectedServer: s2 }), h2 = o4 && o4.get("description"), g2 = a2("Markdown", true), y2 = a2("Link"), S = a2("VersionStamp"), _2 = a2("OpenAPIVersion"), v2 = a2("InfoUrl"), b = a2("InfoBasePath"), w2 = a2("License"), C2 = a2("Contact");
    return Xe.default.createElement("div", { className: "info" }, Xe.default.createElement("hgroup", { className: "main" }, Xe.default.createElement("h2", { className: "title" }, u2, Xe.default.createElement("span", null, i2 && Xe.default.createElement(S, { version: i2 }), Xe.default.createElement(_2, { oasVersion: "2.0" }))), r2 || n ? Xe.default.createElement(b, { host: r2, basePath: n }) : null, t2 && Xe.default.createElement(v2, { getComponent: a2, url: t2 })), Xe.default.createElement("div", { className: "description" }, Xe.default.createElement(g2, { source: c2 })), d2 && Xe.default.createElement("div", { className: "info__tos" }, Xe.default.createElement(y2, { target: "_blank", href: sanitizeUrl2(d2) }, "Terms of service")), (p2 == null ? void 0 : p2.size) > 0 && Xe.default.createElement(C2, { getComponent: a2, data: p2, selectedServer: s2, url: t2 }), (m2 == null ? void 0 : m2.size) > 0 && Xe.default.createElement(w2, { getComponent: a2, license: m2, selectedServer: s2, url: t2 }), f2 ? Xe.default.createElement(y2, { className: "info__extdocs", target: "_blank", href: sanitizeUrl2(f2) }, h2 || f2) : null);
  }
};
var Ta = Info3;
var InfoContainer = class extends Xe.default.Component {
  render() {
    const { specSelectors: e2, getComponent: t2, oas3Selectors: r2 } = this.props, n = e2.info(), a2 = e2.url(), o4 = e2.basePath(), s2 = e2.host(), l2 = e2.externalDocs(), i2 = r2.selectedServer(), c2 = t2("info");
    return Xe.default.createElement("div", null, n && n.count() ? Xe.default.createElement(c2, { info: n, url: a2, host: s2, basePath: o4, externalDocs: l2, getComponent: t2, selectedServer: i2 }) : null);
  }
};
var Contact3 = class extends Xe.default.Component {
  render() {
    const { data: e2, getComponent: t2, selectedServer: r2, url: n } = this.props, a2 = e2.get("name", "the developer"), o4 = safeBuildUrl(e2.get("url"), n, { selectedServer: r2 }), s2 = e2.get("email"), l2 = t2("Link");
    return Xe.default.createElement("div", { className: "info__contact" }, o4 && Xe.default.createElement("div", null, Xe.default.createElement(l2, { href: sanitizeUrl2(o4), target: "_blank" }, a2, " - Website")), s2 && Xe.default.createElement(l2, { href: sanitizeUrl2(`mailto:${s2}`) }, o4 ? `Send email to ${a2}` : `Contact ${a2}`));
  }
};
var Ba = Contact3;
var License3 = class extends Xe.default.Component {
  render() {
    const { license: e2, getComponent: t2, selectedServer: r2, url: n } = this.props, a2 = e2.get("name", "License"), o4 = safeBuildUrl(e2.get("url"), n, { selectedServer: r2 }), s2 = t2("Link");
    return Xe.default.createElement("div", { className: "info__license" }, o4 ? Xe.default.createElement("div", { className: "info__license__url" }, Xe.default.createElement(s2, { target: "_blank", href: sanitizeUrl2(o4) }, a2)) : Xe.default.createElement("span", null, a2));
  }
};
var ja = License3;
var JumpToPath = class extends Xe.default.Component {
  render() {
    return null;
  }
};
var CopyToClipboardBtn = class extends Xe.default.Component {
  render() {
    let { getComponent: e2 } = this.props;
    const t2 = e2("CopyIcon");
    return Xe.default.createElement("div", { className: "view-line-link copy-to-clipboard", title: "Copy to clipboard" }, Xe.default.createElement(vr.CopyToClipboard, { text: this.props.textToCopy }, Xe.default.createElement(t2, null)));
  }
};
var Footer = class extends Xe.default.Component {
  render() {
    return Xe.default.createElement("div", { className: "footer" });
  }
};
var FilterContainer = class extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "onFilterChange", (e2) => {
      const { target: { value: t2 } } = e2;
      this.props.layoutActions.updateFilter(t2);
    });
  }
  render() {
    const { specSelectors: e2, layoutSelectors: t2, getComponent: r2 } = this.props, n = r2("Col"), a2 = "loading" === e2.loadingStatus(), o4 = "failed" === e2.loadingStatus(), s2 = t2.currentFilter(), l2 = ["operation-filter-input"];
    return o4 && l2.push("failed"), a2 && l2.push("loading"), Xe.default.createElement("div", null, false === s2 ? null : Xe.default.createElement("div", { className: "filter-container" }, Xe.default.createElement(n, { className: "filter wrapper", mobile: 12 }, Xe.default.createElement("input", { className: l2.join(" "), placeholder: "Filter by tag", type: "text", onChange: this.onFilterChange, value: "string" == typeof s2 ? s2 : "", disabled: a2 }))));
  }
};
var Pa = Function.prototype;
var _ParamBody = class _ParamBody extends Xe.PureComponent {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "updateValues", (e2) => {
      let { param: t2, isExecute: r2, consumesValue: n = "" } = e2, a2 = /xml/i.test(n), o4 = /json/i.test(n), s2 = a2 ? t2.get("value_xml") : t2.get("value");
      if (void 0 !== s2) {
        let e3 = !s2 && o4 ? "{}" : s2;
        this.setState({ value: e3 }), this.onChange(e3, { isXml: a2, isEditBox: r2 });
      } else a2 ? this.onChange(this.sample("xml"), { isXml: a2, isEditBox: r2 }) : this.onChange(this.sample(), { isEditBox: r2 });
    });
    __publicField(this, "sample", (e2) => {
      let { param: t2, fn: r2 } = this.props, n = r2.inferSchema(t2.toJS());
      return r2.getSampleSchema(n, e2, { includeWriteOnly: true });
    });
    __publicField(this, "onChange", (e2, { isEditBox: t2, isXml: r2 }) => {
      this.setState({ value: e2, isEditBox: t2 }), this._onChange(e2, r2);
    });
    __publicField(this, "_onChange", (e2, t2) => {
      (this.props.onChange || Pa)(e2, t2);
    });
    __publicField(this, "handleOnChange", (e2) => {
      const { consumesValue: t2 } = this.props, r2 = /xml/i.test(t2), n = e2.target.value;
      this.onChange(n, { isXml: r2, isEditBox: this.state.isEditBox });
    });
    __publicField(this, "toggleIsEditBox", () => this.setState((e2) => ({ isEditBox: !e2.isEditBox })));
    this.state = { isEditBox: false, value: "" };
  }
  componentDidMount() {
    this.updateValues.call(this, this.props);
  }
  UNSAFE_componentWillReceiveProps(e2) {
    this.updateValues.call(this, e2);
  }
  render() {
    let { onChangeConsumes: e2, param: t2, isExecute: r2, specSelectors: n, pathMethod: a2, getComponent: o4 } = this.props;
    const s2 = o4("Button"), l2 = o4("TextArea"), i2 = o4("HighlightCode", true), c2 = o4("contentType");
    let u2 = (n ? n.parameterWithMetaByIdentity(a2, t2) : t2).get("errors", (0, Qe.List)()), d2 = n.contentTypeValues(a2).get("requestContentType"), p2 = this.props.consumes && this.props.consumes.size ? this.props.consumes : _ParamBody.defaultProp.consumes, { value: m2, isEditBox: f2 } = this.state, h2 = null;
    getKnownSyntaxHighlighterLanguage(m2) && (h2 = "json");
    const g2 = `${createHtmlReadyId(`${a2[1]}${a2[0]}_parameters`)}_select`;
    return Xe.default.createElement("div", { className: "body-param", "data-param-name": t2.get("name"), "data-param-in": t2.get("in") }, f2 && r2 ? Xe.default.createElement(l2, { className: "body-param__text" + (u2.count() ? " invalid" : ""), value: m2, onChange: this.handleOnChange }) : m2 && Xe.default.createElement(i2, { className: "body-param__example", language: h2 }, m2), Xe.default.createElement("div", { className: "body-param-options" }, r2 ? Xe.default.createElement("div", { className: "body-param-edit" }, Xe.default.createElement(s2, { className: f2 ? "btn cancel body-param__example-edit" : "btn edit body-param__example-edit", onClick: this.toggleIsEditBox }, f2 ? "Cancel" : "Edit")) : null, Xe.default.createElement("label", { htmlFor: g2 }, Xe.default.createElement("span", null, "Parameter content type"), Xe.default.createElement(c2, { value: d2, contentTypes: p2, onChange: e2, className: "body-param-content-type", ariaLabel: "Parameter content type", controlId: g2 }))));
  }
};
__publicField(_ParamBody, "defaultProp", { consumes: (0, Qe.fromJS)(["application/json"]), param: (0, Qe.fromJS)({}), onChange: Pa, onChangeConsumes: Pa });
var ParamBody = _ParamBody;
var Curl = class extends Xe.default.Component {
  render() {
    const { request: e2, getComponent: t2 } = this.props, r2 = requestSnippetGenerator_curl_bash(e2), n = t2("SyntaxHighlighter", true);
    return Xe.default.createElement("div", { className: "curl-command" }, Xe.default.createElement("h4", null, "Curl"), Xe.default.createElement("div", { className: "copy-to-clipboard" }, Xe.default.createElement(vr.CopyToClipboard, { text: r2 }, Xe.default.createElement("button", null))), Xe.default.createElement("div", null, Xe.default.createElement(n, { language: "bash", className: "curl microlight", renderPlainText: ({ children: e3, PlainTextViewer: t3 }) => Xe.default.createElement(t3, { className: "curl" }, e3) }, r2)));
  }
};
var property = ({ propKey: e2, propVal: t2, propClass: r2 }) => Xe.default.createElement("span", { className: r2 }, Xe.default.createElement("br", null), e2, ": ", String(t2));
var TryItOutButton = class extends Xe.default.Component {
  render() {
    const { onTryoutClick: e2, onCancelClick: t2, onResetClick: r2, enabled: n, hasUserEditedBody: a2, isOAS3: o4 } = this.props, s2 = o4 && a2;
    return Xe.default.createElement("div", { className: s2 ? "try-out btn-group" : "try-out" }, n ? Xe.default.createElement("button", { className: "btn try-out__btn cancel", onClick: t2 }, "Cancel") : Xe.default.createElement("button", { className: "btn try-out__btn", onClick: e2 }, "Try it out "), s2 && Xe.default.createElement("button", { className: "btn try-out__btn reset", onClick: r2 }, "Reset"));
  }
};
__publicField(TryItOutButton, "defaultProps", { onTryoutClick: Function.prototype, onCancelClick: Function.prototype, onResetClick: Function.prototype, enabled: false, hasUserEditedBody: false, isOAS3: false });
var VersionPragmaFilter = class extends Xe.default.PureComponent {
  render() {
    const { bypass: e2, isSwagger2: t2, isOAS3: r2, alsoShow: n } = this.props;
    return e2 ? Xe.default.createElement("div", null, this.props.children) : t2 && r2 ? Xe.default.createElement("div", { className: "version-pragma" }, n, Xe.default.createElement("div", { className: "version-pragma__message version-pragma__message--ambiguous" }, Xe.default.createElement("div", null, Xe.default.createElement("h3", null, "Unable to render this definition"), Xe.default.createElement("p", null, Xe.default.createElement("code", null, "swagger"), " and ", Xe.default.createElement("code", null, "openapi"), " fields cannot be present in the same Swagger or OpenAPI definition. Please remove one of the fields."), Xe.default.createElement("p", null, "Supported version fields are ", Xe.default.createElement("code", null, "swagger: ", '"2.0"'), " and those that match ", Xe.default.createElement("code", null, "openapi: 3.0.n"), " (for example, ", Xe.default.createElement("code", null, "openapi: 3.0.0"), ").")))) : t2 || r2 ? Xe.default.createElement("div", null, this.props.children) : Xe.default.createElement("div", { className: "version-pragma" }, n, Xe.default.createElement("div", { className: "version-pragma__message version-pragma__message--missing" }, Xe.default.createElement("div", null, Xe.default.createElement("h3", null, "Unable to render this definition"), Xe.default.createElement("p", null, "The provided definition does not specify a valid version field."), Xe.default.createElement("p", null, "Please indicate a valid Swagger or OpenAPI version field. Supported version fields are ", Xe.default.createElement("code", null, "swagger: ", '"2.0"'), " and those that match ", Xe.default.createElement("code", null, "openapi: 3.0.n"), " (for example, ", Xe.default.createElement("code", null, "openapi: 3.0.0"), ")."))));
  }
};
__publicField(VersionPragmaFilter, "defaultProps", { alsoShow: null, children: null, bypass: false });
var version_stamp = ({ version: e2 }) => Xe.default.createElement("small", null, Xe.default.createElement("pre", { className: "version" }, " ", e2, " "));
var openapi_version = ({ oasVersion: e2 }) => Xe.default.createElement("small", { className: "version-stamp" }, Xe.default.createElement("pre", { className: "version" }, "OAS ", e2));
var deep_link = ({ enabled: e2, path: t2, text: r2 }) => Xe.default.createElement("a", { className: "nostyle", onClick: e2 ? (e3) => e3.preventDefault() : null, href: e2 ? `#/${t2}` : null }, Xe.default.createElement("span", null, r2));
var svg_assets = () => Xe.default.createElement("div", null, Xe.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", className: "svg-assets" }, Xe.default.createElement("defs", null, Xe.default.createElement("symbol", { viewBox: "0 0 20 20", id: "unlocked" }, Xe.default.createElement("path", { d: "M15.8 8H14V5.6C14 2.703 12.665 1 10 1 7.334 1 6 2.703 6 5.6V6h2v-.801C8 3.754 8.797 3 10 3c1.203 0 2 .754 2 2.199V8H4c-.553 0-1 .646-1 1.199V17c0 .549.428 1.139.951 1.307l1.197.387C5.672 18.861 6.55 19 7.1 19h5.8c.549 0 1.428-.139 1.951-.307l1.196-.387c.524-.167.953-.757.953-1.306V9.199C17 8.646 16.352 8 15.8 8z" })), Xe.default.createElement("symbol", { viewBox: "0 0 20 20", id: "locked" }, Xe.default.createElement("path", { d: "M15.8 8H14V5.6C14 2.703 12.665 1 10 1 7.334 1 6 2.703 6 5.6V8H4c-.553 0-1 .646-1 1.199V17c0 .549.428 1.139.951 1.307l1.197.387C5.672 18.861 6.55 19 7.1 19h5.8c.549 0 1.428-.139 1.951-.307l1.196-.387c.524-.167.953-.757.953-1.306V9.199C17 8.646 16.352 8 15.8 8zM12 8H8V5.199C8 3.754 8.797 3 10 3c1.203 0 2 .754 2 2.199V8z" })), Xe.default.createElement("symbol", { viewBox: "0 0 20 20", id: "close" }, Xe.default.createElement("path", { d: "M14.348 14.849c-.469.469-1.229.469-1.697 0L10 11.819l-2.651 3.029c-.469.469-1.229.469-1.697 0-.469-.469-.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-.469-.469-.469-1.228 0-1.697.469-.469 1.228-.469 1.697 0L10 8.183l2.651-3.031c.469-.469 1.228-.469 1.697 0 .469.469.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c.469.469.469 1.229 0 1.698z" })), Xe.default.createElement("symbol", { viewBox: "0 0 20 20", id: "large-arrow" }, Xe.default.createElement("path", { d: "M13.25 10L6.109 2.58c-.268-.27-.268-.707 0-.979.268-.27.701-.27.969 0l7.83 7.908c.268.271.268.709 0 .979l-7.83 7.908c-.268.271-.701.27-.969 0-.268-.269-.268-.707 0-.979L13.25 10z" })), Xe.default.createElement("symbol", { viewBox: "0 0 20 20", id: "large-arrow-down" }, Xe.default.createElement("path", { d: "M17.418 6.109c.272-.268.709-.268.979 0s.271.701 0 .969l-7.908 7.83c-.27.268-.707.268-.979 0l-7.908-7.83c-.27-.268-.27-.701 0-.969.271-.268.709-.268.979 0L10 13.25l7.418-7.141z" })), Xe.default.createElement("symbol", { viewBox: "0 0 20 20", id: "large-arrow-up" }, Xe.default.createElement("path", { d: "M 17.418 14.908 C 17.69 15.176 18.127 15.176 18.397 14.908 C 18.667 14.64 18.668 14.207 18.397 13.939 L 10.489 6.109 C 10.219 5.841 9.782 5.841 9.51 6.109 L 1.602 13.939 C 1.332 14.207 1.332 14.64 1.602 14.908 C 1.873 15.176 2.311 15.176 2.581 14.908 L 10 7.767 L 17.418 14.908 Z" })), Xe.default.createElement("symbol", { viewBox: "0 0 24 24", id: "jump-to" }, Xe.default.createElement("path", { d: "M19 7v4H5.83l3.58-3.59L8 6l-6 6 6 6 1.41-1.41L5.83 13H21V7z" })), Xe.default.createElement("symbol", { viewBox: "0 0 24 24", id: "expand" }, Xe.default.createElement("path", { d: "M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z" })), Xe.default.createElement("symbol", { viewBox: "0 0 15 16", id: "copy" }, Xe.default.createElement("g", { transform: "translate(2, -1)" }, Xe.default.createElement("path", { fill: "#ffffff", fillRule: "evenodd", d: "M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z" }))))));
var Ma = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ Remarkable: function() {
  return Remarkable;
} });
var qa = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ linkify: function() {
  return linkify;
} });
var La = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return purify;
} });
La.default.addHook && La.default.addHook("beforeSanitizeElements", function(e2) {
  return e2.href && e2.setAttribute("rel", "noopener noreferrer"), e2;
});
var Da = function Markdown({ source: e2, className: t2 = "", getConfigs: r2 = () => ({ useUnsafeMarkdown: false }) }) {
  if ("string" != typeof e2) return null;
  const n = new Ma.Remarkable({ html: true, typographer: true, breaks: true, linkTarget: "_blank" }).use(qa.linkify);
  n.core.ruler.disable(["replacements", "smartquotes"]);
  const { useUnsafeMarkdown: a2 } = r2(), o4 = n.render(e2), s2 = sanitizer(o4, { useUnsafeMarkdown: a2 });
  return e2 && o4 && s2 ? Xe.default.createElement("div", { className: (0, _r.default)(t2, "markdown"), dangerouslySetInnerHTML: { __html: s2 } }) : null;
};
function sanitizer(e2, { useUnsafeMarkdown: t2 = false } = {}) {
  const r2 = t2, n = t2 ? [] : ["style", "class"];
  return t2 && !sanitizer.hasWarnedAboutDeprecation && (console.warn("useUnsafeMarkdown display configuration parameter is deprecated since >3.26.0 and will be removed in v4.0.0."), sanitizer.hasWarnedAboutDeprecation = true), La.default.sanitize(e2, { ADD_ATTR: ["target"], FORBID_TAGS: ["style", "form"], ALLOW_DATA_ATTR: r2, FORBID_ATTR: n });
}
sanitizer.hasWarnedAboutDeprecation = false;
var BaseLayout = class extends Xe.default.Component {
  render() {
    const { errSelectors: e2, specSelectors: t2, getComponent: r2 } = this.props, n = r2("SvgAssets"), a2 = r2("InfoContainer", true), o4 = r2("VersionPragmaFilter"), s2 = r2("operations", true), l2 = r2("Models", true), i2 = r2("Webhooks", true), c2 = r2("Row"), u2 = r2("Col"), d2 = r2("errors", true), p2 = r2("ServersContainer", true), m2 = r2("SchemesContainer", true), f2 = r2("AuthorizeBtnContainer", true), h2 = r2("FilterContainer", true), g2 = t2.isSwagger2(), y2 = t2.isOAS3(), S = t2.isOAS31(), _2 = !t2.specStr(), v2 = t2.loadingStatus();
    let b = null;
    if ("loading" === v2 && (b = Xe.default.createElement("div", { className: "info" }, Xe.default.createElement("div", { className: "loading-container" }, Xe.default.createElement("div", { className: "loading" })))), "failed" === v2 && (b = Xe.default.createElement("div", { className: "info" }, Xe.default.createElement("div", { className: "loading-container" }, Xe.default.createElement("h4", { className: "title" }, "Failed to load API definition."), Xe.default.createElement(d2, null)))), "failedConfig" === v2) {
      const t3 = e2.lastError(), r3 = t3 ? t3.get("message") : "";
      b = Xe.default.createElement("div", { className: "info failed-config" }, Xe.default.createElement("div", { className: "loading-container" }, Xe.default.createElement("h4", { className: "title" }, "Failed to load remote configuration."), Xe.default.createElement("p", null, r3)));
    }
    if (!b && _2 && (b = Xe.default.createElement("h4", null, "No API definition provided.")), b) return Xe.default.createElement("div", { className: "swagger-ui" }, Xe.default.createElement("div", { className: "loading-container" }, b));
    const w2 = t2.servers(), C2 = t2.schemes(), x2 = w2 && w2.size, O2 = C2 && C2.size, k = !!t2.securityDefinitions();
    return Xe.default.createElement("div", { className: "swagger-ui" }, Xe.default.createElement(n, null), Xe.default.createElement(o4, { isSwagger2: g2, isOAS3: y2, alsoShow: Xe.default.createElement(d2, null) }, Xe.default.createElement(d2, null), Xe.default.createElement(c2, { className: "information-container" }, Xe.default.createElement(u2, { mobile: 12 }, Xe.default.createElement(a2, null))), x2 || O2 || k ? Xe.default.createElement("div", { className: "scheme-container" }, Xe.default.createElement(u2, { className: "schemes wrapper", mobile: 12 }, x2 || O2 ? Xe.default.createElement("div", { className: "schemes-server-container" }, x2 ? Xe.default.createElement(p2, null) : null, O2 ? Xe.default.createElement(m2, null) : null) : null, k ? Xe.default.createElement(f2, null) : null)) : null, Xe.default.createElement(h2, null), Xe.default.createElement(c2, null, Xe.default.createElement(u2, { mobile: 12, desktop: 12 }, Xe.default.createElement(s2, null))), S && Xe.default.createElement(c2, { className: "webhooks-container" }, Xe.default.createElement(u2, { mobile: 12, desktop: 12 }, Xe.default.createElement(i2, null))), Xe.default.createElement(c2, null, Xe.default.createElement(u2, { mobile: 12, desktop: 12 }, Xe.default.createElement(l2, null)))));
  }
};
var core_components = () => ({ components: { App: Oa, authorizationPopup: AuthorizationPopup, authorizeBtn: AuthorizeBtn, AuthorizeBtnContainer, authorizeOperationBtn: AuthorizeOperationBtn, auths: Auths, AuthItem: auth_item_Auths, authError: AuthError, oauth2: Oauth2, apiKeyAuth: ApiKeyAuth, basicAuth: BasicAuth, clear: Clear, liveResponse: LiveResponse, InitializedInput, info: Ta, InfoContainer, InfoUrl, InfoBasePath, Contact: Ba, License: ja, JumpToPath, CopyToClipboardBtn, onlineValidatorBadge: OnlineValidatorBadge, operations: Operations, operation: Operation3, OperationSummary, OperationSummaryMethod, OperationSummaryPath, responses: Responses3, response: Response5, ResponseExtension: response_extension, responseBody: ResponseBody, parameters: Parameters, parameterRow: ParameterRow, execute: Execute, headers: headers_Headers, errors: Errors, contentType: ContentType, overview: Overview, footer: Footer, FilterContainer, ParamBody, curl: Curl, Property: property, TryItOutButton, Markdown: Da, BaseLayout, VersionPragmaFilter, VersionStamp: version_stamp, OperationExt: operation_extensions, OperationExtRow: operation_extension_row, ParameterExt: parameter_extension, ParameterIncludeEmpty, OperationTag, OperationContainer, OpenAPIVersion: openapi_version, DeepLink: deep_link, SvgAssets: svg_assets, Example: Example3, ExamplesSelect, ExamplesSelectValueRetainer } });
var form_components = () => ({ components: { ...Ke } });
var base = () => [configsPlugin, util, logs, view3, view_legacy, plugins_spec, err, icons, plugins_layout, json_schema_5, json_schema_5_samples, core_components, form_components, swagger_client, auth, downloadUrlPlugin, deep_linking, filter4, on_complete, plugins_request_snippets, syntax_highlighting, versions, safe_render()];
var Ua = (0, Qe.Map)();
function onlyOAS3(e2) {
  return (t2, r2) => (...n) => {
    if (r2.getSystem().specSelectors.isOAS3()) {
      const t3 = e2(...n);
      return "function" == typeof t3 ? t3(r2) : t3;
    }
    return t2(...n);
  };
}
var $a = onlyOAS3((0, Jr.default)(null));
var Ja = onlyOAS3((e2, t2) => (e3) => e3.getSystem().specSelectors.findSchema(t2));
var Va = onlyOAS3(() => (e2) => {
  const t2 = e2.getSystem().specSelectors.specJson().getIn(["components", "schemas"]);
  return Qe.Map.isMap(t2) ? t2 : Ua;
});
var Ka = onlyOAS3(() => (e2) => e2.getSystem().specSelectors.specJson().hasIn(["servers", 0]));
var za = onlyOAS3((0, Dt.createSelector)(Yr, (e2) => e2.getIn(["components", "securitySchemes"]) || null));
var wrap_selectors_validOperationMethods = (e2, t2) => (r2, ...n) => t2.specSelectors.isOAS3() ? t2.oas3Selectors.validOperationMethods() : e2(...n);
var Fa = $a;
var Wa = $a;
var Ha = $a;
var Ga = $a;
var Xa = $a;
var Ya = /* @__PURE__ */ function wrap_selectors_onlyOAS3(e2) {
  return (t2, r2) => (...n) => {
    if (r2.getSystem().specSelectors.isOAS3()) {
      let t3 = r2.getState().getIn(["spec", "resolvedSubtrees", "components", "securitySchemes"]);
      return e2(r2, t3, ...n);
    }
    return t2(...n);
  };
}((0, Dt.createSelector)((e2) => e2, ({ specSelectors: e2 }) => e2.securityDefinitions(), (e2, t2) => {
  let r2 = (0, Qe.List)();
  return t2 ? (t2.entrySeq().forEach(([e3, t3]) => {
    const n = t3.get("type");
    if ("oauth2" === n && t3.get("flows").entrySeq().forEach(([n2, a2]) => {
      let o4 = (0, Qe.fromJS)({ flow: n2, authorizationUrl: a2.get("authorizationUrl"), tokenUrl: a2.get("tokenUrl"), scopes: a2.get("scopes"), type: t3.get("type"), description: t3.get("description") });
      r2 = r2.push(new Qe.Map({ [e3]: o4.filter((e4) => void 0 !== e4) }));
    }), "http" !== n && "apiKey" !== n || (r2 = r2.push(new Qe.Map({ [e3]: t3 }))), "openIdConnect" === n && t3.get("openIdConnectData")) {
      let n2 = t3.get("openIdConnectData");
      (n2.get("grant_types_supported") || ["authorization_code", "implicit"]).forEach((a2) => {
        let o4 = n2.get("scopes_supported") && n2.get("scopes_supported").reduce((e4, t4) => e4.set(t4, ""), new Qe.Map()), s2 = (0, Qe.fromJS)({ flow: a2, authorizationUrl: n2.get("authorization_endpoint"), tokenUrl: n2.get("token_endpoint"), scopes: o4, type: "oauth2", openIdConnectUrl: t3.get("openIdConnectUrl") });
        r2 = r2.push(new Qe.Map({ [e3]: s2.filter((e4) => void 0 !== e4) }));
      });
    }
  }), r2) : r2;
}));
function OAS3ComponentWrapFactory(e2) {
  return (t2, r2) => (n) => {
    var _a6;
    return "function" == typeof ((_a6 = r2.specSelectors) == null ? void 0 : _a6.isOAS3) ? r2.specSelectors.isOAS3() ? Xe.default.createElement(e2, (0, cr.default)({}, n, r2, { Ori: t2 })) : Xe.default.createElement(t2, n) : (console.warn("OAS3 wrapper: couldn't get spec"), null);
  };
}
var Qa = (0, Qe.Map)();
var selectors_isSwagger2 = () => (e2) => function isSwagger2(e3) {
  const t2 = e3.get("swagger");
  return "string" == typeof t2 && "2.0" === t2;
}(e2.getSystem().specSelectors.specJson());
var selectors_isOAS30 = () => (e2) => function isOAS30(e3) {
  const t2 = e3.get("openapi");
  return "string" == typeof t2 && /^3\.0\.([0123])(?:-rc[012])?$/.test(t2);
}(e2.getSystem().specSelectors.specJson());
var selectors_isOAS3 = () => (e2) => e2.getSystem().specSelectors.isOAS30();
function selectors_onlyOAS3(e2) {
  return (t2, ...r2) => (n) => {
    if (n.specSelectors.isOAS3()) {
      const a2 = e2(t2, ...r2);
      return "function" == typeof a2 ? a2(n) : a2;
    }
    return null;
  };
}
var Za = selectors_onlyOAS3(() => (e2) => e2.specSelectors.specJson().get("servers", Qa));
var findSchema = (e2, t2) => {
  const r2 = e2.getIn(["resolvedSubtrees", "components", "schemas", t2], null), n = e2.getIn(["json", "components", "schemas", t2], null);
  return r2 || n || null;
};
var eo = selectors_onlyOAS3((e2, { callbacks: t2, specPath: r2 }) => (e3) => {
  const n = e3.specSelectors.validOperationMethods();
  return Qe.Map.isMap(t2) ? t2.reduce((e4, t3, a2) => {
    if (!Qe.Map.isMap(t3)) return e4;
    const o4 = t3.reduce((e5, t4, o5) => {
      if (!Qe.Map.isMap(t4)) return e5;
      const s2 = t4.entrySeq().filter(([e6]) => n.includes(e6)).map(([e6, t5]) => ({ operation: (0, Qe.Map)({ operation: t5 }), method: e6, path: o5, callbackName: a2, specPath: r2.concat([a2, o5, e6]) }));
      return e5.concat(s2);
    }, (0, Qe.List)());
    return e4.concat(o4);
  }, (0, Qe.List)()).groupBy((e4) => e4.callbackName).map((e4) => e4.toArray()).toObject() : {};
});
var callbacks = ({ callbacks: e2, specPath: t2, specSelectors: r2, getComponent: n }) => {
  const a2 = r2.callbacksOperations({ callbacks: e2, specPath: t2 }), o4 = Object.keys(a2), s2 = n("OperationContainer", true);
  return 0 === o4.length ? Xe.default.createElement("span", null, "No callbacks") : Xe.default.createElement("div", null, o4.map((e3) => Xe.default.createElement("div", { key: `${e3}` }, Xe.default.createElement("h2", null, e3), a2[e3].map((t3) => Xe.default.createElement(s2, { key: `${e3}-${t3.path}-${t3.method}`, op: t3.operation, tag: "callbacks", method: t3.method, path: t3.path, specPath: t3.specPath, allowTryItOut: false })))));
};
var getDefaultRequestBodyValue = (e2, t2, r2, n) => {
  const a2 = e2.getIn(["content", t2]) ?? (0, Qe.OrderedMap)(), o4 = a2.get("schema", (0, Qe.OrderedMap)()).toJS(), s2 = void 0 !== a2.get("examples"), l2 = a2.get("example"), i2 = s2 ? a2.getIn(["examples", r2, "value"]) : l2;
  return stringify(n.getSampleSchema(o4, t2, { includeWriteOnly: true }, i2));
};
var request_body = ({ userHasEditedBody: e2, requestBody: t2, requestBodyValue: r2, requestBodyInclusionSetting: n, requestBodyErrors: a2, getComponent: o4, getConfigs: s2, specSelectors: l2, fn: i2, contentType: c2, isExecute: u2, specPath: d2, onChange: p2, onChangeIncludeEmpty: m2, activeExamplesKey: f2, updateActiveExamplesKey: h2, setRetainRequestBodyValueFlag: g2 }) => {
  const handleFile = (e3) => {
    p2(e3.target.files[0]);
  }, setIsIncludedOptions = (e3) => {
    let t3 = { key: e3, shouldDispatchInit: false, defaultValue: true };
    return "no value" === n.get(e3, "no value") && (t3.shouldDispatchInit = true), t3;
  }, y2 = o4("Markdown", true), S = o4("modelExample"), _2 = o4("RequestBodyEditor"), v2 = o4("HighlightCode", true), b = o4("ExamplesSelectValueRetainer"), w2 = o4("Example"), C2 = o4("ParameterIncludeEmpty"), { showCommonExtensions: x2 } = s2(), O2 = (t2 == null ? void 0 : t2.get("description")) ?? null, k = (t2 == null ? void 0 : t2.get("content")) ?? new Qe.OrderedMap();
  c2 = c2 || k.keySeq().first() || "";
  const N2 = k.get(c2) ?? (0, Qe.OrderedMap)(), A2 = N2.get("schema", (0, Qe.OrderedMap)()), I = N2.get("examples", null), R2 = I == null ? void 0 : I.map((e3, r3) => {
    const n2 = e3 == null ? void 0 : e3.get("value", null);
    return n2 && (e3 = e3.set("value", getDefaultRequestBodyValue(t2, c2, r3, i2), n2)), e3;
  });
  if (a2 = Qe.List.isList(a2) ? a2 : (0, Qe.List)(), !N2.size) return null;
  const T3 = "object" === N2.getIn(["schema", "type"]), B2 = "binary" === N2.getIn(["schema", "format"]), j2 = "base64" === N2.getIn(["schema", "format"]);
  if ("application/octet-stream" === c2 || 0 === c2.indexOf("image/") || 0 === c2.indexOf("audio/") || 0 === c2.indexOf("video/") || B2 || j2) {
    const e3 = o4("Input");
    return u2 ? Xe.default.createElement(e3, { type: "file", onChange: handleFile }) : Xe.default.createElement("i", null, "Example values are not available for ", Xe.default.createElement("code", null, c2), " media types.");
  }
  if (T3 && ("application/x-www-form-urlencoded" === c2 || 0 === c2.indexOf("multipart/")) && A2.get("properties", (0, Qe.OrderedMap)()).size > 0) {
    const e3 = o4("JsonSchemaForm"), t3 = o4("ParameterExt"), s3 = A2.get("properties", (0, Qe.OrderedMap)());
    return r2 = Qe.Map.isMap(r2) ? r2 : (0, Qe.OrderedMap)(), Xe.default.createElement("div", { className: "table-container" }, O2 && Xe.default.createElement(y2, { source: O2 }), Xe.default.createElement("table", null, Xe.default.createElement("tbody", null, Qe.Map.isMap(s3) && s3.entrySeq().map(([s4, l3]) => {
      var _a6, _b, _c, _d;
      if (l3.get("readOnly")) return;
      const c3 = (_b = (_a6 = l3.get("oneOf")) == null ? void 0 : _a6.get(0)) == null ? void 0 : _b.toJS(), d3 = (_d = (_c = l3.get("anyOf")) == null ? void 0 : _c.get(0)) == null ? void 0 : _d.toJS();
      l3 = (0, Qe.fromJS)(i2.mergeJsonSchema(l3.toJS(), c3 ?? d3 ?? {}));
      let f3 = x2 ? getCommonExtensions(l3) : null;
      const h3 = A2.get("required", (0, Qe.List)()).includes(s4), g3 = l3.get("type"), S2 = l3.get("format"), _3 = l3.get("description"), v3 = r2.getIn([s4, "value"]), b2 = r2.getIn([s4, "errors"]) || a2, w3 = n.get(s4) || false;
      let O3 = i2.getSampleSchema(l3, false, { includeWriteOnly: true });
      false === O3 && (O3 = "false"), 0 === O3 && (O3 = "0"), "string" != typeof O3 && "object" === g3 && (O3 = stringify(O3)), "string" == typeof O3 && "array" === g3 && (O3 = JSON.parse(O3));
      const k2 = "string" === g3 && ("binary" === S2 || "base64" === S2);
      return Xe.default.createElement("tr", { key: s4, className: "parameters", "data-property-name": s4 }, Xe.default.createElement("td", { className: "parameters-col_name" }, Xe.default.createElement("div", { className: h3 ? "parameter__name required" : "parameter__name" }, s4, h3 ? Xe.default.createElement("span", null, "*") : null), Xe.default.createElement("div", { className: "parameter__type" }, g3, S2 && Xe.default.createElement("span", { className: "prop-format" }, "($", S2, ")"), x2 && f3.size ? f3.entrySeq().map(([e4, r3]) => Xe.default.createElement(t3, { key: `${e4}-${r3}`, xKey: e4, xVal: r3 })) : null), Xe.default.createElement("div", { className: "parameter__deprecated" }, l3.get("deprecated") ? "deprecated" : null)), Xe.default.createElement("td", { className: "parameters-col_description" }, Xe.default.createElement(y2, { source: _3 }), u2 ? Xe.default.createElement("div", null, Xe.default.createElement(e3, { fn: i2, dispatchInitialValue: !k2, schema: l3, description: s4, getComponent: o4, value: void 0 === v3 ? O3 : v3, required: h3, errors: b2, onChange: (e4) => {
        p2(e4, [s4]);
      } }), h3 ? null : Xe.default.createElement(C2, { onChange: (e4) => m2(s4, e4), isIncluded: w3, isIncludedOptions: setIsIncludedOptions(s4), isDisabled: Array.isArray(v3) ? 0 !== v3.length : !isEmptyValue(v3) })) : null));
    }))));
  }
  const P2 = getDefaultRequestBodyValue(t2, c2, f2, i2);
  let M2 = null;
  return getKnownSyntaxHighlighterLanguage(P2) && (M2 = "json"), Xe.default.createElement("div", null, O2 && Xe.default.createElement(y2, { source: O2 }), R2 ? Xe.default.createElement(b, { userHasEditedBody: e2, examples: R2, currentKey: f2, currentUserInputValue: r2, onSelect: (e3) => {
    h2(e3);
  }, updateValue: p2, defaultToFirstExample: true, getComponent: o4, setRetainRequestBodyValueFlag: g2 }) : null, u2 ? Xe.default.createElement("div", null, Xe.default.createElement(_2, { value: r2, errors: a2, defaultValue: P2, onChange: p2, getComponent: o4 })) : Xe.default.createElement(S, { getComponent: o4, getConfigs: s2, specSelectors: l2, expandDepth: 1, isExecute: u2, schema: N2.get("schema"), specPath: d2.push("content", c2), example: Xe.default.createElement(v2, { className: "body-param__example", language: M2 }, stringify(r2) || P2), includeWriteOnly: true }), R2 ? Xe.default.createElement(w2, { example: R2.get(f2), getComponent: o4, getConfigs: s2 }) : null);
};
var operation_link_OperationLink = class extends Xe.Component {
  render() {
    const { link: e2, name: t2, getComponent: r2 } = this.props, n = r2("Markdown", true);
    let a2 = e2.get("operationId") || e2.get("operationRef"), o4 = e2.get("parameters") && e2.get("parameters").toJS(), s2 = e2.get("description");
    return Xe.default.createElement("div", { className: "operation-link" }, Xe.default.createElement("div", { className: "description" }, Xe.default.createElement("b", null, Xe.default.createElement("code", null, t2)), s2 ? Xe.default.createElement(n, { source: s2 }) : null), Xe.default.createElement("pre", null, "Operation `", a2, "`", Xe.default.createElement("br", null), Xe.default.createElement("br", null), "Parameters ", function padString(e3, t3) {
      if ("string" != typeof t3) return "";
      return t3.split("\n").map((t4, r3) => r3 > 0 ? Array(e3 + 1).join(" ") + t4 : t4).join("\n");
    }(0, JSON.stringify(o4, null, 2)) || "{}", Xe.default.createElement("br", null)));
  }
};
var to = operation_link_OperationLink;
var components_servers = ({ servers: e2, currentServer: t2, setSelectedServer: r2, setServerVariableValue: n, getServerVariable: a2, getEffectiveServerValue: o4 }) => {
  const s2 = (e2.find((e3) => e3.get("url") === t2) || (0, Qe.OrderedMap)()).get("variables") || (0, Qe.OrderedMap)(), l2 = 0 !== s2.size;
  (0, Xe.useEffect)(() => {
    var _a6;
    t2 || r2((_a6 = e2.first()) == null ? void 0 : _a6.get("url"));
  }, []), (0, Xe.useEffect)(() => {
    const a3 = e2.find((e3) => e3.get("url") === t2);
    if (!a3) return void r2(e2.first().get("url"));
    (a3.get("variables") || (0, Qe.OrderedMap)()).map((e3, r3) => {
      n({ server: t2, key: r3, val: e3.get("default") || "" });
    });
  }, [t2, e2]);
  const i2 = (0, Xe.useCallback)((e3) => {
    r2(e3.target.value);
  }, [r2]), c2 = (0, Xe.useCallback)((e3) => {
    const r3 = e3.target.getAttribute("data-variable"), a3 = e3.target.value;
    n({ server: t2, key: r3, val: a3 });
  }, [n, t2]);
  return Xe.default.createElement("div", { className: "servers" }, Xe.default.createElement("label", { htmlFor: "servers" }, Xe.default.createElement("select", { onChange: i2, value: t2, id: "servers" }, e2.valueSeq().map((e3) => Xe.default.createElement("option", { value: e3.get("url"), key: e3.get("url") }, e3.get("url"), e3.get("description") && ` - ${e3.get("description")}`)).toArray())), l2 && Xe.default.createElement("div", null, Xe.default.createElement("div", { className: "computed-url" }, "Computed URL:", Xe.default.createElement("code", null, o4(t2))), Xe.default.createElement("h4", null, "Server variables"), Xe.default.createElement("table", null, Xe.default.createElement("tbody", null, s2.entrySeq().map(([e3, r3]) => Xe.default.createElement("tr", { key: e3 }, Xe.default.createElement("td", null, e3), Xe.default.createElement("td", null, r3.get("enum") ? Xe.default.createElement("select", { "data-variable": e3, onChange: c2 }, r3.get("enum").map((r4) => Xe.default.createElement("option", { selected: r4 === a2(t2, e3), key: r4, value: r4 }, r4))) : Xe.default.createElement("input", { type: "text", value: a2(t2, e3) || "", onChange: c2, "data-variable": e3 }))))))));
};
var ServersContainer = class extends Xe.default.Component {
  render() {
    const { specSelectors: e2, oas3Selectors: t2, oas3Actions: r2, getComponent: n } = this.props, a2 = e2.servers(), o4 = n("Servers");
    return a2 && a2.size ? Xe.default.createElement("div", null, Xe.default.createElement("span", { className: "servers-title" }, "Servers"), Xe.default.createElement(o4, { servers: a2, currentServer: t2.selectedServer(), setSelectedServer: r2.setSelectedServer, setServerVariableValue: r2.setServerVariableValue, getServerVariable: t2.serverVariableValue, getEffectiveServerValue: t2.serverEffectiveValue })) : null;
  }
};
var ro = Function.prototype;
var RequestBodyEditor = class extends Xe.PureComponent {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "applyDefaultValue", (e2) => {
      const { onChange: t2, defaultValue: r2 } = e2 || this.props;
      return this.setState({ value: r2 }), t2(r2);
    });
    __publicField(this, "onChange", (e2) => {
      this.props.onChange(stringify(e2));
    });
    __publicField(this, "onDomChange", (e2) => {
      const t2 = e2.target.value;
      this.setState({ value: t2 }, () => this.onChange(t2));
    });
    this.state = { value: stringify(e2.value) || e2.defaultValue }, e2.onChange(e2.value);
  }
  UNSAFE_componentWillReceiveProps(e2) {
    this.props.value !== e2.value && e2.value !== this.state.value && this.setState({ value: stringify(e2.value) }), !e2.value && e2.defaultValue && this.state.value && this.applyDefaultValue(e2);
  }
  render() {
    let { getComponent: e2, errors: t2 } = this.props, { value: r2 } = this.state, n = t2.size > 0;
    const a2 = e2("TextArea");
    return Xe.default.createElement("div", { className: "body-param" }, Xe.default.createElement(a2, { className: (0, _r.default)("body-param__text", { invalid: n }), title: t2.size ? t2.join(", ") : "", value: r2, onChange: this.onDomChange }));
  }
};
__publicField(RequestBodyEditor, "defaultProps", { onChange: ro, userHasEditedBody: false });
var HttpAuth = class extends Xe.default.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "onChange", (e2) => {
      let { onChange: t2 } = this.props, { value: r2, name: n } = e2.target, a2 = Object.assign({}, this.state.value);
      n ? a2[n] = r2 : a2 = r2, this.setState({ value: a2 }, () => t2(this.state));
    });
    let { name: r2, schema: n } = this.props, a2 = this.getValue();
    this.state = { name: r2, schema: n, value: a2 };
  }
  getValue() {
    let { name: e2, authorized: t2 } = this.props;
    return t2 && t2.getIn([e2, "value"]);
  }
  render() {
    let { schema: e2, getComponent: t2, errSelectors: r2, name: n } = this.props;
    const a2 = t2("Input"), o4 = t2("Row"), s2 = t2("Col"), l2 = t2("authError"), i2 = t2("Markdown", true), c2 = t2("JumpToPath", true), u2 = (e2.get("scheme") || "").toLowerCase();
    let d2 = this.getValue(), p2 = r2.allErrors().filter((e3) => e3.get("authId") === n);
    if ("basic" === u2) {
      let t3 = d2 ? d2.get("username") : null;
      return Xe.default.createElement("div", null, Xe.default.createElement("h4", null, Xe.default.createElement("code", null, n || e2.get("name")), " (http, Basic)", Xe.default.createElement(c2, { path: ["securityDefinitions", n] })), t3 && Xe.default.createElement("h6", null, "Authorized"), Xe.default.createElement(o4, null, Xe.default.createElement(i2, { source: e2.get("description") })), Xe.default.createElement(o4, null, Xe.default.createElement("label", { htmlFor: "auth-basic-username" }, "Username:"), t3 ? Xe.default.createElement("code", null, " ", t3, " ") : Xe.default.createElement(s2, null, Xe.default.createElement(a2, { id: "auth-basic-username", type: "text", required: "required", name: "username", "aria-label": "auth-basic-username", onChange: this.onChange, autoFocus: true }))), Xe.default.createElement(o4, null, Xe.default.createElement("label", { htmlFor: "auth-basic-password" }, "Password:"), t3 ? Xe.default.createElement("code", null, " ****** ") : Xe.default.createElement(s2, null, Xe.default.createElement(a2, { id: "auth-basic-password", autoComplete: "new-password", name: "password", type: "password", "aria-label": "auth-basic-password", onChange: this.onChange }))), p2.valueSeq().map((e3, t4) => Xe.default.createElement(l2, { error: e3, key: t4 })));
    }
    return "bearer" === u2 ? Xe.default.createElement("div", null, Xe.default.createElement("h4", null, Xe.default.createElement("code", null, n || e2.get("name")), " (http, Bearer)", Xe.default.createElement(c2, { path: ["securityDefinitions", n] })), d2 && Xe.default.createElement("h6", null, "Authorized"), Xe.default.createElement(o4, null, Xe.default.createElement(i2, { source: e2.get("description") })), Xe.default.createElement(o4, null, Xe.default.createElement("label", { htmlFor: "auth-bearer-value" }, "Value:"), d2 ? Xe.default.createElement("code", null, " ****** ") : Xe.default.createElement(s2, null, Xe.default.createElement(a2, { id: "auth-bearer-value", type: "text", "aria-label": "auth-bearer-value", onChange: this.onChange, autoFocus: true }))), p2.valueSeq().map((e3, t3) => Xe.default.createElement(l2, { error: e3, key: t3 }))) : Xe.default.createElement("div", null, Xe.default.createElement("em", null, Xe.default.createElement("b", null, n), " HTTP authentication: unsupported scheme ", `'${u2}'`));
  }
};
var OperationServers2 = class extends Xe.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "setSelectedServer", (e2) => {
      const { path: t2, method: r2 } = this.props;
      return this.forceUpdate(), this.props.setSelectedServer(e2, `${t2}:${r2}`);
    });
    __publicField(this, "setServerVariableValue", (e2) => {
      const { path: t2, method: r2 } = this.props;
      return this.forceUpdate(), this.props.setServerVariableValue({ ...e2, namespace: `${t2}:${r2}` });
    });
    __publicField(this, "getSelectedServer", () => {
      const { path: e2, method: t2 } = this.props;
      return this.props.getSelectedServer(`${e2}:${t2}`);
    });
    __publicField(this, "getServerVariable", (e2, t2) => {
      const { path: r2, method: n } = this.props;
      return this.props.getServerVariable({ namespace: `${r2}:${n}`, server: e2 }, t2);
    });
    __publicField(this, "getEffectiveServerValue", (e2) => {
      const { path: t2, method: r2 } = this.props;
      return this.props.getEffectiveServerValue({ server: e2, namespace: `${t2}:${r2}` });
    });
  }
  render() {
    const { operationServers: e2, pathServers: t2, getComponent: r2 } = this.props;
    if (!e2 && !t2) return null;
    const n = r2("Servers"), a2 = e2 || t2, o4 = e2 ? "operation" : "path";
    return Xe.default.createElement("div", { className: "opblock-section operation-servers" }, Xe.default.createElement("div", { className: "opblock-section-header" }, Xe.default.createElement("div", { className: "tab-header" }, Xe.default.createElement("h4", { className: "opblock-title" }, "Servers"))), Xe.default.createElement("div", { className: "opblock-description-wrapper" }, Xe.default.createElement("h4", { className: "message" }, "These ", o4, "-level options override the global server options."), Xe.default.createElement(n, { servers: a2, currentServer: this.getSelectedServer(), setSelectedServer: this.setSelectedServer, setServerVariableValue: this.setServerVariableValue, getServerVariable: this.getServerVariable, getEffectiveServerValue: this.getEffectiveServerValue })));
  }
};
var no = { Callbacks: callbacks, HttpAuth, RequestBody: request_body, Servers: components_servers, ServersContainer, RequestBodyEditor, OperationServers: OperationServers2, operationLink: to };
var ao = new Ma.Remarkable("commonmark");
ao.block.ruler.enable(["table"]), ao.set({ linkTarget: "_blank" });
var oo = OAS3ComponentWrapFactory(({ source: e2, className: t2 = "", getConfigs: r2 = () => ({ useUnsafeMarkdown: false }) }) => {
  if ("string" != typeof e2) return null;
  if (e2) {
    const { useUnsafeMarkdown: n } = r2(), a2 = sanitizer(ao.render(e2), { useUnsafeMarkdown: n });
    let o4;
    return "string" == typeof a2 && (o4 = a2.trim()), Xe.default.createElement("div", { dangerouslySetInnerHTML: { __html: o4 }, className: (0, _r.default)(t2, "renderedMarkdown") });
  }
  return null;
});
var so = OAS3ComponentWrapFactory(({ Ori: e2, ...t2 }) => {
  const { schema: r2, getComponent: n, errSelectors: a2, authorized: o4, onAuthChange: s2, name: l2 } = t2, i2 = n("HttpAuth");
  return "http" === r2.get("type") ? Xe.default.createElement(i2, { key: l2, schema: r2, name: l2, errSelectors: a2, authorized: o4, getComponent: n, onChange: s2 }) : Xe.default.createElement(e2, t2);
});
var lo = OAS3ComponentWrapFactory(OnlineValidatorBadge);
var ModelComponent = class extends Xe.Component {
  render() {
    let { getConfigs: e2, schema: t2, Ori: r2 } = this.props, n = ["model-box"], a2 = null;
    return true === t2.get("deprecated") && (n.push("deprecated"), a2 = Xe.default.createElement("span", { className: "model-deprecated-warning" }, "Deprecated:")), Xe.default.createElement("div", { className: n.join(" ") }, a2, Xe.default.createElement(r2, (0, cr.default)({}, this.props, { getConfigs: e2, depth: 1, expandDepth: this.props.expandDepth || 0 })));
  }
};
var io = OAS3ComponentWrapFactory(ModelComponent);
var co = OAS3ComponentWrapFactory(({ Ori: e2, ...t2 }) => {
  const { schema: r2, getComponent: n, errors: a2, onChange: o4 } = t2, s2 = r2 && r2.get ? r2.get("format") : null, l2 = r2 && r2.get ? r2.get("type") : null, i2 = n("Input");
  return l2 && "string" === l2 && s2 && ("binary" === s2 || "base64" === s2) ? Xe.default.createElement(i2, { type: "file", className: a2.length ? "invalid" : "", title: a2.length ? a2 : "", onChange: (e3) => {
    o4(e3.target.files[0]);
  }, disabled: e2.isDisabled }) : Xe.default.createElement(e2, t2);
});
var uo = { Markdown: oo, AuthItem: so, OpenAPIVersion: /* @__PURE__ */ function OAS30ComponentWrapFactory(e2) {
  return (t2, r2) => (n) => {
    var _a6;
    return "function" == typeof ((_a6 = r2.specSelectors) == null ? void 0 : _a6.isOAS30) ? r2.specSelectors.isOAS30() ? Xe.default.createElement(e2, (0, cr.default)({}, n, r2, { Ori: t2 })) : Xe.default.createElement(t2, n) : (console.warn("OAS30 wrapper: couldn't get spec"), null);
  };
}((e2) => {
  const { Ori: t2 } = e2;
  return Xe.default.createElement(t2, { oasVersion: "3.0" });
}), JsonSchema_string: co, model: io, onlineValidatorBadge: lo };
var po = "oas3_set_servers";
var mo = "oas3_set_request_body_value";
var fo = "oas3_set_request_body_retain_flag";
var ho = "oas3_set_request_body_inclusion";
var go = "oas3_set_active_examples_member";
var yo = "oas3_set_request_content_type";
var Eo = "oas3_set_response_content_type";
var So = "oas3_set_server_variable_value";
var _o = "oas3_set_request_body_validate_error";
var vo = "oas3_clear_request_body_validate_error";
var bo = "oas3_clear_request_body_value";
function setSelectedServer(e2, t2) {
  return { type: po, payload: { selectedServerUrl: e2, namespace: t2 } };
}
function setRequestBodyValue({ value: e2, pathMethod: t2 }) {
  return { type: mo, payload: { value: e2, pathMethod: t2 } };
}
var setRetainRequestBodyValueFlag = ({ value: e2, pathMethod: t2 }) => ({ type: fo, payload: { value: e2, pathMethod: t2 } });
function setRequestBodyInclusion({ value: e2, pathMethod: t2, name: r2 }) {
  return { type: ho, payload: { value: e2, pathMethod: t2, name: r2 } };
}
function setActiveExamplesMember({ name: e2, pathMethod: t2, contextType: r2, contextName: n }) {
  return { type: go, payload: { name: e2, pathMethod: t2, contextType: r2, contextName: n } };
}
function setRequestContentType({ value: e2, pathMethod: t2 }) {
  return { type: yo, payload: { value: e2, pathMethod: t2 } };
}
function setResponseContentType({ value: e2, path: t2, method: r2 }) {
  return { type: Eo, payload: { value: e2, path: t2, method: r2 } };
}
function setServerVariableValue({ server: e2, namespace: t2, key: r2, val: n }) {
  return { type: So, payload: { server: e2, namespace: t2, key: r2, val: n } };
}
var setRequestBodyValidateError = ({ path: e2, method: t2, validationErrors: r2 }) => ({ type: _o, payload: { path: e2, method: t2, validationErrors: r2 } });
var clearRequestBodyValidateError = ({ path: e2, method: t2 }) => ({ type: vo, payload: { path: e2, method: t2 } });
var initRequestBodyValidateError = ({ pathMethod: e2 }) => ({ type: vo, payload: { path: e2[0], method: e2[1] } });
var clearRequestBodyValue = ({ pathMethod: e2 }) => ({ type: bo, payload: { pathMethod: e2 } });
var wo = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return _e.default;
} });
var oas3_selectors_onlyOAS3 = (e2) => (t2, ...r2) => (n) => {
  if (n.getSystem().specSelectors.isOAS3()) {
    const a2 = e2(t2, ...r2);
    return "function" == typeof a2 ? a2(n) : a2;
  }
  return null;
};
var Co = oas3_selectors_onlyOAS3((e2, t2) => {
  const r2 = t2 ? [t2, "selectedServer"] : ["selectedServer"];
  return e2.getIn(r2) || "";
});
var xo = oas3_selectors_onlyOAS3((e2, t2, r2) => e2.getIn(["requestData", t2, r2, "bodyValue"]) || null);
var Oo = oas3_selectors_onlyOAS3((e2, t2, r2) => e2.getIn(["requestData", t2, r2, "retainBodyValue"]) || false);
var selectDefaultRequestBodyValue = (e2, t2, r2) => (e3) => {
  const { oas3Selectors: n, specSelectors: a2, fn: o4 } = e3.getSystem();
  if (a2.isOAS3()) {
    const e4 = n.requestContentType(t2, r2);
    if (e4) return getDefaultRequestBodyValue(a2.specResolvedSubtree(["paths", t2, r2, "requestBody"]), e4, n.activeExamplesMember(t2, r2, "requestBody", "requestBody"), o4);
  }
  return null;
};
var ko = oas3_selectors_onlyOAS3((e2, t2, r2) => (e3) => {
  const { oas3Selectors: n, specSelectors: a2, fn: o4 } = e3;
  let s2 = false;
  const l2 = n.requestContentType(t2, r2);
  let i2 = n.requestBodyValue(t2, r2);
  const c2 = a2.specResolvedSubtree(["paths", t2, r2, "requestBody"]);
  if (!c2) return false;
  if (Qe.Map.isMap(i2) && (i2 = stringify(i2.mapEntries((e4) => Qe.Map.isMap(e4[1]) ? [e4[0], e4[1].get("value")] : e4).toJS())), Qe.List.isList(i2) && (i2 = stringify(i2)), l2) {
    const e4 = getDefaultRequestBodyValue(c2, l2, n.activeExamplesMember(t2, r2, "requestBody", "requestBody"), o4);
    s2 = !!i2 && i2 !== e4;
  }
  return s2;
});
var No = oas3_selectors_onlyOAS3((e2, t2, r2) => e2.getIn(["requestData", t2, r2, "bodyInclusion"]) || (0, Qe.Map)());
var Ao = oas3_selectors_onlyOAS3((e2, t2, r2) => e2.getIn(["requestData", t2, r2, "errors"]) || null);
var Io = oas3_selectors_onlyOAS3((e2, t2, r2, n, a2) => e2.getIn(["examples", t2, r2, n, a2, "activeExample"]) || null);
var Ro = oas3_selectors_onlyOAS3((e2, t2, r2) => e2.getIn(["requestData", t2, r2, "requestContentType"]) || null);
var To = oas3_selectors_onlyOAS3((e2, t2, r2) => e2.getIn(["requestData", t2, r2, "responseContentType"]) || null);
var Bo = oas3_selectors_onlyOAS3((e2, t2, r2) => {
  let n;
  if ("string" != typeof t2) {
    const { server: e3, namespace: a2 } = t2;
    n = a2 ? [a2, "serverVariableValues", e3, r2] : ["serverVariableValues", e3, r2];
  } else {
    n = ["serverVariableValues", t2, r2];
  }
  return e2.getIn(n) || null;
});
var jo = oas3_selectors_onlyOAS3((e2, t2) => {
  let r2;
  if ("string" != typeof t2) {
    const { server: e3, namespace: n } = t2;
    r2 = n ? [n, "serverVariableValues", e3] : ["serverVariableValues", e3];
  } else {
    r2 = ["serverVariableValues", t2];
  }
  return e2.getIn(r2) || (0, Qe.OrderedMap)();
});
var Po = oas3_selectors_onlyOAS3((e2, t2) => {
  var r2, n;
  if ("string" != typeof t2) {
    const { server: a3, namespace: o4 } = t2;
    n = a3, r2 = o4 ? e2.getIn([o4, "serverVariableValues", n]) : e2.getIn(["serverVariableValues", n]);
  } else n = t2, r2 = e2.getIn(["serverVariableValues", n]);
  r2 = r2 || (0, Qe.OrderedMap)();
  let a2 = n;
  return r2.map((e3, t3) => {
    a2 = a2.replace(new RegExp(`{${(0, wo.default)(t3)}}`, "g"), e3);
  }), a2;
});
var Mo = /* @__PURE__ */ function validateRequestBodyIsRequired(e2) {
  return (...t2) => (r2) => {
    const n = r2.getSystem().specSelectors.specJson();
    let a2 = [...t2][1] || [];
    return !n.getIn(["paths", ...a2, "requestBody", "required"]) || e2(...t2);
  };
}((e2, t2) => ((e3, t3) => (t3 = t3 || [], !!e3.getIn(["requestData", ...t3, "bodyValue"])))(e2, t2));
var validateShallowRequired = (e2, { oas3RequiredRequestBodyContentType: t2, oas3RequestContentType: r2, oas3RequestBodyValue: n }) => {
  let a2 = [];
  if (!Qe.Map.isMap(n)) return a2;
  let o4 = [];
  return Object.keys(t2.requestContentType).forEach((e3) => {
    if (e3 === r2) {
      t2.requestContentType[e3].forEach((e4) => {
        o4.indexOf(e4) < 0 && o4.push(e4);
      });
    }
  }), o4.forEach((e3) => {
    n.getIn([e3, "value"]) || a2.push(e3);
  }), a2;
};
var qo = (0, Jr.default)(["get", "put", "post", "delete", "options", "head", "patch", "trace"]);
var Lo = { [po]: (e2, { payload: { selectedServerUrl: t2, namespace: r2 } }) => {
  const n = r2 ? [r2, "selectedServer"] : ["selectedServer"];
  return e2.setIn(n, t2);
}, [mo]: (e2, { payload: { value: t2, pathMethod: r2 } }) => {
  let [n, a2] = r2;
  if (!Qe.Map.isMap(t2)) return e2.setIn(["requestData", n, a2, "bodyValue"], t2);
  let o4, s2 = e2.getIn(["requestData", n, a2, "bodyValue"]) || (0, Qe.Map)();
  Qe.Map.isMap(s2) || (s2 = (0, Qe.Map)());
  const [...l2] = t2.keys();
  return l2.forEach((e3) => {
    let r3 = t2.getIn([e3]);
    s2.has(e3) && Qe.Map.isMap(r3) || (o4 = s2.setIn([e3, "value"], r3));
  }), e2.setIn(["requestData", n, a2, "bodyValue"], o4);
}, [fo]: (e2, { payload: { value: t2, pathMethod: r2 } }) => {
  let [n, a2] = r2;
  return e2.setIn(["requestData", n, a2, "retainBodyValue"], t2);
}, [ho]: (e2, { payload: { value: t2, pathMethod: r2, name: n } }) => {
  let [a2, o4] = r2;
  return e2.setIn(["requestData", a2, o4, "bodyInclusion", n], t2);
}, [go]: (e2, { payload: { name: t2, pathMethod: r2, contextType: n, contextName: a2 } }) => {
  let [o4, s2] = r2;
  return e2.setIn(["examples", o4, s2, n, a2, "activeExample"], t2);
}, [yo]: (e2, { payload: { value: t2, pathMethod: r2 } }) => {
  let [n, a2] = r2;
  return e2.setIn(["requestData", n, a2, "requestContentType"], t2);
}, [Eo]: (e2, { payload: { value: t2, path: r2, method: n } }) => e2.setIn(["requestData", r2, n, "responseContentType"], t2), [So]: (e2, { payload: { server: t2, namespace: r2, key: n, val: a2 } }) => {
  const o4 = r2 ? [r2, "serverVariableValues", t2, n] : ["serverVariableValues", t2, n];
  return e2.setIn(o4, a2);
}, [_o]: (e2, { payload: { path: t2, method: r2, validationErrors: n } }) => {
  let a2 = [];
  if (a2.push("Required field is not provided"), n.missingBodyValue) return e2.setIn(["requestData", t2, r2, "errors"], (0, Qe.fromJS)(a2));
  if (n.missingRequiredKeys && n.missingRequiredKeys.length > 0) {
    const { missingRequiredKeys: o4 } = n;
    return e2.updateIn(["requestData", t2, r2, "bodyValue"], (0, Qe.fromJS)({}), (e3) => o4.reduce((e4, t3) => e4.setIn([t3, "errors"], (0, Qe.fromJS)(a2)), e3));
  }
  return console.warn("unexpected result: SET_REQUEST_BODY_VALIDATE_ERROR"), e2;
}, [vo]: (e2, { payload: { path: t2, method: r2 } }) => {
  const n = e2.getIn(["requestData", t2, r2, "bodyValue"]);
  if (!Qe.Map.isMap(n)) return e2.setIn(["requestData", t2, r2, "errors"], (0, Qe.fromJS)([]));
  const [...a2] = n.keys();
  return a2 ? e2.updateIn(["requestData", t2, r2, "bodyValue"], (0, Qe.fromJS)({}), (e3) => a2.reduce((e4, t3) => e4.setIn([t3, "errors"], (0, Qe.fromJS)([])), e3)) : e2;
}, [bo]: (e2, { payload: { pathMethod: t2 } }) => {
  let [r2, n] = t2;
  const a2 = e2.getIn(["requestData", r2, n, "bodyValue"]);
  return a2 ? Qe.Map.isMap(a2) ? e2.setIn(["requestData", r2, n, "bodyValue"], (0, Qe.Map)()) : e2.setIn(["requestData", r2, n, "bodyValue"], "") : e2;
} };
function oas3() {
  return { components: no, wrapComponents: uo, statePlugins: { spec: { wrapSelectors: ze, selectors: We }, auth: { wrapSelectors: Fe }, oas3: { actions: { ...He }, reducers: Lo, selectors: { ...Ge } } } };
}
var webhooks = ({ specSelectors: e2, getComponent: t2 }) => {
  const r2 = e2.selectWebhooksOperations(), n = Object.keys(r2), a2 = t2("OperationContainer", true);
  return 0 === n.length ? null : Xe.default.createElement("div", { className: "webhooks" }, Xe.default.createElement("h2", null, "Webhooks"), n.map((e3) => Xe.default.createElement("div", { key: `${e3}-webhook` }, r2[e3].map((t3) => Xe.default.createElement(a2, { key: `${e3}-${t3.method}-webhook`, op: t3.operation, tag: "webhooks", method: t3.method, path: e3, specPath: (0, Qe.List)(t3.specPath), allowTryItOut: false })))));
};
var components_license = ({ getComponent: e2, specSelectors: t2 }) => {
  const r2 = t2.selectLicenseNameField(), n = t2.selectLicenseUrl(), a2 = e2("Link");
  return Xe.default.createElement("div", { className: "info__license" }, n ? Xe.default.createElement("div", { className: "info__license__url" }, Xe.default.createElement(a2, { target: "_blank", href: sanitizeUrl2(n) }, r2)) : Xe.default.createElement("span", null, r2));
};
var components_contact = ({ getComponent: e2, specSelectors: t2 }) => {
  const r2 = t2.selectContactNameField(), n = t2.selectContactUrl(), a2 = t2.selectContactEmailField(), o4 = e2("Link");
  return Xe.default.createElement("div", { className: "info__contact" }, n && Xe.default.createElement("div", null, Xe.default.createElement(o4, { href: sanitizeUrl2(n), target: "_blank" }, r2, " - Website")), a2 && Xe.default.createElement(o4, { href: sanitizeUrl2(`mailto:${a2}`) }, n ? `Send email to ${r2}` : `Contact ${r2}`));
};
var oas31_components_info = ({ getComponent: e2, specSelectors: t2 }) => {
  const r2 = t2.version(), n = t2.url(), a2 = t2.basePath(), o4 = t2.host(), s2 = t2.selectInfoSummaryField(), l2 = t2.selectInfoDescriptionField(), i2 = t2.selectInfoTitleField(), c2 = t2.selectInfoTermsOfServiceUrl(), u2 = t2.selectExternalDocsUrl(), d2 = t2.selectExternalDocsDescriptionField(), p2 = t2.contact(), m2 = t2.license(), f2 = e2("Markdown", true), h2 = e2("Link"), g2 = e2("VersionStamp"), y2 = e2("OpenAPIVersion"), S = e2("InfoUrl"), _2 = e2("InfoBasePath"), v2 = e2("License", true), b = e2("Contact", true), w2 = e2("JsonSchemaDialect", true);
  return Xe.default.createElement("div", { className: "info" }, Xe.default.createElement("hgroup", { className: "main" }, Xe.default.createElement("h2", { className: "title" }, i2, Xe.default.createElement("span", null, r2 && Xe.default.createElement(g2, { version: r2 }), Xe.default.createElement(y2, { oasVersion: "3.1" }))), (o4 || a2) && Xe.default.createElement(_2, { host: o4, basePath: a2 }), n && Xe.default.createElement(S, { getComponent: e2, url: n })), s2 && Xe.default.createElement("p", { className: "info__summary" }, s2), Xe.default.createElement("div", { className: "info__description description" }, Xe.default.createElement(f2, { source: l2 })), c2 && Xe.default.createElement("div", { className: "info__tos" }, Xe.default.createElement(h2, { target: "_blank", href: sanitizeUrl2(c2) }, "Terms of service")), p2.size > 0 && Xe.default.createElement(b, null), m2.size > 0 && Xe.default.createElement(v2, null), u2 && Xe.default.createElement(h2, { className: "info__extdocs", target: "_blank", href: sanitizeUrl2(u2) }, d2 || u2), Xe.default.createElement(w2, null));
};
var json_schema_dialect = ({ getComponent: e2, specSelectors: t2 }) => {
  const r2 = t2.selectJsonSchemaDialectField(), n = t2.selectJsonSchemaDialectDefault(), a2 = e2("Link");
  return Xe.default.createElement(Xe.default.Fragment, null, r2 && r2 === n && Xe.default.createElement("p", { className: "info__jsonschemadialect" }, "JSON Schema dialect:", " ", Xe.default.createElement(a2, { target: "_blank", href: sanitizeUrl2(r2) }, r2)), r2 && r2 !== n && Xe.default.createElement("div", { className: "error-wrapper" }, Xe.default.createElement("div", { className: "no-margin" }, Xe.default.createElement("div", { className: "errors" }, Xe.default.createElement("div", { className: "errors-wrapper" }, Xe.default.createElement("h4", { className: "center" }, "Warning"), Xe.default.createElement("p", { className: "message" }, Xe.default.createElement("strong", null, "OpenAPI.jsonSchemaDialect"), " field contains a value different from the default value of", " ", Xe.default.createElement(a2, { target: "_blank", href: n }, n), ". Values different from the default one are currently not supported. Please either omit the field or provide it with the default value."))))));
};
var version_pragma_filter = ({ bypass: e2, isSwagger2: t2, isOAS3: r2, isOAS31: n, alsoShow: a2, children: o4 }) => e2 ? Xe.default.createElement("div", null, o4) : t2 && (r2 || n) ? Xe.default.createElement("div", { className: "version-pragma" }, a2, Xe.default.createElement("div", { className: "version-pragma__message version-pragma__message--ambiguous" }, Xe.default.createElement("div", null, Xe.default.createElement("h3", null, "Unable to render this definition"), Xe.default.createElement("p", null, Xe.default.createElement("code", null, "swagger"), " and ", Xe.default.createElement("code", null, "openapi"), " fields cannot be present in the same Swagger or OpenAPI definition. Please remove one of the fields."), Xe.default.createElement("p", null, "Supported version fields are ", Xe.default.createElement("code", null, 'swagger: "2.0"'), " and those that match ", Xe.default.createElement("code", null, "openapi: 3.x.y"), " (for example,", " ", Xe.default.createElement("code", null, "openapi: 3.1.0"), ").")))) : t2 || r2 || n ? Xe.default.createElement("div", null, o4) : Xe.default.createElement("div", { className: "version-pragma" }, a2, Xe.default.createElement("div", { className: "version-pragma__message version-pragma__message--missing" }, Xe.default.createElement("div", null, Xe.default.createElement("h3", null, "Unable to render this definition"), Xe.default.createElement("p", null, "The provided definition does not specify a valid version field."), Xe.default.createElement("p", null, "Please indicate a valid Swagger or OpenAPI version field. Supported version fields are ", Xe.default.createElement("code", null, 'swagger: "2.0"'), " and those that match ", Xe.default.createElement("code", null, "openapi: 3.x.y"), " (for example,", " ", Xe.default.createElement("code", null, "openapi: 3.1.0"), ")."))));
var getModelName = (e2) => "string" == typeof e2 && e2.includes("#/components/schemas/") ? ((e3) => {
  const t2 = e3.replace(/~1/g, "/").replace(/~0/g, "~");
  try {
    return decodeURIComponent(t2);
  } catch {
    return t2;
  }
})(e2.replace(/^.*#\/components\/schemas\//, "")) : null;
var Do = (0, Xe.forwardRef)(({ schema: e2, getComponent: t2, onToggle: r2 = () => {
} }, n) => {
  const a2 = t2("JSONSchema202012"), o4 = getModelName(e2.get("$$ref")), s2 = (0, Xe.useCallback)((e3, t3) => {
    r2(o4, t3);
  }, [o4, r2]);
  return Xe.default.createElement(a2, { name: o4, schema: e2.toJS(), ref: n, onExpand: s2 });
});
var Uo = Do;
var models = ({ specActions: e2, specSelectors: t2, layoutSelectors: r2, layoutActions: n, getComponent: a2, getConfigs: o4, fn: s2 }) => {
  const l2 = t2.selectSchemas(), i2 = Object.keys(l2).length > 0, c2 = ["components", "schemas"], { docExpansion: u2, defaultModelsExpandDepth: d2 } = o4(), p2 = d2 > 0 && "none" !== u2, m2 = r2.isShown(c2, p2), f2 = a2("Collapse"), h2 = a2("JSONSchema202012"), g2 = a2("ArrowUpIcon"), y2 = a2("ArrowDownIcon"), { getTitle: S } = s2.jsonSchema202012.useFn();
  (0, Xe.useEffect)(() => {
    const r3 = m2 && d2 > 1, n2 = null != t2.specResolvedSubtree(c2);
    r3 && !n2 && e2.requestResolvedSubtree(c2);
  }, [m2, d2]);
  const _2 = (0, Xe.useCallback)(() => {
    n.show(c2, !m2);
  }, [m2]), v2 = (0, Xe.useCallback)((e3) => {
    null !== e3 && n.readyToScroll(c2, e3);
  }, []), handleJSONSchema202012Ref = (e3) => (t3) => {
    null !== t3 && n.readyToScroll([...c2, e3], t3);
  }, handleJSONSchema202012Expand = (r3) => (n2, a3) => {
    if (a3) {
      const n3 = [...c2, r3];
      null != t2.specResolvedSubtree(n3) || e2.requestResolvedSubtree([...c2, r3]);
    }
  };
  return !i2 || d2 < 0 ? null : Xe.default.createElement("section", { className: (0, _r.default)("models", { "is-open": m2 }), ref: v2 }, Xe.default.createElement("h4", null, Xe.default.createElement("button", { "aria-expanded": m2, className: "models-control", onClick: _2 }, Xe.default.createElement("span", null, "Schemas"), m2 ? Xe.default.createElement(g2, null) : Xe.default.createElement(y2, null))), Xe.default.createElement(f2, { isOpened: m2 }, Object.entries(l2).map(([e3, t3]) => {
    const r3 = S(t3, { lookup: "basic" }) || e3;
    return Xe.default.createElement(h2, { key: e3, ref: handleJSONSchema202012Ref(e3), schema: t3, name: r3, onExpand: handleJSONSchema202012Expand(e3) });
  })));
};
var mutual_tls_auth = ({ schema: e2, getComponent: t2 }) => {
  const r2 = t2("JumpToPath", true);
  return Xe.default.createElement("div", null, Xe.default.createElement("h4", null, e2.get("name"), " (mutualTLS)", " ", Xe.default.createElement(r2, { path: ["securityDefinitions", e2.get("name")] })), Xe.default.createElement("p", null, "Mutual TLS is required by this API/Operation. Certificates are managed via your Operating System and/or your browser."), Xe.default.createElement("p", null, e2.get("description")));
};
var auths_Auths = class extends Xe.default.Component {
  constructor(e2, t2) {
    super(e2, t2);
    __publicField(this, "onAuthChange", (e2) => {
      let { name: t2 } = e2;
      this.setState({ [t2]: e2 });
    });
    __publicField(this, "submitAuth", (e2) => {
      e2.preventDefault();
      let { authActions: t2 } = this.props;
      t2.authorizeWithPersistOption(this.state);
    });
    __publicField(this, "logoutClick", (e2) => {
      e2.preventDefault();
      let { authActions: t2, definitions: r2 } = this.props, n = r2.map((e3, t3) => t3).toArray();
      this.setState(n.reduce((e3, t3) => (e3[t3] = "", e3), {})), t2.logoutWithPersistOption(n);
    });
    __publicField(this, "close", (e2) => {
      e2.preventDefault();
      let { authActions: t2 } = this.props;
      t2.showDefinitions(false);
    });
    this.state = {};
  }
  render() {
    let { definitions: e2, getComponent: t2, authSelectors: r2, errSelectors: n } = this.props;
    const a2 = t2("AuthItem"), o4 = t2("oauth2", true), s2 = t2("Button"), l2 = r2.authorized(), i2 = e2.filter((e3, t3) => !!l2.get(t3)), c2 = e2.filter((e3) => "oauth2" !== e3.get("type") && "mutualTLS" !== e3.get("type")), u2 = e2.filter((e3) => "oauth2" === e3.get("type")), d2 = e2.filter((e3) => "mutualTLS" === e3.get("type"));
    return Xe.default.createElement("div", { className: "auth-container" }, c2.size > 0 && Xe.default.createElement("form", { onSubmit: this.submitAuth }, c2.map((e3, r3) => Xe.default.createElement(a2, { key: r3, schema: e3, name: r3, getComponent: t2, onAuthChange: this.onAuthChange, authorized: l2, errSelectors: n })).toArray(), Xe.default.createElement("div", { className: "auth-btn-wrapper" }, c2.size === i2.size ? Xe.default.createElement(s2, { className: "btn modal-btn auth", onClick: this.logoutClick, "aria-label": "Remove authorization" }, "Logout") : Xe.default.createElement(s2, { type: "submit", className: "btn modal-btn auth authorize", "aria-label": "Apply credentials" }, "Authorize"), Xe.default.createElement(s2, { className: "btn modal-btn auth btn-done", onClick: this.close }, "Close"))), u2.size > 0 ? Xe.default.createElement("div", null, Xe.default.createElement("div", { className: "scope-def" }, Xe.default.createElement("p", null, "Scopes are used to grant an application different levels of access to data on behalf of the end user. Each API may declare one or more scopes."), Xe.default.createElement("p", null, "API requires the following scopes. Select which ones you want to grant to Swagger UI.")), e2.filter((e3) => "oauth2" === e3.get("type")).map((e3, t3) => Xe.default.createElement("div", { key: t3 }, Xe.default.createElement(o4, { authorized: l2, schema: e3, name: t3 }))).toArray()) : null, d2.size > 0 && Xe.default.createElement("div", null, d2.map((e3, r3) => Xe.default.createElement(a2, { key: r3, schema: e3, name: r3, getComponent: t2, onAuthChange: this.onAuthChange, authorized: l2, errSelectors: n })).toArray()));
  }
};
var $o = auths_Auths;
var isOAS31 = (e2) => {
  const t2 = e2.get("openapi");
  return "string" == typeof t2 && /^3\.1\.(?:[1-9]\d*|0)$/.test(t2);
};
var fn_createOnlyOAS31Selector = (e2) => (t2, ...r2) => (n) => {
  if (n.getSystem().specSelectors.isOAS31()) {
    const a2 = e2(t2, ...r2);
    return "function" == typeof a2 ? a2(n) : a2;
  }
  return null;
};
var createOnlyOAS31SelectorWrapper = (e2) => (t2, r2) => (n, ...a2) => {
  if (r2.getSystem().specSelectors.isOAS31()) {
    const o4 = e2(n, ...a2);
    return "function" == typeof o4 ? o4(t2, r2) : o4;
  }
  return t2(...a2);
};
var fn_createSystemSelector = (e2) => (t2, ...r2) => (n) => {
  const a2 = e2(t2, n, ...r2);
  return "function" == typeof a2 ? a2(n) : a2;
};
var createOnlyOAS31ComponentWrapper = (e2) => (t2, r2) => (n) => r2.specSelectors.isOAS31() ? Xe.default.createElement(e2, (0, cr.default)({}, n, { originalComponent: t2, getSystem: r2.getSystem })) : Xe.default.createElement(t2, n);
var Jo = createOnlyOAS31ComponentWrapper(({ getSystem: e2 }) => {
  const t2 = e2().getComponent("OAS31License", true);
  return Xe.default.createElement(t2, null);
});
var Vo = createOnlyOAS31ComponentWrapper(({ getSystem: e2 }) => {
  const t2 = e2().getComponent("OAS31Contact", true);
  return Xe.default.createElement(t2, null);
});
var Ko = createOnlyOAS31ComponentWrapper(({ getSystem: e2 }) => {
  const t2 = e2().getComponent("OAS31Info", true);
  return Xe.default.createElement(t2, null);
});
var zo = createOnlyOAS31ComponentWrapper(({ getSystem: e2, ...t2 }) => {
  const r2 = e2(), { getComponent: n, fn: a2, getConfigs: o4 } = r2, s2 = o4(), l2 = n("OAS31Model"), i2 = n("JSONSchema202012"), c2 = n("JSONSchema202012Keyword$schema"), u2 = n("JSONSchema202012Keyword$vocabulary"), d2 = n("JSONSchema202012Keyword$id"), p2 = n("JSONSchema202012Keyword$anchor"), m2 = n("JSONSchema202012Keyword$dynamicAnchor"), f2 = n("JSONSchema202012Keyword$ref"), h2 = n("JSONSchema202012Keyword$dynamicRef"), g2 = n("JSONSchema202012Keyword$defs"), y2 = n("JSONSchema202012Keyword$comment"), S = n("JSONSchema202012KeywordAllOf"), _2 = n("JSONSchema202012KeywordAnyOf"), v2 = n("JSONSchema202012KeywordOneOf"), b = n("JSONSchema202012KeywordNot"), w2 = n("JSONSchema202012KeywordIf"), C2 = n("JSONSchema202012KeywordThen"), x2 = n("JSONSchema202012KeywordElse"), O2 = n("JSONSchema202012KeywordDependentSchemas"), k = n("JSONSchema202012KeywordPrefixItems"), N2 = n("JSONSchema202012KeywordItems"), A2 = n("JSONSchema202012KeywordContains"), I = n("JSONSchema202012KeywordProperties"), R2 = n("JSONSchema202012KeywordPatternProperties"), T3 = n("JSONSchema202012KeywordAdditionalProperties"), B2 = n("JSONSchema202012KeywordPropertyNames"), j2 = n("JSONSchema202012KeywordUnevaluatedItems"), P2 = n("JSONSchema202012KeywordUnevaluatedProperties"), M2 = n("JSONSchema202012KeywordType"), q2 = n("JSONSchema202012KeywordEnum"), L2 = n("JSONSchema202012KeywordConst"), D = n("JSONSchema202012KeywordConstraint"), U = n("JSONSchema202012KeywordDependentRequired"), $ = n("JSONSchema202012KeywordContentSchema"), J = n("JSONSchema202012KeywordTitle"), V = n("JSONSchema202012KeywordDescription"), K = n("JSONSchema202012KeywordDefault"), z = n("JSONSchema202012KeywordDeprecated"), F2 = n("JSONSchema202012KeywordReadOnly"), W = n("JSONSchema202012KeywordWriteOnly"), H2 = n("JSONSchema202012Accordion"), G = n("JSONSchema202012ExpandDeepButton"), X2 = n("JSONSchema202012ChevronRightIcon"), Y2 = n("withJSONSchema202012Context")(l2, { config: { default$schema: "https://spec.openapis.org/oas/3.1/dialect/base", defaultExpandedLevels: s2.defaultModelExpandDepth, includeReadOnly: Boolean(t2.includeReadOnly), includeWriteOnly: Boolean(t2.includeWriteOnly) }, components: { JSONSchema: i2, Keyword$schema: c2, Keyword$vocabulary: u2, Keyword$id: d2, Keyword$anchor: p2, Keyword$dynamicAnchor: m2, Keyword$ref: f2, Keyword$dynamicRef: h2, Keyword$defs: g2, Keyword$comment: y2, KeywordAllOf: S, KeywordAnyOf: _2, KeywordOneOf: v2, KeywordNot: b, KeywordIf: w2, KeywordThen: C2, KeywordElse: x2, KeywordDependentSchemas: O2, KeywordPrefixItems: k, KeywordItems: N2, KeywordContains: A2, KeywordProperties: I, KeywordPatternProperties: R2, KeywordAdditionalProperties: T3, KeywordPropertyNames: B2, KeywordUnevaluatedItems: j2, KeywordUnevaluatedProperties: P2, KeywordType: M2, KeywordEnum: q2, KeywordConst: L2, KeywordConstraint: D, KeywordDependentRequired: U, KeywordContentSchema: $, KeywordTitle: J, KeywordDescription: V, KeywordDefault: K, KeywordDeprecated: z, KeywordReadOnly: F2, KeywordWriteOnly: W, Accordion: H2, ExpandDeepButton: G, ChevronRightIcon: X2 }, fn: { upperFirst: a2.upperFirst, isExpandable: a2.jsonSchema202012.isExpandable, getProperties: a2.jsonSchema202012.getProperties } });
  return Xe.default.createElement(Y2, t2);
});
var Fo = zo;
var Wo = createOnlyOAS31ComponentWrapper(({ getSystem: e2 }) => {
  const { getComponent: t2, fn: r2, getConfigs: n } = e2(), a2 = n();
  if (Wo.ModelsWithJSONSchemaContext) return Xe.default.createElement(Wo.ModelsWithJSONSchemaContext, null);
  const o4 = t2("OAS31Models", true), s2 = t2("JSONSchema202012"), l2 = t2("JSONSchema202012Keyword$schema"), i2 = t2("JSONSchema202012Keyword$vocabulary"), c2 = t2("JSONSchema202012Keyword$id"), u2 = t2("JSONSchema202012Keyword$anchor"), d2 = t2("JSONSchema202012Keyword$dynamicAnchor"), p2 = t2("JSONSchema202012Keyword$ref"), m2 = t2("JSONSchema202012Keyword$dynamicRef"), f2 = t2("JSONSchema202012Keyword$defs"), h2 = t2("JSONSchema202012Keyword$comment"), g2 = t2("JSONSchema202012KeywordAllOf"), y2 = t2("JSONSchema202012KeywordAnyOf"), S = t2("JSONSchema202012KeywordOneOf"), _2 = t2("JSONSchema202012KeywordNot"), v2 = t2("JSONSchema202012KeywordIf"), b = t2("JSONSchema202012KeywordThen"), w2 = t2("JSONSchema202012KeywordElse"), C2 = t2("JSONSchema202012KeywordDependentSchemas"), x2 = t2("JSONSchema202012KeywordPrefixItems"), O2 = t2("JSONSchema202012KeywordItems"), k = t2("JSONSchema202012KeywordContains"), N2 = t2("JSONSchema202012KeywordProperties"), A2 = t2("JSONSchema202012KeywordPatternProperties"), I = t2("JSONSchema202012KeywordAdditionalProperties"), R2 = t2("JSONSchema202012KeywordPropertyNames"), T3 = t2("JSONSchema202012KeywordUnevaluatedItems"), B2 = t2("JSONSchema202012KeywordUnevaluatedProperties"), j2 = t2("JSONSchema202012KeywordType"), P2 = t2("JSONSchema202012KeywordEnum"), M2 = t2("JSONSchema202012KeywordConst"), q2 = t2("JSONSchema202012KeywordConstraint"), L2 = t2("JSONSchema202012KeywordDependentRequired"), D = t2("JSONSchema202012KeywordContentSchema"), U = t2("JSONSchema202012KeywordTitle"), $ = t2("JSONSchema202012KeywordDescription"), J = t2("JSONSchema202012KeywordDefault"), V = t2("JSONSchema202012KeywordDeprecated"), K = t2("JSONSchema202012KeywordReadOnly"), z = t2("JSONSchema202012KeywordWriteOnly"), F2 = t2("JSONSchema202012Accordion"), W = t2("JSONSchema202012ExpandDeepButton"), H2 = t2("JSONSchema202012ChevronRightIcon"), G = t2("withJSONSchema202012Context");
  return Wo.ModelsWithJSONSchemaContext = G(o4, { config: { default$schema: "https://spec.openapis.org/oas/3.1/dialect/base", defaultExpandedLevels: a2.defaultModelsExpandDepth - 1, includeReadOnly: true, includeWriteOnly: true }, components: { JSONSchema: s2, Keyword$schema: l2, Keyword$vocabulary: i2, Keyword$id: c2, Keyword$anchor: u2, Keyword$dynamicAnchor: d2, Keyword$ref: p2, Keyword$dynamicRef: m2, Keyword$defs: f2, Keyword$comment: h2, KeywordAllOf: g2, KeywordAnyOf: y2, KeywordOneOf: S, KeywordNot: _2, KeywordIf: v2, KeywordThen: b, KeywordElse: w2, KeywordDependentSchemas: C2, KeywordPrefixItems: x2, KeywordItems: O2, KeywordContains: k, KeywordProperties: N2, KeywordPatternProperties: A2, KeywordAdditionalProperties: I, KeywordPropertyNames: R2, KeywordUnevaluatedItems: T3, KeywordUnevaluatedProperties: B2, KeywordType: j2, KeywordEnum: P2, KeywordConst: M2, KeywordConstraint: q2, KeywordDependentRequired: L2, KeywordContentSchema: D, KeywordTitle: U, KeywordDescription: $, KeywordDefault: J, KeywordDeprecated: V, KeywordReadOnly: K, KeywordWriteOnly: z, Accordion: F2, ExpandDeepButton: W, ChevronRightIcon: H2 }, fn: { upperFirst: r2.upperFirst, isExpandable: r2.jsonSchema202012.isExpandable, getProperties: r2.jsonSchema202012.getProperties } }), Xe.default.createElement(Wo.ModelsWithJSONSchemaContext, null);
});
Wo.ModelsWithJSONSchemaContext = null;
var Ho = Wo;
var wrap_components_version_pragma_filter = (e2, t2) => (e3) => {
  const r2 = t2.specSelectors.isOAS31(), n = t2.getComponent("OAS31VersionPragmaFilter");
  return Xe.default.createElement(n, (0, cr.default)({ isOAS31: r2 }, e3));
};
var Go = createOnlyOAS31ComponentWrapper(({ originalComponent: e2, ...t2 }) => {
  const { getComponent: r2, schema: n } = t2, a2 = r2("MutualTLSAuth", true);
  return "mutualTLS" === n.get("type") ? Xe.default.createElement(a2, { schema: n }) : Xe.default.createElement(e2, t2);
});
var Xo = Go;
var Yo = createOnlyOAS31ComponentWrapper(({ getSystem: e2, ...t2 }) => {
  const r2 = e2().getComponent("OAS31Auths", true);
  return Xe.default.createElement(r2, t2);
});
var Qo = (0, Qe.Map)();
var Zo = (0, Dt.createSelector)((e2, t2) => t2.specSelectors.specJson(), isOAS31);
var selectors_webhooks = () => (e2) => {
  const t2 = e2.specSelectors.specJson().get("webhooks");
  return Qe.Map.isMap(t2) ? t2 : Qo;
};
var es = (0, Dt.createSelector)([(e2, t2) => t2.specSelectors.webhooks(), (e2, t2) => t2.specSelectors.validOperationMethods(), (e2, t2) => t2.specSelectors.specResolvedSubtree(["webhooks"])], (e2, t2) => e2.reduce((e3, r2, n) => {
  if (!Qe.Map.isMap(r2)) return e3;
  const a2 = r2.entrySeq().filter(([e4]) => t2.includes(e4)).map(([e4, t3]) => ({ operation: (0, Qe.Map)({ operation: t3 }), method: e4, path: n, specPath: ["webhooks", n, e4] }));
  return e3.concat(a2);
}, (0, Qe.List)()).groupBy((e3) => e3.path).map((e3) => e3.toArray()).toObject());
var selectors_license = () => (e2) => {
  const t2 = e2.specSelectors.info().get("license");
  return Qe.Map.isMap(t2) ? t2 : Qo;
};
var selectLicenseNameField = () => (e2) => e2.specSelectors.license().get("name", "License");
var selectLicenseUrlField = () => (e2) => e2.specSelectors.license().get("url");
var ts = (0, Dt.createSelector)([(e2, t2) => t2.specSelectors.url(), (e2, t2) => t2.oas3Selectors.selectedServer(), (e2, t2) => t2.specSelectors.selectLicenseUrlField()], (e2, t2, r2) => {
  if (r2) return safeBuildUrl(r2, e2, { selectedServer: t2 });
});
var selectLicenseIdentifierField = () => (e2) => e2.specSelectors.license().get("identifier");
var selectors_contact = () => (e2) => {
  const t2 = e2.specSelectors.info().get("contact");
  return Qe.Map.isMap(t2) ? t2 : Qo;
};
var selectContactNameField = () => (e2) => e2.specSelectors.contact().get("name", "the developer");
var selectContactEmailField = () => (e2) => e2.specSelectors.contact().get("email");
var selectContactUrlField = () => (e2) => e2.specSelectors.contact().get("url");
var rs = (0, Dt.createSelector)([(e2, t2) => t2.specSelectors.url(), (e2, t2) => t2.oas3Selectors.selectedServer(), (e2, t2) => t2.specSelectors.selectContactUrlField()], (e2, t2, r2) => {
  if (r2) return safeBuildUrl(r2, e2, { selectedServer: t2 });
});
var selectInfoTitleField = () => (e2) => e2.specSelectors.info().get("title");
var selectInfoSummaryField = () => (e2) => e2.specSelectors.info().get("summary");
var selectInfoDescriptionField = () => (e2) => e2.specSelectors.info().get("description");
var selectInfoTermsOfServiceField = () => (e2) => e2.specSelectors.info().get("termsOfService");
var ns = (0, Dt.createSelector)([(e2, t2) => t2.specSelectors.url(), (e2, t2) => t2.oas3Selectors.selectedServer(), (e2, t2) => t2.specSelectors.selectInfoTermsOfServiceField()], (e2, t2, r2) => {
  if (r2) return safeBuildUrl(r2, e2, { selectedServer: t2 });
});
var selectExternalDocsDescriptionField = () => (e2) => e2.specSelectors.externalDocs().get("description");
var selectExternalDocsUrlField = () => (e2) => e2.specSelectors.externalDocs().get("url");
var as = (0, Dt.createSelector)([(e2, t2) => t2.specSelectors.url(), (e2, t2) => t2.oas3Selectors.selectedServer(), (e2, t2) => t2.specSelectors.selectExternalDocsUrlField()], (e2, t2, r2) => {
  if (r2) return safeBuildUrl(r2, e2, { selectedServer: t2 });
});
var selectJsonSchemaDialectField = () => (e2) => e2.specSelectors.specJson().get("jsonSchemaDialect");
var selectJsonSchemaDialectDefault = () => "https://spec.openapis.org/oas/3.1/dialect/base";
var os = (0, Dt.createSelector)((e2, t2) => t2.specSelectors.definitions(), (e2, t2) => t2.specSelectors.specResolvedSubtree(["components", "schemas"]), (e2, t2) => Qe.Map.isMap(e2) ? Qe.Map.isMap(t2) ? Object.entries(e2.toJS()).reduce((e3, [r2, n]) => {
  const a2 = t2.get(r2);
  return e3[r2] = (a2 == null ? void 0 : a2.toJS()) || n, e3;
}, {}) : e2.toJS() : {});
var wrap_selectors_isOAS3 = (e2, t2) => (r2, ...n) => t2.specSelectors.isOAS31() || e2(...n);
var ss = createOnlyOAS31SelectorWrapper(() => (e2, t2) => t2.oas31Selectors.selectLicenseUrl());
var ls = createOnlyOAS31SelectorWrapper(() => (e2, t2) => {
  const r2 = t2.specSelectors.securityDefinitions();
  let n = e2();
  return r2 ? (r2.entrySeq().forEach(([e3, t3]) => {
    "mutualTLS" === t3.get("type") && (n = n.push(new Qe.Map({ [e3]: t3 })));
  }), n) : n;
});
var is5 = (0, Dt.createSelector)([(e2, t2) => t2.specSelectors.url(), (e2, t2) => t2.oas3Selectors.selectedServer(), (e2, t2) => t2.specSelectors.selectLicenseUrlField(), (e2, t2) => t2.specSelectors.selectLicenseIdentifierField()], (e2, t2, r2, n) => r2 ? safeBuildUrl(r2, e2, { selectedServer: t2 }) : n ? `https://spdx.org/licenses/${n}.html` : void 0);
var keywords_Example = ({ schema: e2, getSystem: t2 }) => {
  const { fn: r2 } = t2(), { hasKeyword: n, stringify: a2 } = r2.jsonSchema202012.useFn();
  return n(e2, "example") ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--example" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "Example"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--const" }, a2(e2.example))) : null;
};
var keywords_Xml = ({ schema: e2, getSystem: t2 }) => {
  const r2 = (e2 == null ? void 0 : e2.xml) || {}, { fn: n, getComponent: a2 } = t2(), { useIsExpandedDeeply: o4, useComponent: s2 } = n.jsonSchema202012, l2 = o4(), i2 = !!(r2.name || r2.namespace || r2.prefix), [c2, u2] = (0, Xe.useState)(l2), [d2, p2] = (0, Xe.useState)(false), m2 = s2("Accordion"), f2 = s2("ExpandDeepButton"), h2 = a2("JSONSchema202012DeepExpansionContext")(), g2 = (0, Xe.useCallback)(() => {
    u2((e3) => !e3);
  }, []), y2 = (0, Xe.useCallback)((e3, t3) => {
    u2(t3), p2(t3);
  }, []);
  return 0 === Object.keys(r2).length ? null : Xe.default.createElement(h2.Provider, { value: d2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--xml" }, i2 ? Xe.default.createElement(Xe.default.Fragment, null, Xe.default.createElement(m2, { expanded: c2, onChange: g2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "XML")), Xe.default.createElement(f2, { expanded: c2, onClick: y2 })) : Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "XML"), true === r2.attribute && Xe.default.createElement("span", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--muted" }, "attribute"), true === r2.wrapped && Xe.default.createElement("span", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--muted" }, "wrapped"), Xe.default.createElement("strong", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--primary" }, "object"), Xe.default.createElement("ul", { className: (0, _r.default)("json-schema-2020-12-keyword__children", { "json-schema-2020-12-keyword__children--collapsed": !c2 }) }, c2 && Xe.default.createElement(Xe.default.Fragment, null, r2.name && Xe.default.createElement("li", { className: "json-schema-2020-12-property" }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "name"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, r2.name))), r2.namespace && Xe.default.createElement("li", { className: "json-schema-2020-12-property" }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "namespace"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, r2.namespace))), r2.prefix && Xe.default.createElement("li", { className: "json-schema-2020-12-property" }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "prefix"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, r2.prefix)))))));
};
var Discriminator_DiscriminatorMapping = ({ discriminator: e2 }) => {
  const t2 = (e2 == null ? void 0 : e2.mapping) || {};
  return 0 === Object.keys(t2).length ? null : Object.entries(t2).map(([e3, t3]) => Xe.default.createElement("div", { key: `${e3}-${t3}`, className: "json-schema-2020-12-keyword" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, e3), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, t3)));
};
var Discriminator_Discriminator = ({ schema: e2, getSystem: t2 }) => {
  const r2 = (e2 == null ? void 0 : e2.discriminator) || {}, { fn: n, getComponent: a2 } = t2(), { useIsExpandedDeeply: o4, useComponent: s2 } = n.jsonSchema202012, l2 = o4(), i2 = !!r2.mapping, [c2, u2] = (0, Xe.useState)(l2), [d2, p2] = (0, Xe.useState)(false), m2 = s2("Accordion"), f2 = s2("ExpandDeepButton"), h2 = a2("JSONSchema202012DeepExpansionContext")(), g2 = (0, Xe.useCallback)(() => {
    u2((e3) => !e3);
  }, []), y2 = (0, Xe.useCallback)((e3, t3) => {
    u2(t3), p2(t3);
  }, []);
  return 0 === Object.keys(r2).length ? null : Xe.default.createElement(h2.Provider, { value: d2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--discriminator" }, i2 ? Xe.default.createElement(Xe.default.Fragment, null, Xe.default.createElement(m2, { expanded: c2, onChange: g2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "Discriminator")), Xe.default.createElement(f2, { expanded: c2, onClick: y2 })) : Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "Discriminator"), r2.propertyName && Xe.default.createElement("span", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--muted" }, r2.propertyName), Xe.default.createElement("strong", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--primary" }, "object"), Xe.default.createElement("ul", { className: (0, _r.default)("json-schema-2020-12-keyword__children", { "json-schema-2020-12-keyword__children--collapsed": !c2 }) }, c2 && Xe.default.createElement("li", { className: "json-schema-2020-12-property" }, Xe.default.createElement(Discriminator_DiscriminatorMapping, { discriminator: r2 })))));
};
var keywords_ExternalDocs = ({ schema: e2, getSystem: t2 }) => {
  const r2 = (e2 == null ? void 0 : e2.externalDocs) || {}, { fn: n, getComponent: a2 } = t2(), { useIsExpandedDeeply: o4, useComponent: s2 } = n.jsonSchema202012, l2 = o4(), i2 = !(!r2.description && !r2.url), [c2, u2] = (0, Xe.useState)(l2), [d2, p2] = (0, Xe.useState)(false), m2 = s2("Accordion"), f2 = s2("ExpandDeepButton"), h2 = a2("JSONSchema202012KeywordDescription"), g2 = a2("Link"), y2 = a2("JSONSchema202012DeepExpansionContext")(), S = (0, Xe.useCallback)(() => {
    u2((e3) => !e3);
  }, []), _2 = (0, Xe.useCallback)((e3, t3) => {
    u2(t3), p2(t3);
  }, []);
  return 0 === Object.keys(r2).length ? null : Xe.default.createElement(y2.Provider, { value: d2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--externalDocs" }, i2 ? Xe.default.createElement(Xe.default.Fragment, null, Xe.default.createElement(m2, { expanded: c2, onChange: S }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "External documentation")), Xe.default.createElement(f2, { expanded: c2, onClick: _2 })) : Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "External documentation"), Xe.default.createElement("strong", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--primary" }, "object"), Xe.default.createElement("ul", { className: (0, _r.default)("json-schema-2020-12-keyword__children", { "json-schema-2020-12-keyword__children--collapsed": !c2 }) }, c2 && Xe.default.createElement(Xe.default.Fragment, null, r2.description && Xe.default.createElement("li", { className: "json-schema-2020-12-property" }, Xe.default.createElement(h2, { schema: r2, getSystem: t2 })), r2.url && Xe.default.createElement("li", { className: "json-schema-2020-12-property" }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "url"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, Xe.default.createElement(g2, { target: "_blank", href: sanitizeUrl2(r2.url) }, r2.url))))))));
};
var keywords_Description = ({ schema: e2, getSystem: t2 }) => {
  if (!(e2 == null ? void 0 : e2.description)) return null;
  const { getComponent: r2 } = t2(), n = r2("Markdown");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--description" }, Xe.default.createElement("div", { className: "json-schema-2020-12-core-keyword__value json-schema-2020-12-core-keyword__value--secondary" }, Xe.default.createElement(n, { source: e2.description })));
};
var cs = createOnlyOAS31ComponentWrapper(keywords_Description);
var us = createOnlyOAS31ComponentWrapper(({ schema: e2, getSystem: t2, originalComponent: r2 }) => {
  const { getComponent: n } = t2(), a2 = n("JSONSchema202012KeywordDiscriminator"), o4 = n("JSONSchema202012KeywordXml"), s2 = n("JSONSchema202012KeywordExample"), l2 = n("JSONSchema202012KeywordExternalDocs");
  return Xe.default.createElement(Xe.default.Fragment, null, Xe.default.createElement(r2, { schema: e2 }), Xe.default.createElement(a2, { schema: e2, getSystem: t2 }), Xe.default.createElement(o4, { schema: e2, getSystem: t2 }), Xe.default.createElement(l2, { schema: e2, getSystem: t2 }), Xe.default.createElement(s2, { schema: e2, getSystem: t2 }));
});
var ds = us;
var keywords_Properties = ({ schema: e2, getSystem: t2 }) => {
  const { fn: r2 } = t2(), { useComponent: n } = r2.jsonSchema202012, { getDependentRequired: a2, getProperties: o4 } = r2.jsonSchema202012.useFn(), s2 = r2.jsonSchema202012.useConfig(), l2 = Array.isArray(e2 == null ? void 0 : e2.required) ? e2.required : [], i2 = n("JSONSchema"), c2 = o4(e2, s2);
  return 0 === Object.keys(c2).length ? null : Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--properties" }, Xe.default.createElement("ul", null, Object.entries(c2).map(([t3, r3]) => {
    const n2 = l2.includes(t3), o5 = a2(t3, e2);
    return Xe.default.createElement("li", { key: t3, className: (0, _r.default)("json-schema-2020-12-property", { "json-schema-2020-12-property--required": n2 }) }, Xe.default.createElement(i2, { name: t3, schema: r3, dependentRequired: o5 }));
  })));
};
var ps = createOnlyOAS31ComponentWrapper(keywords_Properties);
var getProperties = (e2, { includeReadOnly: t2, includeWriteOnly: r2 }) => {
  if (!(e2 == null ? void 0 : e2.properties)) return {};
  const n = Object.entries(e2.properties).filter(([, e3]) => (!(true === (e3 == null ? void 0 : e3.readOnly)) || t2) && (!(true === (e3 == null ? void 0 : e3.writeOnly)) || r2));
  return Object.fromEntries(n);
};
var ms = function oas31_after_load_afterLoad({ fn: e2, getSystem: t2 }) {
  if (e2.jsonSchema202012) {
    const r2 = ((e3, t3) => {
      const { fn: r3 } = t3();
      if ("function" != typeof e3) return null;
      const { hasKeyword: n } = r3.jsonSchema202012;
      return (t4) => e3(t4) || n(t4, "example") || (t4 == null ? void 0 : t4.xml) || (t4 == null ? void 0 : t4.discriminator) || (t4 == null ? void 0 : t4.externalDocs);
    })(e2.jsonSchema202012.isExpandable, t2);
    Object.assign(this.fn.jsonSchema202012, { isExpandable: r2, getProperties });
  }
  if ("function" == typeof e2.sampleFromSchema && e2.jsonSchema202012) {
    const r2 = ((e3, t3) => {
      const { fn: r3, specSelectors: n } = t3;
      return Object.fromEntries(Object.entries(e3).map(([e4, t4]) => {
        const a2 = r3[e4];
        return [e4, (...e5) => n.isOAS31() ? t4(...e5) : "function" == typeof a2 ? a2(...e5) : void 0];
      }));
    })({ sampleFromSchema: e2.jsonSchema202012.sampleFromSchema, sampleFromSchemaGeneric: e2.jsonSchema202012.sampleFromSchemaGeneric, createXMLExample: e2.jsonSchema202012.createXMLExample, memoizedSampleFromSchema: e2.jsonSchema202012.memoizedSampleFromSchema, memoizedCreateXMLExample: e2.jsonSchema202012.memoizedCreateXMLExample, getJsonSampleSchema: e2.jsonSchema202012.getJsonSampleSchema, getYamlSampleSchema: e2.jsonSchema202012.getYamlSampleSchema, getXmlSampleSchema: e2.jsonSchema202012.getXmlSampleSchema, getSampleSchema: e2.jsonSchema202012.getSampleSchema, mergeJsonSchema: e2.jsonSchema202012.mergeJsonSchema }, t2());
    Object.assign(this.fn, r2);
  }
};
var oas31 = ({ fn: e2 }) => {
  const t2 = e2.createSystemSelector || fn_createSystemSelector, r2 = e2.createOnlyOAS31Selector || fn_createOnlyOAS31Selector;
  return { afterLoad: ms, fn: { isOAS31, createSystemSelector: fn_createSystemSelector, createOnlyOAS31Selector: fn_createOnlyOAS31Selector }, components: { Webhooks: webhooks, JsonSchemaDialect: json_schema_dialect, MutualTLSAuth: mutual_tls_auth, OAS31Info: oas31_components_info, OAS31License: components_license, OAS31Contact: components_contact, OAS31VersionPragmaFilter: version_pragma_filter, OAS31Model: Uo, OAS31Models: models, OAS31Auths: $o, JSONSchema202012KeywordExample: keywords_Example, JSONSchema202012KeywordXml: keywords_Xml, JSONSchema202012KeywordDiscriminator: Discriminator_Discriminator, JSONSchema202012KeywordExternalDocs: keywords_ExternalDocs }, wrapComponents: { InfoContainer: Ko, License: Jo, Contact: Vo, VersionPragmaFilter: wrap_components_version_pragma_filter, Model: Fo, Models: Ho, AuthItem: Xo, auths: Yo, JSONSchema202012KeywordDescription: cs, JSONSchema202012KeywordDefault: ds, JSONSchema202012KeywordProperties: ps }, statePlugins: { auth: { wrapSelectors: { definitionsToAuthorize: ls } }, spec: { selectors: { isOAS31: t2(Zo), license: selectors_license, selectLicenseNameField, selectLicenseUrlField, selectLicenseIdentifierField: r2(selectLicenseIdentifierField), selectLicenseUrl: t2(ts), contact: selectors_contact, selectContactNameField, selectContactEmailField, selectContactUrlField, selectContactUrl: t2(rs), selectInfoTitleField, selectInfoSummaryField: r2(selectInfoSummaryField), selectInfoDescriptionField, selectInfoTermsOfServiceField, selectInfoTermsOfServiceUrl: t2(ns), selectExternalDocsDescriptionField, selectExternalDocsUrlField, selectExternalDocsUrl: t2(as), webhooks: r2(selectors_webhooks), selectWebhooksOperations: r2(t2(es)), selectJsonSchemaDialectField, selectJsonSchemaDialectDefault, selectSchemas: t2(os) }, wrapSelectors: { isOAS3: wrap_selectors_isOAS3, selectLicenseUrl: ss } }, oas31: { selectors: { selectLicenseUrl: r2(t2(is5)) } } } };
};
var fs = Kt.default.object;
var hs = Kt.default.bool;
var gs = (Kt.default.oneOfType([fs, hs]), (0, Xe.createContext)(null));
gs.displayName = "JSONSchemaContext";
var ys = (0, Xe.createContext)(0);
ys.displayName = "JSONSchemaLevelContext";
var Es = (0, Xe.createContext)(false);
Es.displayName = "JSONSchemaDeepExpansionContext";
var Ss = (0, Xe.createContext)(/* @__PURE__ */ new Set());
var useConfig = () => {
  const { config: e2 } = (0, Xe.useContext)(gs);
  return e2;
};
var useComponent = (e2) => {
  const { components: t2 } = (0, Xe.useContext)(gs);
  return t2[e2] || null;
};
var useFn = (e2 = void 0) => {
  const { fn: t2 } = (0, Xe.useContext)(gs);
  return void 0 !== e2 ? t2[e2] : t2;
};
var useLevel = () => {
  const e2 = (0, Xe.useContext)(ys);
  return [e2, e2 + 1];
};
var useIsExpanded = () => {
  const [e2] = useLevel(), { defaultExpandedLevels: t2 } = useConfig();
  return t2 - e2 > 0;
};
var useIsExpandedDeeply = () => (0, Xe.useContext)(Es);
var useRenderedSchemas = (e2 = void 0) => {
  if (void 0 === e2) return (0, Xe.useContext)(Ss);
  const t2 = (0, Xe.useContext)(Ss);
  return /* @__PURE__ */ new Set([...t2, e2]);
};
var _s = (0, Xe.forwardRef)(({ schema: e2, name: t2 = "", dependentRequired: r2 = [], onExpand: n = () => {
} }, a2) => {
  const o4 = useFn(), s2 = useIsExpanded(), l2 = useIsExpandedDeeply(), [i2, c2] = (0, Xe.useState)(s2 || l2), [u2, d2] = (0, Xe.useState)(l2), [p2, m2] = useLevel(), f2 = (() => {
    const [e3] = useLevel();
    return e3 > 0;
  })(), h2 = o4.isExpandable(e2) || r2.length > 0, g2 = ((e3) => useRenderedSchemas().has(e3))(e2), y2 = useRenderedSchemas(e2), S = o4.stringifyConstraints(e2), _2 = useComponent("Accordion"), v2 = useComponent("Keyword$schema"), b = useComponent("Keyword$vocabulary"), w2 = useComponent("Keyword$id"), C2 = useComponent("Keyword$anchor"), x2 = useComponent("Keyword$dynamicAnchor"), O2 = useComponent("Keyword$ref"), k = useComponent("Keyword$dynamicRef"), N2 = useComponent("Keyword$defs"), A2 = useComponent("Keyword$comment"), I = useComponent("KeywordAllOf"), R2 = useComponent("KeywordAnyOf"), T3 = useComponent("KeywordOneOf"), B2 = useComponent("KeywordNot"), j2 = useComponent("KeywordIf"), P2 = useComponent("KeywordThen"), M2 = useComponent("KeywordElse"), q2 = useComponent("KeywordDependentSchemas"), L2 = useComponent("KeywordPrefixItems"), D = useComponent("KeywordItems"), U = useComponent("KeywordContains"), $ = useComponent("KeywordProperties"), J = useComponent("KeywordPatternProperties"), V = useComponent("KeywordAdditionalProperties"), K = useComponent("KeywordPropertyNames"), z = useComponent("KeywordUnevaluatedItems"), F2 = useComponent("KeywordUnevaluatedProperties"), W = useComponent("KeywordType"), H2 = useComponent("KeywordEnum"), G = useComponent("KeywordConst"), X2 = useComponent("KeywordConstraint"), Y2 = useComponent("KeywordDependentRequired"), Q = useComponent("KeywordContentSchema"), Z = useComponent("KeywordTitle"), ee = useComponent("KeywordDescription"), te = useComponent("KeywordDefault"), re = useComponent("KeywordDeprecated"), ne = useComponent("KeywordReadOnly"), ae = useComponent("KeywordWriteOnly"), oe = useComponent("ExpandDeepButton");
  (0, Xe.useEffect)(() => {
    d2(l2);
  }, [l2]), (0, Xe.useEffect)(() => {
    d2(u2);
  }, [u2]);
  const se = (0, Xe.useCallback)((e3, t3) => {
    c2(t3), !t3 && d2(false), n(e3, t3, false);
  }, [n]), le = (0, Xe.useCallback)((e3, t3) => {
    c2(t3), d2(t3), n(e3, t3, true);
  }, [n]);
  return Xe.default.createElement(ys.Provider, { value: m2 }, Xe.default.createElement(Es.Provider, { value: u2 }, Xe.default.createElement(Ss.Provider, { value: y2 }, Xe.default.createElement("article", { ref: a2, "data-json-schema-level": p2, className: (0, _r.default)("json-schema-2020-12", { "json-schema-2020-12--embedded": f2, "json-schema-2020-12--circular": g2 }) }, Xe.default.createElement("div", { className: "json-schema-2020-12-head" }, h2 && !g2 ? Xe.default.createElement(Xe.default.Fragment, null, Xe.default.createElement(_2, { expanded: i2, onChange: se }, Xe.default.createElement(Z, { title: t2, schema: e2 })), Xe.default.createElement(oe, { expanded: i2, onClick: le })) : Xe.default.createElement(Z, { title: t2, schema: e2 }), Xe.default.createElement(re, { schema: e2 }), Xe.default.createElement(ne, { schema: e2 }), Xe.default.createElement(ae, { schema: e2 }), Xe.default.createElement(W, { schema: e2, isCircular: g2 }), S.length > 0 && S.map((e3) => Xe.default.createElement(X2, { key: `${e3.scope}-${e3.value}`, constraint: e3 }))), Xe.default.createElement("div", { className: (0, _r.default)("json-schema-2020-12-body", { "json-schema-2020-12-body--collapsed": !i2 }) }, i2 && Xe.default.createElement(Xe.default.Fragment, null, Xe.default.createElement(ee, { schema: e2 }), !g2 && h2 && Xe.default.createElement(Xe.default.Fragment, null, Xe.default.createElement($, { schema: e2 }), Xe.default.createElement(J, { schema: e2 }), Xe.default.createElement(V, { schema: e2 }), Xe.default.createElement(F2, { schema: e2 }), Xe.default.createElement(K, { schema: e2 }), Xe.default.createElement(I, { schema: e2 }), Xe.default.createElement(R2, { schema: e2 }), Xe.default.createElement(T3, { schema: e2 }), Xe.default.createElement(B2, { schema: e2 }), Xe.default.createElement(j2, { schema: e2 }), Xe.default.createElement(P2, { schema: e2 }), Xe.default.createElement(M2, { schema: e2 }), Xe.default.createElement(q2, { schema: e2 }), Xe.default.createElement(L2, { schema: e2 }), Xe.default.createElement(D, { schema: e2 }), Xe.default.createElement(z, { schema: e2 }), Xe.default.createElement(U, { schema: e2 }), Xe.default.createElement(Q, { schema: e2 })), Xe.default.createElement(H2, { schema: e2 }), Xe.default.createElement(G, { schema: e2 }), Xe.default.createElement(Y2, { schema: e2, dependentRequired: r2 }), Xe.default.createElement(te, { schema: e2 }), Xe.default.createElement(v2, { schema: e2 }), Xe.default.createElement(b, { schema: e2 }), Xe.default.createElement(w2, { schema: e2 }), Xe.default.createElement(C2, { schema: e2 }), Xe.default.createElement(x2, { schema: e2 }), Xe.default.createElement(O2, { schema: e2 }), !g2 && h2 && Xe.default.createElement(N2, { schema: e2 }), Xe.default.createElement(k, { schema: e2 }), Xe.default.createElement(A2, { schema: e2 })))))));
});
var vs = _s;
var keywords_$schema = ({ schema: e2 }) => (e2 == null ? void 0 : e2.$schema) ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--$schema" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "$schema"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, e2.$schema)) : null;
var $vocabulary_$vocabulary = ({ schema: e2 }) => {
  const t2 = useIsExpanded(), r2 = useIsExpandedDeeply(), [n, a2] = (0, Xe.useState)(t2 || r2), o4 = useComponent("Accordion"), s2 = (0, Xe.useCallback)(() => {
    a2((e3) => !e3);
  }, []);
  return (e2 == null ? void 0 : e2.$vocabulary) ? "object" != typeof e2.$vocabulary ? null : Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--$vocabulary" }, Xe.default.createElement(o4, { expanded: n, onChange: s2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "$vocabulary")), Xe.default.createElement("strong", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--primary" }, "object"), Xe.default.createElement("ul", null, n && Object.entries(e2.$vocabulary).map(([e3, t3]) => Xe.default.createElement("li", { key: e3, className: (0, _r.default)("json-schema-2020-12-$vocabulary-uri", { "json-schema-2020-12-$vocabulary-uri--disabled": !t3 }) }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, e3))))) : null;
};
var keywords_$id = ({ schema: e2 }) => (e2 == null ? void 0 : e2.$id) ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--$id" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "$id"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, e2.$id)) : null;
var keywords_$anchor = ({ schema: e2 }) => (e2 == null ? void 0 : e2.$anchor) ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--$anchor" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "$anchor"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, e2.$anchor)) : null;
var keywords_$dynamicAnchor = ({ schema: e2 }) => (e2 == null ? void 0 : e2.$dynamicAnchor) ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--$dynamicAnchor" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "$dynamicAnchor"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, e2.$dynamicAnchor)) : null;
var keywords_$ref = ({ schema: e2 }) => (e2 == null ? void 0 : e2.$ref) ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--$ref" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "$ref"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, e2.$ref)) : null;
var keywords_$dynamicRef = ({ schema: e2 }) => (e2 == null ? void 0 : e2.$dynamicRef) ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--$dynamicRef" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "$dynamicRef"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, e2.$dynamicRef)) : null;
var keywords_$defs = ({ schema: e2 }) => {
  const t2 = (e2 == null ? void 0 : e2.$defs) || {}, r2 = useIsExpanded(), n = useIsExpandedDeeply(), [a2, o4] = (0, Xe.useState)(r2 || n), [s2, l2] = (0, Xe.useState)(false), i2 = useComponent("Accordion"), c2 = useComponent("ExpandDeepButton"), u2 = useComponent("JSONSchema"), d2 = (0, Xe.useCallback)(() => {
    o4((e3) => !e3);
  }, []), p2 = (0, Xe.useCallback)((e3, t3) => {
    o4(t3), l2(t3);
  }, []);
  return 0 === Object.keys(t2).length ? null : Xe.default.createElement(Es.Provider, { value: s2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--$defs" }, Xe.default.createElement(i2, { expanded: a2, onChange: d2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "$defs")), Xe.default.createElement(c2, { expanded: a2, onClick: p2 }), Xe.default.createElement("strong", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--primary" }, "object"), Xe.default.createElement("ul", { className: (0, _r.default)("json-schema-2020-12-keyword__children", { "json-schema-2020-12-keyword__children--collapsed": !a2 }) }, a2 && Xe.default.createElement(Xe.default.Fragment, null, Object.entries(t2).map(([e3, t3]) => Xe.default.createElement("li", { key: e3, className: "json-schema-2020-12-property" }, Xe.default.createElement(u2, { name: e3, schema: t3 })))))));
};
var keywords_$comment = ({ schema: e2 }) => (e2 == null ? void 0 : e2.$comment) ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--$comment" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--secondary" }, "$comment"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--secondary" }, e2.$comment)) : null;
var keywords_AllOf = ({ schema: e2 }) => {
  const t2 = (e2 == null ? void 0 : e2.allOf) || [], r2 = useFn(), n = useIsExpanded(), a2 = useIsExpandedDeeply(), [o4, s2] = (0, Xe.useState)(n || a2), [l2, i2] = (0, Xe.useState)(false), c2 = useComponent("Accordion"), u2 = useComponent("ExpandDeepButton"), d2 = useComponent("JSONSchema"), p2 = useComponent("KeywordType"), m2 = (0, Xe.useCallback)(() => {
    s2((e3) => !e3);
  }, []), f2 = (0, Xe.useCallback)((e3, t3) => {
    s2(t3), i2(t3);
  }, []);
  return Array.isArray(t2) && 0 !== t2.length ? Xe.default.createElement(Es.Provider, { value: l2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--allOf" }, Xe.default.createElement(c2, { expanded: o4, onChange: m2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "All of")), Xe.default.createElement(u2, { expanded: o4, onClick: f2 }), Xe.default.createElement(p2, { schema: { allOf: t2 } }), Xe.default.createElement("ul", { className: (0, _r.default)("json-schema-2020-12-keyword__children", { "json-schema-2020-12-keyword__children--collapsed": !o4 }) }, o4 && Xe.default.createElement(Xe.default.Fragment, null, t2.map((e3, t3) => Xe.default.createElement("li", { key: `#${t3}`, className: "json-schema-2020-12-property" }, Xe.default.createElement(d2, { name: `#${t3} ${r2.getTitle(e3)}`, schema: e3 }))))))) : null;
};
var keywords_AnyOf = ({ schema: e2 }) => {
  const t2 = (e2 == null ? void 0 : e2.anyOf) || [], r2 = useFn(), n = useIsExpanded(), a2 = useIsExpandedDeeply(), [o4, s2] = (0, Xe.useState)(n || a2), [l2, i2] = (0, Xe.useState)(false), c2 = useComponent("Accordion"), u2 = useComponent("ExpandDeepButton"), d2 = useComponent("JSONSchema"), p2 = useComponent("KeywordType"), m2 = (0, Xe.useCallback)(() => {
    s2((e3) => !e3);
  }, []), f2 = (0, Xe.useCallback)((e3, t3) => {
    s2(t3), i2(t3);
  }, []);
  return Array.isArray(t2) && 0 !== t2.length ? Xe.default.createElement(Es.Provider, { value: l2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--anyOf" }, Xe.default.createElement(c2, { expanded: o4, onChange: m2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Any of")), Xe.default.createElement(u2, { expanded: o4, onClick: f2 }), Xe.default.createElement(p2, { schema: { anyOf: t2 } }), Xe.default.createElement("ul", { className: (0, _r.default)("json-schema-2020-12-keyword__children", { "json-schema-2020-12-keyword__children--collapsed": !o4 }) }, o4 && Xe.default.createElement(Xe.default.Fragment, null, t2.map((e3, t3) => Xe.default.createElement("li", { key: `#${t3}`, className: "json-schema-2020-12-property" }, Xe.default.createElement(d2, { name: `#${t3} ${r2.getTitle(e3)}`, schema: e3 }))))))) : null;
};
var keywords_OneOf = ({ schema: e2 }) => {
  const t2 = (e2 == null ? void 0 : e2.oneOf) || [], r2 = useFn(), n = useIsExpanded(), a2 = useIsExpandedDeeply(), [o4, s2] = (0, Xe.useState)(n || a2), [l2, i2] = (0, Xe.useState)(false), c2 = useComponent("Accordion"), u2 = useComponent("ExpandDeepButton"), d2 = useComponent("JSONSchema"), p2 = useComponent("KeywordType"), m2 = (0, Xe.useCallback)(() => {
    s2((e3) => !e3);
  }, []), f2 = (0, Xe.useCallback)((e3, t3) => {
    s2(t3), i2(t3);
  }, []);
  return Array.isArray(t2) && 0 !== t2.length ? Xe.default.createElement(Es.Provider, { value: l2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--oneOf" }, Xe.default.createElement(c2, { expanded: o4, onChange: m2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "One of")), Xe.default.createElement(u2, { expanded: o4, onClick: f2 }), Xe.default.createElement(p2, { schema: { oneOf: t2 } }), Xe.default.createElement("ul", { className: (0, _r.default)("json-schema-2020-12-keyword__children", { "json-schema-2020-12-keyword__children--collapsed": !o4 }) }, o4 && Xe.default.createElement(Xe.default.Fragment, null, t2.map((e3, t3) => Xe.default.createElement("li", { key: `#${t3}`, className: "json-schema-2020-12-property" }, Xe.default.createElement(d2, { name: `#${t3} ${r2.getTitle(e3)}`, schema: e3 }))))))) : null;
};
var keywords_Not = ({ schema: e2 }) => {
  const t2 = useFn(), r2 = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "not")) return null;
  const n = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Not");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--not" }, Xe.default.createElement(r2, { name: n, schema: e2.not }));
};
var keywords_If = ({ schema: e2 }) => {
  const t2 = useFn(), r2 = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "if")) return null;
  const n = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "If");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--if" }, Xe.default.createElement(r2, { name: n, schema: e2.if }));
};
var keywords_Then = ({ schema: e2 }) => {
  const t2 = useFn(), r2 = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "then")) return null;
  const n = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Then");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--then" }, Xe.default.createElement(r2, { name: n, schema: e2.then }));
};
var keywords_Else = ({ schema: e2 }) => {
  const t2 = useFn(), r2 = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "else")) return null;
  const n = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Else");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--if" }, Xe.default.createElement(r2, { name: n, schema: e2.else }));
};
var keywords_DependentSchemas = ({ schema: e2 }) => {
  const t2 = (e2 == null ? void 0 : e2.dependentSchemas) || [], r2 = useIsExpanded(), n = useIsExpandedDeeply(), [a2, o4] = (0, Xe.useState)(r2 || n), [s2, l2] = (0, Xe.useState)(false), i2 = useComponent("Accordion"), c2 = useComponent("ExpandDeepButton"), u2 = useComponent("JSONSchema"), d2 = (0, Xe.useCallback)(() => {
    o4((e3) => !e3);
  }, []), p2 = (0, Xe.useCallback)((e3, t3) => {
    o4(t3), l2(t3);
  }, []);
  return "object" != typeof t2 || 0 === Object.keys(t2).length ? null : Xe.default.createElement(Es.Provider, { value: s2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--dependentSchemas" }, Xe.default.createElement(i2, { expanded: a2, onChange: d2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Dependent schemas")), Xe.default.createElement(c2, { expanded: a2, onClick: p2 }), Xe.default.createElement("strong", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--primary" }, "object"), Xe.default.createElement("ul", { className: (0, _r.default)("json-schema-2020-12-keyword__children", { "json-schema-2020-12-keyword__children--collapsed": !a2 }) }, a2 && Xe.default.createElement(Xe.default.Fragment, null, Object.entries(t2).map(([e3, t3]) => Xe.default.createElement("li", { key: e3, className: "json-schema-2020-12-property" }, Xe.default.createElement(u2, { name: e3, schema: t3 })))))));
};
var keywords_PrefixItems = ({ schema: e2 }) => {
  const t2 = (e2 == null ? void 0 : e2.prefixItems) || [], r2 = useFn(), n = useIsExpanded(), a2 = useIsExpandedDeeply(), [o4, s2] = (0, Xe.useState)(n || a2), [l2, i2] = (0, Xe.useState)(false), c2 = useComponent("Accordion"), u2 = useComponent("ExpandDeepButton"), d2 = useComponent("JSONSchema"), p2 = useComponent("KeywordType"), m2 = (0, Xe.useCallback)(() => {
    s2((e3) => !e3);
  }, []), f2 = (0, Xe.useCallback)((e3, t3) => {
    s2(t3), i2(t3);
  }, []);
  return Array.isArray(t2) && 0 !== t2.length ? Xe.default.createElement(Es.Provider, { value: l2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--prefixItems" }, Xe.default.createElement(c2, { expanded: o4, onChange: m2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Prefix items")), Xe.default.createElement(u2, { expanded: o4, onClick: f2 }), Xe.default.createElement(p2, { schema: { prefixItems: t2 } }), Xe.default.createElement("ul", { className: (0, _r.default)("json-schema-2020-12-keyword__children", { "json-schema-2020-12-keyword__children--collapsed": !o4 }) }, o4 && Xe.default.createElement(Xe.default.Fragment, null, t2.map((e3, t3) => Xe.default.createElement("li", { key: `#${t3}`, className: "json-schema-2020-12-property" }, Xe.default.createElement(d2, { name: `#${t3} ${r2.getTitle(e3)}`, schema: e3 }))))))) : null;
};
var keywords_Items = ({ schema: e2 }) => {
  const t2 = useFn(), r2 = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "items")) return null;
  const n = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Items");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--items" }, Xe.default.createElement(r2, { name: n, schema: e2.items }));
};
var keywords_Contains = ({ schema: e2 }) => {
  const t2 = useFn(), r2 = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "contains")) return null;
  const n = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Contains");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--contains" }, Xe.default.createElement(r2, { name: n, schema: e2.contains }));
};
var keywords_Properties_Properties = ({ schema: e2 }) => {
  const t2 = useFn(), r2 = (e2 == null ? void 0 : e2.properties) || {}, n = Array.isArray(e2 == null ? void 0 : e2.required) ? e2.required : [], a2 = useComponent("JSONSchema");
  return 0 === Object.keys(r2).length ? null : Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--properties" }, Xe.default.createElement("ul", null, Object.entries(r2).map(([r3, o4]) => {
    const s2 = n.includes(r3), l2 = t2.getDependentRequired(r3, e2);
    return Xe.default.createElement("li", { key: r3, className: (0, _r.default)("json-schema-2020-12-property", { "json-schema-2020-12-property--required": s2 }) }, Xe.default.createElement(a2, { name: r3, schema: o4, dependentRequired: l2 }));
  })));
};
var PatternProperties_PatternProperties = ({ schema: e2 }) => {
  const t2 = (e2 == null ? void 0 : e2.patternProperties) || {}, r2 = useComponent("JSONSchema");
  return 0 === Object.keys(t2).length ? null : Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--patternProperties" }, Xe.default.createElement("ul", null, Object.entries(t2).map(([e3, t3]) => Xe.default.createElement("li", { key: e3, className: "json-schema-2020-12-property" }, Xe.default.createElement(r2, { name: e3, schema: t3 })))));
};
var keywords_AdditionalProperties = ({ schema: e2 }) => {
  const t2 = useFn(), { additionalProperties: r2 } = e2, n = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "additionalProperties")) return null;
  const a2 = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Additional properties");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--additionalProperties" }, true === r2 ? Xe.default.createElement(Xe.default.Fragment, null, a2, Xe.default.createElement("span", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--primary" }, "allowed")) : false === r2 ? Xe.default.createElement(Xe.default.Fragment, null, a2, Xe.default.createElement("span", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--primary" }, "forbidden")) : Xe.default.createElement(n, { name: a2, schema: r2 }));
};
var keywords_PropertyNames = ({ schema: e2 }) => {
  const t2 = useFn(), { propertyNames: r2 } = e2, n = useComponent("JSONSchema"), a2 = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Property names");
  return t2.hasKeyword(e2, "propertyNames") ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--propertyNames" }, Xe.default.createElement(n, { name: a2, schema: r2 })) : null;
};
var keywords_UnevaluatedItems = ({ schema: e2 }) => {
  const t2 = useFn(), { unevaluatedItems: r2 } = e2, n = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "unevaluatedItems")) return null;
  const a2 = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Unevaluated items");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--unevaluatedItems" }, Xe.default.createElement(n, { name: a2, schema: r2 }));
};
var keywords_UnevaluatedProperties = ({ schema: e2 }) => {
  const t2 = useFn(), { unevaluatedProperties: r2 } = e2, n = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "unevaluatedProperties")) return null;
  const a2 = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Unevaluated properties");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--unevaluatedProperties" }, Xe.default.createElement(n, { name: a2, schema: r2 }));
};
var keywords_Type = ({ schema: e2, isCircular: t2 = false }) => {
  const r2 = useFn().getType(e2), n = t2 ? " [circular]" : "";
  return Xe.default.createElement("strong", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--primary" }, `${r2}${n}`);
};
var Enum_Enum = ({ schema: e2 }) => {
  const t2 = useFn();
  return Array.isArray(e2 == null ? void 0 : e2.enum) ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--enum" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Allowed values"), Xe.default.createElement("ul", null, e2.enum.map((e3) => {
    const r2 = t2.stringify(e3);
    return Xe.default.createElement("li", { key: r2 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--const" }, r2));
  }))) : null;
};
var keywords_Const = ({ schema: e2 }) => {
  const t2 = useFn();
  return t2.hasKeyword(e2, "const") ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--const" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Const"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--const" }, t2.stringify(e2.const))) : null;
};
var Constraint = ({ constraint: e2 }) => Xe.default.createElement("span", { className: `json-schema-2020-12__constraint json-schema-2020-12__constraint--${e2.scope}` }, e2.value);
var bs = Xe.default.memo(Constraint);
var DependentRequired_DependentRequired = ({ dependentRequired: e2 }) => 0 === e2.length ? null : Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--dependentRequired" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Required when defined"), Xe.default.createElement("ul", null, e2.map((e3) => Xe.default.createElement("li", { key: e3 }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--warning" }, e3)))));
var keywords_ContentSchema = ({ schema: e2 }) => {
  const t2 = useFn(), r2 = useComponent("JSONSchema");
  if (!t2.hasKeyword(e2, "contentSchema")) return null;
  const n = Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Content schema");
  return Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--contentSchema" }, Xe.default.createElement(r2, { name: n, schema: e2.contentSchema }));
};
var Title_Title = ({ title: e2 = "", schema: t2 }) => {
  const r2 = useFn(), n = e2 || r2.getTitle(t2);
  return n ? Xe.default.createElement("div", { className: "json-schema-2020-12__title" }, n) : null;
};
var keywords_Description_Description = ({ schema: e2 }) => (e2 == null ? void 0 : e2.description) ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--description" }, Xe.default.createElement("div", { className: "json-schema-2020-12-core-keyword__value json-schema-2020-12-core-keyword__value--secondary" }, e2.description)) : null;
var keywords_Default = ({ schema: e2 }) => {
  const t2 = useFn();
  return t2.hasKeyword(e2, "default") ? Xe.default.createElement("div", { className: "json-schema-2020-12-keyword json-schema-2020-12-keyword--default" }, Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__name json-schema-2020-12-keyword__name--primary" }, "Default"), Xe.default.createElement("span", { className: "json-schema-2020-12-keyword__value json-schema-2020-12-keyword__value--const" }, t2.stringify(e2.default))) : null;
};
var keywords_Deprecated = ({ schema: e2 }) => true !== (e2 == null ? void 0 : e2.deprecated) ? null : Xe.default.createElement("span", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--warning" }, "deprecated");
var keywords_ReadOnly = ({ schema: e2 }) => true !== (e2 == null ? void 0 : e2.readOnly) ? null : Xe.default.createElement("span", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--muted" }, "read-only");
var keywords_WriteOnly = ({ schema: e2 }) => true !== (e2 == null ? void 0 : e2.writeOnly) ? null : Xe.default.createElement("span", { className: "json-schema-2020-12__attribute json-schema-2020-12__attribute--muted" }, "write-only");
var Accordion_Accordion = ({ expanded: e2 = false, children: t2, onChange: r2 }) => {
  const n = useComponent("ChevronRightIcon"), a2 = (0, Xe.useCallback)((t3) => {
    r2(t3, !e2);
  }, [e2, r2]);
  return Xe.default.createElement("button", { type: "button", className: "json-schema-2020-12-accordion", onClick: a2 }, Xe.default.createElement("div", { className: "json-schema-2020-12-accordion__children" }, t2), Xe.default.createElement("span", { className: (0, _r.default)("json-schema-2020-12-accordion__icon", { "json-schema-2020-12-accordion__icon--expanded": e2, "json-schema-2020-12-accordion__icon--collapsed": !e2 }) }, Xe.default.createElement(n, null)));
};
var ExpandDeepButton_ExpandDeepButton = ({ expanded: e2, onClick: t2 }) => {
  const r2 = (0, Xe.useCallback)((r3) => {
    t2(r3, !e2);
  }, [e2, t2]);
  return Xe.default.createElement("button", { type: "button", className: "json-schema-2020-12-expand-deep-button", onClick: r2 }, e2 ? "Collapse all" : "Expand all");
};
var icons_ChevronRight = () => Xe.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24" }, Xe.default.createElement("path", { d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" }));
var fn_upperFirst = (e2) => "string" == typeof e2 ? `${e2.charAt(0).toUpperCase()}${e2.slice(1)}` : e2;
var getTitle = (e2, { lookup: t2 = "extended" } = {}) => {
  const r2 = useFn();
  if (null != (e2 == null ? void 0 : e2.title)) return r2.upperFirst(String(e2.title));
  if ("extended" === t2) {
    if (null != (e2 == null ? void 0 : e2.$anchor)) return r2.upperFirst(String(e2.$anchor));
    if (null != (e2 == null ? void 0 : e2.$id)) return String(e2.$id);
  }
  return "";
};
var getType = (e2, t2 = /* @__PURE__ */ new WeakSet()) => {
  const r2 = useFn();
  if (null == e2) return "any";
  if (r2.isBooleanJSONSchema(e2)) return e2 ? "any" : "never";
  if ("object" != typeof e2) return "any";
  if (t2.has(e2)) return "any";
  t2.add(e2);
  const { type: n, prefixItems: a2, items: o4 } = e2, getArrayType = () => {
    if (Array.isArray(a2)) {
      const e3 = a2.map((e4) => getType(e4, t2)), r3 = o4 ? getType(o4, t2) : "any";
      return `array<[${e3.join(", ")}], ${r3}>`;
    }
    if (o4) {
      return `array<${getType(o4, t2)}>`;
    }
    return "array<any>";
  };
  if (e2.not && "any" === getType(e2.not)) return "never";
  const handleCombiningKeywords = (r3, n2) => {
    if (Array.isArray(e2[r3])) {
      return `(${e2[r3].map((e3) => getType(e3, t2)).join(n2)})`;
    }
    return null;
  }, s2 = [Array.isArray(n) ? n.map((e3) => "array" === e3 ? getArrayType() : e3).join(" | ") : "array" === n ? getArrayType() : ["null", "boolean", "object", "array", "number", "integer", "string"].includes(n) ? n : (() => {
    if (Object.hasOwn(e2, "prefixItems") || Object.hasOwn(e2, "items") || Object.hasOwn(e2, "contains")) return getArrayType();
    if (Object.hasOwn(e2, "properties") || Object.hasOwn(e2, "additionalProperties") || Object.hasOwn(e2, "patternProperties")) return "object";
    if (["int32", "int64"].includes(e2.format)) return "integer";
    if (["float", "double"].includes(e2.format)) return "number";
    if (Object.hasOwn(e2, "minimum") || Object.hasOwn(e2, "maximum") || Object.hasOwn(e2, "exclusiveMinimum") || Object.hasOwn(e2, "exclusiveMaximum") || Object.hasOwn(e2, "multipleOf")) return "number | integer";
    if (Object.hasOwn(e2, "pattern") || Object.hasOwn(e2, "format") || Object.hasOwn(e2, "minLength") || Object.hasOwn(e2, "maxLength")) return "string";
    if (void 0 !== e2.const) {
      if (null === e2.const) return "null";
      if ("boolean" == typeof e2.const) return "boolean";
      if ("number" == typeof e2.const) return Number.isInteger(e2.const) ? "integer" : "number";
      if ("string" == typeof e2.const) return "string";
      if (Array.isArray(e2.const)) return "array<any>";
      if ("object" == typeof e2.const) return "object";
    }
    return null;
  })(), handleCombiningKeywords("oneOf", " | "), handleCombiningKeywords("anyOf", " | "), handleCombiningKeywords("allOf", " & ")].filter(Boolean).join(" | ");
  return t2.delete(e2), s2 || "any";
};
var isBooleanJSONSchema = (e2) => "boolean" == typeof e2;
var hasKeyword = (e2, t2) => null !== e2 && "object" == typeof e2 && Object.hasOwn(e2, t2);
var isExpandable = (e2) => {
  const t2 = useFn();
  return (e2 == null ? void 0 : e2.$schema) || (e2 == null ? void 0 : e2.$vocabulary) || (e2 == null ? void 0 : e2.$id) || (e2 == null ? void 0 : e2.$anchor) || (e2 == null ? void 0 : e2.$dynamicAnchor) || (e2 == null ? void 0 : e2.$ref) || (e2 == null ? void 0 : e2.$dynamicRef) || (e2 == null ? void 0 : e2.$defs) || (e2 == null ? void 0 : e2.$comment) || (e2 == null ? void 0 : e2.allOf) || (e2 == null ? void 0 : e2.anyOf) || (e2 == null ? void 0 : e2.oneOf) || t2.hasKeyword(e2, "not") || t2.hasKeyword(e2, "if") || t2.hasKeyword(e2, "then") || t2.hasKeyword(e2, "else") || (e2 == null ? void 0 : e2.dependentSchemas) || (e2 == null ? void 0 : e2.prefixItems) || t2.hasKeyword(e2, "items") || t2.hasKeyword(e2, "contains") || (e2 == null ? void 0 : e2.properties) || (e2 == null ? void 0 : e2.patternProperties) || t2.hasKeyword(e2, "additionalProperties") || t2.hasKeyword(e2, "propertyNames") || t2.hasKeyword(e2, "unevaluatedItems") || t2.hasKeyword(e2, "unevaluatedProperties") || (e2 == null ? void 0 : e2.description) || (e2 == null ? void 0 : e2.enum) || t2.hasKeyword(e2, "const") || t2.hasKeyword(e2, "contentSchema") || t2.hasKeyword(e2, "default");
};
var fn_stringify = (e2) => null === e2 || ["number", "bigint", "boolean"].includes(typeof e2) ? String(e2) : Array.isArray(e2) ? `[${e2.map(fn_stringify).join(", ")}]` : JSON.stringify(e2);
var stringifyConstraintRange = (e2, t2, r2) => {
  const n = "number" == typeof t2, a2 = "number" == typeof r2;
  return n && a2 ? t2 === r2 ? `${t2} ${e2}` : `[${t2}, ${r2}] ${e2}` : n ? `>= ${t2} ${e2}` : a2 ? `<= ${r2} ${e2}` : null;
};
var stringifyConstraints = (e2) => {
  const t2 = [], r2 = ((e3) => {
    if ("number" != typeof (e3 == null ? void 0 : e3.multipleOf)) return null;
    if (e3.multipleOf <= 0) return null;
    if (1 === e3.multipleOf) return null;
    const { multipleOf: t3 } = e3;
    if (Number.isInteger(t3)) return `multiple of ${t3}`;
    const r3 = 10 ** t3.toString().split(".")[1].length;
    return `multiple of ${t3 * r3}/${r3}`;
  })(e2);
  null !== r2 && t2.push({ scope: "number", value: r2 });
  const n = ((e3) => {
    const t3 = e3 == null ? void 0 : e3.minimum, r3 = e3 == null ? void 0 : e3.maximum, n2 = e3 == null ? void 0 : e3.exclusiveMinimum, a3 = e3 == null ? void 0 : e3.exclusiveMaximum, o5 = "number" == typeof t3, s3 = "number" == typeof r3, l3 = "number" == typeof n2, i2 = "number" == typeof a3, c2 = l3 && (!o5 || t3 < n2), u2 = i2 && (!s3 || r3 > a3);
    if ((o5 || l3) && (s3 || i2)) return `${c2 ? "(" : "["}${c2 ? n2 : t3}, ${u2 ? a3 : r3}${u2 ? ")" : "]"}`;
    if (o5 || l3) return `${c2 ? ">" : ""} ${c2 ? n2 : t3}`;
    if (s3 || i2) return `${u2 ? "<" : ""} ${u2 ? a3 : r3}`;
    return null;
  })(e2);
  null !== n && t2.push({ scope: "number", value: n }), (e2 == null ? void 0 : e2.format) && t2.push({ scope: "string", value: e2.format });
  const a2 = stringifyConstraintRange("characters", e2 == null ? void 0 : e2.minLength, e2 == null ? void 0 : e2.maxLength);
  null !== a2 && t2.push({ scope: "string", value: a2 }), (e2 == null ? void 0 : e2.pattern) && t2.push({ scope: "string", value: `matches ${e2 == null ? void 0 : e2.pattern}` }), (e2 == null ? void 0 : e2.contentMediaType) && t2.push({ scope: "string", value: `media type: ${e2.contentMediaType}` }), (e2 == null ? void 0 : e2.contentEncoding) && t2.push({ scope: "string", value: `encoding: ${e2.contentEncoding}` });
  const o4 = stringifyConstraintRange((e2 == null ? void 0 : e2.hasUniqueItems) ? "unique items" : "items", e2 == null ? void 0 : e2.minItems, e2 == null ? void 0 : e2.maxItems);
  null !== o4 && t2.push({ scope: "array", value: o4 });
  const s2 = stringifyConstraintRange("contained items", e2 == null ? void 0 : e2.minContains, e2 == null ? void 0 : e2.maxContains);
  null !== s2 && t2.push({ scope: "array", value: s2 });
  const l2 = stringifyConstraintRange("properties", e2 == null ? void 0 : e2.minProperties, e2 == null ? void 0 : e2.maxProperties);
  return null !== l2 && t2.push({ scope: "object", value: l2 }), t2;
};
var getDependentRequired = (e2, t2) => (t2 == null ? void 0 : t2.dependentRequired) ? Array.from(Object.entries(t2.dependentRequired).reduce((t3, [r2, n]) => Array.isArray(n) && n.includes(e2) ? (t3.add(r2), t3) : t3, /* @__PURE__ */ new Set())) : [];
var withJSONSchemaContext = (e2, t2 = {}) => {
  const r2 = { components: { JSONSchema: vs, Keyword$schema: keywords_$schema, Keyword$vocabulary: $vocabulary_$vocabulary, Keyword$id: keywords_$id, Keyword$anchor: keywords_$anchor, Keyword$dynamicAnchor: keywords_$dynamicAnchor, Keyword$ref: keywords_$ref, Keyword$dynamicRef: keywords_$dynamicRef, Keyword$defs: keywords_$defs, Keyword$comment: keywords_$comment, KeywordAllOf: keywords_AllOf, KeywordAnyOf: keywords_AnyOf, KeywordOneOf: keywords_OneOf, KeywordNot: keywords_Not, KeywordIf: keywords_If, KeywordThen: keywords_Then, KeywordElse: keywords_Else, KeywordDependentSchemas: keywords_DependentSchemas, KeywordPrefixItems: keywords_PrefixItems, KeywordItems: keywords_Items, KeywordContains: keywords_Contains, KeywordProperties: keywords_Properties_Properties, KeywordPatternProperties: PatternProperties_PatternProperties, KeywordAdditionalProperties: keywords_AdditionalProperties, KeywordPropertyNames: keywords_PropertyNames, KeywordUnevaluatedItems: keywords_UnevaluatedItems, KeywordUnevaluatedProperties: keywords_UnevaluatedProperties, KeywordType: keywords_Type, KeywordEnum: Enum_Enum, KeywordConst: keywords_Const, KeywordConstraint: bs, KeywordDependentRequired: DependentRequired_DependentRequired, KeywordContentSchema: keywords_ContentSchema, KeywordTitle: Title_Title, KeywordDescription: keywords_Description_Description, KeywordDefault: keywords_Default, KeywordDeprecated: keywords_Deprecated, KeywordReadOnly: keywords_ReadOnly, KeywordWriteOnly: keywords_WriteOnly, Accordion: Accordion_Accordion, ExpandDeepButton: ExpandDeepButton_ExpandDeepButton, ChevronRightIcon: icons_ChevronRight, ...t2.components }, config: { default$schema: "https://json-schema.org/draft/2020-12/schema", defaultExpandedLevels: 0, ...t2.config }, fn: { upperFirst: fn_upperFirst, getTitle, getType, isBooleanJSONSchema, hasKeyword, isExpandable, stringify: fn_stringify, stringifyConstraints, getDependentRequired, ...t2.fn } }, HOC = (t3) => Xe.default.createElement(gs.Provider, { value: r2 }, Xe.default.createElement(e2, t3));
  return HOC.contexts = { JSONSchemaContext: gs }, HOC.displayName = e2.displayName, HOC;
};
var json_schema_2020_12 = () => ({ components: { JSONSchema202012: vs, JSONSchema202012Keyword$schema: keywords_$schema, JSONSchema202012Keyword$vocabulary: $vocabulary_$vocabulary, JSONSchema202012Keyword$id: keywords_$id, JSONSchema202012Keyword$anchor: keywords_$anchor, JSONSchema202012Keyword$dynamicAnchor: keywords_$dynamicAnchor, JSONSchema202012Keyword$ref: keywords_$ref, JSONSchema202012Keyword$dynamicRef: keywords_$dynamicRef, JSONSchema202012Keyword$defs: keywords_$defs, JSONSchema202012Keyword$comment: keywords_$comment, JSONSchema202012KeywordAllOf: keywords_AllOf, JSONSchema202012KeywordAnyOf: keywords_AnyOf, JSONSchema202012KeywordOneOf: keywords_OneOf, JSONSchema202012KeywordNot: keywords_Not, JSONSchema202012KeywordIf: keywords_If, JSONSchema202012KeywordThen: keywords_Then, JSONSchema202012KeywordElse: keywords_Else, JSONSchema202012KeywordDependentSchemas: keywords_DependentSchemas, JSONSchema202012KeywordPrefixItems: keywords_PrefixItems, JSONSchema202012KeywordItems: keywords_Items, JSONSchema202012KeywordContains: keywords_Contains, JSONSchema202012KeywordProperties: keywords_Properties_Properties, JSONSchema202012KeywordPatternProperties: PatternProperties_PatternProperties, JSONSchema202012KeywordAdditionalProperties: keywords_AdditionalProperties, JSONSchema202012KeywordPropertyNames: keywords_PropertyNames, JSONSchema202012KeywordUnevaluatedItems: keywords_UnevaluatedItems, JSONSchema202012KeywordUnevaluatedProperties: keywords_UnevaluatedProperties, JSONSchema202012KeywordType: keywords_Type, JSONSchema202012KeywordEnum: Enum_Enum, JSONSchema202012KeywordConst: keywords_Const, JSONSchema202012KeywordConstraint: bs, JSONSchema202012KeywordDependentRequired: DependentRequired_DependentRequired, JSONSchema202012KeywordContentSchema: keywords_ContentSchema, JSONSchema202012KeywordTitle: Title_Title, JSONSchema202012KeywordDescription: keywords_Description_Description, JSONSchema202012KeywordDefault: keywords_Default, JSONSchema202012KeywordDeprecated: keywords_Deprecated, JSONSchema202012KeywordReadOnly: keywords_ReadOnly, JSONSchema202012KeywordWriteOnly: keywords_WriteOnly, JSONSchema202012Accordion: Accordion_Accordion, JSONSchema202012ExpandDeepButton: ExpandDeepButton_ExpandDeepButton, JSONSchema202012ChevronRightIcon: icons_ChevronRight, withJSONSchema202012Context: withJSONSchemaContext, JSONSchema202012DeepExpansionContext: () => Es }, fn: { upperFirst: fn_upperFirst, jsonSchema202012: { isExpandable, hasKeyword, useFn, useConfig, useComponent, useIsExpandedDeeply } } });
var ws2 = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return ve.default;
} });
var array = (e2, { sample: t2 }) => ((e3, t3 = {}) => {
  const { minItems: r2, maxItems: n, uniqueItems: a2 } = t3, { contains: o4, minContains: s2, maxContains: l2 } = t3;
  let i2 = [...e3];
  if (null != o4 && "object" == typeof o4) {
    if (Number.isInteger(s2) && s2 > 1) {
      const e4 = i2.at(0);
      for (let t4 = 1; t4 < s2; t4 += 1) i2.unshift(e4);
    }
    Number.isInteger(l2);
  }
  if (Number.isInteger(n) && n > 0 && (i2 = e3.slice(0, n)), Number.isInteger(r2) && r2 > 0) for (let e4 = 0; i2.length < r2; e4 += 1) i2.push(i2[e4 % i2.length]);
  return true === a2 && (i2 = Array.from(new Set(i2))), i2;
})(t2, e2);
var object = () => {
  throw new Error("Not implemented");
};
var bytes = (e2) => vt()(e2);
var pick3 = (e2) => e2.at(0);
var predicates_isBooleanJSONSchema = (e2) => "boolean" == typeof e2;
var isJSONSchemaObject = (e2) => (0, ws2.default)(e2);
var isJSONSchema = (e2) => predicates_isBooleanJSONSchema(e2) || isJSONSchemaObject(e2);
var Cs = class Registry {
  constructor() {
    __publicField(this, "data", {});
  }
  register(e2, t2) {
    this.data[e2] = t2;
  }
  unregister(e2) {
    void 0 === e2 ? this.data = {} : delete this.data[e2];
  }
  get(e2) {
    return this.data[e2];
  }
};
var int32 = () => 2 ** 30 >>> 0;
var int64 = () => 2 ** 53 - 1;
var generators_float = () => 0.1;
var generators_double = () => 0.1;
var email = () => "user@example.com";
var idn_email = () => "@example.com";
var hostname = () => "example.com";
var idn_hostname = () => ".com";
var ipv4 = () => "198.51.100.42";
var ipv6 = () => "2001:0db8:5b96:0000:0000:426f:8e17:642a";
var uri = () => "https://example.com/";
var uri_reference = () => "path/index.html";
var iri = () => "https://.com/";
var iri_reference = () => "path/.html";
var uuid = () => "3fa85f64-5717-4562-b3fc-2c963f66afa6";
var uri_template = () => "https://example.com/dictionary/{term:1}/{term}";
var json_pointer = () => "/a/b/c";
var relative_json_pointer = () => "1/0";
var date_time = () => (/* @__PURE__ */ new Date()).toISOString();
var date = () => (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
var time = () => (/* @__PURE__ */ new Date()).toISOString().substring(11);
var duration = () => "P3D";
var generators_password = () => "********";
var regex = () => "^[a-z]+$";
var _e2, _a2;
var xs = new (_a2 = class extends Cs {
  constructor() {
    super(...arguments);
    __privateAdd(this, _e2, { int32, int64, float: generators_float, double: generators_double, email, "idn-email": idn_email, hostname, "idn-hostname": idn_hostname, ipv4, ipv6, uri, "uri-reference": uri_reference, iri, "iri-reference": iri_reference, uuid, "uri-template": uri_template, "json-pointer": json_pointer, "relative-json-pointer": relative_json_pointer, "date-time": date_time, date, time, duration, password: generators_password, regex });
    __publicField(this, "data", { ...__privateGet(this, _e2) });
  }
  get defaults() {
    return { ...__privateGet(this, _e2) };
  }
}, _e2 = new WeakMap(), _a2)();
var formatAPI = (e2, t2) => "function" == typeof t2 ? xs.register(e2, t2) : null === t2 ? xs.unregister(e2) : xs.get(e2);
formatAPI.getDefaults = () => xs.defaults;
var Os = formatAPI;
var ks = __webpack_require__(287).Buffer;
var _7bit = (e2) => ks.from(e2).toString("ascii");
var Ns = __webpack_require__(287).Buffer;
var _8bit = (e2) => Ns.from(e2).toString("utf8");
var As = __webpack_require__(287).Buffer;
var binary4 = (e2) => As.from(e2).toString("binary");
var quoted_printable = (e2) => {
  let t2 = "";
  for (let r2 = 0; r2 < e2.length; r2++) {
    const n = e2.charCodeAt(r2);
    if (61 === n) t2 += "=3D";
    else if (n >= 33 && n <= 60 || n >= 62 && n <= 126 || 9 === n || 32 === n) t2 += e2.charAt(r2);
    else if (13 === n || 10 === n) t2 += "\r\n";
    else if (n > 126) {
      const n2 = unescape(encodeURIComponent(e2.charAt(r2)));
      for (let e3 = 0; e3 < n2.length; e3++) t2 += "=" + ("0" + n2.charCodeAt(e3).toString(16)).slice(-2).toUpperCase();
    } else t2 += "=" + ("0" + n.toString(16)).slice(-2).toUpperCase();
  }
  return t2;
};
var Is = __webpack_require__(287).Buffer;
var base16 = (e2) => Is.from(e2).toString("hex");
var Rs = __webpack_require__(287).Buffer;
var base32 = (e2) => {
  const t2 = Rs.from(e2).toString("utf8"), r2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  let n = 0, a2 = "", o4 = 0, s2 = 0;
  for (let e3 = 0; e3 < t2.length; e3++) for (o4 = o4 << 8 | t2.charCodeAt(e3), s2 += 8; s2 >= 5; ) a2 += r2.charAt(o4 >>> s2 - 5 & 31), s2 -= 5;
  s2 > 0 && (a2 += r2.charAt(o4 << 5 - s2 & 31), n = (8 - 8 * t2.length % 5) % 5);
  for (let e3 = 0; e3 < n; e3++) a2 += "=";
  return a2;
};
var Ts = __webpack_require__(287).Buffer;
var base64 = (e2) => Ts.from(e2).toString("base64");
var Bs = __webpack_require__(287).Buffer;
var base64url = (e2) => Bs.from(e2).toString("base64url");
var _e3, _a3;
var js = new (_a3 = class extends Cs {
  constructor() {
    super(...arguments);
    __privateAdd(this, _e3, { "7bit": _7bit, "8bit": _8bit, binary: binary4, "quoted-printable": quoted_printable, base16, base32, base64, base64url });
    __publicField(this, "data", { ...__privateGet(this, _e3) });
  }
  get defaults() {
    return { ...__privateGet(this, _e3) };
  }
}, _e3 = new WeakMap(), _a3)();
var encoderAPI = (e2, t2) => "function" == typeof t2 ? js.register(e2, t2) : null === t2 ? js.unregister(e2) : js.get(e2);
encoderAPI.getDefaults = () => js.defaults;
var Ps = encoderAPI;
var Ms = { "text/plain": () => "string", "text/css": () => ".selector { border: 1px solid red }", "text/csv": () => "value1,value2,value3", "text/html": () => "<p>content</p>", "text/calendar": () => "BEGIN:VCALENDAR", "text/javascript": () => "console.dir('Hello world!');", "text/xml": () => '<person age="30">John Doe</person>', "text/*": () => "string" };
var qs = { "image/*": () => bytes(25).toString("binary") };
var Ls = { "audio/*": () => bytes(25).toString("binary") };
var Ds = { "video/*": () => bytes(25).toString("binary") };
var Us = { "application/json": () => '{"key":"value"}', "application/ld+json": () => '{"name": "John Doe"}', "application/x-httpd-php": () => "<?php echo '<p>Hello World!</p>'; ?>", "application/rtf": () => String.raw`{\rtf1\adeflang1025\ansi\ansicpg1252\uc1`, "application/x-sh": () => 'echo "Hello World!"', "application/xhtml+xml": () => "<p>content</p>", "application/*": () => bytes(25).toString("binary") };
var _e4, _a4;
var $s = new (_a4 = class extends Cs {
  constructor() {
    super(...arguments);
    __privateAdd(this, _e4, { ...Ms, ...qs, ...Ls, ...Ds, ...Us });
    __publicField(this, "data", { ...__privateGet(this, _e4) });
  }
  get defaults() {
    return { ...__privateGet(this, _e4) };
  }
}, _e4 = new WeakMap(), _a4)();
var mediaTypeAPI = (e2, t2) => {
  if ("function" == typeof t2) return $s.register(e2, t2);
  if (null === t2) return $s.unregister(e2);
  const r2 = e2.split(";").at(0), n = `${r2.split("/").at(0)}/*`;
  return $s.get(e2) || $s.get(r2) || $s.get(n);
};
mediaTypeAPI.getDefaults = () => $s.defaults;
var Js = mediaTypeAPI;
var applyStringConstraints = (e2, t2 = {}) => {
  const { maxLength: r2, minLength: n } = t2;
  let a2 = e2;
  if (Number.isInteger(r2) && r2 > 0 && (a2 = a2.slice(0, r2)), Number.isInteger(n) && n > 0) {
    let e3 = 0;
    for (; a2.length < n; ) a2 += a2[e3++ % a2.length];
  }
  return a2;
};
var types_string = (e2, { sample: t2 } = {}) => {
  const { contentEncoding: r2, contentMediaType: n, contentSchema: a2 } = e2, { pattern: o4, format: s2 } = e2, l2 = Ps(r2) || aa.default;
  let i2;
  return i2 = "string" == typeof o4 ? applyStringConstraints(((e3) => {
    try {
      return new Rr.default(e3).gen();
    } catch {
      return "string";
    }
  })(o4), e2) : "string" == typeof s2 ? ((e3) => {
    const { format: t3 } = e3, r3 = Os(t3);
    return "function" == typeof r3 ? r3(e3) : "string";
  })(e2) : isJSONSchema(a2) && "string" == typeof n && void 0 !== t2 ? Array.isArray(t2) || "object" == typeof t2 ? JSON.stringify(t2) : applyStringConstraints(String(t2), e2) : "string" == typeof n ? ((e3) => {
    const { contentMediaType: t3 } = e3, r3 = Js(t3);
    return "function" == typeof r3 ? r3(e3) : "string";
  })(e2) : applyStringConstraints("string", e2), l2(i2);
};
var applyNumberConstraints = (e2, t2 = {}) => {
  const { minimum: r2, maximum: n, exclusiveMinimum: a2, exclusiveMaximum: o4 } = t2, { multipleOf: s2 } = t2, l2 = Number.isInteger(e2) ? 1 : Number.EPSILON;
  let i2 = "number" == typeof r2 ? r2 : null, c2 = "number" == typeof n ? n : null, u2 = e2;
  if ("number" == typeof a2 && (i2 = null !== i2 ? Math.max(i2, a2 + l2) : a2 + l2), "number" == typeof o4 && (c2 = null !== c2 ? Math.min(c2, o4 - l2) : o4 - l2), u2 = i2 > c2 && e2 || i2 || c2 || u2, "number" == typeof s2 && s2 > 0) {
    const e3 = u2 % s2;
    u2 = 0 === e3 ? u2 : u2 + s2 - e3;
  }
  return u2;
};
var types_number = (e2) => {
  const { format: t2 } = e2;
  let r2;
  return r2 = "string" == typeof t2 ? ((e3) => {
    const { format: t3 } = e3, r3 = Os(t3);
    return "function" == typeof r3 ? r3(e3) : 0;
  })(e2) : 0, applyNumberConstraints(r2, e2);
};
var types_integer = (e2) => {
  const { format: t2 } = e2;
  let r2;
  return r2 = "string" == typeof t2 ? ((e3) => {
    const { format: t3 } = e3, r3 = Os(t3);
    if ("function" == typeof r3) return r3(e3);
    switch (t3) {
      case "int32":
        return int32();
      case "int64":
        return int64();
    }
    return 0;
  })(e2) : 0, applyNumberConstraints(r2, e2);
};
var types_boolean = (e2) => "boolean" != typeof e2.default || e2.default;
var Vs = new Proxy({ array, object, string: types_string, number: types_number, integer: types_integer, boolean: types_boolean, null: () => null }, { get: (e2, t2) => "string" == typeof t2 && Object.hasOwn(e2, t2) ? e2[t2] : () => `Unknown Type: ${t2}` });
var Ks = ["array", "object", "number", "integer", "string", "boolean", "null"];
var hasExample = (e2) => {
  if (!isJSONSchemaObject(e2)) return false;
  const { examples: t2, example: r2, default: n } = e2;
  return !!(Array.isArray(t2) && t2.length >= 1) || (void 0 !== n || void 0 !== r2);
};
var extractExample = (e2) => {
  if (!isJSONSchemaObject(e2)) return null;
  const { examples: t2, example: r2, default: n } = e2;
  return Array.isArray(t2) && t2.length >= 1 ? t2.at(0) : void 0 !== n ? n : void 0 !== r2 ? r2 : void 0;
};
var zs = { array: ["items", "prefixItems", "contains", "maxContains", "minContains", "maxItems", "minItems", "uniqueItems", "unevaluatedItems"], object: ["properties", "additionalProperties", "patternProperties", "propertyNames", "minProperties", "maxProperties", "required", "dependentSchemas", "dependentRequired", "unevaluatedProperties"], string: ["pattern", "format", "minLength", "maxLength", "contentEncoding", "contentMediaType", "contentSchema"], integer: ["minimum", "maximum", "exclusiveMinimum", "exclusiveMaximum", "multipleOf"] };
zs.number = zs.integer;
var Fs = "string";
var inferTypeFromValue = (e2) => void 0 === e2 ? null : null === e2 ? "null" : Array.isArray(e2) ? "array" : Number.isInteger(e2) ? "integer" : typeof e2;
var foldType = (e2) => {
  if (Array.isArray(e2) && e2.length >= 1) {
    if (e2.includes("array")) return "array";
    if (e2.includes("object")) return "object";
    {
      const t2 = pick3(e2);
      if (Ks.includes(t2)) return t2;
    }
  }
  return Ks.includes(e2) ? e2 : null;
};
var inferType = (e2, t2 = /* @__PURE__ */ new WeakSet()) => {
  if (!isJSONSchemaObject(e2)) return Fs;
  if (t2.has(e2)) return Fs;
  t2.add(e2);
  let { type: r2, const: n } = e2;
  if (r2 = foldType(r2), "string" != typeof r2) {
    const t3 = Object.keys(zs);
    e: for (let n2 = 0; n2 < t3.length; n2 += 1) {
      const a2 = t3[n2], o4 = zs[a2];
      for (let t4 = 0; t4 < o4.length; t4 += 1) {
        const n3 = o4[t4];
        if (Object.hasOwn(e2, n3)) {
          r2 = a2;
          break e;
        }
      }
    }
  }
  if ("string" != typeof r2 && void 0 !== n) {
    const e3 = inferTypeFromValue(n);
    r2 = "string" == typeof e3 ? e3 : r2;
  }
  if ("string" != typeof r2) {
    const combineTypes = (r3) => {
      if (Array.isArray(e2[r3])) {
        const n3 = e2[r3].map((e3) => inferType(e3, t2));
        return foldType(n3);
      }
      return null;
    }, n2 = combineTypes("allOf"), a2 = combineTypes("anyOf"), o4 = combineTypes("oneOf"), s2 = e2.not ? inferType(e2.not, t2) : null;
    (n2 || a2 || o4 || s2) && (r2 = foldType([n2, a2, o4, s2].filter(Boolean)));
  }
  if ("string" != typeof r2 && hasExample(e2)) {
    const t3 = extractExample(e2), n2 = inferTypeFromValue(t3);
    r2 = "string" == typeof n2 ? n2 : r2;
  }
  return t2.delete(e2), r2 || Fs;
};
var type_getType = (e2) => inferType(e2);
var typeCast = (e2) => predicates_isBooleanJSONSchema(e2) ? /* @__PURE__ */ ((e3) => false === e3 ? { not: {} } : {})(e2) : isJSONSchemaObject(e2) ? e2 : {};
var merge4 = (e2, t2, r2 = {}) => {
  if (predicates_isBooleanJSONSchema(e2) && true === e2) return true;
  if (predicates_isBooleanJSONSchema(e2) && false === e2) return false;
  if (predicates_isBooleanJSONSchema(t2) && true === t2) return true;
  if (predicates_isBooleanJSONSchema(t2) && false === t2) return false;
  if (!isJSONSchema(e2)) return t2;
  if (!isJSONSchema(t2)) return e2;
  const n = { ...t2, ...e2 };
  if (t2.type && e2.type && Array.isArray(t2.type) && "string" == typeof t2.type) {
    const r3 = normalizeArray2(t2.type).concat(e2.type);
    n.type = Array.from(new Set(r3));
  }
  if (Array.isArray(t2.required) && Array.isArray(e2.required) && (n.required = [.../* @__PURE__ */ new Set([...e2.required, ...t2.required])]), t2.properties && e2.properties) {
    const a2 = /* @__PURE__ */ new Set([...Object.keys(t2.properties), ...Object.keys(e2.properties)]);
    n.properties = {};
    for (const o4 of a2) {
      const a3 = t2.properties[o4] || {}, s2 = e2.properties[o4] || {};
      a3.readOnly && !r2.includeReadOnly || a3.writeOnly && !r2.includeWriteOnly ? n.required = (n.required || []).filter((e3) => e3 !== o4) : n.properties[o4] = merge4(s2, a3, r2);
    }
  }
  return isJSONSchema(t2.items) && isJSONSchema(e2.items) && (n.items = merge4(e2.items, t2.items, r2)), isJSONSchema(t2.contains) && isJSONSchema(e2.contains) && (n.contains = merge4(e2.contains, t2.contains, r2)), isJSONSchema(t2.contentSchema) && isJSONSchema(e2.contentSchema) && (n.contentSchema = merge4(e2.contentSchema, t2.contentSchema, r2)), n;
};
var Ws = merge4;
var main_sampleFromSchemaGeneric = (e2, t2 = {}, r2 = void 0, n = false) => {
  var _a6, _b, _c, _d, _e6, _f, _g, _h, _i;
  if (null == e2 && void 0 === r2) return;
  "function" == typeof (e2 == null ? void 0 : e2.toJS) && (e2 = e2.toJS()), e2 = typeCast(e2);
  let a2 = void 0 !== r2 || hasExample(e2);
  const o4 = !a2 && Array.isArray(e2.oneOf) && e2.oneOf.length > 0, s2 = !a2 && Array.isArray(e2.anyOf) && e2.anyOf.length > 0;
  if (!a2 && (o4 || s2)) {
    const r3 = typeCast(pick3(o4 ? e2.oneOf : e2.anyOf));
    !(e2 = Ws(e2, r3, t2)).xml && r3.xml && (e2.xml = r3.xml), hasExample(e2) && hasExample(r3) && (a2 = true);
  }
  const l2 = {};
  let { xml: i2, properties: c2, additionalProperties: u2, items: d2, contains: p2 } = e2 || {}, m2 = type_getType(e2), { includeReadOnly: f2, includeWriteOnly: h2 } = t2;
  i2 = i2 || {};
  let g2, { name: y2, prefix: S, namespace: _2 } = i2, v2 = {};
  if (Object.hasOwn(e2, "type") || (e2.type = m2), n && (y2 = y2 || "notagname", g2 = (S ? `${S}:` : "") + y2, _2)) {
    l2[S ? `xmlns:${S}` : "xmlns"] = _2;
  }
  n && (v2[g2] = []);
  const b = objectify(c2);
  let w2, C2 = 0;
  const hasExceededMaxProperties = () => Number.isInteger(e2.maxProperties) && e2.maxProperties > 0 && C2 >= e2.maxProperties, canAddProperty = (t3) => !(Number.isInteger(e2.maxProperties) && e2.maxProperties > 0) || !hasExceededMaxProperties() && (!((t4) => !Array.isArray(e2.required) || 0 === e2.required.length || !e2.required.includes(t4))(t3) || e2.maxProperties - C2 - (() => {
    if (!Array.isArray(e2.required) || 0 === e2.required.length) return 0;
    let t4 = 0;
    return n ? e2.required.forEach((e3) => t4 += void 0 === v2[e3] ? 0 : 1) : e2.required.forEach((e3) => {
      var _a7;
      t4 += void 0 === ((_a7 = v2[g2]) == null ? void 0 : _a7.find((t5) => void 0 !== t5[e3])) ? 0 : 1;
    }), e2.required.length - t4;
  })() > 0);
  if (w2 = n ? (r3, a3 = void 0) => {
    if (e2 && b[r3]) {
      if (b[r3].xml = b[r3].xml || {}, b[r3].xml.attribute) {
        const e3 = Array.isArray(b[r3].enum) ? pick3(b[r3].enum) : void 0;
        if (hasExample(b[r3])) l2[b[r3].xml.name || r3] = extractExample(b[r3]);
        else if (void 0 !== e3) l2[b[r3].xml.name || r3] = e3;
        else {
          const e4 = typeCast(b[r3]), t3 = type_getType(e4), n2 = b[r3].xml.name || r3;
          l2[n2] = Vs[t3](e4);
        }
        return;
      }
      b[r3].xml.name = b[r3].xml.name || r3;
    } else b[r3] || false === u2 || (b[r3] = { xml: { name: r3 } });
    let o5 = main_sampleFromSchemaGeneric(b[r3], t2, a3, n);
    canAddProperty(r3) && (C2++, Array.isArray(o5) ? v2[g2] = v2[g2].concat(o5) : v2[g2].push(o5));
  } : (r3, a3) => {
    var _a7;
    if (canAddProperty(r3)) {
      if ((0, ws2.default)((_a7 = e2.discriminator) == null ? void 0 : _a7.mapping) && e2.discriminator.propertyName === r3 && "string" == typeof e2.$$ref) {
        for (const t3 in e2.discriminator.mapping) if (-1 !== e2.$$ref.search(e2.discriminator.mapping[t3])) {
          v2[r3] = t3;
          break;
        }
      } else v2[r3] = main_sampleFromSchemaGeneric(b[r3], t2, a3, n);
      C2++;
    }
  }, a2) {
    let a3;
    if (a3 = void 0 !== r2 ? r2 : extractExample(e2), !n) {
      if ("number" == typeof a3 && "string" === m2) return `${a3}`;
      if ("string" != typeof a3 || "string" === m2) return a3;
      try {
        return JSON.parse(a3);
      } catch {
        return a3;
      }
    }
    if ("array" === m2) {
      if (!Array.isArray(a3)) {
        if ("string" == typeof a3) return a3;
        a3 = [a3];
      }
      let r3 = [];
      return isJSONSchemaObject(d2) && (d2.xml = d2.xml || i2 || {}, d2.xml.name = d2.xml.name || i2.name, r3 = a3.map((e3) => main_sampleFromSchemaGeneric(d2, t2, e3, n))), isJSONSchemaObject(p2) && (p2.xml = p2.xml || i2 || {}, p2.xml.name = p2.xml.name || i2.name, r3 = [main_sampleFromSchemaGeneric(p2, t2, void 0, n), ...r3]), r3 = Vs.array(e2, { sample: r3 }), i2.wrapped ? (v2[g2] = r3, (0, Tr.default)(l2) || v2[g2].push({ _attr: l2 })) : v2 = r3, v2;
    }
    if ("object" === m2) {
      if ("string" == typeof a3) return a3;
      for (const e3 in a3) Object.hasOwn(a3, e3) && (((_a6 = b[e3]) == null ? void 0 : _a6.readOnly) && !f2 || ((_b = b[e3]) == null ? void 0 : _b.writeOnly) && !h2 || (((_d = (_c = b[e3]) == null ? void 0 : _c.xml) == null ? void 0 : _d.attribute) ? l2[b[e3].xml.name || e3] = a3[e3] : w2(e3, a3[e3])));
      return (0, Tr.default)(l2) || v2[g2].push({ _attr: l2 }), v2;
    }
    return v2[g2] = (0, Tr.default)(l2) ? a3 : [{ _attr: l2 }, a3], v2;
  }
  if ("array" === m2) {
    let r3 = [];
    if (isJSONSchemaObject(p2)) if (n && (p2.xml = p2.xml || e2.xml || {}, p2.xml.name = p2.xml.name || i2.name), Array.isArray(p2.anyOf)) {
      const { anyOf: e3, ...a3 } = d2;
      r3.push(...p2.anyOf.map((e4) => main_sampleFromSchemaGeneric(Ws(e4, a3, t2), t2, void 0, n)));
    } else if (Array.isArray(p2.oneOf)) {
      const { oneOf: e3, ...a3 } = d2;
      r3.push(...p2.oneOf.map((e4) => main_sampleFromSchemaGeneric(Ws(e4, a3, t2), t2, void 0, n)));
    } else {
      if (!(!n || n && i2.wrapped)) return main_sampleFromSchemaGeneric(p2, t2, void 0, n);
      r3.push(main_sampleFromSchemaGeneric(p2, t2, void 0, n));
    }
    if (isJSONSchemaObject(d2)) if (n && (d2.xml = d2.xml || e2.xml || {}, d2.xml.name = d2.xml.name || i2.name), Array.isArray(d2.anyOf)) {
      const { anyOf: e3, ...a3 } = d2;
      r3.push(...d2.anyOf.map((e4) => main_sampleFromSchemaGeneric(Ws(e4, a3, t2), t2, void 0, n)));
    } else if (Array.isArray(d2.oneOf)) {
      const { oneOf: e3, ...a3 } = d2;
      r3.push(...d2.oneOf.map((e4) => main_sampleFromSchemaGeneric(Ws(e4, a3, t2), t2, void 0, n)));
    } else {
      if (!(!n || n && i2.wrapped)) return main_sampleFromSchemaGeneric(d2, t2, void 0, n);
      r3.push(main_sampleFromSchemaGeneric(d2, t2, void 0, n));
    }
    return r3 = Vs.array(e2, { sample: r3 }), n && i2.wrapped ? (v2[g2] = r3, (0, Tr.default)(l2) || v2[g2].push({ _attr: l2 }), v2) : r3;
  }
  if ("object" === m2) {
    for (let e3 in b) Object.hasOwn(b, e3) && (((_e6 = b[e3]) == null ? void 0 : _e6.deprecated) || ((_f = b[e3]) == null ? void 0 : _f.readOnly) && !f2 || ((_g = b[e3]) == null ? void 0 : _g.writeOnly) && !h2 || w2(e3));
    if (n && l2 && v2[g2].push({ _attr: l2 }), hasExceededMaxProperties()) return v2;
    if (predicates_isBooleanJSONSchema(u2) && u2) n ? v2[g2].push({ additionalProp: "Anything can be here" }) : v2.additionalProp1 = {}, C2++;
    else if (isJSONSchemaObject(u2)) {
      const r3 = u2, a3 = main_sampleFromSchemaGeneric(r3, t2, void 0, n);
      if (n && "string" == typeof ((_h = r3 == null ? void 0 : r3.xml) == null ? void 0 : _h.name) && "notagname" !== ((_i = r3 == null ? void 0 : r3.xml) == null ? void 0 : _i.name)) v2[g2].push(a3);
      else {
        const t3 = Number.isInteger(e2.minProperties) && e2.minProperties > 0 && C2 < e2.minProperties ? e2.minProperties - C2 : 3;
        for (let e3 = 1; e3 <= t3; e3++) {
          if (hasExceededMaxProperties()) return v2;
          if (n) {
            const t4 = {};
            t4["additionalProp" + e3] = a3.notagname, v2[g2].push(t4);
          } else v2["additionalProp" + e3] = a3;
          C2++;
        }
      }
    }
    return v2;
  }
  let x2;
  if (void 0 !== e2.const) x2 = e2.const;
  else if (e2 && Array.isArray(e2.enum)) x2 = pick3(normalizeArray2(e2.enum));
  else {
    const r3 = isJSONSchemaObject(e2.contentSchema) ? main_sampleFromSchemaGeneric(e2.contentSchema, t2, void 0, n) : void 0;
    x2 = Vs[m2](e2, { sample: r3 });
  }
  return n ? (v2[g2] = (0, Tr.default)(l2) ? x2 : [{ _attr: l2 }, x2], v2) : x2;
};
var main_createXMLExample = (e2, t2, r2) => {
  const n = main_sampleFromSchemaGeneric(e2, t2, r2, true);
  if (n) return "string" == typeof n ? n : Ir()(n, { declaration: true, indent: "	" });
};
var main_sampleFromSchema = (e2, t2, r2) => main_sampleFromSchemaGeneric(e2, t2, r2, false);
var main_resolver = (e2, t2, r2) => [e2, JSON.stringify(t2), JSON.stringify(r2)];
var Hs = utils_memoizeN(main_createXMLExample, main_resolver);
var Gs = utils_memoizeN(main_sampleFromSchema, main_resolver);
var _e5, _a5;
var Xs = new (_a5 = class extends Cs {
  constructor() {
    super(...arguments);
    __privateAdd(this, _e5, {});
    __publicField(this, "data", { ...__privateGet(this, _e5) });
  }
  get defaults() {
    return { ...__privateGet(this, _e5) };
  }
}, _e5 = new WeakMap(), _a5)();
var api_optionAPI = (e2, t2) => (void 0 !== t2 && Xs.register(e2, t2), Xs.get(e2));
var Ys = [{ when: /json/, shouldStringifyTypes: ["string"] }];
var Qs = ["object"];
var fn_get_json_sample_schema = (e2) => (t2, r2, n, a2) => {
  const { fn: o4 } = e2(), s2 = o4.jsonSchema202012.memoizedSampleFromSchema(t2, r2, a2), l2 = typeof s2, i2 = Ys.reduce((e3, t3) => t3.when.test(n) ? [...e3, ...t3.shouldStringifyTypes] : e3, Qs);
  return (0, gt3.default)(i2, (e3) => e3 === l2) ? JSON.stringify(s2, null, 2) : s2;
};
var fn_get_yaml_sample_schema = (e2) => (t2, r2, n, a2) => {
  const { fn: o4 } = e2(), s2 = o4.jsonSchema202012.getJsonSampleSchema(t2, r2, n, a2);
  let l2;
  try {
    l2 = Ht.default.dump(Ht.default.load(s2), { lineWidth: -1 }, { schema: Ht.JSON_SCHEMA }), "\n" === l2[l2.length - 1] && (l2 = l2.slice(0, l2.length - 1));
  } catch (e3) {
    return console.error(e3), "error: could not generate yaml example";
  }
  return l2.replace(/\t/g, "  ");
};
var fn_get_xml_sample_schema = (e2) => (t2, r2, n) => {
  const { fn: a2 } = e2();
  if (t2 && !t2.xml && (t2.xml = {}), t2 && !t2.xml.name) {
    if (!t2.$$ref && (t2.type || t2.items || t2.properties || t2.additionalProperties)) return '<?xml version="1.0" encoding="UTF-8"?>\n<!-- XML example cannot be generated; root element name is undefined -->';
    if (t2.$$ref) {
      let e3 = t2.$$ref.match(/\S*\/(\S+)$/);
      t2.xml.name = e3[1];
    }
  }
  return a2.jsonSchema202012.memoizedCreateXMLExample(t2, r2, n);
};
var fn_get_sample_schema = (e2) => (t2, r2 = "", n = {}, a2 = void 0) => {
  const { fn: o4 } = e2();
  return "function" == typeof (t2 == null ? void 0 : t2.toJS) && (t2 = t2.toJS()), "function" == typeof (a2 == null ? void 0 : a2.toJS) && (a2 = a2.toJS()), /xml/.test(r2) ? o4.jsonSchema202012.getXmlSampleSchema(t2, n, a2) : /(yaml|yml)/.test(r2) ? o4.jsonSchema202012.getYamlSampleSchema(t2, n, r2, a2) : o4.jsonSchema202012.getJsonSampleSchema(t2, n, r2, a2);
};
var json_schema_2020_12_samples = ({ getSystem: e2 }) => {
  const t2 = fn_get_json_sample_schema(e2), r2 = fn_get_yaml_sample_schema(e2), n = fn_get_xml_sample_schema(e2), a2 = fn_get_sample_schema(e2);
  return { fn: { jsonSchema202012: { sampleFromSchema: main_sampleFromSchema, sampleFromSchemaGeneric: main_sampleFromSchemaGeneric, sampleOptionAPI: api_optionAPI, sampleEncoderAPI: Ps, sampleFormatAPI: Os, sampleMediaTypeAPI: Js, createXMLExample: main_createXMLExample, memoizedSampleFromSchema: Gs, memoizedCreateXMLExample: Hs, getJsonSampleSchema: t2, getYamlSampleSchema: r2, getXmlSampleSchema: n, getSampleSchema: a2, mergeJsonSchema: Ws } } };
};
function PresetApis() {
  return [base, oas3, json_schema_2020_12, json_schema_2020_12_samples, oas31];
}
var inline_plugin = (e2) => () => ({ fn: e2.fn, components: e2.components });
var factorization_system = (e2) => {
  const t2 = et()({ layout: { layout: e2.layout, filter: e2.filter }, spec: { spec: "", url: e2.url }, requestSnippets: e2.requestSnippets }, e2.initialState);
  if (e2.initialState) for (const [r2, n] of Object.entries(e2.initialState)) void 0 === n && delete t2[r2];
  return { system: { configs: e2.configs }, plugins: e2.presets, state: t2 };
};
var query3 = () => (e2) => {
  const t2 = e2.queryConfigEnabled ? (() => {
    const e3 = new URLSearchParams(dt.location.search);
    return Object.fromEntries(e3);
  })() : {};
  return Object.entries(t2).reduce((e3, [t3, r2]) => ("config" === t3 ? e3.configUrl = r2 : "urls.primaryName" === t3 ? e3[t3] = r2 : e3 = (0, Cn.default)(e3, t3, r2), e3), {});
};
var sources_url = ({ url: e2, system: t2 }) => async (r2) => {
  var _a6;
  if (!e2) return {};
  if ("function" != typeof ((_a6 = t2.configsActions) == null ? void 0 : _a6.getConfigByUrl)) return {};
  const n = (() => {
    const e3 = {};
    return e3.promise = new Promise((t3, r3) => {
      e3.resolve = t3, e3.reject = r3;
    }), e3;
  })();
  return t2.configsActions.getConfigByUrl({ url: e2, loadRemoteConfig: true, requestInterceptor: r2.requestInterceptor, responseInterceptor: r2.responseInterceptor }, (e3) => {
    n.resolve(e3);
  }), n.promise;
};
var runtime = () => () => {
  const e2 = {};
  return globalThis.location && (e2.oauth2RedirectUrl = `${globalThis.location.protocol}//${globalThis.location.host}${globalThis.location.pathname.substring(0, globalThis.location.pathname.lastIndexOf("/"))}/oauth2-redirect.html`), e2;
};
var Zs = Object.freeze({ dom_id: null, domNode: null, spec: {}, url: "", urls: null, configUrl: null, layout: "BaseLayout", docExpansion: "list", maxDisplayedTags: -1, filter: false, validatorUrl: "https://validator.swagger.io/validator", oauth2RedirectUrl: void 0, persistAuthorization: false, configs: {}, displayOperationId: false, displayRequestDuration: false, deepLinking: false, tryItOutEnabled: false, requestInterceptor: (e2) => (e2.curlOptions = [], e2), responseInterceptor: (e2) => e2, showMutatedRequest: true, defaultModelRendering: "example", defaultModelExpandDepth: 1, defaultModelsExpandDepth: 1, showExtensions: false, showCommonExtensions: false, withCredentials: false, requestSnippetsEnabled: false, requestSnippets: { generators: { curl_bash: { title: "cURL (bash)", syntax: "bash" }, curl_powershell: { title: "cURL (PowerShell)", syntax: "powershell" }, curl_cmd: { title: "cURL (CMD)", syntax: "bash" } }, defaultExpanded: true, languages: null }, supportedSubmitMethods: ["get", "put", "post", "delete", "options", "head", "patch", "trace"], queryConfigEnabled: false, presets: [PresetApis], plugins: [], initialState: {}, fn: {}, components: {}, syntaxHighlight: { activated: true, theme: "agate" }, operationsSorter: null, tagsSorter: null, onComplete: null, modelPropertyMacro: null, parameterMacro: null });
var el = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return be.default;
} });
var tl = function(e2) {
  var t2 = {};
  return __webpack_require__.d(t2, e2), t2;
}({ default: function() {
  return we.default;
} });
var type_casters_array = (e2, t2 = []) => Array.isArray(e2) ? e2 : t2;
var type_casters_boolean = (e2, t2 = false) => true === e2 || "true" === e2 || 1 === e2 || "1" === e2 || false !== e2 && "false" !== e2 && 0 !== e2 && "0" !== e2 && t2;
var dom_node = (e2) => null === e2 || "null" === e2 ? null : e2;
var type_casters_filter = (e2) => {
  const t2 = String(e2);
  return type_casters_boolean(e2, t2);
};
var type_casters_function = (e2, t2) => "function" == typeof e2 ? e2 : t2;
var nullable_array = (e2) => Array.isArray(e2) ? e2 : null;
var nullable_function = (e2) => "function" == typeof e2 ? e2 : null;
var nullable_string = (e2) => null === e2 || "null" === e2 ? null : String(e2);
var type_casters_number = (e2, t2 = -1) => {
  const r2 = parseInt(e2, 10);
  return Number.isNaN(r2) ? t2 : r2;
};
var type_casters_object = (e2, t2 = {}) => (0, ws2.default)(e2) ? e2 : t2;
var sorter = (e2) => "function" == typeof e2 || "string" == typeof e2 ? e2 : null;
var type_casters_string = (e2) => String(e2);
var syntax_highlight = (e2, t2) => (0, ws2.default)(e2) ? e2 : false === e2 || "false" === e2 || 0 === e2 || "0" === e2 ? { activated: false } : t2;
var undefined_string = (e2) => void 0 === e2 || "undefined" === e2 ? void 0 : String(e2);
var rl = { components: { typeCaster: type_casters_object }, configs: { typeCaster: type_casters_object }, configUrl: { typeCaster: nullable_string }, deepLinking: { typeCaster: type_casters_boolean, defaultValue: Zs.deepLinking }, defaultModelExpandDepth: { typeCaster: type_casters_number, defaultValue: Zs.defaultModelExpandDepth }, defaultModelRendering: { typeCaster: type_casters_string }, defaultModelsExpandDepth: { typeCaster: type_casters_number, defaultValue: Zs.defaultModelsExpandDepth }, displayOperationId: { typeCaster: type_casters_boolean, defaultValue: Zs.displayOperationId }, displayRequestDuration: { typeCaster: type_casters_boolean, defaultValue: Zs.displayRequestDuration }, docExpansion: { typeCaster: type_casters_string }, dom_id: { typeCaster: nullable_string }, domNode: { typeCaster: dom_node }, filter: { typeCaster: type_casters_filter }, fn: { typeCaster: type_casters_object }, initialState: { typeCaster: type_casters_object }, layout: { typeCaster: type_casters_string }, maxDisplayedTags: { typeCaster: type_casters_number, defaultValue: Zs.maxDisplayedTags }, modelPropertyMacro: { typeCaster: nullable_function }, oauth2RedirectUrl: { typeCaster: undefined_string }, onComplete: { typeCaster: nullable_function }, operationsSorter: { typeCaster: sorter }, paramaterMacro: { typeCaster: nullable_function }, persistAuthorization: { typeCaster: type_casters_boolean, defaultValue: Zs.persistAuthorization }, plugins: { typeCaster: type_casters_array, defaultValue: Zs.plugins }, presets: { typeCaster: type_casters_array, defaultValue: Zs.presets }, requestInterceptor: { typeCaster: type_casters_function, defaultValue: Zs.requestInterceptor }, requestSnippets: { typeCaster: type_casters_object, defaultValue: Zs.requestSnippets }, requestSnippetsEnabled: { typeCaster: type_casters_boolean, defaultValue: Zs.requestSnippetsEnabled }, responseInterceptor: { typeCaster: type_casters_function, defaultValue: Zs.responseInterceptor }, showCommonExtensions: { typeCaster: type_casters_boolean, defaultValue: Zs.showCommonExtensions }, showExtensions: { typeCaster: type_casters_boolean, defaultValue: Zs.showExtensions }, showMutatedRequest: { typeCaster: type_casters_boolean, defaultValue: Zs.showMutatedRequest }, spec: { typeCaster: type_casters_object, defaultValue: Zs.spec }, supportedSubmitMethods: { typeCaster: type_casters_array, defaultValue: Zs.supportedSubmitMethods }, syntaxHighlight: { typeCaster: syntax_highlight, defaultValue: Zs.syntaxHighlight }, "syntaxHighlight.activated": { typeCaster: type_casters_boolean, defaultValue: Zs.syntaxHighlight.activated }, "syntaxHighlight.theme": { typeCaster: type_casters_string }, tagsSorter: { typeCaster: sorter }, tryItOutEnabled: { typeCaster: type_casters_boolean, defaultValue: Zs.tryItOutEnabled }, url: { typeCaster: type_casters_string }, urls: { typeCaster: nullable_array }, "urls.primaryName": { typeCaster: type_casters_string }, validatorUrl: { typeCaster: nullable_string }, withCredentials: { typeCaster: type_casters_boolean, defaultValue: Zs.withCredentials } };
var type_cast = (e2) => Object.entries(rl).reduce((e3, [t2, { typeCaster: r2, defaultValue: n }]) => {
  if ((0, el.default)(e3, t2)) {
    const a2 = r2((0, ar.default)(e3, t2), n);
    e3 = (0, tl.default)(t2, a2, e3);
  }
  return e3;
}, { ...e2 });
var config_merge = (e2, ...t2) => {
  let r2 = Symbol.for("domNode"), n = Symbol.for("primaryName");
  const a2 = [];
  for (const e3 of t2) {
    const t3 = { ...e3 };
    Object.hasOwn(t3, "domNode") && (r2 = t3.domNode, delete t3.domNode), Object.hasOwn(t3, "urls.primaryName") ? (n = t3["urls.primaryName"], delete t3["urls.primaryName"]) : Array.isArray(t3.urls) && Object.hasOwn(t3.urls, "primaryName") && (n = t3.urls.primaryName, delete t3.urls.primaryName), a2.push(t3);
  }
  const o4 = et()(e2, ...a2);
  return r2 !== Symbol.for("domNode") && (o4.domNode = r2), n !== Symbol.for("primaryName") && Array.isArray(o4.urls) && (o4.urls.primaryName = n), type_cast(o4);
};
function SwaggerUI(e2) {
  const t2 = query3()(e2), r2 = runtime()(), n = SwaggerUI.config.merge({}, SwaggerUI.config.defaults, r2, e2, t2), a2 = factorization_system(n), o4 = inline_plugin(n), s2 = new Store(a2);
  s2.register([n.plugins, o4]);
  const l2 = s2.getSystem(), persistConfigs = (e3) => {
    s2.setConfigs(e3), l2.configsActions.loaded();
  }, updateSpec2 = (e3) => {
    !t2.url && "object" == typeof e3.spec && Object.keys(e3.spec).length > 0 ? (l2.specActions.updateUrl(""), l2.specActions.updateLoadingStatus("success"), l2.specActions.updateSpec(JSON.stringify(e3.spec))) : "function" == typeof l2.specActions.download && e3.url && !e3.urls && (l2.specActions.updateUrl(e3.url), l2.specActions.download(e3.url));
  }, render2 = (e3) => {
    if (e3.domNode) l2.render(e3.domNode, "App");
    else if (e3.dom_id) {
      const t3 = document.querySelector(e3.dom_id);
      l2.render(t3, "App");
    } else null === e3.dom_id || null === e3.domNode || console.error("Skipped rendering: no `dom_id` or `domNode` was specified");
  };
  return n.configUrl ? ((async () => {
    const { configUrl: e3 } = n, r3 = await sources_url({ url: e3, system: l2 })(n), a3 = SwaggerUI.config.merge({}, n, r3, t2);
    persistConfigs(a3), null !== r3 && updateSpec2(a3), render2(a3);
  })(), l2) : (persistConfigs(n), updateSpec2(n), render2(n), l2);
}
SwaggerUI.System = Store, SwaggerUI.config = { defaults: Zs, merge: config_merge, typeCast: type_cast, typeCastMappings: rl }, SwaggerUI.presets = { base, apis: PresetApis }, SwaggerUI.plugins = { Auth: auth, Configs: configsPlugin, DeepLining: deep_linking, Err: err, Filter: filter4, Icons: icons, JSONSchema5: json_schema_5, JSONSchema5Samples: json_schema_5_samples, JSONSchema202012: json_schema_2020_12, JSONSchema202012Samples: json_schema_2020_12_samples, Layout: plugins_layout, Logs: logs, OpenAPI30: oas3, OpenAPI31: oas3, OnComplete: on_complete, RequestSnippets: plugins_request_snippets, Spec: plugins_spec, SwaggerClient: swagger_client, Util: util, View: view3, ViewLegacy: view_legacy, DownloadUrl: downloadUrlPlugin, SyntaxHighlighting: syntax_highlighting, Versions: versions, SafeRender: safe_render };
var nl = SwaggerUI;
var al = Oe.A;
export {
  al as default
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

css.escape/css.escape.js:
  (*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

repeat-string/index.js:
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)

fast-json-patch/module/helpers.mjs:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   *)

fast-json-patch/module/duplex.mjs:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2021 Joachim Wester
   * MIT license
   *)

dompurify/dist/purify.es.mjs:
  (*! @license DOMPurify 3.1.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.6/LICENSE *)

swagger-ui/dist/swagger-ui-es-bundle-core.js:
  (*! For license information please see swagger-ui-es-bundle-core.js.LICENSE.txt *)
*/
//# sourceMappingURL=swagger-ui.js.map
